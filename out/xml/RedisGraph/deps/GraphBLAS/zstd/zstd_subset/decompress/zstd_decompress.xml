<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/zstd/zstd_subset/decompress/zstd_decompress.c"><comment type="block">/*
 * Copyright (c) Yann Collet, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
 */</comment>


<comment type="block">/* ***************************************************************
*  Tuning parameters
*****************************************************************/</comment>
<comment type="block" format="doxygen">/*!
 * HEAPMODE :
 * Select how default decompression function ZSTD_decompress() allocates its context,
 * on stack (0), or into heap (1, default; requires malloc()).
 * Note that functions with explicit context such as ZSTD_decompressDCtx() are unaffected.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ZSTD_HEAPMODE</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>ZSTD_HEAPMODE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/*!
*  LEGACY_SUPPORT :
*  if set to 1+, ZSTD_decompress() can decode older formats (v0.1+)
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ZSTD_LEGACY_SUPPORT</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>ZSTD_LEGACY_SUPPORT</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/*!
 *  MAXWINDOWSIZE_DEFAULT :
 *  maximum window size accepted by DStream __by default__.
 *  Frames requiring more memory will be rejected.
 *  It's possible to set a different limit using ZSTD_DCtx_setMaxWindowSize().
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ZSTD_MAXWINDOWSIZE_DEFAULT</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>ZSTD_MAXWINDOWSIZE_DEFAULT</name></cpp:macro> <cpp:value>(((U32)1 &lt;&lt; ZSTD_WINDOWLOG_LIMIT_DEFAULT) + 1)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/*!
 *  NO_FORWARD_PROGRESS_MAX :
 *  maximum allowed nb of calls to ZSTD_decompressStream()
 *  without any forward progress
 *  (defined as: no byte read from input, and no byte flushed to output)
 *  before triggering an error.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ZSTD_NO_FORWARD_PROGRESS_MAX</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>ZSTD_NO_FORWARD_PROGRESS_MAX</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*-*******************************************************
*  Dependencies
*********************************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/zstd_deps.h"</cpp:file></cpp:include>   <comment type="block">/* ZSTD_memcpy, ZSTD_memmove, ZSTD_memset */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/mem.h"</cpp:file></cpp:include>         <comment type="block">/* low level memory routines */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FSE_STATIC_LINKING_ONLY</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/fse.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_STATIC_LINKING_ONLY</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/huf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/xxhash.h"</cpp:file></cpp:include> <comment type="block">/* XXH64_reset, XXH64_update, XXH64_digest, XXH64 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/zstd_internal.h"</cpp:file></cpp:include>  <comment type="block">/* blockProperties_t */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_decompress_internal.h"</cpp:file></cpp:include>   <comment type="block">/* ZSTD_DCtx */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_ddict.h"</cpp:file></cpp:include>  <comment type="block">/* ZSTD_DDictDictContent */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_decompress_block.h"</cpp:file></cpp:include>   <comment type="block">/* ZSTD_decompressBlock_internal */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/bits.h"</cpp:file></cpp:include>  <comment type="block">/* ZSTD_highbit32 */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ZSTD_LEGACY_SUPPORT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>ZSTD_LEGACY_SUPPORT</name><operator>&gt;=</operator><literal type="number">1</literal><operator>)</operator></expr></cpp:if>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>"../legacy/zstd_legacy.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<comment type="block" format="doxygen">/*************************************
 * Multiple DDicts Hashset internals *
 *************************************/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DDICT_HASHSET_MAX_LOAD_FACTOR_COUNT_MULT</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DDICT_HASHSET_MAX_LOAD_FACTOR_SIZE_MULT</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>  <comment type="block">/* These two constants represent SIZE_MULT/COUNT_MULT load factor without using a float.
                                                    * Currently, that means a 0.75 load factor.
                                                    * So, if count * COUNT_MULT / size * SIZE_MULT != 0, then we've exceeded
                                                    * the load factor of the ddict hash set.
                                                    */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DDICT_HASHSET_TABLE_BASE_SIZE</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DDICT_HASHSET_RESIZE_FACTOR</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<comment type="block">/* Hash function to determine starting position of dict insertion within the table
 * Returns an index between [0, hashSet-&gt;ddictPtrTableSize]
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_DDictHashSet_getIndex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ZSTD_DDictHashSet</name><modifier>*</modifier></type> <name>hashSet</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>dictID</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U64</name></type> <name>hash</name> <init>= <expr><call><name>XXH64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dictID</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>U32</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/* DDict ptr table size is a multiple of 2, use size - 1 as mask to get index within [0, hashSet-&gt;ddictPtrTableSize) */</comment>
    <return>return <expr><name>hash</name> <operator>&amp;</operator> <operator>(</operator><name><name>hashSet</name><operator>-&gt;</operator><name>ddictPtrTableSize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Adds DDict to a hashset without resizing it.
 * If inserting a DDict with a dictID that already exists in the set, replaces the one in the set.
 * Returns 0 if successful, or a zstd error code if something went wrong.
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_DDictHashSet_emplaceDDict</name><parameter_list>(<parameter><decl><type><name>ZSTD_DDictHashSet</name><modifier>*</modifier></type> <name>hashSet</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ZSTD_DDict</name><modifier>*</modifier></type> <name>ddict</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dictID</name> <init>= <expr><call><name>ZSTD_getDictID_fromDDict</name><argument_list>(<argument><expr><name>ddict</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>idx</name> <init>= <expr><call><name>ZSTD_DDictHashSet_getIndex</name><argument_list>(<argument><expr><name>hashSet</name></expr></argument>, <argument><expr><name>dictID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>idxRangeMask</name> <init>= <expr><name><name>hashSet</name><operator>-&gt;</operator><name>ddictPtrTableSize</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>hashSet</name><operator>-&gt;</operator><name>ddictPtrCount</name></name> <operator>==</operator> <name><name>hashSet</name><operator>-&gt;</operator><name>ddictPtrTableSize</name></name></expr></argument>, <argument><expr><name>GENERIC</name></expr></argument>, <argument><expr><literal type="string">"Hash set is full!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"Hashed index: for dictID: %u is %zu"</literal></expr></argument>, <argument><expr><name>dictID</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name><name>hashSet</name><operator>-&gt;</operator><name>ddictPtrTable</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Replace existing ddict if inserting ddict with same dictID */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>ZSTD_getDictID_fromDDict</name><argument_list>(<argument><expr><name><name>hashSet</name><operator>-&gt;</operator><name>ddictPtrTable</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>dictID</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"DictID already exists, replacing rather than adding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hashSet</name><operator>-&gt;</operator><name>ddictPtrTable</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name>ddict</name></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>idx</name> <operator>&amp;=</operator> <name>idxRangeMask</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"Final idx after probing for dictID %u is: %zu"</literal></expr></argument>, <argument><expr><name>dictID</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashSet</name><operator>-&gt;</operator><name>ddictPtrTable</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name>ddict</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashSet</name><operator>-&gt;</operator><name>ddictPtrCount</name></name><operator>++</operator></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Expands hash table by factor of DDICT_HASHSET_RESIZE_FACTOR and
 * rehashes all values, allocates new table, frees old table.
 * Returns 0 on success, otherwise a zstd error code.
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_DDictHashSet_expand</name><parameter_list>(<parameter><decl><type><name>ZSTD_DDictHashSet</name><modifier>*</modifier></type> <name>hashSet</name></decl></parameter>, <parameter><decl><type><name>ZSTD_customMem</name></type> <name>customMem</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>newTableSize</name> <init>= <expr><name><name>hashSet</name><operator>-&gt;</operator><name>ddictPtrTableSize</name></name> <operator>*</operator> <name>DDICT_HASHSET_RESIZE_FACTOR</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_DDict</name><modifier>*</modifier><modifier>*</modifier></type> <name>newTable</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ZSTD_DDict</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name>ZSTD_customCalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_DDict</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>newTableSize</name></expr></argument>, <argument><expr><name>customMem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_DDict</name><modifier>*</modifier><modifier>*</modifier></type> <name>oldTable</name> <init>= <expr><name><name>hashSet</name><operator>-&gt;</operator><name>ddictPtrTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>oldTableSize</name> <init>= <expr><name><name>hashSet</name><operator>-&gt;</operator><name>ddictPtrTableSize</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"Expanding DDict hash table! Old size: %zu new size: %zu"</literal></expr></argument>, <argument><expr><name>oldTableSize</name></expr></argument>, <argument><expr><name>newTableSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><operator>!</operator><name>newTable</name></expr></argument>, <argument><expr><name>memory_allocation</name></expr></argument>, <argument><expr><literal type="string">"Expanded hashset allocation failed!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashSet</name><operator>-&gt;</operator><name>ddictPtrTable</name></name> <operator>=</operator> <name>newTable</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashSet</name><operator>-&gt;</operator><name>ddictPtrTableSize</name></name> <operator>=</operator> <name>newTableSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashSet</name><operator>-&gt;</operator><name>ddictPtrCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>oldTableSize</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>oldTable</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_DDictHashSet_emplaceDDict</name><argument_list>(<argument><expr><name>hashSet</name></expr></argument>, <argument><expr><name><name>oldTable</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>ZSTD_customFree</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>oldTable</name></expr></argument>, <argument><expr><name>customMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"Finished re-hash"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Fetches a DDict with the given dictID
 * Returns the ZSTD_DDict* with the requested dictID. If it doesn't exist, then returns NULL.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>ZSTD_DDict</name><modifier>*</modifier></type> <name>ZSTD_DDictHashSet_getDDict</name><parameter_list>(<parameter><decl><type><name>ZSTD_DDictHashSet</name><modifier>*</modifier></type> <name>hashSet</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>dictID</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>idx</name> <init>= <expr><call><name>ZSTD_DDictHashSet_getIndex</name><argument_list>(<argument><expr><name>hashSet</name></expr></argument>, <argument><expr><name>dictID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>idxRangeMask</name> <init>= <expr><name><name>hashSet</name><operator>-&gt;</operator><name>ddictPtrTableSize</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"Hashed index: for dictID: %u is %zu"</literal></expr></argument>, <argument><expr><name>dictID</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>currDictID</name> <init>= <expr><call><name>ZSTD_getDictID_fromDDict</name><argument_list>(<argument><expr><name><name>hashSet</name><operator>-&gt;</operator><name>ddictPtrTable</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>currDictID</name> <operator>==</operator> <name>dictID</name> <operator>||</operator> <name>currDictID</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* currDictID == 0 implies a NULL ddict entry */</comment>
            <break>break;</break>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>idx</name> <operator>&amp;=</operator> <name>idxRangeMask</name></expr>;</expr_stmt>    <comment type="block">/* Goes to start of table when we reach the end */</comment>
            <expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"Final idx after probing for dictID %u is: %zu"</literal></expr></argument>, <argument><expr><name>dictID</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>hashSet</name><operator>-&gt;</operator><name>ddictPtrTable</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Allocates space for and returns a ddict hash set
 * The hash set's ZSTD_DDict* table has all values automatically set to NULL to begin with.
 * Returns NULL if allocation failed.
 */</comment>
<function><type><specifier>static</specifier> <name>ZSTD_DDictHashSet</name><modifier>*</modifier></type> <name>ZSTD_createDDictHashSet</name><parameter_list>(<parameter><decl><type><name>ZSTD_customMem</name></type> <name>customMem</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_DDictHashSet</name><modifier>*</modifier></type> <name>ret</name> <init>= <expr><operator>(</operator><name>ZSTD_DDictHashSet</name><operator>*</operator><operator>)</operator><call><name>ZSTD_customMalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_DDictHashSet</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>customMem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"Allocating new hash set"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>ddictPtrTable</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>ZSTD_DDict</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name>ZSTD_customCalloc</name><argument_list>(<argument><expr><name>DDICT_HASHSET_TABLE_BASE_SIZE</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_DDict</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>customMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ret</name><operator>-&gt;</operator><name>ddictPtrTable</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>ZSTD_customFree</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>customMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>ddictPtrTableSize</name></name> <operator>=</operator> <name>DDICT_HASHSET_TABLE_BASE_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>ddictPtrCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Frees the table of ZSTD_DDict* within a hashset, then frees the hashset itself.
 * Note: The ZSTD_DDict* within the table are NOT freed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_freeDDictHashSet</name><parameter_list>(<parameter><decl><type><name>ZSTD_DDictHashSet</name><modifier>*</modifier></type> <name>hashSet</name></decl></parameter>, <parameter><decl><type><name>ZSTD_customMem</name></type> <name>customMem</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"Freeing ddict hash set"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>hashSet</name> <operator>&amp;&amp;</operator> <name><name>hashSet</name><operator>-&gt;</operator><name>ddictPtrTable</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>ZSTD_customFree</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name><name>hashSet</name><operator>-&gt;</operator><name>ddictPtrTable</name></name></expr></argument>, <argument><expr><name>customMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>hashSet</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>ZSTD_customFree</name><argument_list>(<argument><expr><name>hashSet</name></expr></argument>, <argument><expr><name>customMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Public function: Adds a DDict into the ZSTD_DDictHashSet, possibly triggering a resize of the hash set.
 * Returns 0 on success, or a ZSTD error.
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_DDictHashSet_addDDict</name><parameter_list>(<parameter><decl><type><name>ZSTD_DDictHashSet</name><modifier>*</modifier></type> <name>hashSet</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ZSTD_DDict</name><modifier>*</modifier></type> <name>ddict</name></decl></parameter>, <parameter><decl><type><name>ZSTD_customMem</name></type> <name>customMem</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"Adding dict ID: %u to hashset with - Count: %zu Tablesize: %zu"</literal></expr></argument>, <argument><expr><call><name>ZSTD_getDictID_fromDDict</name><argument_list>(<argument><expr><name>ddict</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>hashSet</name><operator>-&gt;</operator><name>ddictPtrCount</name></name></expr></argument>, <argument><expr><name><name>hashSet</name><operator>-&gt;</operator><name>ddictPtrTableSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>hashSet</name><operator>-&gt;</operator><name>ddictPtrCount</name></name> <operator>*</operator> <name>DDICT_HASHSET_MAX_LOAD_FACTOR_COUNT_MULT</name> <operator>/</operator> <name><name>hashSet</name><operator>-&gt;</operator><name>ddictPtrTableSize</name></name> <operator>*</operator> <name>DDICT_HASHSET_MAX_LOAD_FACTOR_SIZE_MULT</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_DDictHashSet_expand</name><argument_list>(<argument><expr><name>hashSet</name></expr></argument>, <argument><expr><name>customMem</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_DDictHashSet_emplaceDDict</name><argument_list>(<argument><expr><name>hashSet</name></expr></argument>, <argument><expr><name>ddict</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*-*************************************************************
*   Context management
***************************************************************/</comment>
<function><type><name>size_t</name></type> <name>ZSTD_sizeof_DCtx</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>dctx</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* support sizeof NULL */</comment>
    <return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>dctx</name></expr></argument>)</argument_list></sizeof>
           <operator>+</operator> <call><name>ZSTD_sizeof_DDict</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>ddictLocal</name></name></expr></argument>)</argument_list></call>
           <operator>+</operator> <name><name>dctx</name><operator>-&gt;</operator><name>inBuffSize</name></name> <operator>+</operator> <name><name>dctx</name><operator>-&gt;</operator><name>outBuffSize</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_estimateDCtxSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_DCtx</name></expr></argument>)</argument_list></sizeof></expr>;</return> </block_content>}</block></function>


<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_startingInputLength</name><parameter_list>(<parameter><decl><type><name>ZSTD_format_e</name></type> <name>format</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>startingInputLength</name> <init>= <expr><call><name>ZSTD_FRAMEHEADERSIZE_PREFIX</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/* only supports formats ZSTD_f_zstd1 and ZSTD_f_zstd1_magicless */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>format</name> <operator>==</operator> <name>ZSTD_f_zstd1</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>format</name> <operator>==</operator> <name>ZSTD_f_zstd1_magicless</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>startingInputLength</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_DCtx_resetParameters</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>==</operator> <name>zdss_init</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <name>ZSTD_f_zstd1</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>maxWindowSize</name></name> <operator>=</operator> <name>ZSTD_MAXWINDOWSIZE_DEFAULT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>outBufferMode</name></name> <operator>=</operator> <name>ZSTD_bm_buffered</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>forceIgnoreChecksum</name></name> <operator>=</operator> <name>ZSTD_d_validateChecksum</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>refMultipleDDicts</name></name> <operator>=</operator> <name>ZSTD_rmd_refSingleDDict</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_initDCtx_internal</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>staticSize</name></name>  <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>ddict</name></name>       <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>ddictLocal</name></name>  <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>dictEnd</name></name>     <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>ddictIsCold</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>dictUses</name></name> <operator>=</operator> <name>ZSTD_dont_use</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>inBuff</name></name>      <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>inBuffSize</name></name>  <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>outBuffSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>=</operator> <name>zdss_init</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ZSTD_LEGACY_SUPPORT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>ZSTD_LEGACY_SUPPORT</name><operator>&gt;=</operator><literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>legacyContext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>previousLegacyVersion</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>noForwardProgress</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>oversizedDuration</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DYNAMIC_BMI2</name></expr></cpp:if>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>bmi2</name></name> <operator>=</operator> <call><name>ZSTD_cpuSupportsBmi2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>ddictSet</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_DCtx_resetParameters</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION</name></cpp:ifdef>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>dictContentEndForFuzzing</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>ZSTD_initStaticDCtx</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>workspace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>workspaceSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dctx</name> <init>= <expr><operator>(</operator><name>ZSTD_DCtx</name><operator>*</operator><operator>)</operator> <name>workspace</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><name>workspace</name> <operator>&amp;</operator> <literal type="number">7</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* 8-aligned */</comment>
    <if_stmt><if>if <condition>(<expr><name>workspaceSize</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_DCtx</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* minimum size */</comment>

    <expr_stmt><expr><call><name>ZSTD_initDCtx_internal</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>staticSize</name></name> <operator>=</operator> <name>workspaceSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>inBuff</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>dctx</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    <return>return <expr><name>dctx</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>ZSTD_createDCtx_internal</name><parameter_list>(<parameter><decl><type><name>ZSTD_customMem</name></type> <name>customMem</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name><name>customMem</name><operator>.</operator><name>customAlloc</name></name><operator>)</operator> <operator>^</operator> <operator>(</operator><operator>!</operator><name><name>customMem</name><operator>.</operator><name>customFree</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <block>{<block_content>   <decl_stmt><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dctx</name> <init>= <expr><operator>(</operator><name>ZSTD_DCtx</name><operator>*</operator><operator>)</operator><call><name>ZSTD_customMalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>dctx</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>customMem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>dctx</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>customMem</name></name> <operator>=</operator> <name>customMem</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_initDCtx_internal</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>dctx</name></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>

<function><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>ZSTD_createDCtx_advanced</name><parameter_list>(<parameter><decl><type><name>ZSTD_customMem</name></type> <name>customMem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_createDCtx_internal</name><argument_list>(<argument><expr><name>customMem</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>ZSTD_createDCtx</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_createDCtx"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>ZSTD_createDCtx_internal</name><argument_list>(<argument><expr><name>ZSTD_defaultCMem</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_clearDict</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>ZSTD_freeDDict</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>ddictLocal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>ddictLocal</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>ddict</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>dictUses</name></name> <operator>=</operator> <name>ZSTD_dont_use</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_freeDCtx</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>dctx</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* support free on NULL */</comment>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>staticSize</name></name></expr></argument>, <argument><expr><name>memory_allocation</name></expr></argument>, <argument><expr><literal type="string">"not compatible with static DCtx"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>ZSTD_customMem</name> <specifier>const</specifier></type> <name>cMem</name> <init>= <expr><name><name>dctx</name><operator>-&gt;</operator><name>customMem</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ZSTD_clearDict</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_customFree</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>inBuff</name></name></expr></argument>, <argument><expr><name>cMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>inBuff</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ZSTD_LEGACY_SUPPORT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>ZSTD_LEGACY_SUPPORT</name> <operator>&gt;=</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
        <if_stmt><if>if <condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>legacyContext</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ZSTD_freeLegacyStreamContext</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>legacyContext</name></name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>previousLegacyVersion</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if_stmt><if>if <condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>ddictSet</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>ZSTD_freeDDictHashSet</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>ddictSet</name></name></expr></argument>, <argument><expr><name>cMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>ddictSet</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>ZSTD_customFree</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>cMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/* no longer useful */</comment>
<function><type><name>void</name></type> <name>ZSTD_copyDCtx</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dstDCtx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>srcDCtx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>toCopy</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>dstDCtx</name><operator>-&gt;</operator><name>inBuff</name></name><operator>)</operator> <operator>-</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>dstDCtx</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>dstDCtx</name></expr></argument>, <argument><expr><name>srcDCtx</name></expr></argument>, <argument><expr><name>toCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* no need to copy workspace */</comment>
</block_content>}</block></function>

<comment type="block">/* Given a dctx with a digested frame params, re-selects the correct ZSTD_DDict based on
 * the requested dict ID from the frame. If there exists a reference to the correct ZSTD_DDict, then
 * accordingly sets the ddict to be used to decompress the frame.
 *
 * If no DDict is found, then no action is taken, and the ZSTD_DCtx::ddict remains as-is.
 *
 * ZSTD_d_refMultipleDDicts must be enabled for this function to be called.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_DCtx_selectFrameDDict</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>refMultipleDDicts</name></name> <operator>&amp;&amp;</operator> <name><name>dctx</name><operator>-&gt;</operator><name>ddictSet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"Adjusting DDict based on requested dict ID from frame"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>ddict</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_DDict</name><modifier>*</modifier></type> <name>frameDDict</name> <init>= <expr><call><name>ZSTD_DDictHashSet_getDDict</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>ddictSet</name></name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>dictID</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>frameDDict</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"DDict found!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ZSTD_clearDict</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>dictID</name></name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>dictID</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>ddict</name></name> <operator>=</operator> <name>frameDDict</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>dictUses</name></name> <operator>=</operator> <name>ZSTD_use_indefinitely</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*-*************************************************************
 *   Frame header decoding
 ***************************************************************/</comment>

<comment type="block" format="doxygen">/*! ZSTD_isFrame() :
 *  Tells if the content of `buffer` starts with a valid Frame Identifier.
 *  Note : Frame Identifier is 4 bytes. If `size &lt; 4`, @return will always be 0.
 *  Note 2 : Legacy Frame Identifiers are considered valid only if Legacy Support is enabled.
 *  Note 3 : Skippable Frame Identifiers are considered valid. */</comment>
<function><type><name>unsigned</name></type> <name>ZSTD_isFrame</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <name>ZSTD_FRAMEIDSIZE</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>magic</name> <init>= <expr><call><name>MEM_readLE32</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>magic</name> <operator>==</operator> <name>ZSTD_MAGICNUMBER</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>magic</name> <operator>&amp;</operator> <name>ZSTD_MAGIC_SKIPPABLE_MASK</name><operator>)</operator> <operator>==</operator> <name>ZSTD_MAGIC_SKIPPABLE_START</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ZSTD_LEGACY_SUPPORT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>ZSTD_LEGACY_SUPPORT</name> <operator>&gt;=</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isLegacy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! ZSTD_isSkippableFrame() :
 *  Tells if the content of `buffer` starts with a valid Frame Identifier for a skippable frame.
 *  Note : Frame Identifier is 4 bytes. If `size &lt; 4`, @return will always be 0.
 */</comment>
<function><type><name>unsigned</name></type> <name>ZSTD_isSkippableFrame</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <name>ZSTD_FRAMEIDSIZE</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>magic</name> <init>= <expr><call><name>MEM_readLE32</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>magic</name> <operator>&amp;</operator> <name>ZSTD_MAGIC_SKIPPABLE_MASK</name><operator>)</operator> <operator>==</operator> <name>ZSTD_MAGIC_SKIPPABLE_START</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** ZSTD_frameHeaderSize_internal() :
 *  srcSize must be large enough to reach header size fields.
 *  note : only works for formats ZSTD_f_zstd1 and ZSTD_f_zstd1_magicless.
 * @return : size of the Frame Header
 *           or an error code, which can be tested with ZSTD_isError() */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_frameHeaderSize_internal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>ZSTD_format_e</name></type> <name>format</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>minInputSize</name> <init>= <expr><call><name>ZSTD_startingInputLength</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>srcSize</name> <operator>&lt;</operator> <name>minInputSize</name></expr></argument>, <argument><expr><name>srcSize_wrong</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <block>{<block_content>   <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier></type> <name>fhd</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name><operator>)</operator><index>[<expr><name>minInputSize</name><operator>-</operator><literal type="number">1</literal></expr>]</index></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>dictID</name><init>= <expr><name>fhd</name> <operator>&amp;</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>singleSegment</name> <init>= <expr><operator>(</operator><name>fhd</name> <operator>&gt;&gt;</operator> <literal type="number">5</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>fcsId</name> <init>= <expr><name>fhd</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal></expr></init></decl>;</decl_stmt>
        <return>return <expr><name>minInputSize</name> <operator>+</operator> <operator>!</operator><name>singleSegment</name>
             <operator>+</operator> <name><name>ZSTD_did_fieldSize</name><index>[<expr><name>dictID</name></expr>]</index></name> <operator>+</operator> <name><name>ZSTD_fcs_fieldSize</name><index>[<expr><name>fcsId</name></expr>]</index></name>
             <operator>+</operator> <operator>(</operator><name>singleSegment</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>fcsId</name><operator>)</operator></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** ZSTD_frameHeaderSize() :
 *  srcSize must be &gt;= ZSTD_frameHeaderSize_prefix.
 * @return : size of the Frame Header,
 *           or an error code (if srcSize is too small) */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_frameHeaderSize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_frameHeaderSize_internal</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>ZSTD_f_zstd1</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/** ZSTD_getFrameHeader_advanced() :
 *  decode Frame Header, or require larger `srcSize`.
 *  note : only works for formats ZSTD_f_zstd1 and ZSTD_f_zstd1_magicless
 * @return : 0, `zfhPtr` is correctly filled,
 *          &gt;0, `srcSize` is too small, value is wanted `srcSize` amount,
**           or an error code, which can be tested using ZSTD_isError() */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_getFrameHeader_advanced</name><parameter_list>(<parameter><decl><type><name>ZSTD_frameHeader</name><modifier>*</modifier></type> <name>zfhPtr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>ZSTD_format_e</name></type> <name>format</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>minInputSize</name> <init>= <expr><call><name>ZSTD_startingInputLength</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_getFrameHeader_advanced: minInputSize = %zu, srcSize = %zu"</literal></expr></argument>, <argument><expr><name>minInputSize</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>srcSize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* note : technically could be considered an assert(), since it's an invalid entry */</comment>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>src</name><operator>==</operator><name>NULL</name></expr></argument>, <argument><expr><name>GENERIC</name></expr></argument>, <argument><expr><literal type="string">"invalid parameter : src==NULL, but srcSize&gt;0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>srcSize</name> <operator>&lt;</operator> <name>minInputSize</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>srcSize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>format</name> <operator>!=</operator> <name>ZSTD_f_zstd1_magicless</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* when receiving less than @minInputSize bytes,
             * control these bytes at least correspond to a supported magic number
             * in order to error out early if they don't.
            **/</comment>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>toCopy</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>hbuf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt> <expr_stmt><expr><call><name>MEM_writeLE32</name><argument_list>(<argument><expr><name>hbuf</name></expr></argument>, <argument><expr><name>ZSTD_MAGICNUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>src</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>hbuf</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>toCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>( <expr><call><name>MEM_readLE32</name><argument_list>(<argument><expr><name>hbuf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ZSTD_MAGICNUMBER</name></expr> )</condition> <block>{<block_content>
                <comment type="block">/* not a zstd frame : let's check if it's a skippable frame */</comment>
                <expr_stmt><expr><call><name>MEM_writeLE32</name><argument_list>(<argument><expr><name>hbuf</name></expr></argument>, <argument><expr><name>ZSTD_MAGIC_SKIPPABLE_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>hbuf</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>toCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>MEM_readLE32</name><argument_list>(<argument><expr><name>hbuf</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>ZSTD_MAGIC_SKIPPABLE_MASK</name><operator>)</operator> <operator>!=</operator> <name>ZSTD_MAGIC_SKIPPABLE_START</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr><name>prefix_unknown</name></expr></argument>,
                                <argument><expr><literal type="string">"first bytes don't correspond to any supported magic number"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>   </block_content>}</block></if></if_stmt>   </block_content>}</block></if></if_stmt>
        <return>return <expr><name>minInputSize</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><name>zfhPtr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>zfhPtr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* not strictly necessary, but static analyzers may not understand that zfhPtr will be read only if return value is zero, since they are 2 different signals */</comment>
    <if_stmt><if>if <condition>( <expr><operator>(</operator><name>format</name> <operator>!=</operator> <name>ZSTD_f_zstd1_magicless</name><operator>)</operator>
      <operator>&amp;&amp;</operator> <operator>(</operator><call><name>MEM_readLE32</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ZSTD_MAGICNUMBER</name><operator>)</operator></expr> )</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>MEM_readLE32</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>ZSTD_MAGIC_SKIPPABLE_MASK</name><operator>)</operator> <operator>==</operator> <name>ZSTD_MAGIC_SKIPPABLE_START</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* skippable frame */</comment>
            <if_stmt><if>if <condition>(<expr><name>srcSize</name> <operator>&lt;</operator> <name>ZSTD_SKIPPABLEHEADERSIZE</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>ZSTD_SKIPPABLEHEADERSIZE</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* magic number + frame length */</comment>
            <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><name>zfhPtr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>zfhPtr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>zfhPtr</name><operator>-&gt;</operator><name>frameContentSize</name></name> <operator>=</operator> <call><name>MEM_readLE32</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <name>ZSTD_FRAMEIDSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>zfhPtr</name><operator>-&gt;</operator><name>frameType</name></name> <operator>=</operator> <name>ZSTD_skippableFrame</name></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr><name>prefix_unknown</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* ensure there is enough `srcSize` to fully read/decode frame header */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>fhsize</name> <init>= <expr><call><name>ZSTD_frameHeaderSize_internal</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>srcSize</name> <operator>&lt;</operator> <name>fhsize</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>fhsize</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>zfhPtr</name><operator>-&gt;</operator><name>headerSize</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>fhsize</name></expr>;</expr_stmt>
    </block_content>}</block>

    <block>{<block_content>   <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier></type> <name>fhdByte</name> <init>= <expr><name><name>ip</name><index>[<expr><name>minInputSize</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>pos</name> <init>= <expr><name>minInputSize</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>dictIDSizeCode</name> <init>= <expr><name>fhdByte</name><operator>&amp;</operator><literal type="number">3</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>checksumFlag</name> <init>= <expr><operator>(</operator><name>fhdByte</name><operator>&gt;&gt;</operator><literal type="number">2</literal><operator>)</operator><operator>&amp;</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>singleSegment</name> <init>= <expr><operator>(</operator><name>fhdByte</name><operator>&gt;&gt;</operator><literal type="number">5</literal><operator>)</operator><operator>&amp;</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>fcsID</name> <init>= <expr><name>fhdByte</name><operator>&gt;&gt;</operator><literal type="number">6</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U64</name></type> <name>windowSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name></type> <name>dictID</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U64</name></type> <name>frameContentSize</name> <init>= <expr><name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><operator>(</operator><name>fhdByte</name> <operator>&amp;</operator> <literal type="number">0x08</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>frameParameter_unsupported</name></expr></argument>,
                        <argument><expr><literal type="string">"reserved bits, must be zero"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>singleSegment</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier></type> <name>wlByte</name> <init>= <expr><name><name>ip</name><index>[<expr><name>pos</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>windowLog</name> <init>= <expr><operator>(</operator><name>wlByte</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>+</operator> <name>ZSTD_WINDOWLOG_ABSOLUTEMIN</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>windowLog</name> <operator>&gt;</operator> <name>ZSTD_WINDOWLOG_MAX</name></expr></argument>, <argument><expr><name>frameParameter_windowTooLarge</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>windowSize</name> <operator>=</operator> <operator>(</operator><literal type="number">1ULL</literal> <operator>&lt;&lt;</operator> <name>windowLog</name><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>windowSize</name> <operator>+=</operator> <operator>(</operator><name>windowSize</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>*</operator> <operator>(</operator><name>wlByte</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <switch>switch<condition>(<expr><name>dictIDSizeCode</name></expr>)</condition>
        <block>{<block_content>
            <default>default:</default>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* impossible */</comment>
                <expr_stmt><expr><name>ZSTD_FALLTHROUGH</name></expr>;</expr_stmt>
            <case>case <expr><literal type="number">0</literal></expr> :</case> <break>break;</break>
            <case>case <expr><literal type="number">1</literal></expr> :</case> <expr_stmt><expr><name>dictID</name> <operator>=</operator> <name><name>ip</name><index>[<expr><name>pos</name></expr>]</index></name></expr>;</expr_stmt> <expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">2</literal></expr> :</case> <expr_stmt><expr><name>dictID</name> <operator>=</operator> <call><name>MEM_readLE16</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>pos</name><operator>+=</operator><literal type="number">2</literal></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">3</literal></expr> :</case> <expr_stmt><expr><name>dictID</name> <operator>=</operator> <call><name>MEM_readLE32</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>pos</name><operator>+=</operator><literal type="number">4</literal></expr>;</expr_stmt> <break>break;</break>
        </block_content>}</block></switch>
        <switch>switch<condition>(<expr><name>fcsID</name></expr>)</condition>
        <block>{<block_content>
            <default>default:</default>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* impossible */</comment>
                <expr_stmt><expr><name>ZSTD_FALLTHROUGH</name></expr>;</expr_stmt>
            <case>case <expr><literal type="number">0</literal></expr> :</case> <if_stmt><if>if <condition>(<expr><name>singleSegment</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>frameContentSize</name> <operator>=</operator> <name><name>ip</name><index>[<expr><name>pos</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt> <break>break;</break>
            <case>case <expr><literal type="number">1</literal></expr> :</case> <expr_stmt><expr><name>frameContentSize</name> <operator>=</operator> <call><name>MEM_readLE16</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><name>pos</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">256</literal></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">2</literal></expr> :</case> <expr_stmt><expr><name>frameContentSize</name> <operator>=</operator> <call><name>MEM_readLE32</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">3</literal></expr> :</case> <expr_stmt><expr><name>frameContentSize</name> <operator>=</operator> <call><name>MEM_readLE64</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
        </block_content>}</block></switch>
        <if_stmt><if>if <condition>(<expr><name>singleSegment</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>windowSize</name> <operator>=</operator> <name>frameContentSize</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>zfhPtr</name><operator>-&gt;</operator><name>frameType</name></name> <operator>=</operator> <name>ZSTD_frame</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zfhPtr</name><operator>-&gt;</operator><name>frameContentSize</name></name> <operator>=</operator> <name>frameContentSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zfhPtr</name><operator>-&gt;</operator><name>windowSize</name></name> <operator>=</operator> <name>windowSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zfhPtr</name><operator>-&gt;</operator><name>blockSizeMax</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>windowSize</name></expr></argument>, <argument><expr><name>ZSTD_BLOCKSIZE_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zfhPtr</name><operator>-&gt;</operator><name>dictID</name></name> <operator>=</operator> <name>dictID</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zfhPtr</name><operator>-&gt;</operator><name>checksumFlag</name></name> <operator>=</operator> <name>checksumFlag</name></expr>;</expr_stmt>
    </block_content>}</block>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** ZSTD_getFrameHeader() :
 *  decode Frame Header, or require larger `srcSize`.
 *  note : this function does not consume input, it only reads it.
 * @return : 0, `zfhPtr` is correctly filled,
 *          &gt;0, `srcSize` is too small, value is wanted `srcSize` amount,
 *           or an error code, which can be tested using ZSTD_isError() */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_getFrameHeader</name><parameter_list>(<parameter><decl><type><name>ZSTD_frameHeader</name><modifier>*</modifier></type> <name>zfhPtr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_getFrameHeader_advanced</name><argument_list>(<argument><expr><name>zfhPtr</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>ZSTD_f_zstd1</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** ZSTD_getFrameContentSize() :
 *  compatible with legacy mode
 * @return : decompressed size of the single frame pointed to be `src` if known, otherwise
 *         - ZSTD_CONTENTSIZE_UNKNOWN if the size cannot be determined
 *         - ZSTD_CONTENTSIZE_ERROR if an error occurred (e.g. invalid magic number, srcSize too small) */</comment>
<function><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>ZSTD_getFrameContentSize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ZSTD_LEGACY_SUPPORT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>ZSTD_LEGACY_SUPPORT</name> <operator>&gt;=</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isLegacy</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name> <specifier>const</specifier></type> <name>ret</name> <init>= <expr><call><name>ZSTD_getDecompressedSize_legacy</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><ternary><condition><expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr> </then><else>: <expr><name>ret</name></expr></else></ternary></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>   <decl_stmt><decl><type><name>ZSTD_frameHeader</name></type> <name>zfh</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ZSTD_getFrameHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zfh</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>ZSTD_CONTENTSIZE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>zfh</name><operator>.</operator><name>frameType</name></name> <operator>==</operator> <name>ZSTD_skippableFrame</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <return>return <expr><name><name>zfh</name><operator>.</operator><name>frameContentSize</name></name></expr>;</return>
    </block_content>}</block></else></if_stmt>   </block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>readSkippableFrameSize</name><parameter_list>(<parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>skippableHeaderSize</name> <init>= <expr><name>ZSTD_SKIPPABLEHEADERSIZE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>sizeU32</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>srcSize</name> <operator>&lt;</operator> <name>ZSTD_SKIPPABLEHEADERSIZE</name></expr></argument>, <argument><expr><name>srcSize_wrong</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>sizeU32</name> <operator>=</operator> <call><name>MEM_readLE32</name><argument_list>(<argument><expr><operator>(</operator><name>BYTE</name> <specifier>const</specifier><operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <name>ZSTD_FRAMEIDSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>sizeU32</name> <operator>+</operator> <name>ZSTD_SKIPPABLEHEADERSIZE</name><operator>)</operator> <operator>&lt;</operator> <name>sizeU32</name></expr></argument>,
                    <argument><expr><name>frameParameter_unsupported</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>skippableSize</name> <init>= <expr><name>skippableHeaderSize</name> <operator>+</operator> <name>sizeU32</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>skippableSize</name> <operator>&gt;</operator> <name>srcSize</name></expr></argument>, <argument><expr><name>srcSize_wrong</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>skippableSize</name></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! ZSTD_readSkippableFrame() :
 * Retrieves a zstd skippable frame containing data given by src, and writes it to dst buffer.
 *
 * The parameter magicVariant will receive the magicVariant that was supplied when the frame was written,
 * i.e. magicNumber - ZSTD_MAGIC_SKIPPABLE_START.  This can be NULL if the caller is not interested
 * in the magicVariant.
 *
 * Returns an error if destination buffer is not large enough, or if the frame is not skippable.
 *
 * @return : number of bytes written or a ZSTD error.
 */</comment>
<function><type><name>ZSTDLIB_API</name> <name>size_t</name></type> <name>ZSTD_readSkippableFrame</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>, <parameter><decl><type><name>unsigned</name><modifier>*</modifier></type> <name>magicVariant</name></decl></parameter>,
                                            <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>magicNumber</name> <init>= <expr><call><name>MEM_readLE32</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>skippableFrameSize</name> <init>= <expr><call><name>readSkippableFrameSize</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>skippableContentSize</name> <init>= <expr><name>skippableFrameSize</name> <operator>-</operator> <name>ZSTD_SKIPPABLEHEADERSIZE</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* check input validity */</comment>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><operator>!</operator><call><name>ZSTD_isSkippableFrame</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>frameParameter_unsupported</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>skippableFrameSize</name> <argument_list type="generic">&lt; <argument><expr><name>ZSTD_SKIPPABLEHEADERSIZE</name> <operator>||</operator> <name>skippableFrameSize</name></expr></argument> &gt;</argument_list></name> <name>srcSize</name></expr></argument>, <argument><expr><name>srcSize_wrong</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>skippableContentSize</name> <operator>&gt;</operator> <name>dstCapacity</name></expr></argument>, <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* deliver payload */</comment>
    <if_stmt><if>if <condition>(<expr><name>skippableContentSize</name> <operator>&gt;</operator> <literal type="number">0</literal>  <operator>&amp;&amp;</operator> <name>dst</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name> <operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <name>ZSTD_SKIPPABLEHEADERSIZE</name></expr></argument>, <argument><expr><name>skippableContentSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>magicVariant</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>magicVariant</name> <operator>=</operator> <name>magicNumber</name> <operator>-</operator> <name>ZSTD_MAGIC_SKIPPABLE_START</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>skippableContentSize</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** ZSTD_findDecompressedSize() :
 *  compatible with legacy mode
 *  `srcSize` must be the exact length of some number of ZSTD compressed and/or
 *      skippable frames
 *  @return : decompressed size of the frames contained */</comment>
<function><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>ZSTD_findDecompressedSize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>totalDstSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>srcSize</name> <operator>&gt;=</operator> <call><name>ZSTD_startingInputLength</name><argument_list>(<argument><expr><name>ZSTD_f_zstd1</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>magicNumber</name> <init>= <expr><call><name>MEM_readLE32</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>magicNumber</name> <operator>&amp;</operator> <name>ZSTD_MAGIC_SKIPPABLE_MASK</name><operator>)</operator> <operator>==</operator> <name>ZSTD_MAGIC_SKIPPABLE_START</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>skippableSize</name> <init>= <expr><call><name>readSkippableFrameSize</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>skippableSize</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <return>return <expr><name>ZSTD_CONTENTSIZE_ERROR</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>skippableSize</name> <operator>&lt;=</operator> <name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>src</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>BYTE</name> <operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <name>skippableSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>srcSize</name> <operator>-=</operator> <name>skippableSize</name></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <block>{<block_content>   <decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name> <specifier>const</specifier></type> <name>ret</name> <init>= <expr><call><name>ZSTD_getFrameContentSize</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&gt;=</operator> <name>ZSTD_CONTENTSIZE_ERROR</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

            <comment type="block">/* check for overflow */</comment>
            <if_stmt><if>if <condition>(<expr><name>totalDstSize</name> <operator>+</operator> <name>ret</name> <operator>&lt;</operator> <name>totalDstSize</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ZSTD_CONTENTSIZE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>totalDstSize</name> <operator>+=</operator> <name>ret</name></expr>;</expr_stmt>
        </block_content>}</block>
        <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>frameSrcSize</name> <init>= <expr><call><name>ZSTD_findFrameCompressedSize</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>frameSrcSize</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <return>return <expr><name>ZSTD_CONTENTSIZE_ERROR</name></expr>;</return>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>src</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>BYTE</name> <operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <name>frameSrcSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>srcSize</name> <operator>-=</operator> <name>frameSrcSize</name></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></while>  <comment type="block">/* while (srcSize &gt;= ZSTD_frameHeaderSize_prefix) */</comment>

    <if_stmt><if>if <condition>(<expr><name>srcSize</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ZSTD_CONTENTSIZE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>totalDstSize</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** ZSTD_getDecompressedSize() :
 *  compatible with legacy mode
 * @return : decompressed size if known, 0 otherwise
             note : 0 can mean any of the following :
                   - frame content is empty
                   - decompressed size field is not present in frame header
                   - frame header unknown / not supported
                   - frame header not complete (`srcSize` too small) */</comment>
<function><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>ZSTD_getDecompressedSize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name> <specifier>const</specifier></type> <name>ret</name> <init>= <expr><call><name>ZSTD_getFrameContentSize</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ZSTD_STATIC_ASSERT</name><argument_list>(<argument><expr><name>ZSTD_CONTENTSIZE_ERROR</name> <operator>&lt;</operator> <name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><ternary><condition><expr><operator>(</operator><name>ret</name> <operator>&gt;=</operator> <name>ZSTD_CONTENTSIZE_ERROR</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>ret</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/** ZSTD_decodeFrameHeader() :
 * `headerSize` must be the size provided by ZSTD_frameHeaderSize().
 * If multiple DDict references are enabled, also will choose the correct DDict to use.
 * @return : 0 if success, or an error code, which can be tested using ZSTD_isError() */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_decodeFrameHeader</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>headerSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>result</name> <init>= <expr><call><name>ZSTD_getFrameHeader_advanced</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>dctx</name><operator>-&gt;</operator><name>fParams</name></name><operator>)</operator></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>headerSize</name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>format</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>    <comment type="block">/* invalid header */</comment>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>result</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>srcSize_wrong</name></expr></argument>, <argument><expr><literal type="string">"headerSize too small"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reference DDict requested by frame if dctx references multiple ddicts */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>refMultipleDDicts</name></name> <operator>==</operator> <name>ZSTD_rmd_refMultipleDDicts</name> <operator>&amp;&amp;</operator> <name><name>dctx</name><operator>-&gt;</operator><name>ddictSet</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>ZSTD_DCtx_selectFrameDDict</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION</name></cpp:ifndef>
    <comment type="block">/* Skip the dictID check in fuzzing mode, because it makes the search
     * harder.
     */</comment>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>dictID</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>dctx</name><operator>-&gt;</operator><name>dictID</name></name> <operator>!=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>dictID</name></name><operator>)</operator></expr></argument>,
                    <argument><expr><name>dictionary_wrong</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>validateChecksum</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>dctx</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>checksumFlag</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dctx</name><operator>-&gt;</operator><name>forceIgnoreChecksum</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>validateChecksum</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>XXH64_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dctx</name><operator>-&gt;</operator><name>xxhState</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>processedCSize</name></name> <operator>+=</operator> <name>headerSize</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ZSTD_frameSizeInfo</name></type> <name>ZSTD_errorFrameSizeInfo</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>ret</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_frameSizeInfo</name></type> <name>frameSizeInfo</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>frameSizeInfo</name><operator>.</operator><name>compressedSize</name></name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>frameSizeInfo</name><operator>.</operator><name>decompressedBound</name></name> <operator>=</operator> <name>ZSTD_CONTENTSIZE_ERROR</name></expr>;</expr_stmt>
    <return>return <expr><name>frameSizeInfo</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ZSTD_frameSizeInfo</name></type> <name>ZSTD_findFrameSizeInfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_frameSizeInfo</name></type> <name>frameSizeInfo</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>frameSizeInfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_frameSizeInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ZSTD_LEGACY_SUPPORT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>ZSTD_LEGACY_SUPPORT</name> <operator>&gt;=</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isLegacy</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>ZSTD_findFrameSizeInfoLegacy</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>srcSize</name> <operator>&gt;=</operator> <name>ZSTD_SKIPPABLEHEADERSIZE</name><operator>)</operator>
        <operator>&amp;&amp;</operator> <operator>(</operator><call><name>MEM_readLE32</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>ZSTD_MAGIC_SKIPPABLE_MASK</name><operator>)</operator> <operator>==</operator> <name>ZSTD_MAGIC_SKIPPABLE_START</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>frameSizeInfo</name><operator>.</operator><name>compressedSize</name></name> <operator>=</operator> <call><name>readSkippableFrameSize</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name><name>frameSizeInfo</name><operator>.</operator><name>compressedSize</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
               <name><name>frameSizeInfo</name><operator>.</operator><name>compressedSize</name></name> <operator>&lt;=</operator> <name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>frameSizeInfo</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ipstart</name> <init>= <expr><name>ip</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>remainingSize</name> <init>= <expr><name>srcSize</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>nbBlocks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ZSTD_frameHeader</name></type> <name>zfh</name></decl>;</decl_stmt>

        <comment type="block">/* Extract Frame Header */</comment>
        <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>ret</name> <init>= <expr><call><name>ZSTD_getFrameHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zfh</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><call><name>ZSTD_errorFrameSizeInfo</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><call><name>ZSTD_errorFrameSizeInfo</name><argument_list>(<argument><expr><call><name>ERROR</name><argument_list>(<argument><expr><name>srcSize_wrong</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block>

        <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name><name>zfh</name><operator>.</operator><name>headerSize</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>remainingSize</name> <operator>-=</operator> <name><name>zfh</name><operator>.</operator><name>headerSize</name></name></expr>;</expr_stmt>

        <comment type="block">/* Iterate over each block */</comment>
        <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>blockProperties_t</name></type> <name>blockProperties</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>cBlockSize</name> <init>= <expr><call><name>ZSTD_getcBlockSize</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>remainingSize</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blockProperties</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>cBlockSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><call><name>ZSTD_errorFrameSizeInfo</name><argument_list>(<argument><expr><name>cBlockSize</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>ZSTD_blockHeaderSize</name> <operator>+</operator> <name>cBlockSize</name> <operator>&gt;</operator> <name>remainingSize</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><call><name>ZSTD_errorFrameSizeInfo</name><argument_list>(<argument><expr><call><name>ERROR</name><argument_list>(<argument><expr><name>srcSize_wrong</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>ZSTD_blockHeaderSize</name> <operator>+</operator> <name>cBlockSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>remainingSize</name> <operator>-=</operator> <name>ZSTD_blockHeaderSize</name> <operator>+</operator> <name>cBlockSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>nbBlocks</name><operator>++</operator></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>blockProperties</name><operator>.</operator><name>lastBlock</name></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></while>

        <comment type="block">/* Final frame content checksum */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>zfh</name><operator>.</operator><name>checksumFlag</name></name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>remainingSize</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><call><name>ZSTD_errorFrameSizeInfo</name><argument_list>(<argument><expr><call><name>ERROR</name><argument_list>(<argument><expr><name>srcSize_wrong</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>ip</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>frameSizeInfo</name><operator>.</operator><name>compressedSize</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>ipstart</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>frameSizeInfo</name><operator>.</operator><name>decompressedBound</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>zfh</name><operator>.</operator><name>frameContentSize</name></name> <operator>!=</operator> <name>ZSTD_CONTENTSIZE_UNKNOWN</name><operator>)</operator></expr>
                                        ?</condition><then> <expr><name><name>zfh</name><operator>.</operator><name>frameContentSize</name></name></expr>
                                        </then><else>: <expr><name>nbBlocks</name> <operator>*</operator> <name><name>zfh</name><operator>.</operator><name>blockSizeMax</name></name></expr></else></ternary></expr>;</expr_stmt>
        <return>return <expr><name>frameSizeInfo</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** ZSTD_findFrameCompressedSize() :
 *  compatible with legacy mode
 *  `src` must point to the start of a ZSTD frame, ZSTD legacy frame, or skippable frame
 *  `srcSize` must be at least as large as the frame contained
 *  @return : the compressed size of the frame starting at `src` */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_findFrameCompressedSize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_frameSizeInfo</name> <specifier>const</specifier></type> <name>frameSizeInfo</name> <init>= <expr><call><name>ZSTD_findFrameSizeInfo</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><name><name>frameSizeInfo</name><operator>.</operator><name>compressedSize</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** ZSTD_decompressBound() :
 *  compatible with legacy mode
 *  `src` must point to the start of a ZSTD frame or a skippeable frame
 *  `srcSize` must be at least as large as the frame contained
 *  @return : the maximum decompressed size of the compressed source
 */</comment>
<function><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>ZSTD_decompressBound</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>bound</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Iterate over each frame */</comment>
    <while>while <condition>(<expr><name>srcSize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>ZSTD_frameSizeInfo</name> <specifier>const</specifier></type> <name>frameSizeInfo</name> <init>= <expr><call><name>ZSTD_findFrameSizeInfo</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>compressedSize</name> <init>= <expr><name><name>frameSizeInfo</name><operator>.</operator><name>compressedSize</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name> <specifier>const</specifier></type> <name>decompressedBound</name> <init>= <expr><name><name>frameSizeInfo</name><operator>.</operator><name>decompressedBound</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>compressedSize</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>decompressedBound</name> <operator>==</operator> <name>ZSTD_CONTENTSIZE_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>ZSTD_CONTENTSIZE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>srcSize</name> <operator>&gt;=</operator> <name>compressedSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>src</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <name>compressedSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>srcSize</name> <operator>-=</operator> <name>compressedSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bound</name> <operator>+=</operator> <name>decompressedBound</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>bound</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*-*************************************************************
 *   Frame decoding
 ***************************************************************/</comment>

<comment type="block" format="doxygen">/** ZSTD_insertBlock() :
 *  insert `src` block into `dctx` history. Useful to track uncompressed blocks. */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_insertBlock</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>blockStart</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>blockSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_insertBlock: %u bytes"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>blockSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_checkContinuity</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>blockStart</name></expr></argument>, <argument><expr><name>blockSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>previousDstEnd</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>blockStart</name> <operator>+</operator> <name>blockSize</name></expr>;</expr_stmt>
    <return>return <expr><name>blockSize</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_copyRawBlock</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                          <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_copyRawBlock"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>srcSize</name> <operator>&gt;</operator> <name>dstCapacity</name></expr></argument>, <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>dst</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>srcSize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr><name>dstBuffer_null</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>srcSize</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_setRleBlock</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                               <parameter><decl><type><name>BYTE</name></type> <name>b</name></decl></parameter>,
                               <parameter><decl><type><name>size_t</name></type> <name>regenSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>regenSize</name> <operator>&gt;</operator> <name>dstCapacity</name></expr></argument>, <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>dst</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>regenSize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr><name>dstBuffer_null</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>regenSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>regenSize</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_DCtx_trace_end</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name> <specifier>const</specifier><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><name>U64</name></type> <name>uncompressedSize</name></decl></parameter>, <parameter><decl><type><name>U64</name></type> <name>compressedSize</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>streaming</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ZSTD_TRACE</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>traceCtx</name></name> <operator>&amp;&amp;</operator> <name>ZSTD_trace_decompress_end</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>ZSTD_Trace</name></type> <name>trace</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trace</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>trace</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>trace</name><operator>.</operator><name>version</name></name> <operator>=</operator> <name>ZSTD_VERSION_NUMBER</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>trace</name><operator>.</operator><name>streaming</name></name> <operator>=</operator> <name>streaming</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>ddict</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>trace</name><operator>.</operator><name>dictionaryID</name></name> <operator>=</operator> <call><name>ZSTD_getDictID_fromDDict</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>ddict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>trace</name><operator>.</operator><name>dictionarySize</name></name> <operator>=</operator> <call><name>ZSTD_DDict_dictSize</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>ddict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>trace</name><operator>.</operator><name>dictionaryIsCold</name></name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>ddictIsCold</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>trace</name><operator>.</operator><name>uncompressedSize</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>uncompressedSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>trace</name><operator>.</operator><name>compressedSize</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>compressedSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>trace</name><operator>.</operator><name>dctx</name></name> <operator>=</operator> <name>dctx</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_trace_decompress_end</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>traceCtx</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>trace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>dctx</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>uncompressedSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>compressedSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>streaming</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*! ZSTD_decompressFrame() :
 * @dctx must be properly initialized
 *  will update *srcPtr and *srcSizePtr,
 *  to make *srcPtr progress by one frame. */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_decompressFrame</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>,
                                   <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                             <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier><modifier>*</modifier></type> <name>srcPtr</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>srcSizePtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>istart</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>*</operator><name>srcPtr</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><name>istart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ostart</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend</name> <init>= <expr><ternary><condition><expr><name>dstCapacity</name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>ostart</name> <operator>+</operator> <name>dstCapacity</name></expr> </then><else>: <expr><name>ostart</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><name>ostart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>remainingSrcSize</name> <init>= <expr><operator>*</operator><name>srcSizePtr</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_decompressFrame (srcSize:%i)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>*</operator><name>srcSizePtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check */</comment>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(
        <argument><expr><name>remainingSrcSize</name> <operator>&lt;</operator> <call><name>ZSTD_FRAMEHEADERSIZE_MIN</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>format</name></name></expr></argument>)</argument_list></call><operator>+</operator><name>ZSTD_blockHeaderSize</name></expr></argument>,
        <argument><expr><name>srcSize_wrong</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Frame Header */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>frameHeaderSize</name> <init>= <expr><call><name>ZSTD_frameHeaderSize_internal</name><argument_list>(
                <argument><expr><name>ip</name></expr></argument>, <argument><expr><call><name>ZSTD_FRAMEHEADERSIZE_PREFIX</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>format</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>format</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>frameHeaderSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>frameHeaderSize</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>remainingSrcSize</name> <operator>&lt;</operator> <name>frameHeaderSize</name><operator>+</operator><name>ZSTD_blockHeaderSize</name></expr></argument>,
                        <argument><expr><name>srcSize_wrong</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_decodeFrameHeader</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>frameHeaderSize</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>frameHeaderSize</name></expr>;</expr_stmt> <expr_stmt><expr><name>remainingSrcSize</name> <operator>-=</operator> <name>frameHeaderSize</name></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* Loop on each block */</comment>
    <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>decodedSize</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>blockProperties_t</name></type> <name>blockProperties</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>cBlockSize</name> <init>= <expr><call><name>ZSTD_getcBlockSize</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>remainingSrcSize</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blockProperties</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>cBlockSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>cBlockSize</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>ZSTD_blockHeaderSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>remainingSrcSize</name> <operator>-=</operator> <name>ZSTD_blockHeaderSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>cBlockSize</name> <operator>&gt;</operator> <name>remainingSrcSize</name></expr></argument>, <argument><expr><name>srcSize_wrong</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <switch>switch<condition>(<expr><name><name>blockProperties</name><operator>.</operator><name>blockType</name></name></expr>)</condition>
        <block>{<block_content>
        <case>case <expr><name>bt_compressed</name></expr>:</case>
            <expr_stmt><expr><name>decodedSize</name> <operator>=</operator> <call><name>ZSTD_decompressBlock_internal</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name><operator>-</operator><name>op</name><operator>)</operator></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>cBlockSize</name></expr></argument>, <comment type="block">/* frame */</comment> <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>not_streaming</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>bt_raw</name></expr> :</case>
            <expr_stmt><expr><name>decodedSize</name> <operator>=</operator> <call><name>ZSTD_copyRawBlock</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name><operator>-</operator><name>op</name><operator>)</operator></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>cBlockSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>bt_rle</name></expr> :</case>
            <expr_stmt><expr><name>decodedSize</name> <operator>=</operator> <call><name>ZSTD_setRleBlock</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name><operator>-</operator><name>op</name><operator>)</operator></expr></argument>, <argument><expr><operator>*</operator><name>ip</name></expr></argument>, <argument><expr><name><name>blockProperties</name><operator>.</operator><name>origSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>bt_reserved</name></expr> :</case>
        <default>default:</default>
            <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">"invalid block type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>

        <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>decodedSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>decodedSize</name></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>validateChecksum</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>XXH64_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dctx</name><operator>-&gt;</operator><name>xxhState</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>decodedSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>decodedSize</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>decodedSize</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ip</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>cBlockSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>remainingSrcSize</name> <operator>-=</operator> <name>cBlockSize</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>blockProperties</name><operator>.</operator><name>lastBlock</name></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>frameContentSize</name></name> <operator>!=</operator> <name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><operator>(</operator><name>U64</name><operator>)</operator><operator>(</operator><name>op</name><operator>-</operator><name>ostart</name><operator>)</operator> <operator>!=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>frameContentSize</name></name></expr></argument>,
                        <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>checksumFlag</name></name></expr>)</condition> <block>{<block_content> <comment type="block">/* Frame content checksum verification */</comment>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>remainingSrcSize</name><operator>&lt;</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>checksum_wrong</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dctx</name><operator>-&gt;</operator><name>forceIgnoreChecksum</name></name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>checkCalc</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><call><name>XXH64_digest</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dctx</name><operator>-&gt;</operator><name>xxhState</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name></type> <name>checkRead</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>checkRead</name> <operator>=</operator> <call><name>MEM_readLE32</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>checkRead</name> <operator>!=</operator> <name>checkCalc</name></expr></argument>, <argument><expr><name>checksum_wrong</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>ip</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>remainingSrcSize</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>ZSTD_DCtx_trace_end</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><operator>(</operator><name>U64</name><operator>)</operator><operator>(</operator><name>op</name><operator>-</operator><name>ostart</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>U64</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>istart</name><operator>)</operator></expr></argument>, <comment type="block">/* streaming */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Allow caller to get size read */</comment>
    <expr_stmt><expr><operator>*</operator><name>srcPtr</name> <operator>=</operator> <name>ip</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>srcSizePtr</name> <operator>=</operator> <name>remainingSrcSize</name></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>op</name><operator>-</operator><name>ostart</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_decompressMultiFrame</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>,
                                        <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                                  <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                                  <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>,
                                  <parameter><decl><type><specifier>const</specifier> <name>ZSTD_DDict</name><modifier>*</modifier></type> <name>ddict</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>void</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dststart</name> <init>= <expr><name>dst</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>moreThan1Frame</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_decompressMultiFrame"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dict</name><operator>==</operator><name>NULL</name> <operator>||</operator> <name>ddict</name><operator>==</operator><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* either dict or ddict set, not both */</comment>

    <if_stmt><if>if <condition>(<expr><name>ddict</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>dict</name> <operator>=</operator> <call><name>ZSTD_DDict_dictContent</name><argument_list>(<argument><expr><name>ddict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dictSize</name> <operator>=</operator> <call><name>ZSTD_DDict_dictSize</name><argument_list>(<argument><expr><name>ddict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <while>while <condition>(<expr><name>srcSize</name> <operator>&gt;=</operator> <call><name>ZSTD_startingInputLength</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>format</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ZSTD_LEGACY_SUPPORT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>ZSTD_LEGACY_SUPPORT</name> <operator>&gt;=</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
        <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isLegacy</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>size_t</name></type> <name>decodedSize</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>frameSize</name> <init>= <expr><call><name>ZSTD_findFrameCompressedSizeLegacy</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>frameSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>frameSize</name></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>staticSize</name></name></expr></argument>, <argument><expr><name>memory_allocation</name></expr></argument>,
                <argument><expr><literal type="string">"legacy support is not compatible with static dctx"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>decodedSize</name> <operator>=</operator> <call><name>ZSTD_decompressLegacy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>frameSize</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>decodedSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>decodedSize</name></expr>;</return></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>decodedSize</name> <operator>&lt;=</operator> <name>dstCapacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>dst</name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name> <operator>+</operator> <name>decodedSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>dstCapacity</name> <operator>-=</operator> <name>decodedSize</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>src</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <name>frameSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>srcSize</name> <operator>-=</operator> <name>frameSize</name></expr>;</expr_stmt>

            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>magicNumber</name> <init>= <expr><call><name>MEM_readLE32</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"reading magic number %08X (expecting %08X)"</literal></expr></argument>,
                        <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>magicNumber</name></expr></argument>, <argument><expr><name>ZSTD_MAGICNUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>magicNumber</name> <operator>&amp;</operator> <name>ZSTD_MAGIC_SKIPPABLE_MASK</name><operator>)</operator> <operator>==</operator> <name>ZSTD_MAGIC_SKIPPABLE_START</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>skippableSize</name> <init>= <expr><call><name>readSkippableFrameSize</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>skippableSize</name></expr></argument>, <argument><expr><literal type="string">"readSkippableFrameSize failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>skippableSize</name> <operator>&lt;=</operator> <name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>src</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>BYTE</name> <operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <name>skippableSize</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>srcSize</name> <operator>-=</operator> <name>skippableSize</name></expr>;</expr_stmt>
                <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>   </block_content>}</block>

        <if_stmt><if>if <condition>(<expr><name>ddict</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* we were called from ZSTD_decompress_usingDDict */</comment>
            <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_decompressBegin_usingDDict</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>ddict</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* this will initialize correctly with no dict if dict == NULL, so
             * use this in all cases but ddict */</comment>
            <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_decompressBegin_usingDict</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>ZSTD_checkContinuity</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <block>{<block_content>   <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>res</name> <init>= <expr><call><name>ZSTD_decompressFrame</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>,
                                                    <argument><expr><operator>&amp;</operator><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>srcSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(
                <argument><expr><operator>(</operator><call><name>ZSTD_getErrorCode</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ZSTD_error_prefix_unknown</name><operator>)</operator>
             <operator>&amp;&amp;</operator> <operator>(</operator><name>moreThan1Frame</name><operator>==</operator><literal type="number">1</literal><operator>)</operator></expr></argument>,
                <argument><expr><name>srcSize_wrong</name></expr></argument>,
                <argument><expr><literal type="string">"At least one frame successfully completed, "</literal>
                <literal type="string">"but following bytes are garbage: "</literal>
                <literal type="string">"it's more likely to be a srcSize error, "</literal>
                <literal type="string">"specifying more input bytes than size of frame(s). "</literal>
                <literal type="string">"Note: one could be unlucky, it might be a corruption error instead, "</literal>
                <literal type="string">"happening right at the place where we expect zstd magic bytes. "</literal>
                <literal type="string">"But this is _much_ less likely than a srcSize field error."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>res</name> <operator>&lt;=</operator> <name>dstCapacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>dst</name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name> <operator>+</operator> <name>res</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>dstCapacity</name> <operator>-=</operator> <name>res</name></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><name>moreThan1Frame</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></while>  <comment type="block">/* while (srcSize &gt;= ZSTD_frameHeaderSize_prefix) */</comment>

    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>srcSize_wrong</name></expr></argument>, <argument><expr><literal type="string">"input not entirely consumed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name> <operator>-</operator> <operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dststart</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_decompress_usingDict</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>,
                                 <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_decompressMultiFrame</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>ZSTD_DDict</name> <specifier>const</specifier><modifier>*</modifier></type> <name>ZSTD_getDDict</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch <condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>dictUses</name></name></expr>)</condition> <block>{<block_content>
    <default>default:</default>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* Impossible */</comment>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ZSTD_FALLTHROUGH</name></expr>;</expr_stmt>
    <case>case <expr><name>ZSTD_dont_use</name></expr>:</case>
        <expr_stmt><expr><call><name>ZSTD_clearDict</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    <case>case <expr><name>ZSTD_use_indefinitely</name></expr>:</case>
        <return>return <expr><name><name>dctx</name><operator>-&gt;</operator><name>ddict</name></name></expr>;</return>
    <case>case <expr><name>ZSTD_use_once</name></expr>:</case>
        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>dictUses</name></name> <operator>=</operator> <name>ZSTD_dont_use</name></expr>;</expr_stmt>
        <return>return <expr><name><name>dctx</name><operator>-&gt;</operator><name>ddict</name></name></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_decompressDCtx</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_decompress_usingDDict</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><call><name>ZSTD_getDDict</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>size_t</name></type> <name>ZSTD_decompress</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ZSTD_HEAPMODE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>ZSTD_HEAPMODE</name><operator>&gt;=</operator><literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <decl_stmt><decl><type><name>size_t</name></type> <name>regenSize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dctx</name> <init>=  <expr><call><name>ZSTD_createDCtx_internal</name><argument_list>(<argument><expr><name>ZSTD_defaultCMem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>dctx</name><operator>==</operator><name>NULL</name></expr></argument>, <argument><expr><name>memory_allocation</name></expr></argument>, <argument><expr><literal type="string">"NULL pointer!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>regenSize</name> <operator>=</operator> <call><name>ZSTD_decompressDCtx</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_freeDCtx</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>regenSize</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>   <comment type="block">/* stack mode */</comment>
    <decl_stmt><decl><type><name>ZSTD_DCtx</name></type> <name>dctx</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ZSTD_initDCtx_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>ZSTD_decompressDCtx</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<comment type="block">/*-**************************************
*   Advanced Streaming Decompression API
*   Bufferless and synchronous
****************************************/</comment>
<function><type><name>size_t</name></type> <name>ZSTD_nextSrcSizeToDecompress</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name><name>dctx</name><operator>-&gt;</operator><name>expected</name></name></expr>;</return> </block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Similar to ZSTD_nextSrcSizeToDecompress(), but when a block input can be streamed, we
 * allow taking a partial block as the input. Currently only raw uncompressed blocks can
 * be streamed.
 *
 * For blocks that can be streamed, this allows us to reduce the latency until we produce
 * output, and avoid copying the input.
 *
 * @param inputSize - The total amount of input that the caller currently has.
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_nextSrcSizeToDecompressWithInputSize</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>inputSize</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>dctx</name><operator>-&gt;</operator><name>stage</name></name> <operator>==</operator> <name>ZSTDds_decompressBlock</name> <operator>||</operator> <name><name>dctx</name><operator>-&gt;</operator><name>stage</name></name> <operator>==</operator> <name>ZSTDds_decompressLastBlock</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name><name>dctx</name><operator>-&gt;</operator><name>expected</name></name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>bType</name></name> <operator>!=</operator> <name>bt_raw</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name><name>dctx</name><operator>-&gt;</operator><name>expected</name></name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>BOUNDED</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>inputSize</name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>expected</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>ZSTD_nextInputType_e</name></type> <name>ZSTD_nextInputType</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <switch>switch<condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>stage</name></name></expr>)</condition>
    <block>{<block_content>
    <default>default:</default>   <comment type="block">/* should not happen */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ZSTD_FALLTHROUGH</name></expr>;</expr_stmt>
    <case>case <expr><name>ZSTDds_getFrameHeaderSize</name></expr>:</case>
        <expr_stmt><expr><name>ZSTD_FALLTHROUGH</name></expr>;</expr_stmt>
    <case>case <expr><name>ZSTDds_decodeFrameHeader</name></expr>:</case>
        <return>return <expr><name>ZSTDnit_frameHeader</name></expr>;</return>
    <case>case <expr><name>ZSTDds_decodeBlockHeader</name></expr>:</case>
        <return>return <expr><name>ZSTDnit_blockHeader</name></expr>;</return>
    <case>case <expr><name>ZSTDds_decompressBlock</name></expr>:</case>
        <return>return <expr><name>ZSTDnit_block</name></expr>;</return>
    <case>case <expr><name>ZSTDds_decompressLastBlock</name></expr>:</case>
        <return>return <expr><name>ZSTDnit_lastBlock</name></expr>;</return>
    <case>case <expr><name>ZSTDds_checkChecksum</name></expr>:</case>
        <return>return <expr><name>ZSTDnit_checksum</name></expr>;</return>
    <case>case <expr><name>ZSTDds_decodeSkippableHeader</name></expr>:</case>
        <expr_stmt><expr><name>ZSTD_FALLTHROUGH</name></expr>;</expr_stmt>
    <case>case <expr><name>ZSTDds_skipFrame</name></expr>:</case>
        <return>return <expr><name>ZSTDnit_skippableFrame</name></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ZSTD_isSkipFrame</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name><name>dctx</name><operator>-&gt;</operator><name>stage</name></name> <operator>==</operator> <name>ZSTDds_skipFrame</name></expr>;</return> </block_content>}</block></function>

<comment type="block" format="doxygen">/** ZSTD_decompressContinue() :
 *  srcSize : must be the exact nb of bytes expected (see ZSTD_nextSrcSizeToDecompress())
 *  @return : nb of bytes generated into `dst` (necessarily &lt;= `dstCapacity)
 *            or an error code, which can be tested using ZSTD_isError() */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_decompressContinue</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_decompressContinue (srcSize:%u)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Sanity check */</comment>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>srcSize</name> <operator>!=</operator> <call><name>ZSTD_nextSrcSizeToDecompressWithInputSize</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>srcSize_wrong</name></expr></argument>, <argument><expr><literal type="string">"not allowed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_checkContinuity</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>processedCSize</name></name> <operator>+=</operator> <name>srcSize</name></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>stage</name></name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>ZSTDds_getFrameHeaderSize</name></expr> :</case>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>src</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>ZSTD_f_zstd1</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* allows header */</comment>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>srcSize</name> <operator>&gt;=</operator> <name>ZSTD_FRAMEIDSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* to read skippable magic number */</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>MEM_readLE32</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>ZSTD_MAGIC_SKIPPABLE_MASK</name><operator>)</operator> <operator>==</operator> <name>ZSTD_MAGIC_SKIPPABLE_START</name></expr>)</condition> <block>{<block_content>        <comment type="block">/* skippable frame */</comment>
                <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>headerBuffer</name></name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>expected</name></name> <operator>=</operator> <name>ZSTD_SKIPPABLEHEADERSIZE</name> <operator>-</operator> <name>srcSize</name></expr>;</expr_stmt>  <comment type="block">/* remaining to load to get full skippable frame header */</comment>
                <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>stage</name></name> <operator>=</operator> <name>ZSTDds_decodeSkippableHeader</name></expr>;</expr_stmt>
                <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>   </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>headerSize</name></name> <operator>=</operator> <call><name>ZSTD_frameHeaderSize_internal</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>format</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>headerSize</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name><name>dctx</name><operator>-&gt;</operator><name>headerSize</name></name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>headerBuffer</name></name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>expected</name></name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>headerSize</name></name> <operator>-</operator> <name>srcSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>stage</name></name> <operator>=</operator> <name>ZSTDds_decodeFrameHeader</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>

    <case>case <expr><name>ZSTDds_decodeFrameHeader</name></expr>:</case>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>src</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>headerBuffer</name></name> <operator>+</operator> <operator>(</operator><name><name>dctx</name><operator>-&gt;</operator><name>headerSize</name></name> <operator>-</operator> <name>srcSize</name><operator>)</operator></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_decodeFrameHeader</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>headerBuffer</name></name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>headerSize</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>expected</name></name> <operator>=</operator> <name>ZSTD_blockHeaderSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>stage</name></name> <operator>=</operator> <name>ZSTDds_decodeBlockHeader</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>

    <case>case <expr><name>ZSTDds_decodeBlockHeader</name></expr>:</case>
        <block>{<block_content>   <decl_stmt><decl><type><name>blockProperties_t</name></type> <name>bp</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>cBlockSize</name> <init>= <expr><call><name>ZSTD_getcBlockSize</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>ZSTD_blockHeaderSize</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>cBlockSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>cBlockSize</name></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>cBlockSize</name> <operator>&gt;</operator> <name><name>dctx</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>blockSizeMax</name></name></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">"Block Size Exceeds Maximum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>expected</name></name> <operator>=</operator> <name>cBlockSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>bType</name></name> <operator>=</operator> <name><name>bp</name><operator>.</operator><name>blockType</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>rleSize</name></name> <operator>=</operator> <name><name>bp</name><operator>.</operator><name>origSize</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>cBlockSize</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>stage</name></name> <operator>=</operator> <ternary><condition><expr><name><name>bp</name><operator>.</operator><name>lastBlock</name></name></expr> ?</condition><then> <expr><name>ZSTDds_decompressLastBlock</name></expr> </then><else>: <expr><name>ZSTDds_decompressBlock</name></expr></else></ternary></expr>;</expr_stmt>
                <return>return <expr><literal type="number">0</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* empty block */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>bp</name><operator>.</operator><name>lastBlock</name></name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>checksumFlag</name></name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>expected</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>stage</name></name> <operator>=</operator> <name>ZSTDds_checkChecksum</name></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>expected</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* end of frame */</comment>
                    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>stage</name></name> <operator>=</operator> <name>ZSTDds_getFrameHeaderSize</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>expected</name></name> <operator>=</operator> <name>ZSTD_blockHeaderSize</name></expr>;</expr_stmt>  <comment type="block">/* jump to next header */</comment>
                <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>stage</name></name> <operator>=</operator> <name>ZSTDds_decodeBlockHeader</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block>

    <case>case <expr><name>ZSTDds_decompressLastBlock</name></expr>:</case>
    <case>case <expr><name>ZSTDds_decompressBlock</name></expr>:</case>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_decompressContinue: case ZSTDds_decompressBlock"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name></type> <name>rSize</name></decl>;</decl_stmt>
            <switch>switch<condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>bType</name></name></expr>)</condition>
            <block>{<block_content>
            <case>case <expr><name>bt_compressed</name></expr>:</case>
                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_decompressContinue: case bt_compressed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>rSize</name> <operator>=</operator> <call><name>ZSTD_decompressBlock_internal</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <comment type="block">/* frame */</comment> <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>is_streaming</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>expected</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Streaming not supported */</comment>
                <break>break;</break>
            <case>case <expr><name>bt_raw</name></expr> :</case>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>srcSize</name> <operator>&lt;=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>expected</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>rSize</name> <operator>=</operator> <call><name>ZSTD_copyRawBlock</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>rSize</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_copyRawBlock failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rSize</name> <operator>==</operator> <name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>expected</name></name> <operator>-=</operator> <name>rSize</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>bt_rle</name></expr> :</case>
                <expr_stmt><expr><name>rSize</name> <operator>=</operator> <call><name>ZSTD_setRleBlock</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>rleSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>expected</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Streaming not supported */</comment>
                <break>break;</break>
            <case>case <expr><name>bt_reserved</name></expr> :</case>   <comment type="block">/* should never happen */</comment>
            <default>default:</default>
                <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">"invalid block type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></switch>
            <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>rSize</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>rSize</name> <operator>&gt;</operator> <name><name>dctx</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>blockSizeMax</name></name></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">"Decompressed Block Size Exceeds Maximum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_decompressContinue: decoded size from block : %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>rSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>decodedSize</name></name> <operator>+=</operator> <name>rSize</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>validateChecksum</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>XXH64_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dctx</name><operator>-&gt;</operator><name>xxhState</name></name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>rSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>previousDstEnd</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>dst</name> <operator>+</operator> <name>rSize</name></expr>;</expr_stmt>

            <comment type="block">/* Stay on the same stage until we are finished streaming the block. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>expected</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <return>return <expr><name>rSize</name></expr>;</return>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>stage</name></name> <operator>==</operator> <name>ZSTDds_decompressLastBlock</name></expr>)</condition> <block>{<block_content>   <comment type="block">/* end of frame */</comment>
                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_decompressContinue: decoded size from frame : %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>dctx</name><operator>-&gt;</operator><name>decodedSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(
                    <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>frameContentSize</name></name> <operator>!=</operator> <name>ZSTD_CONTENTSIZE_UNKNOWN</name>
                 <operator>&amp;&amp;</operator> <name><name>dctx</name><operator>-&gt;</operator><name>decodedSize</name></name> <operator>!=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>frameContentSize</name></name></expr></argument>,
                    <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>checksumFlag</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* another round for frame checksum */</comment>
                    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>expected</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>stage</name></name> <operator>=</operator> <name>ZSTDds_checkChecksum</name></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><call><name>ZSTD_DCtx_trace_end</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>decodedSize</name></name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>processedCSize</name></name></expr></argument>, <comment type="block">/* streaming */</comment> <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>expected</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>   <comment type="block">/* ends here */</comment>
                    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>stage</name></name> <operator>=</operator> <name>ZSTDds_getFrameHeaderSize</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>stage</name></name> <operator>=</operator> <name>ZSTDds_decodeBlockHeader</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>expected</name></name> <operator>=</operator> <name>ZSTD_blockHeaderSize</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <return>return <expr><name>rSize</name></expr>;</return>
        </block_content>}</block>

    <case>case <expr><name>ZSTDds_checkChecksum</name></expr>:</case>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>srcSize</name> <operator>==</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* guaranteed by dctx-&gt;expected */</comment>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>validateChecksum</name></name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>h32</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><call><name>XXH64_digest</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dctx</name><operator>-&gt;</operator><name>xxhState</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>check32</name> <init>= <expr><call><name>MEM_readLE32</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_decompressContinue: checksum : calculated %08X :: %08X read"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>h32</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>check32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>check32</name> <operator>!=</operator> <name>h32</name></expr></argument>, <argument><expr><name>checksum_wrong</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>ZSTD_DCtx_trace_end</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>decodedSize</name></name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>processedCSize</name></name></expr></argument>, <comment type="block">/* streaming */</comment> <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>expected</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>stage</name></name> <operator>=</operator> <name>ZSTDds_getFrameHeaderSize</name></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block>

    <case>case <expr><name>ZSTDds_decodeSkippableHeader</name></expr>:</case>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>src</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>srcSize</name> <operator>&lt;=</operator> <name>ZSTD_SKIPPABLEHEADERSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>headerBuffer</name></name> <operator>+</operator> <operator>(</operator><name>ZSTD_SKIPPABLEHEADERSIZE</name> <operator>-</operator> <name>srcSize</name><operator>)</operator></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* complete skippable header */</comment>
        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>expected</name></name> <operator>=</operator> <call><name>MEM_readLE32</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>headerBuffer</name></name> <operator>+</operator> <name>ZSTD_FRAMEIDSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* note : dctx-&gt;expected can grow seriously large, beyond local buffer size */</comment>
        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>stage</name></name> <operator>=</operator> <name>ZSTDds_skipFrame</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>

    <case>case <expr><name>ZSTDds_skipFrame</name></expr>:</case>
        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>expected</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>stage</name></name> <operator>=</operator> <name>ZSTDds_getFrameHeaderSize</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>

    <default>default:</default>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* impossible */</comment>
        <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr><name>GENERIC</name></expr></argument>, <argument><expr><literal type="string">"impossible to reach"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* some compilers require default to do something */</comment>
    </block_content>}</block></switch>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_refDictContent</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>dictEnd</name></name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>previousDstEnd</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>virtualStart</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>dict</name> <operator>-</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>dctx</name><operator>-&gt;</operator><name>previousDstEnd</name></name><operator>)</operator> <operator>-</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>dctx</name><operator>-&gt;</operator><name>prefixStart</name></name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>prefixStart</name></name> <operator>=</operator> <name>dict</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>previousDstEnd</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>dict</name> <operator>+</operator> <name>dictSize</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION</name></cpp:ifdef>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>dictContentBeginForFuzzing</name></name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>prefixStart</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>dictContentEndForFuzzing</name></name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>previousDstEnd</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! ZSTD_loadDEntropy() :
 *  dict : must point at beginning of a valid zstd dictionary.
 * @return : size of entropy tables read */</comment>
<function><type><name>size_t</name></type>
<name>ZSTD_loadDEntropy</name><parameter_list>(<parameter><decl><type><name>ZSTD_entropyDTables_t</name><modifier>*</modifier></type> <name>entropy</name></decl></parameter>,
                  <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>dictSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>dictPtr</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>dict</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictEnd</name> <init>= <expr><name>dictPtr</name> <operator>+</operator> <name>dictSize</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>dictSize</name> <operator>&lt;=</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name>dictionary_corrupted</name></expr></argument>, <argument><expr><literal type="string">"dict is too small"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>MEM_readLE32</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ZSTD_MAGIC_DICTIONARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* dict must be valid */</comment>
    <expr_stmt><expr><name>dictPtr</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>   <comment type="block">/* skip header = magic + dictID */</comment>

    <expr_stmt><expr><call><name>ZSTD_STATIC_ASSERT</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ZSTD_entropyDTables_t</name></expr></argument>, <argument><expr><name>OFTable</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>ZSTD_entropyDTables_t</name></expr></argument>, <argument><expr><name>LLTable</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>entropy</name><operator>-&gt;</operator><name>LLTable</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_STATIC_ASSERT</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ZSTD_entropyDTables_t</name></expr></argument>, <argument><expr><name>MLTable</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>ZSTD_entropyDTables_t</name></expr></argument>, <argument><expr><name>OFTable</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>entropy</name><operator>-&gt;</operator><name>OFTable</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>entropy</name><operator>-&gt;</operator><name>LLTable</name></name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>entropy</name><operator>-&gt;</operator><name>OFTable</name></name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>entropy</name><operator>-&gt;</operator><name>MLTable</name></name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <name>HUF_DECOMPRESS_WORKSPACE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>void</name><modifier>*</modifier> <specifier>const</specifier></type> <name>workspace</name> <init>= <expr><operator>&amp;</operator><name><name>entropy</name><operator>-&gt;</operator><name>LLTable</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* use fse tables as temporary workspace; implies fse tables are grouped together */</comment>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>workspaceSize</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>entropy</name><operator>-&gt;</operator><name>LLTable</name></name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>entropy</name><operator>-&gt;</operator><name>OFTable</name></name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>entropy</name><operator>-&gt;</operator><name>MLTable</name></name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HUF_FORCE_DECOMPRESS_X1</name></cpp:ifdef>
        <comment type="block">/* in minimal huffman, we always use X1 variants */</comment>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>hSize</name> <init>= <expr><call><name>HUF_readDTableX1_wksp</name><argument_list>(<argument><expr><name><name>entropy</name><operator>-&gt;</operator><name>hufTable</name></name></expr></argument>,
                                                <argument><expr><name>dictPtr</name></expr></argument>, <argument><expr><name>dictEnd</name> <operator>-</operator> <name>dictPtr</name></expr></argument>,
                                                <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>workspaceSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>hSize</name> <init>= <expr><call><name>HUF_readDTableX2_wksp</name><argument_list>(<argument><expr><name><name>entropy</name><operator>-&gt;</operator><name>hufTable</name></name></expr></argument>,
                                                <argument><expr><name>dictPtr</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>dictEnd</name> <operator>-</operator> <name>dictPtr</name><operator>)</operator></expr></argument>,
                                                <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>workspaceSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><call><name>HUF_isError</name><argument_list>(<argument><expr><name>hSize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dictionary_corrupted</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dictPtr</name> <operator>+=</operator> <name>hSize</name></expr>;</expr_stmt>
    </block_content>}</block>

    <block>{<block_content>   <decl_stmt><decl><type><name>short</name></type> <name><name>offcodeNCount</name><index>[<expr><name>MaxOff</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name></type> <name>offcodeMaxValue</name> <init>= <expr><name>MaxOff</name></expr></init></decl>, <decl><type ref="prev"/><name>offcodeLog</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>offcodeHeaderSize</name> <init>= <expr><call><name>FSE_readNCount</name><argument_list>(<argument><expr><name>offcodeNCount</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offcodeMaxValue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offcodeLog</name></expr></argument>, <argument><expr><name>dictPtr</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>dictEnd</name><operator>-</operator><name>dictPtr</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><call><name>FSE_isError</name><argument_list>(<argument><expr><name>offcodeHeaderSize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dictionary_corrupted</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>offcodeMaxValue</name> <operator>&gt;</operator> <name>MaxOff</name></expr></argument>, <argument><expr><name>dictionary_corrupted</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>offcodeLog</name> <operator>&gt;</operator> <name>OffFSELog</name></expr></argument>, <argument><expr><name>dictionary_corrupted</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_buildFSETable</name><argument_list>( <argument><expr><name><name>entropy</name><operator>-&gt;</operator><name>OFTable</name></name></expr></argument>,
                            <argument><expr><name>offcodeNCount</name></expr></argument>, <argument><expr><name>offcodeMaxValue</name></expr></argument>,
                            <argument><expr><name>OF_base</name></expr></argument>, <argument><expr><name>OF_bits</name></expr></argument>,
                            <argument><expr><name>offcodeLog</name></expr></argument>,
                            <argument><expr><name><name>entropy</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>entropy</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
                            <comment type="block">/* bmi2 */</comment><argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dictPtr</name> <operator>+=</operator> <name>offcodeHeaderSize</name></expr>;</expr_stmt>
    </block_content>}</block>

    <block>{<block_content>   <decl_stmt><decl><type><name>short</name></type> <name><name>matchlengthNCount</name><index>[<expr><name>MaxML</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name></type> <name>matchlengthMaxValue</name> <init>= <expr><name>MaxML</name></expr></init></decl>, <decl><type ref="prev"/><name>matchlengthLog</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>matchlengthHeaderSize</name> <init>= <expr><call><name>FSE_readNCount</name><argument_list>(<argument><expr><name>matchlengthNCount</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>matchlengthMaxValue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>matchlengthLog</name></expr></argument>, <argument><expr><name>dictPtr</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>dictEnd</name><operator>-</operator><name>dictPtr</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><call><name>FSE_isError</name><argument_list>(<argument><expr><name>matchlengthHeaderSize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dictionary_corrupted</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>matchlengthMaxValue</name> <operator>&gt;</operator> <name>MaxML</name></expr></argument>, <argument><expr><name>dictionary_corrupted</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>matchlengthLog</name> <operator>&gt;</operator> <name>MLFSELog</name></expr></argument>, <argument><expr><name>dictionary_corrupted</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_buildFSETable</name><argument_list>( <argument><expr><name><name>entropy</name><operator>-&gt;</operator><name>MLTable</name></name></expr></argument>,
                            <argument><expr><name>matchlengthNCount</name></expr></argument>, <argument><expr><name>matchlengthMaxValue</name></expr></argument>,
                            <argument><expr><name>ML_base</name></expr></argument>, <argument><expr><name>ML_bits</name></expr></argument>,
                            <argument><expr><name>matchlengthLog</name></expr></argument>,
                            <argument><expr><name><name>entropy</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>entropy</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
                            <comment type="block">/* bmi2 */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dictPtr</name> <operator>+=</operator> <name>matchlengthHeaderSize</name></expr>;</expr_stmt>
    </block_content>}</block>

    <block>{<block_content>   <decl_stmt><decl><type><name>short</name></type> <name><name>litlengthNCount</name><index>[<expr><name>MaxLL</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name></type> <name>litlengthMaxValue</name> <init>= <expr><name>MaxLL</name></expr></init></decl>, <decl><type ref="prev"/><name>litlengthLog</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>litlengthHeaderSize</name> <init>= <expr><call><name>FSE_readNCount</name><argument_list>(<argument><expr><name>litlengthNCount</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>litlengthMaxValue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>litlengthLog</name></expr></argument>, <argument><expr><name>dictPtr</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>dictEnd</name><operator>-</operator><name>dictPtr</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><call><name>FSE_isError</name><argument_list>(<argument><expr><name>litlengthHeaderSize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dictionary_corrupted</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>litlengthMaxValue</name> <operator>&gt;</operator> <name>MaxLL</name></expr></argument>, <argument><expr><name>dictionary_corrupted</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>litlengthLog</name> <operator>&gt;</operator> <name>LLFSELog</name></expr></argument>, <argument><expr><name>dictionary_corrupted</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_buildFSETable</name><argument_list>( <argument><expr><name><name>entropy</name><operator>-&gt;</operator><name>LLTable</name></name></expr></argument>,
                            <argument><expr><name>litlengthNCount</name></expr></argument>, <argument><expr><name>litlengthMaxValue</name></expr></argument>,
                            <argument><expr><name>LL_base</name></expr></argument>, <argument><expr><name>LL_bits</name></expr></argument>,
                            <argument><expr><name>litlengthLog</name></expr></argument>,
                            <argument><expr><name><name>entropy</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>entropy</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
                            <comment type="block">/* bmi2 */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dictPtr</name> <operator>+=</operator> <name>litlengthHeaderSize</name></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>dictPtr</name><operator>+</operator><literal type="number">12</literal> <operator>&gt;</operator> <name>dictEnd</name></expr></argument>, <argument><expr><name>dictionary_corrupted</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>dictContentSize</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>dictEnd</name> <operator>-</operator> <operator>(</operator><name>dictPtr</name><operator>+</operator><literal type="number">12</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>rep</name> <init>= <expr><call><name>MEM_readLE32</name><argument_list>(<argument><expr><name>dictPtr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name>dictPtr</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>rep</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>rep</name> <operator>&gt;</operator> <name>dictContentSize</name></expr></argument>,
                            <argument><expr><name>dictionary_corrupted</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>entropy</name><operator>-&gt;</operator><name>rep</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>rep</name></expr>;</expr_stmt>
    </block_content>}</block></for>   </block_content>}</block>

    <return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>dictPtr</name> <operator>-</operator> <operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>dict</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_decompress_insertDictionary</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>dictSize</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ZSTD_refDictContent</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>magic</name> <init>= <expr><call><name>MEM_readLE32</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>magic</name> <operator>!=</operator> <name>ZSTD_MAGIC_DICTIONARY</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><call><name>ZSTD_refDictContent</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>)</argument_list></call></expr>;</return>   <comment type="block">/* pure content mode */</comment>
    </block_content>}</block></if></if_stmt>   </block_content>}</block>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>dictID</name></name> <operator>=</operator> <call><name>MEM_readLE32</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>dict</name> <operator>+</operator> <name>ZSTD_FRAMEIDSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* load entropy tables */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>eSize</name> <init>= <expr><call><name>ZSTD_loadDEntropy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dctx</name><operator>-&gt;</operator><name>entropy</name></name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>eSize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dictionary_corrupted</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dict</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>dict</name> <operator>+</operator> <name>eSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dictSize</name> <operator>-=</operator> <name>eSize</name></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>litEntropy</name></name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>fseEntropy</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/* reference dictionary content */</comment>
    <return>return <expr><call><name>ZSTD_refDictContent</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_decompressBegin</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dctx</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ZSTD_TRACE</name></expr></cpp:if>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>traceCtx</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>ZSTD_trace_decompress_begin</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>ZSTD_trace_decompress_begin</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>expected</name></name> <operator>=</operator> <call><name>ZSTD_startingInputLength</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>format</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* dctx-&gt;format must be properly set */</comment>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>stage</name></name> <operator>=</operator> <name>ZSTDds_getFrameHeaderSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>processedCSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>decodedSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>previousDstEnd</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>prefixStart</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>virtualStart</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>dictEnd</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>hufTable</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>HUF_DTable</name><operator>)</operator><operator>(</operator><operator>(</operator><name>ZSTD_HUFFDTABLE_CAPACITY_LOG</name><operator>)</operator><operator>*</operator><literal type="number">0x1000001</literal><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* cover both little and big endian */</comment>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>litEntropy</name></name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>fseEntropy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>dictID</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>bType</name></name> <operator>=</operator> <name>bt_reserved</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>rep</name></name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>repStartValue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>rep</name></name></expr></argument>, <argument><expr><name>repStartValue</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repStartValue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* initial repcodes */</comment>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>LLTptr</name></name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>LLTable</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>MLTptr</name></name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>MLTable</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>OFTptr</name></name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>OFTable</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>HUFptr</name></name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>hufTable</name></name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_decompressBegin_usingDict</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_decompressBegin</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>dict</name> <operator>&amp;&amp;</operator> <name>dictSize</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(
            <argument><expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><call><name>ZSTD_decompress_insertDictionary</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><name>dictionary_corrupted</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ======   ZSTD_DDict   ====== */</comment>

<function><type><name>size_t</name></type> <name>ZSTD_decompressBegin_usingDDict</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ZSTD_DDict</name><modifier>*</modifier></type> <name>ddict</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_decompressBegin_usingDDict"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dctx</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ddict</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictStart</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>ZSTD_DDict_dictContent</name><argument_list>(<argument><expr><name>ddict</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>dictSize</name> <init>= <expr><call><name>ZSTD_DDict_dictSize</name><argument_list>(<argument><expr><name>ddict</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictEnd</name> <init>= <expr><name>dictStart</name> <operator>+</operator> <name>dictSize</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>ddictIsCold</name></name> <operator>=</operator> <operator>(</operator><name><name>dctx</name><operator>-&gt;</operator><name>dictEnd</name></name> <operator>!=</operator> <name>dictEnd</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"DDict is %s"</literal></expr></argument>,
                    <argument><expr><ternary><condition><expr><name><name>dctx</name><operator>-&gt;</operator><name>ddictIsCold</name></name></expr> ?</condition><then> <expr><literal type="string">"~cold~"</literal></expr> </then><else>: <expr><literal type="string">"hot!"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_decompressBegin</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ddict</name></expr>)</condition> <block>{<block_content>   <comment type="block">/* NULL ddict is equivalent to no dictionary */</comment>
        <expr_stmt><expr><call><name>ZSTD_copyDDictParameters</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>ddict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! ZSTD_getDictID_fromDict() :
 *  Provides the dictID stored within dictionary.
 *  if @return == 0, the dictionary is not conformant with Zstandard specification.
 *  It can still be loaded, but as a content-only dictionary. */</comment>
<function><type><name>unsigned</name></type> <name>ZSTD_getDictID_fromDict</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>dictSize</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>MEM_readLE32</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ZSTD_MAGIC_DICTIONARY</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>MEM_readLE32</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>dict</name> <operator>+</operator> <name>ZSTD_FRAMEIDSIZE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! ZSTD_getDictID_fromFrame() :
 *  Provides the dictID required to decompress frame stored within `src`.
 *  If @return == 0, the dictID could not be decoded.
 *  This could for one of the following reasons :
 *  - The frame does not require a dictionary (most common case).
 *  - The frame was built with dictID intentionally removed.
 *    Needed dictionary is a hidden piece of information.
 *    Note : this use case also happens when using a non-conformant dictionary.
 *  - `srcSize` is too small, and as a result, frame header could not be decoded.
 *    Note : possible if `srcSize &lt; ZSTD_FRAMEHEADERSIZE_MAX`.
 *  - This is not a Zstandard frame.
 *  When identifying the exact failure cause, it's possible to use
 *  ZSTD_getFrameHeader(), which will provide a more precise error code. */</comment>
<function><type><name>unsigned</name></type> <name>ZSTD_getDictID_fromFrame</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_frameHeader</name></type> <name>zfp</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>ZSTD_frame</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>hError</name> <init>= <expr><call><name>ZSTD_getFrameHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zfp</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>hError</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name><name>zfp</name><operator>.</operator><name>dictID</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*! ZSTD_decompress_usingDDict() :
*   Decompression using a pre-digested Dictionary
*   Use dictionary without significant overhead. */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_decompress_usingDDict</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>,
                                  <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                            <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                            <parameter><decl><type><specifier>const</specifier> <name>ZSTD_DDict</name><modifier>*</modifier></type> <name>ddict</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* pass content and size in case legacy frames are encountered */</comment>
    <return>return <expr><call><name>ZSTD_decompressMultiFrame</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>,
                                     <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                     <argument><expr><name>ddict</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*=====================================
*   Streaming decompression
*====================================*/</comment>

<function><type><name>ZSTD_DStream</name><modifier>*</modifier></type> <name>ZSTD_createDStream</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_createDStream"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>ZSTD_createDCtx_internal</name><argument_list>(<argument><expr><name>ZSTD_defaultCMem</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>ZSTD_DStream</name><modifier>*</modifier></type> <name>ZSTD_initStaticDStream</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>workspace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>workspaceSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_initStaticDCtx</name><argument_list>(<argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>workspaceSize</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>ZSTD_DStream</name><modifier>*</modifier></type> <name>ZSTD_createDStream_advanced</name><parameter_list>(<parameter><decl><type><name>ZSTD_customMem</name></type> <name>customMem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_createDCtx_internal</name><argument_list>(<argument><expr><name>customMem</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_freeDStream</name><parameter_list>(<parameter><decl><type><name>ZSTD_DStream</name><modifier>*</modifier></type> <name>zds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_freeDCtx</name><argument_list>(<argument><expr><name>zds</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ***  Initialization  *** */</comment>

<function><type><name>size_t</name></type> <name>ZSTD_DStreamInSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>  <block>{<block_content> <return>return <expr><name>ZSTD_BLOCKSIZE_MAX</name> <operator>+</operator> <name>ZSTD_blockHeaderSize</name></expr>;</return> </block_content>}</block></function>
<function><type><name>size_t</name></type> <name>ZSTD_DStreamOutSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>ZSTD_BLOCKSIZE_MAX</name></expr>;</return> </block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_DCtx_loadDictionary_advanced</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>,
                                         <parameter><decl><type><name>ZSTD_dictLoadMethod_e</name></type> <name>dictLoadMethod</name></decl></parameter>,
                                         <parameter><decl><type><name>ZSTD_dictContentType_e</name></type> <name>dictContentType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>!=</operator> <name>zdss_init</name></expr></argument>, <argument><expr><name>stage_wrong</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_clearDict</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>dict</name> <operator>&amp;&amp;</operator> <name>dictSize</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>ddictLocal</name></name> <operator>=</operator> <call><name>ZSTD_createDDict_advanced</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>, <argument><expr><name>dictLoadMethod</name></expr></argument>, <argument><expr><name>dictContentType</name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>customMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>ddictLocal</name></name> <operator>==</operator> <name>NULL</name></expr></argument>, <argument><expr><name>memory_allocation</name></expr></argument>, <argument><expr><literal type="string">"NULL pointer!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>ddict</name></name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>ddictLocal</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>dictUses</name></name> <operator>=</operator> <name>ZSTD_use_indefinitely</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_DCtx_loadDictionary_byReference</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_DCtx_loadDictionary_advanced</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>, <argument><expr><name>ZSTD_dlm_byRef</name></expr></argument>, <argument><expr><name>ZSTD_dct_auto</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_DCtx_loadDictionary</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_DCtx_loadDictionary_advanced</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>, <argument><expr><name>ZSTD_dlm_byCopy</name></expr></argument>, <argument><expr><name>ZSTD_dct_auto</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_DCtx_refPrefix_advanced</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>prefix</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>prefixSize</name></decl></parameter>, <parameter><decl><type><name>ZSTD_dictContentType_e</name></type> <name>dictContentType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_DCtx_loadDictionary_advanced</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>prefixSize</name></expr></argument>, <argument><expr><name>ZSTD_dlm_byRef</name></expr></argument>, <argument><expr><name>dictContentType</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>dictUses</name></name> <operator>=</operator> <name>ZSTD_use_once</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_DCtx_refPrefix</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>prefix</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>prefixSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_DCtx_refPrefix_advanced</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>prefixSize</name></expr></argument>, <argument><expr><name>ZSTD_dct_rawContent</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ZSTD_initDStream_usingDict() :
 * return : expected size, aka ZSTD_startingInputLength().
 * this function cannot fail */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_initDStream_usingDict</name><parameter_list>(<parameter><decl><type><name>ZSTD_DStream</name><modifier>*</modifier></type> <name>zds</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_initDStream_usingDict"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_DCtx_reset</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>ZSTD_reset_session_only</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_DCtx_loadDictionary</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>ZSTD_startingInputLength</name><argument_list>(<argument><expr><name><name>zds</name><operator>-&gt;</operator><name>format</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* note : this variant can't fail */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_initDStream</name><parameter_list>(<parameter><decl><type><name>ZSTD_DStream</name><modifier>*</modifier></type> <name>zds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_initDStream"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>ZSTD_initDStream_usingDDict</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ZSTD_initDStream_usingDDict() :
 * ddict will just be referenced, and must outlive decompression session
 * this function cannot fail */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_initDStream_usingDDict</name><parameter_list>(<parameter><decl><type><name>ZSTD_DStream</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ZSTD_DDict</name><modifier>*</modifier></type> <name>ddict</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_DCtx_reset</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>ZSTD_reset_session_only</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_DCtx_refDDict</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>ddict</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>ZSTD_startingInputLength</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>format</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ZSTD_resetDStream() :
 * return : expected size, aka ZSTD_startingInputLength().
 * this function cannot fail */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_resetDStream</name><parameter_list>(<parameter><decl><type><name>ZSTD_DStream</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_DCtx_reset</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>ZSTD_reset_session_only</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>ZSTD_startingInputLength</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>format</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>size_t</name></type> <name>ZSTD_DCtx_refDDict</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ZSTD_DDict</name><modifier>*</modifier></type> <name>ddict</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>!=</operator> <name>zdss_init</name></expr></argument>, <argument><expr><name>stage_wrong</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_clearDict</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ddict</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>ddict</name></name> <operator>=</operator> <name>ddict</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>dictUses</name></name> <operator>=</operator> <name>ZSTD_use_indefinitely</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>refMultipleDDicts</name></name> <operator>==</operator> <name>ZSTD_rmd_refMultipleDDicts</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>ddictSet</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>ddictSet</name></name> <operator>=</operator> <call><name>ZSTD_createDDictHashSet</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>customMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dctx</name><operator>-&gt;</operator><name>ddictSet</name></name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr><name>memory_allocation</name></expr></argument>, <argument><expr><literal type="string">"Failed to allocate memory for hash set!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>dctx</name><operator>-&gt;</operator><name>staticSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Impossible: ddictSet cannot have been allocated if static dctx */</comment>
            <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_DDictHashSet_addDDict</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>ddictSet</name></name></expr></argument>, <argument><expr><name>ddict</name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>customMem</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ZSTD_DCtx_setMaxWindowSize() :
 * note : no direct equivalence in ZSTD_DCtx_setParameter,
 * since this version sets windowSize, and the other sets windowLog */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_DCtx_setMaxWindowSize</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>maxWindowSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_bounds</name> <specifier>const</specifier></type> <name>bounds</name> <init>= <expr><call><name>ZSTD_dParam_getBounds</name><argument_list>(<argument><expr><name>ZSTD_d_windowLogMax</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>min</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>bounds</name><operator>.</operator><name>lowerBound</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>max</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>bounds</name><operator>.</operator><name>upperBound</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>!=</operator> <name>zdss_init</name></expr></argument>, <argument><expr><name>stage_wrong</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>maxWindowSize</name> <operator>&lt;</operator> <name>min</name></expr></argument>, <argument><expr><name>parameter_outOfBound</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>maxWindowSize</name> <operator>&gt;</operator> <name>max</name></expr></argument>, <argument><expr><name>parameter_outOfBound</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>maxWindowSize</name></name> <operator>=</operator> <name>maxWindowSize</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_DCtx_setFormat</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><name>ZSTD_format_e</name></type> <name>format</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_DCtx_setParameter</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>ZSTD_d_format</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>format</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>ZSTD_bounds</name></type> <name>ZSTD_dParam_getBounds</name><parameter_list>(<parameter><decl><type><name>ZSTD_dParameter</name></type> <name>dParam</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_bounds</name></type> <name>bounds</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
    <switch>switch<condition>(<expr><name>dParam</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>ZSTD_d_windowLogMax</name></expr>:</case>
            <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <name>ZSTD_WINDOWLOG_ABSOLUTEMIN</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <name>ZSTD_WINDOWLOG_MAX</name></expr>;</expr_stmt>
            <return>return <expr><name>bounds</name></expr>;</return>
        <case>case <expr><name>ZSTD_d_format</name></expr>:</case>
            <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>ZSTD_f_zstd1</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>ZSTD_f_zstd1_magicless</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ZSTD_STATIC_ASSERT</name><argument_list>(<argument><expr><name>ZSTD_f_zstd1</name> <operator>&lt;</operator> <name>ZSTD_f_zstd1_magicless</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>bounds</name></expr>;</return>
        <case>case <expr><name>ZSTD_d_stableOutBuffer</name></expr>:</case>
            <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>ZSTD_bm_buffered</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>ZSTD_bm_stable</name></expr>;</expr_stmt>
            <return>return <expr><name>bounds</name></expr>;</return>
        <case>case <expr><name>ZSTD_d_forceIgnoreChecksum</name></expr>:</case>
            <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>ZSTD_d_validateChecksum</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>ZSTD_d_ignoreChecksum</name></expr>;</expr_stmt>
            <return>return <expr><name>bounds</name></expr>;</return>
        <case>case <expr><name>ZSTD_d_refMultipleDDicts</name></expr>:</case>
            <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>ZSTD_rmd_refSingleDDict</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>ZSTD_rmd_refMultipleDDicts</name></expr>;</expr_stmt>
            <return>return <expr><name>bounds</name></expr>;</return>
        <default>default:</default><empty_stmt>;</empty_stmt>
    </block_content>}</block></switch>
    <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>error</name></name> <operator>=</operator> <call><name>ERROR</name><argument_list>(<argument><expr><name>parameter_unsupported</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>bounds</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ZSTD_dParam_withinBounds:
 * @return 1 if value is within dParam bounds,
 * 0 otherwise */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ZSTD_dParam_withinBounds</name><parameter_list>(<parameter><decl><type><name>ZSTD_dParameter</name></type> <name>dParam</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_bounds</name> <specifier>const</specifier></type> <name>bounds</name> <init>= <expr><call><name>ZSTD_dParam_getBounds</name><argument_list>(<argument><expr><name>dParam</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name><name>bounds</name><operator>.</operator><name>error</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>value</name> <operator>&lt;</operator> <name><name>bounds</name><operator>.</operator><name>lowerBound</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>value</name> <operator>&gt;</operator> <name><name>bounds</name><operator>.</operator><name>upperBound</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_DBOUNDS</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{                \
    RETURN_ERROR_IF(!ZSTD_dParam_withinBounds(p, v), parameter_outOfBound, ""); \
}</cpp:value></cpp:define>

<function><type><name>size_t</name></type> <name>ZSTD_DCtx_getParameter</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><name>ZSTD_dParameter</name></type> <name>param</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch <condition>(<expr><name>param</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>ZSTD_d_windowLogMax</name></expr>:</case>
            <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>dctx</name><operator>-&gt;</operator><name>maxWindowSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        <case>case <expr><name>ZSTD_d_format</name></expr>:</case>
            <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>dctx</name><operator>-&gt;</operator><name>format</name></name></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        <case>case <expr><name>ZSTD_d_stableOutBuffer</name></expr>:</case>
            <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>dctx</name><operator>-&gt;</operator><name>outBufferMode</name></name></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        <case>case <expr><name>ZSTD_d_forceIgnoreChecksum</name></expr>:</case>
            <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>dctx</name><operator>-&gt;</operator><name>forceIgnoreChecksum</name></name></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        <case>case <expr><name>ZSTD_d_refMultipleDDicts</name></expr>:</case>
            <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>dctx</name><operator>-&gt;</operator><name>refMultipleDDicts</name></name></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        <default>default:</default><empty_stmt>;</empty_stmt>
    </block_content>}</block></switch>
    <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr><name>parameter_unsupported</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_DCtx_setParameter</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><name>ZSTD_dParameter</name></type> <name>dParam</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>!=</operator> <name>zdss_init</name></expr></argument>, <argument><expr><name>stage_wrong</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch<condition>(<expr><name>dParam</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>ZSTD_d_windowLogMax</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>value</name> <operator>=</operator> <name>ZSTD_WINDOWLOG_LIMIT_DEFAULT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>CHECK_DBOUNDS</name><argument_list>(<argument><expr><name>ZSTD_d_windowLogMax</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>maxWindowSize</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>value</name></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        <case>case <expr><name>ZSTD_d_format</name></expr>:</case>
            <expr_stmt><expr><call><name>CHECK_DBOUNDS</name><argument_list>(<argument><expr><name>ZSTD_d_format</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <operator>(</operator><name>ZSTD_format_e</name><operator>)</operator><name>value</name></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        <case>case <expr><name>ZSTD_d_stableOutBuffer</name></expr>:</case>
            <expr_stmt><expr><call><name>CHECK_DBOUNDS</name><argument_list>(<argument><expr><name>ZSTD_d_stableOutBuffer</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>outBufferMode</name></name> <operator>=</operator> <operator>(</operator><name>ZSTD_bufferMode_e</name><operator>)</operator><name>value</name></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        <case>case <expr><name>ZSTD_d_forceIgnoreChecksum</name></expr>:</case>
            <expr_stmt><expr><call><name>CHECK_DBOUNDS</name><argument_list>(<argument><expr><name>ZSTD_d_forceIgnoreChecksum</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>forceIgnoreChecksum</name></name> <operator>=</operator> <operator>(</operator><name>ZSTD_forceIgnoreChecksum_e</name><operator>)</operator><name>value</name></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        <case>case <expr><name>ZSTD_d_refMultipleDDicts</name></expr>:</case>
            <expr_stmt><expr><call><name>CHECK_DBOUNDS</name><argument_list>(<argument><expr><name>ZSTD_d_refMultipleDDicts</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>staticSize</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr><name>parameter_unsupported</name></expr></argument>, <argument><expr><literal type="string">"Static dctx does not support multiple DDicts!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>refMultipleDDicts</name></name> <operator>=</operator> <operator>(</operator><name>ZSTD_refMultipleDDicts_e</name><operator>)</operator><name>value</name></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        <default>default:</default><empty_stmt>;</empty_stmt>
    </block_content>}</block></switch>
    <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr><name>parameter_unsupported</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_DCtx_reset</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><name>ZSTD_ResetDirective</name></type> <name>reset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>( <expr><operator>(</operator><name>reset</name> <operator>==</operator> <name>ZSTD_reset_session_only</name><operator>)</operator>
      <operator>||</operator> <operator>(</operator><name>reset</name> <operator>==</operator> <name>ZSTD_reset_session_and_parameters</name><operator>)</operator></expr> )</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>=</operator> <name>zdss_init</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>noForwardProgress</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>( <expr><operator>(</operator><name>reset</name> <operator>==</operator> <name>ZSTD_reset_parameters</name><operator>)</operator>
      <operator>||</operator> <operator>(</operator><name>reset</name> <operator>==</operator> <name>ZSTD_reset_session_and_parameters</name><operator>)</operator></expr> )</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>!=</operator> <name>zdss_init</name></expr></argument>, <argument><expr><name>stage_wrong</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_clearDict</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_DCtx_resetParameters</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><name>size_t</name></type> <name>ZSTD_sizeof_DStream</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ZSTD_DStream</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_sizeof_DCtx</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_decodingBufferSize_min</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>windowSize</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>frameContentSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>blockSize</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>windowSize</name></expr></argument>, <argument><expr><name>ZSTD_BLOCKSIZE_MAX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/* space is needed to store the litbuffer after the output of a given block without stomping the extDict of a previous run, as well as to cover both windows against wildcopy*/</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name> <specifier>const</specifier></type> <name>neededRBSize</name> <init>= <expr><name>windowSize</name> <operator>+</operator> <name>blockSize</name> <operator>+</operator> <name>ZSTD_BLOCKSIZE_MAX</name> <operator>+</operator> <operator>(</operator><name>WILDCOPY_OVERLENGTH</name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name> <specifier>const</specifier></type> <name>neededSize</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name>frameContentSize</name></expr></argument>, <argument><expr><name>neededRBSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>minRBSize</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>neededSize</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator><name>minRBSize</name> <operator>!=</operator> <name>neededSize</name></expr></argument>,
                    <argument><expr><name>frameParameter_windowTooLarge</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>minRBSize</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_estimateDStreamSize</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>windowSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>blockSize</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name>windowSize</name></expr></argument>, <argument><expr><name>ZSTD_BLOCKSIZE_MAX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>inBuffSize</name> <init>= <expr><name>blockSize</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* no block can be larger */</comment>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>outBuffSize</name> <init>= <expr><call><name>ZSTD_decodingBufferSize_min</name><argument_list>(<argument><expr><name>windowSize</name></expr></argument>, <argument><expr><name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>ZSTD_estimateDCtxSize</name><argument_list>()</argument_list></call> <operator>+</operator> <name>inBuffSize</name> <operator>+</operator> <name>outBuffSize</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_estimateDStreamSize_fromFrame</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>windowSizeMax</name> <init>= <expr><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>ZSTD_WINDOWLOG_MAX</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* note : should be user-selectable, but requires an additional parameter (or a dctx) */</comment>
    <decl_stmt><decl><type><name>ZSTD_frameHeader</name></type> <name>zfh</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>err</name> <init>= <expr><call><name>ZSTD_getFrameHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zfh</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>err</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>err</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>srcSize_wrong</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>zfh</name><operator>.</operator><name>windowSize</name></name> <operator>&gt;</operator> <name>windowSizeMax</name></expr></argument>,
                    <argument><expr><name>frameParameter_windowTooLarge</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>ZSTD_estimateDStreamSize</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>zfh</name><operator>.</operator><name>windowSize</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* *****   Decompression   ***** */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ZSTD_DCtx_isOverflow</name><parameter_list>(<parameter><decl><type><name>ZSTD_DStream</name><modifier>*</modifier></type> <name>zds</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>neededInBuffSize</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>neededOutBuffSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><name><name>zds</name><operator>-&gt;</operator><name>inBuffSize</name></name> <operator>+</operator> <name><name>zds</name><operator>-&gt;</operator><name>outBuffSize</name></name><operator>)</operator> <operator>&gt;=</operator> <operator>(</operator><name>neededInBuffSize</name> <operator>+</operator> <name>neededOutBuffSize</name><operator>)</operator> <operator>*</operator> <name>ZSTD_WORKSPACETOOLARGE_FACTOR</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_DCtx_updateOversizedDuration</name><parameter_list>(<parameter><decl><type><name>ZSTD_DStream</name><modifier>*</modifier></type> <name>zds</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>neededInBuffSize</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>neededOutBuffSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>ZSTD_DCtx_isOverflow</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>neededInBuffSize</name></expr></argument>, <argument><expr><name>neededOutBuffSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>oversizedDuration</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>oversizedDuration</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ZSTD_DCtx_isOversizedTooLong</name><parameter_list>(<parameter><decl><type><name>ZSTD_DStream</name><modifier>*</modifier></type> <name>zds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name><name>zds</name><operator>-&gt;</operator><name>oversizedDuration</name></name> <operator>&gt;=</operator> <name>ZSTD_WORKSPACETOOLARGE_MAXDURATION</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Checks that the output buffer hasn't changed if ZSTD_obm_stable is used. */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_checkOutBuffer</name><parameter_list>(<parameter><decl><type><name>ZSTD_DStream</name> <specifier>const</specifier><modifier>*</modifier></type> <name>zds</name></decl></parameter>, <parameter><decl><type><name>ZSTD_outBuffer</name> <specifier>const</specifier><modifier>*</modifier></type> <name>output</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_outBuffer</name> <specifier>const</specifier></type> <name>expect</name> <init>= <expr><name><name>zds</name><operator>-&gt;</operator><name>expectedOutBuffer</name></name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* No requirement when ZSTD_obm_stable is not enabled. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>zds</name><operator>-&gt;</operator><name>outBufferMode</name></name> <operator>!=</operator> <name>ZSTD_bm_stable</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Any buffer is allowed in zdss_init, this must be the same for every other call until
     * the context is reset.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>zds</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>==</operator> <name>zdss_init</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* The buffer must match our expectation exactly. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>expect</name><operator>.</operator><name>dst</name></name> <operator>==</operator> <name><name>output</name><operator>-&gt;</operator><name>dst</name></name> <operator>&amp;&amp;</operator> <name><name>expect</name><operator>.</operator><name>pos</name></name> <operator>==</operator> <name><name>output</name><operator>-&gt;</operator><name>pos</name></name> <operator>&amp;&amp;</operator> <name><name>expect</name><operator>.</operator><name>size</name></name> <operator>==</operator> <name><name>output</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr><name>dstBuffer_wrong</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_d_stableOutBuffer enabled but output differs!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Calls ZSTD_decompressContinue() with the right parameters for ZSTD_decompressStream()
 * and updates the stage and the output buffer state. This call is extracted so it can be
 * used both when reading directly from the ZSTD_inBuffer, and in buffered input mode.
 * NOTE: You must break after calling this function since the streamStage is modified.
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_decompressContinueStream</name><parameter_list>(
            <parameter><decl><type><name>ZSTD_DStream</name><modifier>*</modifier></type> <name>zds</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>oend</name></decl></parameter>,
            <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>isSkipFrame</name> <init>= <expr><call><name>ZSTD_isSkipFrame</name><argument_list>(<argument><expr><name>zds</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>zds</name><operator>-&gt;</operator><name>outBufferMode</name></name> <operator>==</operator> <name>ZSTD_bm_buffered</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>dstSize</name> <init>= <expr><ternary><condition><expr><name>isSkipFrame</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>zds</name><operator>-&gt;</operator><name>outBuffSize</name></name> <operator>-</operator> <name><name>zds</name><operator>-&gt;</operator><name>outStart</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>decodedSize</name> <init>= <expr><call><name>ZSTD_decompressContinue</name><argument_list>(<argument><expr><name>zds</name></expr></argument>,
                <argument><expr><name><name>zds</name><operator>-&gt;</operator><name>outBuff</name></name> <operator>+</operator> <name><name>zds</name><operator>-&gt;</operator><name>outStart</name></name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>decodedSize</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>decodedSize</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isSkipFrame</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>=</operator> <name>zdss_read</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>=</operator> <name><name>zds</name><operator>-&gt;</operator><name>outStart</name></name> <operator>+</operator> <name>decodedSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>=</operator> <name>zdss_flush</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* Write directly into the output buffer */</comment>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>dstSize</name> <init>= <expr><ternary><condition><expr><name>isSkipFrame</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name> <operator>-</operator> <operator>*</operator><name>op</name><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>decodedSize</name> <init>= <expr><call><name>ZSTD_decompressContinue</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><operator>*</operator><name>op</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>decodedSize</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>op</name> <operator>+=</operator> <name>decodedSize</name></expr>;</expr_stmt>
        <comment type="block">/* Flushing is not needed. */</comment>
        <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>=</operator> <name>zdss_read</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><name>op</name> <operator>&lt;=</operator> <name>oend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>zds</name><operator>-&gt;</operator><name>outBufferMode</name></name> <operator>==</operator> <name>ZSTD_bm_stable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_decompressStream</name><parameter_list>(<parameter><decl><type><name>ZSTD_DStream</name><modifier>*</modifier></type> <name>zds</name></decl></parameter>, <parameter><decl><type><name>ZSTD_outBuffer</name><modifier>*</modifier></type> <name>output</name></decl></parameter>, <parameter><decl><type><name>ZSTD_inBuffer</name><modifier>*</modifier></type> <name>input</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>src</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name><name>input</name><operator>-&gt;</operator><name>src</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>istart</name> <init>= <expr><ternary><condition><expr><name><name>input</name><operator>-&gt;</operator><name>pos</name></name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>src</name> <operator>+</operator> <name><name>input</name><operator>-&gt;</operator><name>pos</name></name></expr> </then><else>: <expr><name>src</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name> <init>= <expr><ternary><condition><expr><name><name>input</name><operator>-&gt;</operator><name>size</name></name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>src</name> <operator>+</operator> <name><name>input</name><operator>-&gt;</operator><name>size</name></name></expr> </then><else>: <expr><name>src</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><name>istart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dst</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>output</name><operator>-&gt;</operator><name>dst</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ostart</name> <init>= <expr><ternary><condition><expr><name><name>output</name><operator>-&gt;</operator><name>pos</name></name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>dst</name> <operator>+</operator> <name><name>output</name><operator>-&gt;</operator><name>pos</name></name></expr> </then><else>: <expr><name>dst</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend</name> <init>= <expr><ternary><condition><expr><name><name>output</name><operator>-&gt;</operator><name>size</name></name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>dst</name> <operator>+</operator> <name><name>output</name><operator>-&gt;</operator><name>size</name></name></expr> </then><else>: <expr><name>dst</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><name>ostart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>someMoreWork</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_decompressStream"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(
        <argument><expr><name><name>input</name><operator>-&gt;</operator><name>pos</name></name> <operator>&gt;</operator> <name><name>input</name><operator>-&gt;</operator><name>size</name></name></expr></argument>,
        <argument><expr><name>srcSize_wrong</name></expr></argument>,
        <argument><expr><literal type="string">"forbidden. in: pos: %u   vs size: %u"</literal></expr></argument>,
        <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>input</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>input</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(
        <argument><expr><name><name>output</name><operator>-&gt;</operator><name>pos</name></name> <operator>&gt;</operator> <name><name>output</name><operator>-&gt;</operator><name>size</name></name></expr></argument>,
        <argument><expr><name>dstSize_tooSmall</name></expr></argument>,
        <argument><expr><literal type="string">"forbidden. out: pos: %u   vs size: %u"</literal></expr></argument>,
        <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>output</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>output</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"input size : %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name><name>input</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name><name>input</name><operator>-&gt;</operator><name>pos</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_checkOutBuffer</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>someMoreWork</name></expr>)</condition> <block>{<block_content>
        <switch>switch<condition>(<expr><name><name>zds</name><operator>-&gt;</operator><name>streamStage</name></name></expr>)</condition>
        <block>{<block_content>
        <case>case <expr><name>zdss_init</name></expr> :</case>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"stage zdss_init =&gt; transparent reset "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>=</operator> <name>zdss_loadHeader</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>lhSize</name></name> <operator>=</operator> <name><name>zds</name><operator>-&gt;</operator><name>inPos</name></name> <operator>=</operator> <name><name>zds</name><operator>-&gt;</operator><name>outStart</name></name> <operator>=</operator> <name><name>zds</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ZSTD_LEGACY_SUPPORT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>ZSTD_LEGACY_SUPPORT</name><operator>&gt;=</operator><literal type="number">1</literal><operator>)</operator></expr></cpp:if>
            <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>legacyVersion</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>hostageByte</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>expectedOutBuffer</name></name> <operator>=</operator> <operator>*</operator><name>output</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ZSTD_FALLTHROUGH</name></expr>;</expr_stmt>

        <case>case <expr><name>zdss_loadHeader</name></expr> :</case>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"stage zdss_loadHeader (srcSize : %u)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>iend</name> <operator>-</operator> <name>ip</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ZSTD_LEGACY_SUPPORT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>ZSTD_LEGACY_SUPPORT</name><operator>&gt;=</operator><literal type="number">1</literal><operator>)</operator></expr></cpp:if>
            <if_stmt><if>if <condition>(<expr><name><name>zds</name><operator>-&gt;</operator><name>legacyVersion</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>zds</name><operator>-&gt;</operator><name>staticSize</name></name></expr></argument>, <argument><expr><name>memory_allocation</name></expr></argument>,
                    <argument><expr><literal type="string">"legacy support is incompatible with static dctx"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>hint</name> <init>= <expr><call><name>ZSTD_decompressLegacyStream</name><argument_list>(<argument><expr><name><name>zds</name><operator>-&gt;</operator><name>legacyContext</name></name></expr></argument>, <argument><expr><name><name>zds</name><operator>-&gt;</operator><name>legacyVersion</name></name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>hint</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>=</operator> <name>zdss_init</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <return>return <expr><name>hint</name></expr>;</return>
            </block_content>}</block>   </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>hSize</name> <init>= <expr><call><name>ZSTD_getFrameHeader_advanced</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zds</name><operator>-&gt;</operator><name>fParams</name></name></expr></argument>, <argument><expr><name><name>zds</name><operator>-&gt;</operator><name>headerBuffer</name></name></expr></argument>, <argument><expr><name><name>zds</name><operator>-&gt;</operator><name>lhSize</name></name></expr></argument>, <argument><expr><name><name>zds</name><operator>-&gt;</operator><name>format</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>zds</name><operator>-&gt;</operator><name>refMultipleDDicts</name></name> <operator>&amp;&amp;</operator> <name><name>zds</name><operator>-&gt;</operator><name>ddictSet</name></name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>ZSTD_DCtx_selectFrameDDict</name><argument_list>(<argument><expr><name>zds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>hSize</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ZSTD_LEGACY_SUPPORT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>ZSTD_LEGACY_SUPPORT</name><operator>&gt;=</operator><literal type="number">1</literal><operator>)</operator></expr></cpp:if>
                    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>legacyVersion</name> <init>= <expr><call><name>ZSTD_isLegacy</name><argument_list>(<argument><expr><name>istart</name></expr></argument>, <argument><expr><name>iend</name><operator>-</operator><name>istart</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>legacyVersion</name></expr>)</condition> <block>{<block_content>
                        <decl_stmt><decl><type><name>ZSTD_DDict</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>ddict</name> <init>= <expr><call><name>ZSTD_getDDict</name><argument_list>(<argument><expr><name>zds</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dict</name> <init>= <expr><ternary><condition><expr><name>ddict</name></expr> ?</condition><then> <expr><call><name>ZSTD_DDict_dictContent</name><argument_list>(<argument><expr><name>ddict</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>dictSize</name> <init>= <expr><ternary><condition><expr><name>ddict</name></expr> ?</condition><then> <expr><call><name>ZSTD_DDict_dictSize</name><argument_list>(<argument><expr><name>ddict</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_decompressStream: detected legacy version v0.%u"</literal></expr></argument>, <argument><expr><name>legacyVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>zds</name><operator>-&gt;</operator><name>staticSize</name></name></expr></argument>, <argument><expr><name>memory_allocation</name></expr></argument>,
                            <argument><expr><literal type="string">"legacy support is incompatible with static dctx"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_initLegacyStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zds</name><operator>-&gt;</operator><name>legacyContext</name></name></expr></argument>,
                                    <argument><expr><name><name>zds</name><operator>-&gt;</operator><name>previousLegacyVersion</name></name></expr></argument>, <argument><expr><name>legacyVersion</name></expr></argument>,
                                    <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>legacyVersion</name></name> <operator>=</operator> <name><name>zds</name><operator>-&gt;</operator><name>previousLegacyVersion</name></name> <operator>=</operator> <name>legacyVersion</name></expr>;</expr_stmt>
                        <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>hint</name> <init>= <expr><call><name>ZSTD_decompressLegacyStream</name><argument_list>(<argument><expr><name><name>zds</name><operator>-&gt;</operator><name>legacyContext</name></name></expr></argument>, <argument><expr><name>legacyVersion</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <if_stmt><if>if <condition>(<expr><name>hint</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>=</operator> <name>zdss_init</name></expr>;</expr_stmt></block_content></block></if></if_stmt>   <comment type="block">/* or stay in stage zdss_loadHeader */</comment>
                            <return>return <expr><name>hint</name></expr>;</return>
                    </block_content>}</block>   </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <return>return <expr><name>hSize</name></expr>;</return>   <comment type="block">/* error */</comment>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>hSize</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>   <comment type="block">/* need more input */</comment>
                    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>toLoad</name> <init>= <expr><name>hSize</name> <operator>-</operator> <name><name>zds</name><operator>-&gt;</operator><name>lhSize</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* if hSize!=0, hSize &gt; zds-&gt;lhSize */</comment>
                    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>remainingInput</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>iend</name><operator>-</operator><name>ip</name><operator>)</operator></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>iend</name> <operator>&gt;=</operator> <name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>toLoad</name> <operator>&gt;</operator> <name>remainingInput</name></expr>)</condition> <block>{<block_content>   <comment type="block">/* not enough input to load full header */</comment>
                        <if_stmt><if>if <condition>(<expr><name>remainingInput</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                            <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name><name>zds</name><operator>-&gt;</operator><name>headerBuffer</name></name> <operator>+</operator> <name><name>zds</name><operator>-&gt;</operator><name>lhSize</name></name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>remainingInput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>lhSize</name></name> <operator>+=</operator> <name>remainingInput</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        <expr_stmt><expr><name><name>input</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name><name>input</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
                        <comment type="block">/* check first few bytes */</comment>
                        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(
                            <argument><expr><call><name>ZSTD_getFrameHeader_advanced</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zds</name><operator>-&gt;</operator><name>fParams</name></name></expr></argument>, <argument><expr><name><name>zds</name><operator>-&gt;</operator><name>headerBuffer</name></name></expr></argument>, <argument><expr><name><name>zds</name><operator>-&gt;</operator><name>lhSize</name></name></expr></argument>, <argument><expr><name><name>zds</name><operator>-&gt;</operator><name>format</name></name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><literal type="string">"First few bytes detected incorrect"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
                        <comment type="block">/* return hint input size */</comment>
                        <return>return <expr><operator>(</operator><call><name>MAX</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><call><name>ZSTD_FRAMEHEADERSIZE_MIN</name><argument_list>(<argument><expr><name><name>zds</name><operator>-&gt;</operator><name>format</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hSize</name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>zds</name><operator>-&gt;</operator><name>lhSize</name></name><operator>)</operator> <operator>+</operator> <name>ZSTD_blockHeaderSize</name></expr>;</return>   <comment type="block">/* remaining header bytes + next block header */</comment>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ip</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name><name>zds</name><operator>-&gt;</operator><name>headerBuffer</name></name> <operator>+</operator> <name><name>zds</name><operator>-&gt;</operator><name>lhSize</name></name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>toLoad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>lhSize</name></name> <operator>=</operator> <name>hSize</name></expr>;</expr_stmt> <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>toLoad</name></expr>;</expr_stmt>
                    <break>break;</break>
            </block_content>}</block></if></if_stmt>   </block_content>}</block>

            <comment type="block">/* check for single-pass mode opportunity */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>zds</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>frameContentSize</name></name> <operator>!=</operator> <name>ZSTD_CONTENTSIZE_UNKNOWN</name>
                <operator>&amp;&amp;</operator> <name><name>zds</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>frameType</name></name> <operator>!=</operator> <name>ZSTD_skippableFrame</name>
                <operator>&amp;&amp;</operator> <operator>(</operator><name>U64</name><operator>)</operator><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name><operator>-</operator><name>op</name><operator>)</operator> <operator>&gt;=</operator> <name><name>zds</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>frameContentSize</name></name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>cSize</name> <init>= <expr><call><name>ZSTD_findFrameCompressedSize</name><argument_list>(<argument><expr><name>istart</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>iend</name><operator>-</operator><name>istart</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>cSize</name> <operator>&lt;=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>iend</name><operator>-</operator><name>istart</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                    <comment type="block">/* shortcut : using single-pass mode */</comment>
                    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>decompressedSize</name> <init>= <expr><call><name>ZSTD_decompress_usingDDict</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name><operator>-</operator><name>op</name><operator>)</operator></expr></argument>, <argument><expr><name>istart</name></expr></argument>, <argument><expr><name>cSize</name></expr></argument>, <argument><expr><call><name>ZSTD_getDDict</name><argument_list>(<argument><expr><name>zds</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>decompressedSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>decompressedSize</name></expr>;</return></block_content></block></if></if_stmt>
                    <macro><name>DEBUGLOG</name><argument_list>(<argument><literal type="number">4</literal></argument>, <argument><literal type="string">"shortcut to single-pass ZSTD_decompress_usingDDict()"</literal></argument>)</argument_list></macro>
                    <expr_stmt><expr><name>ip</name> <operator>=</operator> <name>istart</name> <operator>+</operator> <name>cSize</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>decompressedSize</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>expected</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>=</operator> <name>zdss_init</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>someMoreWork</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <break>break;</break>
            </block_content>}</block></if></if_stmt>   </block_content>}</block></if></if_stmt>

            <comment type="block">/* Check output buffer is large enough for ZSTD_odm_stable. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>zds</name><operator>-&gt;</operator><name>outBufferMode</name></name> <operator>==</operator> <name>ZSTD_bm_stable</name>
                <operator>&amp;&amp;</operator> <name><name>zds</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>frameType</name></name> <operator>!=</operator> <name>ZSTD_skippableFrame</name>
                <operator>&amp;&amp;</operator> <name><name>zds</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>frameContentSize</name></name> <operator>!=</operator> <name>ZSTD_CONTENTSIZE_UNKNOWN</name>
                <operator>&amp;&amp;</operator> <operator>(</operator><name>U64</name><operator>)</operator><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name><operator>-</operator><name>op</name><operator>)</operator> <operator>&lt;</operator> <name><name>zds</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>frameContentSize</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_obm_stable passed but ZSTD_outBuffer is too small"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Consume header (see ZSTDds_decodeFrameHeader) */</comment>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"Consume header"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_decompressBegin_usingDDict</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><call><name>ZSTD_getDDict</name><argument_list>(<argument><expr><name>zds</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>MEM_readLE32</name><argument_list>(<argument><expr><name><name>zds</name><operator>-&gt;</operator><name>headerBuffer</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>ZSTD_MAGIC_SKIPPABLE_MASK</name><operator>)</operator> <operator>==</operator> <name>ZSTD_MAGIC_SKIPPABLE_START</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* skippable frame */</comment>
                <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>expected</name></name> <operator>=</operator> <call><name>MEM_readLE32</name><argument_list>(<argument><expr><name><name>zds</name><operator>-&gt;</operator><name>headerBuffer</name></name> <operator>+</operator> <name>ZSTD_FRAMEIDSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>stage</name></name> <operator>=</operator> <name>ZSTDds_skipFrame</name></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_decodeFrameHeader</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name><name>zds</name><operator>-&gt;</operator><name>headerBuffer</name></name></expr></argument>, <argument><expr><name><name>zds</name><operator>-&gt;</operator><name>lhSize</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>expected</name></name> <operator>=</operator> <name>ZSTD_blockHeaderSize</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>stage</name></name> <operator>=</operator> <name>ZSTDds_decodeBlockHeader</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/* control buffer memory usage */</comment>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"Control max memory usage (%u KB &lt;= max %u KB)"</literal></expr></argument>,
                        <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name><name>zds</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>windowSize</name></name> <operator>&gt;&gt;</operator><literal type="number">10</literal><operator>)</operator></expr></argument>,
                        <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name><name>zds</name><operator>-&gt;</operator><name>maxWindowSize</name></name> <operator>&gt;&gt;</operator> <literal type="number">10</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>windowSize</name></name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name><name>zds</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>windowSize</name></name></expr></argument>, <argument><expr><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>ZSTD_WINDOWLOG_ABSOLUTEMIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>zds</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>windowSize</name></name> <operator>&gt;</operator> <name><name>zds</name><operator>-&gt;</operator><name>maxWindowSize</name></name></expr></argument>,
                            <argument><expr><name>frameParameter_windowTooLarge</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Adapt buffer sizes to frame header instructions */</comment>
            <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>neededInBuffSize</name> <init>= <expr><call><name>MAX</name><argument_list>(<argument><expr><name><name>zds</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>blockSizeMax</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument> <comment type="block">/* frame checksum */</comment>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>neededOutBuffSize</name> <init>= <expr><ternary><condition><expr><name><name>zds</name><operator>-&gt;</operator><name>outBufferMode</name></name> <operator>==</operator> <name>ZSTD_bm_buffered</name></expr>
                        ?</condition><then> <expr><call><name>ZSTD_decodingBufferSize_min</name><argument_list>(<argument><expr><name><name>zds</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>windowSize</name></name></expr></argument>, <argument><expr><name><name>zds</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>frameContentSize</name></name></expr></argument>)</argument_list></call></expr>
                        </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>ZSTD_DCtx_updateOversizedDuration</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>neededInBuffSize</name></expr></argument>, <argument><expr><name>neededOutBuffSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <block>{<block_content>   <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>tooSmall</name> <init>= <expr><operator>(</operator><name><name>zds</name><operator>-&gt;</operator><name>inBuffSize</name></name> <operator>&lt;</operator> <name>neededInBuffSize</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>zds</name><operator>-&gt;</operator><name>outBuffSize</name></name> <operator>&lt;</operator> <name>neededOutBuffSize</name><operator>)</operator></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>tooLarge</name> <init>= <expr><call><name>ZSTD_DCtx_isOversizedTooLong</name><argument_list>(<argument><expr><name>zds</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>tooSmall</name> <operator>||</operator> <name>tooLarge</name></expr>)</condition> <block>{<block_content>
                        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>bufferSize</name> <init>= <expr><name>neededInBuffSize</name> <operator>+</operator> <name>neededOutBuffSize</name></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"inBuff  : from %u to %u"</literal></expr></argument>,
                                    <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>zds</name><operator>-&gt;</operator><name>inBuffSize</name></name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>neededInBuffSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"outBuff : from %u to %u"</literal></expr></argument>,
                                    <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>zds</name><operator>-&gt;</operator><name>outBuffSize</name></name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>neededOutBuffSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name><name>zds</name><operator>-&gt;</operator><name>staticSize</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* static DCtx */</comment>
                            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"staticSize : %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>zds</name><operator>-&gt;</operator><name>staticSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>zds</name><operator>-&gt;</operator><name>staticSize</name></name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_DCtx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* controlled at init */</comment>
                            <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(
                                <argument><expr><name>bufferSize</name> <operator>&gt;</operator> <name><name>zds</name><operator>-&gt;</operator><name>staticSize</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_DCtx</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                                <argument><expr><name>memory_allocation</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if> <else>else <block>{<block_content>
                            <expr_stmt><expr><call><name>ZSTD_customFree</name><argument_list>(<argument><expr><name><name>zds</name><operator>-&gt;</operator><name>inBuff</name></name></expr></argument>, <argument><expr><name><name>zds</name><operator>-&gt;</operator><name>customMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>inBuffSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>outBuffSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>inBuff</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>ZSTD_customMalloc</name><argument_list>(<argument><expr><name>bufferSize</name></expr></argument>, <argument><expr><name><name>zds</name><operator>-&gt;</operator><name>customMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>zds</name><operator>-&gt;</operator><name>inBuff</name></name> <operator>==</operator> <name>NULL</name></expr></argument>, <argument><expr><name>memory_allocation</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                        <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>inBuffSize</name></name> <operator>=</operator> <name>neededInBuffSize</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>outBuff</name></name> <operator>=</operator> <name><name>zds</name><operator>-&gt;</operator><name>inBuff</name></name> <operator>+</operator> <name><name>zds</name><operator>-&gt;</operator><name>inBuffSize</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>outBuffSize</name></name> <operator>=</operator> <name>neededOutBuffSize</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>   </block_content>}</block>   </block_content>}</block>
            <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>=</operator> <name>zdss_read</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ZSTD_FALLTHROUGH</name></expr>;</expr_stmt>

        <case>case <expr><name>zdss_read</name></expr>:</case>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"stage zdss_read"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>neededInSize</name> <init>= <expr><call><name>ZSTD_nextSrcSizeToDecompressWithInputSize</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>iend</name> <operator>-</operator> <name>ip</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"neededInSize = %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>neededInSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>neededInSize</name><operator>==</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* end of frame */</comment>
                    <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>=</operator> <name>zdss_init</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>someMoreWork</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>iend</name><operator>-</operator><name>ip</name><operator>)</operator> <operator>&gt;=</operator> <name>neededInSize</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* decode directly from src */</comment>
                    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_decompressContinueStream</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>neededInSize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>neededInSize</name></expr>;</expr_stmt>
                    <comment type="block">/* Function modifies the stage so we must break */</comment>
                    <break>break;</break>
            </block_content>}</block></if></if_stmt>   </block_content>}</block>
            <if_stmt><if>if <condition>(<expr><name>ip</name><operator>==</operator><name>iend</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>someMoreWork</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>   <comment type="block">/* no more input */</comment>
            <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>=</operator> <name>zdss_load</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ZSTD_FALLTHROUGH</name></expr>;</expr_stmt>

        <case>case <expr><name>zdss_load</name></expr>:</case>
            <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>neededInSize</name> <init>= <expr><call><name>ZSTD_nextSrcSizeToDecompress</name><argument_list>(<argument><expr><name>zds</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>toLoad</name> <init>= <expr><name>neededInSize</name> <operator>-</operator> <name><name>zds</name><operator>-&gt;</operator><name>inPos</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>isSkipFrame</name> <init>= <expr><call><name>ZSTD_isSkipFrame</name><argument_list>(<argument><expr><name>zds</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>size_t</name></type> <name>loadedSize</name></decl>;</decl_stmt>
                <comment type="block">/* At this point we shouldn't be decompressing a block that we can stream. */</comment>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>neededInSize</name> <operator>==</operator> <call><name>ZSTD_nextSrcSizeToDecompressWithInputSize</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>iend</name> <operator>-</operator> <name>ip</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>isSkipFrame</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>loadedSize</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>toLoad</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>iend</name><operator>-</operator><name>ip</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>toLoad</name> <operator>&gt;</operator> <name><name>zds</name><operator>-&gt;</operator><name>inBuffSize</name></name> <operator>-</operator> <name><name>zds</name><operator>-&gt;</operator><name>inPos</name></name></expr></argument>,
                                    <argument><expr><name>corruption_detected</name></expr></argument>,
                                    <argument><expr><literal type="string">"should never happen"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>loadedSize</name> <operator>=</operator> <call><name>ZSTD_limitCopy</name><argument_list>(<argument><expr><name><name>zds</name><operator>-&gt;</operator><name>inBuff</name></name> <operator>+</operator> <name><name>zds</name><operator>-&gt;</operator><name>inPos</name></name></expr></argument>, <argument><expr><name>toLoad</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>iend</name><operator>-</operator><name>ip</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>loadedSize</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>inPos</name></name> <operator>+=</operator> <name>loadedSize</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>loadedSize</name> <operator>&lt;</operator> <name>toLoad</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>someMoreWork</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>   <comment type="block">/* not enough input, wait for more */</comment>

                <comment type="block">/* decode loaded input */</comment>
                <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>inPos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>   <comment type="block">/* input is consumed */</comment>
                <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_decompressContinueStream</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>, <argument><expr><name><name>zds</name><operator>-&gt;</operator><name>inBuff</name></name></expr></argument>, <argument><expr><name>neededInSize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* Function modifies the stage so we must break */</comment>
                <break>break;</break>
            </block_content>}</block>
        <case>case <expr><name>zdss_flush</name></expr>:</case>
            <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>toFlushSize</name> <init>= <expr><name><name>zds</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>-</operator> <name><name>zds</name><operator>-&gt;</operator><name>outStart</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>flushedSize</name> <init>= <expr><call><name>ZSTD_limitCopy</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name><operator>-</operator><name>op</name><operator>)</operator></expr></argument>, <argument><expr><name><name>zds</name><operator>-&gt;</operator><name>outBuff</name></name> <operator>+</operator> <name><name>zds</name><operator>-&gt;</operator><name>outStart</name></name></expr></argument>, <argument><expr><name>toFlushSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>flushedSize</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>outStart</name></name> <operator>+=</operator> <name>flushedSize</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>flushedSize</name> <operator>==</operator> <name>toFlushSize</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* flush completed */</comment>
                    <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>=</operator> <name>zdss_read</name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>( <expr><operator>(</operator><name><name>zds</name><operator>-&gt;</operator><name>outBuffSize</name></name> <operator>&lt;</operator> <name><name>zds</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>frameContentSize</name></name><operator>)</operator>
                      <operator>&amp;&amp;</operator> <operator>(</operator><name><name>zds</name><operator>-&gt;</operator><name>outStart</name></name> <operator>+</operator> <name><name>zds</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>blockSizeMax</name></name> <operator>&gt;</operator> <name><name>zds</name><operator>-&gt;</operator><name>outBuffSize</name></name><operator>)</operator></expr> )</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"restart filling outBuff from beginning (left:%i, needed:%u)"</literal></expr></argument>,
                                <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>zds</name><operator>-&gt;</operator><name>outBuffSize</name></name> <operator>-</operator> <name><name>zds</name><operator>-&gt;</operator><name>outStart</name></name><operator>)</operator></expr></argument>,
                                <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>zds</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>blockSizeMax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>outStart</name></name> <operator>=</operator> <name><name>zds</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <break>break;</break>
            </block_content>}</block></if></if_stmt>   </block_content>}</block>
            <comment type="block">/* cannot complete flush */</comment>
            <expr_stmt><expr><name>someMoreWork</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* impossible */</comment>
            <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr><name>GENERIC</name></expr></argument>, <argument><expr><literal type="string">"impossible to reach"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* some compilers require default to do something */</comment>
    </block_content>}</block></switch>   </block_content>}</block></while>

    <comment type="block">/* result */</comment>
    <expr_stmt><expr><name><name>input</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>input</name><operator>-&gt;</operator><name>src</name></name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>output</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>op</name> <operator>-</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>output</name><operator>-&gt;</operator><name>dst</name></name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* Update the expected output buffer for ZSTD_obm_stable. */</comment>
    <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>expectedOutBuffer</name></name> <operator>=</operator> <operator>*</operator><name>output</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ip</name><operator>==</operator><name>istart</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>op</name><operator>==</operator><name>ostart</name><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* no forward progress */</comment>
        <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>noForwardProgress</name></name> <operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>zds</name><operator>-&gt;</operator><name>noForwardProgress</name></name> <operator>&gt;=</operator> <name>ZSTD_NO_FORWARD_PROGRESS_MAX</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>oend</name></expr></argument>, <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>ip</name><operator>==</operator><name>iend</name></expr></argument>, <argument><expr><name>srcSize_wrong</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>noForwardProgress</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name></type> <name>nextSrcSizeHint</name> <init>= <expr><call><name>ZSTD_nextSrcSizeToDecompress</name><argument_list>(<argument><expr><name>zds</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>nextSrcSizeHint</name></expr>)</condition> <block>{<block_content>   <comment type="block">/* frame fully decoded */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>zds</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>==</operator> <name><name>zds</name><operator>-&gt;</operator><name>outStart</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* output fully flushed */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>zds</name><operator>-&gt;</operator><name>hostageByte</name></name></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>input</name><operator>-&gt;</operator><name>pos</name></name> <operator>&gt;=</operator> <name><name>input</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
                        <comment type="block">/* can't release hostage (not present) */</comment>
                        <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>=</operator> <name>zdss_read</name></expr>;</expr_stmt>
                        <return>return <expr><literal type="number">1</literal></expr>;</return>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name><name>input</name><operator>-&gt;</operator><name>pos</name></name><operator>++</operator></expr>;</expr_stmt>  <comment type="block">/* release hostage */</comment>
                </block_content>}</block></if></if_stmt>   <comment type="block">/* zds-&gt;hostageByte */</comment>
                <return>return <expr><literal type="number">0</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>  <comment type="block">/* zds-&gt;outEnd == zds-&gt;outStart */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>zds</name><operator>-&gt;</operator><name>hostageByte</name></name></expr>)</condition> <block>{<block_content> <comment type="block">/* output not fully flushed; keep last byte as hostage; will be released when all output is flushed */</comment>
                <expr_stmt><expr><name><name>input</name><operator>-&gt;</operator><name>pos</name></name><operator>--</operator></expr>;</expr_stmt>   <comment type="block">/* note : pos &gt; 0, otherwise, impossible to finish reading last block */</comment>
                <expr_stmt><expr><name><name>zds</name><operator>-&gt;</operator><name>hostageByte</name></name><operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>  <comment type="block">/* nextSrcSizeHint==0 */</comment>
        <expr_stmt><expr><name>nextSrcSizeHint</name> <operator>+=</operator> <name>ZSTD_blockHeaderSize</name> <operator>*</operator> <operator>(</operator><call><name>ZSTD_nextInputType</name><argument_list>(<argument><expr><name>zds</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ZSTDnit_block</name><operator>)</operator></expr>;</expr_stmt>   <comment type="block">/* preload header of next block */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>zds</name><operator>-&gt;</operator><name>inPos</name></name> <operator>&lt;=</operator> <name>nextSrcSizeHint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nextSrcSizeHint</name> <operator>-=</operator> <name><name>zds</name><operator>-&gt;</operator><name>inPos</name></name></expr>;</expr_stmt>   <comment type="block">/* part already loaded*/</comment>
        <return>return <expr><name>nextSrcSizeHint</name></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_decompressStream_simpleArgs</name> <parameter_list>(
                            <parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>,
                            <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>dstPos</name></decl></parameter>,
                      <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>srcPos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_outBuffer</name></type> <name>output</name> <init>= <expr><block>{ <expr><name>dst</name></expr>, <expr><name>dstCapacity</name></expr>, <expr><operator>*</operator><name>dstPos</name></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_inBuffer</name></type>  <name>input</name>  <init>= <expr><block>{ <expr><name>src</name></expr>, <expr><name>srcSize</name></expr>, <expr><operator>*</operator><name>srcPos</name></expr> }</block></expr></init></decl>;</decl_stmt>
    <comment type="block">/* ZSTD_compress_generic() will check validity of dstPos and srcPos */</comment>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>cErr</name> <init>= <expr><call><name>ZSTD_decompressStream</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><name>dstPos</name> <operator>=</operator> <name><name>output</name><operator>.</operator><name>pos</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>srcPos</name> <operator>=</operator> <name><name>input</name><operator>.</operator><name>pos</name></name></expr>;</expr_stmt>
    <return>return <expr><name>cErr</name></expr>;</return>
</block_content>}</block></function>
</unit>
