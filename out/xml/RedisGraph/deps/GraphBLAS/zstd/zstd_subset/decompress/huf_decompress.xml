<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/zstd/zstd_subset/decompress/huf_decompress.c"><comment type="block">/* ******************************************************************
 * huff0 huffman decoder,
 * part of Finite State Entropy library
 * Copyright (c) Yann Collet, Facebook, Inc.
 *
 *  You can contact the author at :
 *  - FSE+HUF source repository : https://github.com/Cyan4973/FiniteStateEntropy
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
****************************************************************** */</comment>

<comment type="block">/* **************************************************************
*  Dependencies
****************************************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/zstd_deps.h"</cpp:file></cpp:include>  <comment type="block">/* ZSTD_memcpy, ZSTD_memset */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/compiler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/bitstream.h"</cpp:file></cpp:include>  <comment type="block">/* BIT_* */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/fse.h"</cpp:file></cpp:include>        <comment type="block">/* to compress headers */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_STATIC_LINKING_ONLY</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/huf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/error_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/zstd_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/bits.h"</cpp:file></cpp:include>       <comment type="block">/* ZSTD_highbit32, ZSTD_countTrailingZeros64 */</comment>

<comment type="block">/* **************************************************************
*  Constants
****************************************************************/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_DECODER_FAST_TABLELOG</name></cpp:macro> <cpp:value>11</cpp:value></cpp:define>

<comment type="block">/* **************************************************************
*  Macros
****************************************************************/</comment>

<comment type="block">/* These two optional macros force the use one way or another of the two
 * Huffman decompression implementations. You can't force in both directions
 * at the same time.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HUF_FORCE_DECOMPRESS_X1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> \
    <call><name>defined</name><argument_list>(<argument><expr><name>HUF_FORCE_DECOMPRESS_X2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"Cannot force the use of the X1 and X2 decoders at the same time!"</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ZSTD_ENABLE_ASM_X86_64_BMI2</name> <operator>&amp;&amp;</operator> <name>DYNAMIC_BMI2</name></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_ASM_X86_64_BMI2_ATTRS</name></cpp:macro> <cpp:value>BMI2_TARGET_ATTRIBUTE</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_ASM_X86_64_BMI2_ATTRS</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_EXTERN_C</name></cpp:macro> <cpp:value>extern "C"</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_EXTERN_C</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_ASM_DECL</name></cpp:macro> <cpp:value>HUF_EXTERN_C</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DYNAMIC_BMI2</name> <operator>||</operator> <operator>(</operator><name>ZSTD_ENABLE_ASM_X86_64_BMI2</name> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__BMI2__</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_NEED_BMI2_FUNCTION</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_NEED_BMI2_FUNCTION</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><operator>(</operator><name>ZSTD_ENABLE_ASM_X86_64_BMI2</name> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__BMI2__</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_NEED_DEFAULT_FUNCTION</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_NEED_DEFAULT_FUNCTION</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* **************************************************************
*  Error Management
****************************************************************/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_isError</name></cpp:macro> <cpp:value>ERR_isError</cpp:value></cpp:define>


<comment type="block">/* **************************************************************
*  Byte alignment for workSpace management
****************************************************************/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_ALIGN</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro>         <cpp:value>HUF_ALIGN_MASK((x), (a) - 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_ALIGN_MASK</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>mask</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((x) + (mask)) &amp; ~(mask))</cpp:value></cpp:define>


<comment type="block">/* **************************************************************
*  BMI2 Variant Wrappers
****************************************************************/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DYNAMIC_BMI2</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_DGEN</name><parameter_list>(<parameter><type><name>fn</name></type></parameter>)</parameter_list></cpp:macro>                                                        \
                                                                            \
    <cpp:value>static size_t fn##_default(                                             \
                  void* dst,  size_t dstSize,                               \
            const void* cSrc, size_t cSrcSize,                              \
            const HUF_DTable* DTable)                                       \
    {                                                                       \
        return fn##_body(dst, dstSize, cSrc, cSrcSize, DTable);             \
    }                                                                       \
                                                                            \
    static BMI2_TARGET_ATTRIBUTE size_t fn##_bmi2(                          \
                  void* dst,  size_t dstSize,                               \
            const void* cSrc, size_t cSrcSize,                              \
            const HUF_DTable* DTable)                                       \
    {                                                                       \
        return fn##_body(dst, dstSize, cSrc, cSrcSize, DTable);             \
    }                                                                       \
                                                                            \
    static size_t fn(void* dst, size_t dstSize, void const* cSrc,           \
                     size_t cSrcSize, HUF_DTable const* DTable, int bmi2)   \
    {                                                                       \
        if (bmi2) {                                                         \
            return fn##_bmi2(dst, dstSize, cSrc, cSrcSize, DTable);         \
        }                                                                   \
        return fn##_default(dst, dstSize, cSrc, cSrcSize, DTable);          \
    }</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_DGEN</name><parameter_list>(<parameter><type><name>fn</name></type></parameter>)</parameter_list></cpp:macro>                                                        \
    <cpp:value>static size_t fn(void* dst, size_t dstSize, void const* cSrc,           \
                     size_t cSrcSize, HUF_DTable const* DTable, int bmi2)   \
    {                                                                       \
        (void)bmi2;                                                         \
        return fn##_body(dst, dstSize, cSrc, cSrcSize, DTable);             \
    }</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*-***************************/</comment>
<comment type="block">/*  generic DTableDesc       */</comment>
<comment type="block">/*-***************************/</comment>
<typedef>typedef <type><struct>struct <block>{ <decl_stmt><decl><type><name>BYTE</name></type> <name>maxTableLog</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>BYTE</name></type> <name>tableType</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>BYTE</name></type> <name>tableLog</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>BYTE</name></type> <name>reserved</name></decl>;</decl_stmt> }</block></struct></type> <name>DTableDesc</name>;</typedef>

<function><type><specifier>static</specifier> <name>DTableDesc</name></type> <name>HUF_getDTableDesc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>HUF_DTable</name><modifier>*</modifier></type> <name>table</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DTableDesc</name></type> <name>dtd</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dtd</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dtd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>dtd</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ZSTD_ENABLE_ASM_X86_64_BMI2</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>HUF_initDStream</name><parameter_list>(<parameter><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>ip</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier></type> <name>lastByte</name> <init>= <expr><name><name>ip</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>bitsConsumed</name> <init>= <expr><ternary><condition><expr><name>lastByte</name></expr> ?</condition><then> <expr><literal type="number">8</literal> <operator>-</operator> <call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><name>lastByte</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>value</name> <init>= <expr><call><name>MEM_readLEST</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call> <operator>|</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>bitsConsumed</name> <operator>&lt;=</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>value</name> <operator>&lt;&lt;</operator> <name>bitsConsumed</name></expr>;</return>
</block_content>}</block></function>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name><name>ip</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name><name>op</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U64</name></type> <name><name>bits</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>dt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>ilimit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>oend</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name><name>iend</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>HUF_DecompressAsmArgs</name>;</typedef>

<comment type="block" format="doxygen">/**
 * Initializes args for the asm decoding loop.
 * @returns 0 on success
 *          1 if the fallback implementation should be used.
 *          Or an error code on failure.
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>HUF_DecompressAsmArgs_init</name><parameter_list>(<parameter><decl><type><name>HUF_DecompressAsmArgs</name><modifier>*</modifier></type> <name>args</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>, <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>HUF_DTable</name><modifier>*</modifier></type> <name>DTable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>dt</name> <init>= <expr><name>DTable</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>dtLog</name> <init>= <expr><call><name>HUF_getDTableDesc</name><argument_list>(<argument><expr><name>DTable</name></expr></argument>)</argument_list></call><operator>.</operator><name>tableLog</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ilimit</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <literal type="number">6</literal> <operator>+</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name> <operator>+</operator> <name>dstSize</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* The following condition is false on x32 platform,
     * but HUF_asm is not compatible with this ABI */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>MEM_isLittleEndian</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>MEM_32bits</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* strict minimum : jump table + 1 byte per stream */</comment>
    <if_stmt><if>if <condition>(<expr><name>srcSize</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>corruption_detected</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Must have at least 8 bytes per stream because we don't handle initializing smaller bit containers.
     * If table log is not correct at this point, fallback to the old decoder.
     * On small inputs we don't have enough data to trigger the fast loop, so use the old decoder.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>dtLog</name> <operator>!=</operator> <name>HUF_DECODER_FAST_TABLELOG</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Read the jump table. */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>istart</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>length1</name> <init>= <expr><call><name>MEM_readLE16</name><argument_list>(<argument><expr><name>istart</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>length2</name> <init>= <expr><call><name>MEM_readLE16</name><argument_list>(<argument><expr><name>istart</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>length3</name> <init>= <expr><call><name>MEM_readLE16</name><argument_list>(<argument><expr><name>istart</name><operator>+</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>length4</name> <init>= <expr><name>srcSize</name> <operator>-</operator> <operator>(</operator><name>length1</name> <operator>+</operator> <name>length2</name> <operator>+</operator> <name>length3</name> <operator>+</operator> <literal type="number">6</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>iend</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>istart</name> <operator>+</operator> <literal type="number">6</literal></expr>;</expr_stmt>  <comment type="block">/* jumpTable */</comment>
        <expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>iend</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>args</name><operator>-&gt;</operator><name>iend</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>length1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>iend</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>args</name><operator>-&gt;</operator><name>iend</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name>length2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>iend</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>args</name><operator>-&gt;</operator><name>iend</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name>length3</name></expr>;</expr_stmt>

        <comment type="block">/* HUF_initDStream() requires this, and this small of an input
         * won't benefit from the ASM loop anyways.
         * length1 must be &gt;= 16 so that ip[0] &gt;= ilimit before the loop
         * starts.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>length1</name> <operator>&lt;</operator> <literal type="number">16</literal> <operator>||</operator> <name>length2</name> <operator>&lt;</operator> <literal type="number">8</literal> <operator>||</operator> <name>length3</name> <operator>&lt;</operator> <literal type="number">8</literal> <operator>||</operator> <name>length4</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>length4</name> <operator>&gt;</operator> <name>srcSize</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>corruption_detected</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* overflow */</comment>
    </block_content>}</block>
    <comment type="block">/* ip[] contains the position that is currently loaded into bits[]. */</comment>
    <expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>args</name><operator>-&gt;</operator><name>iend</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>U64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>ip</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>args</name><operator>-&gt;</operator><name>iend</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>U64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>ip</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>args</name><operator>-&gt;</operator><name>iend</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>U64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>ip</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BYTE</name> <specifier>const</specifier><operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <name>srcSize</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>U64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <comment type="block">/* op[] contains the output pointers. */</comment>
    <expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>op</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>args</name><operator>-&gt;</operator><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name>dstSize</name><operator>+</operator><literal type="number">3</literal><operator>)</operator><operator>/</operator><literal type="number">4</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>op</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>args</name><operator>-&gt;</operator><name>op</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name>dstSize</name><operator>+</operator><literal type="number">3</literal><operator>)</operator><operator>/</operator><literal type="number">4</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>op</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>args</name><operator>-&gt;</operator><name>op</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name>dstSize</name><operator>+</operator><literal type="number">3</literal><operator>)</operator><operator>/</operator><literal type="number">4</literal></expr>;</expr_stmt>

    <comment type="block">/* No point to call the ASM loop for tiny outputs. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>args</name><operator>-&gt;</operator><name>op</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&gt;=</operator> <name>oend</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* bits[] is the bit container.
        * It is read from the MSB down to the LSB.
        * It is shifted left as it is read, and zeros are
        * shifted in. After the lowest valid bit a 1 is
        * set, so that CountTrailingZeros(bits[]) can be used
        * to count how many bits we've consumed.
        */</comment>
    <expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>bits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>HUF_initDStream</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>bits</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>HUF_initDStream</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>ip</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>bits</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>HUF_initDStream</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>ip</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>bits</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>HUF_initDStream</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>ip</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If ip[] &gt;= ilimit, it is guaranteed to be safe to
        * reload bits[]. It may be beyond its section, but is
        * guaranteed to be valid (&gt;= istart).
        */</comment>
    <expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>ilimit</name></name> <operator>=</operator> <name>ilimit</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>oend</name></name> <operator>=</operator> <name>oend</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>dt</name></name> <operator>=</operator> <name>dt</name></expr>;</expr_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>HUF_initRemainingDStream</name><parameter_list>(<parameter><decl><type><name>BIT_DStream_t</name><modifier>*</modifier></type> <name>bit</name></decl></parameter>, <parameter><decl><type><name>HUF_DecompressAsmArgs</name> <specifier>const</specifier><modifier>*</modifier></type> <name>args</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stream</name></decl></parameter>, <parameter><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>segmentEnd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Validate that we haven't overwritten. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>args</name><operator>-&gt;</operator><name>op</name><index>[<expr><name>stream</name></expr>]</index></name> <operator>&gt;</operator> <name>segmentEnd</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>corruption_detected</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Validate that we haven't read beyond iend[].
        * Note that ip[] may be &lt; iend[] because the MSB is
        * the next bit to read, and we may have consumed 100%
        * of the stream, so down to iend[i] - 8 is valid.
        */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>args</name><operator>-&gt;</operator><name>ip</name><index>[<expr><name>stream</name></expr>]</index></name> <operator>&lt;</operator> <name><name>args</name><operator>-&gt;</operator><name>iend</name><index>[<expr><name>stream</name></expr>]</index></name> <operator>-</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>corruption_detected</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Construct the BIT_DStream_t. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bit</name><operator>-&gt;</operator><name>bitContainer</name></name> <operator>=</operator> <call><name>MEM_readLE64</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>ip</name><index>[<expr><name>stream</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bit</name><operator>-&gt;</operator><name>bitsConsumed</name></name> <operator>=</operator> <call><name>ZSTD_countTrailingZeros64</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>bits</name><index>[<expr><name>stream</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bit</name><operator>-&gt;</operator><name>start</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name><name>args</name><operator>-&gt;</operator><name>iend</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bit</name><operator>-&gt;</operator><name>limitPtr</name></name> <operator>=</operator> <name><name>bit</name><operator>-&gt;</operator><name>start</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bit</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name><name>args</name><operator>-&gt;</operator><name>ip</name><index>[<expr><name>stream</name></expr>]</index></name></expr>;</expr_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HUF_FORCE_DECOMPRESS_X2</name></cpp:ifndef>

<comment type="block">/*-***************************/</comment>
<comment type="block">/*  single-symbol decoding   */</comment>
<comment type="block">/*-***************************/</comment>
<typedef>typedef <type><struct>struct <block>{ <decl_stmt><decl><type><name>BYTE</name></type> <name>nbBits</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>BYTE</name></type> <name>byte</name></decl>;</decl_stmt> }</block></struct></type> <name>HUF_DEltX1</name>;</typedef>   <comment type="block">/* single-symbol decoding */</comment>

<comment type="block" format="doxygen">/**
 * Packs 4 HUF_DEltX1 structs into a U64. This is used to lay down 4 entries at
 * a time.
 */</comment>
<function><type><specifier>static</specifier> <name>U64</name></type> <name>HUF_DEltX1_set4</name><parameter_list>(<parameter><decl><type><name>BYTE</name></type> <name>symbol</name></decl></parameter>, <parameter><decl><type><name>BYTE</name></type> <name>nbBits</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>U64</name></type> <name>D4</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>MEM_isLittleEndian</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>D4</name> <operator>=</operator> <operator>(</operator><name>symbol</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>+</operator> <name>nbBits</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>D4</name> <operator>=</operator> <name>symbol</name> <operator>+</operator> <operator>(</operator><name>nbBits</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>D4</name> <operator>*=</operator> <literal type="number">0x0001000100010001ULL</literal></expr>;</expr_stmt>
    <return>return <expr><name>D4</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Increase the tableLog to targetTableLog and rescales the stats.
 * If tableLog &gt; targetTableLog this is a no-op.
 * @returns New tableLog
 */</comment>
<function><type><specifier>static</specifier> <name>U32</name></type> <name>HUF_rescaleStats</name><parameter_list>(<parameter><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>huffWeight</name></decl></parameter>, <parameter><decl><type><name>U32</name><modifier>*</modifier></type> <name>rankVal</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>nbSymbols</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>tableLog</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>targetTableLog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>tableLog</name> <operator>&gt;</operator> <name>targetTableLog</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>tableLog</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>tableLog</name> <operator>&lt;</operator> <name>targetTableLog</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>scale</name> <init>= <expr><name>targetTableLog</name> <operator>-</operator> <name>tableLog</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name></type> <name>s</name></decl>;</decl_stmt>
        <comment type="block">/* Increase the weight for all non-zero probability symbols by scale. */</comment>
        <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <name>nbSymbols</name></expr>;</condition> <incr><expr><operator>++</operator><name>s</name></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><name><name>huffWeight</name><index>[<expr><name>s</name></expr>]</index></name> <operator>+=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>huffWeight</name><index>[<expr><name>s</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>scale</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></for>
        <comment type="block">/* Update rankVal to reflect the new weights.
         * All weights except 0 get moved to weight + scale.
         * Weights [1, scale] are empty.
         */</comment>
        <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>targetTableLog</name></expr>;</init> <condition><expr><name>s</name> <operator>&gt;</operator> <name>scale</name></expr>;</condition> <incr><expr><operator>--</operator><name>s</name></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><name><name>rankVal</name><index>[<expr><name>s</name></expr>]</index></name> <operator>=</operator> <name><name>rankVal</name><index>[<expr><name>s</name> <operator>-</operator> <name>scale</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>scale</name></expr>;</init> <condition><expr><name>s</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>s</name></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><name><name>rankVal</name><index>[<expr><name>s</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>targetTableLog</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <block>{
        <decl_stmt><decl><type><name>U32</name></type> <name><name>rankVal</name><index>[<expr><name>HUF_TABLELOG_ABSOLUTEMAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name></type> <name><name>rankStart</name><index>[<expr><name>HUF_TABLELOG_ABSOLUTEMAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name></type> <name><name>statsWksp</name><index>[<expr><name>HUF_READ_STATS_WORKSPACE_SIZE_U32</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name></type> <name><name>symbols</name><index>[<expr><name>HUF_SYMBOLVALUE_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name></type> <name><name>huffWeight</name><index>[<expr><name>HUF_SYMBOLVALUE_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>HUF_ReadDTableX1_Workspace</name>;</typedef>


<function><type><name>size_t</name></type> <name>HUF_readDTableX1_wksp</name><parameter_list>(<parameter><decl><type><name>HUF_DTable</name><modifier>*</modifier></type> <name>DTable</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workSpace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>HUF_readDTableX1_wksp_bmi2</name><argument_list>(<argument><expr><name>DTable</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>, <comment type="block">/* bmi2 */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>HUF_readDTableX1_wksp_bmi2</name><parameter_list>(<parameter><decl><type><name>HUF_DTable</name><modifier>*</modifier></type> <name>DTable</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workSpace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bmi2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name></type> <name>tableLog</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>nbSymbols</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>iSize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dtPtr</name> <init>= <expr><name>DTable</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HUF_DEltX1</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dt</name> <init>= <expr><operator>(</operator><name>HUF_DEltX1</name><operator>*</operator><operator>)</operator><name>dtPtr</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HUF_ReadDTableX1_Workspace</name><modifier>*</modifier></type> <name>wksp</name> <init>= <expr><operator>(</operator><name>HUF_ReadDTableX1_Workspace</name><operator>*</operator><operator>)</operator><name>workSpace</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUG_STATIC_ASSERT</name><argument_list>(<argument><expr><name>HUF_DECOMPRESS_WORKSPACE_SIZE</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>wksp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>wksp</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name>wkspSize</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>tableLog_tooLarge</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>DEBUG_STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DTableDesc</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HUF_DTable</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* ZSTD_memset(huffWeight, 0, sizeof(huffWeight)); */</comment>   <comment type="block">/* is not necessary, even though some analyzer complain ... */</comment>

    <expr_stmt><expr><name>iSize</name> <operator>=</operator> <call><name>HUF_readStats_wksp</name><argument_list>(<argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>huffWeight</name></name></expr></argument>, <argument><expr><name>HUF_SYMBOLVALUE_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>rankVal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbSymbols</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tableLog</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>statsWksp</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>statsWksp</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HUF_isError</name><argument_list>(<argument><expr><name>iSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>iSize</name></expr>;</return></block_content></block></if></if_stmt>


    <comment type="block">/* Table header */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>DTableDesc</name></type> <name>dtd</name> <init>= <expr><call><name>HUF_getDTableDesc</name><argument_list>(<argument><expr><name>DTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>maxTableLog</name> <init>= <expr><name><name>dtd</name><operator>.</operator><name>maxTableLog</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>targetTableLog</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name>maxTableLog</name></expr></argument>, <argument><expr><name>HUF_DECODER_FAST_TABLELOG</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>tableLog</name> <operator>=</operator> <call><name>HUF_rescaleStats</name><argument_list>(<argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>huffWeight</name></name></expr></argument>, <argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>rankVal</name></name></expr></argument>, <argument><expr><name>nbSymbols</name></expr></argument>, <argument><expr><name>tableLog</name></expr></argument>, <argument><expr><name>targetTableLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>tableLog</name> <operator>&gt;</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name><name>dtd</name><operator>.</operator><name>maxTableLog</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>tableLog_tooLarge</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* DTable too small, Huffman tree cannot fit in */</comment>
        <expr_stmt><expr><name><name>dtd</name><operator>.</operator><name>tableType</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dtd</name><operator>.</operator><name>tableLog</name></name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><name>tableLog</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>DTable</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dtd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dtd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* Compute symbols and rankStart given rankVal:
     *
     * rankVal already contains the number of values of each weight.
     *
     * symbols contains the symbols ordered by weight. First are the rankVal[0]
     * weight 0 symbols, followed by the rankVal[1] weight 1 symbols, and so on.
     * symbols[0] is filled (but unused) to avoid a branch.
     *
     * rankStart contains the offset where each rank belongs in the DTable.
     * rankStart[0] is not filled because there are no entries in the table for
     * weight 0.
     */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nextRankStart</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>unroll</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>nLimit</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name>nbSymbols</name> <operator>-</operator> <name>unroll</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name><operator>&lt;</operator><operator>(</operator><name>int</name><operator>)</operator><name>tableLog</name><operator>+</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>curr</name> <init>= <expr><name>nextRankStart</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>nextRankStart</name> <operator>+=</operator> <name><name>wksp</name><operator>-&gt;</operator><name>rankVal</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>wksp</name><operator>-&gt;</operator><name>rankStart</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name>curr</name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <for>for <control>(<init><expr><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>nLimit</name></expr>;</condition> <incr><expr><name>n</name> <operator>+=</operator> <name>unroll</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>u</name></decl>;</decl_stmt>
            <for>for <control>(<init><expr><name>u</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>u</name> <operator>&lt;</operator> <name>unroll</name></expr>;</condition> <incr><expr><operator>++</operator><name>u</name></expr></incr>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>w</name> <init>= <expr><name><name>wksp</name><operator>-&gt;</operator><name>huffWeight</name><index>[<expr><name>n</name><operator>+</operator><name>u</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>wksp</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name><name>wksp</name><operator>-&gt;</operator><name>rankStart</name><index>[<expr><name>w</name></expr>]</index></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><operator>(</operator><name>n</name><operator>+</operator><name>u</name><operator>)</operator></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></for>
        <for>for <control>(<init>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><name>nbSymbols</name></expr>;</condition> <incr><expr><operator>++</operator><name>n</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>w</name> <init>= <expr><name><name>wksp</name><operator>-&gt;</operator><name>huffWeight</name><index>[<expr><name>n</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>wksp</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name><name>wksp</name><operator>-&gt;</operator><name>rankStart</name><index>[<expr><name>w</name></expr>]</index></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><name>n</name></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block>

    <comment type="block">/* fill DTable
     * We fill all entries of each weight in order.
     * That way length is a constant for each iteration of the outer loop.
     * We can switch based on the length to a different inner loop which is
     * optimized for that particular case.
     */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name></type> <name>w</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>symbol</name><init>=<expr><name><name>wksp</name><operator>-&gt;</operator><name>rankVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>rankStart</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>w</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>w</name><operator>&lt;</operator><name>tableLog</name><operator>+</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><operator>++</operator><name>w</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>symbolCount</name> <init>= <expr><name><name>wksp</name><operator>-&gt;</operator><name>rankVal</name><index>[<expr><name>w</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>length</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>w</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>uStart</name> <init>= <expr><name>rankStart</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier></type> <name>nbBits</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>)</operator><operator>(</operator><name>tableLog</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>w</name><operator>)</operator></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>s</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>u</name></decl>;</decl_stmt>
            <switch>switch <condition>(<expr><name>length</name></expr>)</condition> <block>{<block_content>
            <case>case <expr><literal type="number">1</literal></expr>:</case>
                <for>for <control>(<init><expr><name>s</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>s</name><operator>&lt;</operator><name>symbolCount</name></expr>;</condition> <incr><expr><operator>++</operator><name>s</name></expr></incr>)</control> <block>{<block_content>
                    <decl_stmt><decl><type><name>HUF_DEltX1</name></type> <name>D</name></decl>;</decl_stmt>
                    <expr_stmt><expr><name><name>D</name><operator>.</operator><name>byte</name></name> <operator>=</operator> <name><name>wksp</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name>symbol</name> <operator>+</operator> <name>s</name></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>D</name><operator>.</operator><name>nbBits</name></name> <operator>=</operator> <name>nbBits</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>dt</name><index>[<expr><name>uStart</name></expr>]</index></name> <operator>=</operator> <name>D</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>uStart</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                </block_content>}</block></for>
                <break>break;</break>
            <case>case <expr><literal type="number">2</literal></expr>:</case>
                <for>for <control>(<init><expr><name>s</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>s</name><operator>&lt;</operator><name>symbolCount</name></expr>;</condition> <incr><expr><operator>++</operator><name>s</name></expr></incr>)</control> <block>{<block_content>
                    <decl_stmt><decl><type><name>HUF_DEltX1</name></type> <name>D</name></decl>;</decl_stmt>
                    <expr_stmt><expr><name><name>D</name><operator>.</operator><name>byte</name></name> <operator>=</operator> <name><name>wksp</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name>symbol</name> <operator>+</operator> <name>s</name></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>D</name><operator>.</operator><name>nbBits</name></name> <operator>=</operator> <name>nbBits</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>dt</name><index>[<expr><name>uStart</name><operator>+</operator><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>D</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>dt</name><index>[<expr><name>uStart</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>D</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>uStart</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                </block_content>}</block></for>
                <break>break;</break>
            <case>case <expr><literal type="number">4</literal></expr>:</case>
                <for>for <control>(<init><expr><name>s</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>s</name><operator>&lt;</operator><name>symbolCount</name></expr>;</condition> <incr><expr><operator>++</operator><name>s</name></expr></incr>)</control> <block>{<block_content>
                    <decl_stmt><decl><type><name>U64</name> <specifier>const</specifier></type> <name>D4</name> <init>= <expr><call><name>HUF_DEltX1_set4</name><argument_list>(<argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name>symbol</name> <operator>+</operator> <name>s</name></expr>]</index></name></expr></argument>, <argument><expr><name>nbBits</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>MEM_write64</name><argument_list>(<argument><expr><name>dt</name> <operator>+</operator> <name>uStart</name></expr></argument>, <argument><expr><name>D4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>uStart</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
                </block_content>}</block></for>
                <break>break;</break>
            <case>case <expr><literal type="number">8</literal></expr>:</case>
                <for>for <control>(<init><expr><name>s</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>s</name><operator>&lt;</operator><name>symbolCount</name></expr>;</condition> <incr><expr><operator>++</operator><name>s</name></expr></incr>)</control> <block>{<block_content>
                    <decl_stmt><decl><type><name>U64</name> <specifier>const</specifier></type> <name>D4</name> <init>= <expr><call><name>HUF_DEltX1_set4</name><argument_list>(<argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name>symbol</name> <operator>+</operator> <name>s</name></expr>]</index></name></expr></argument>, <argument><expr><name>nbBits</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>MEM_write64</name><argument_list>(<argument><expr><name>dt</name> <operator>+</operator> <name>uStart</name></expr></argument>, <argument><expr><name>D4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>MEM_write64</name><argument_list>(<argument><expr><name>dt</name> <operator>+</operator> <name>uStart</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>D4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>uStart</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
                </block_content>}</block></for>
                <break>break;</break>
            <default>default:</default>
                <for>for <control>(<init><expr><name>s</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>s</name><operator>&lt;</operator><name>symbolCount</name></expr>;</condition> <incr><expr><operator>++</operator><name>s</name></expr></incr>)</control> <block>{<block_content>
                    <decl_stmt><decl><type><name>U64</name> <specifier>const</specifier></type> <name>D4</name> <init>= <expr><call><name>HUF_DEltX1_set4</name><argument_list>(<argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name>symbol</name> <operator>+</operator> <name>s</name></expr>]</index></name></expr></argument>, <argument><expr><name>nbBits</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <for>for <control>(<init><expr><name>u</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>u</name> <operator>&lt;</operator> <name>length</name></expr>;</condition> <incr><expr><name>u</name> <operator>+=</operator> <literal type="number">16</literal></expr></incr>)</control> <block>{<block_content>
                        <expr_stmt><expr><call><name>MEM_write64</name><argument_list>(<argument><expr><name>dt</name> <operator>+</operator> <name>uStart</name> <operator>+</operator> <name>u</name> <operator>+</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>D4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>MEM_write64</name><argument_list>(<argument><expr><name>dt</name> <operator>+</operator> <name>uStart</name> <operator>+</operator> <name>u</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>D4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>MEM_write64</name><argument_list>(<argument><expr><name>dt</name> <operator>+</operator> <name>uStart</name> <operator>+</operator> <name>u</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name>D4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>MEM_write64</name><argument_list>(<argument><expr><name>dt</name> <operator>+</operator> <name>uStart</name> <operator>+</operator> <name>u</name> <operator>+</operator> <literal type="number">12</literal></expr></argument>, <argument><expr><name>D4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></for>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>u</name> <operator>==</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>uStart</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
                </block_content>}</block></for>
                <break>break;</break>
            </block_content>}</block></switch>
            <expr_stmt><expr><name>symbol</name> <operator>+=</operator> <name>symbolCount</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>rankStart</name> <operator>+=</operator> <name>symbolCount</name> <operator>*</operator> <name>length</name></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block>
    <return>return <expr><name>iSize</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>BYTE</name></type>
<name>HUF_decodeSymbolX1</name><parameter_list>(<parameter><decl><type><name>BIT_DStream_t</name><modifier>*</modifier></type> <name>Dstream</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>HUF_DEltX1</name><modifier>*</modifier></type> <name>dt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dtLog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>val</name> <init>= <expr><call><name>BIT_lookBitsFast</name><argument_list>(<argument><expr><name>Dstream</name></expr></argument>, <argument><expr><name>dtLog</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* note : dtLog &gt;= 1 */</comment>
    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier></type> <name>c</name> <init>= <expr><name><name>dt</name><index>[<expr><name>val</name></expr>]</index></name><operator>.</operator><name>byte</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BIT_skipBits</name><argument_list>(<argument><expr><name>Dstream</name></expr></argument>, <argument><expr><name><name>dt</name><index>[<expr><name>val</name></expr>]</index></name><operator>.</operator><name>nbBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_DECODE_SYMBOLX1_0</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>DStreamPtr</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>*ptr++ = HUF_decodeSymbolX1(DStreamPtr, dt, dtLog)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_DECODE_SYMBOLX1_1</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>DStreamPtr</name></type></parameter>)</parameter_list></cpp:macro>  \
    <cpp:value>if (MEM_64bits() || (HUF_TABLELOG_MAX&lt;=12)) \
        HUF_DECODE_SYMBOLX1_0(ptr, DStreamPtr)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_DECODE_SYMBOLX1_2</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>DStreamPtr</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>if (MEM_64bits()) \
        HUF_DECODE_SYMBOLX1_0(ptr, DStreamPtr)</cpp:value></cpp:define>

<function><type><name>HINT_INLINE</name> <name>size_t</name></type>
<name>HUF_decodeStreamX1</name><parameter_list>(<parameter><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>BIT_DStream_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>bitDPtr</name></decl></parameter>, <parameter><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>pEnd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>HUF_DEltX1</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dtLog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>pStart</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* up to 4 symbols at a time */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pEnd</name> <operator>-</operator> <name>p</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
        <while>while <condition>(<expr><operator>(</operator><call><name>BIT_reloadDStream</name><argument_list>(<argument><expr><name>bitDPtr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BIT_DStream_unfinished</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>p</name> <operator>&lt;</operator> <name>pEnd</name><operator>-</operator><literal type="number">3</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX1_2</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bitDPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX1_1</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bitDPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX1_2</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bitDPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX1_0</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bitDPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>BIT_reloadDStream</name><argument_list>(<argument><expr><name>bitDPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* [0-3] symbols remaining */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>MEM_32bits</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <while>while <condition>(<expr><operator>(</operator><call><name>BIT_reloadDStream</name><argument_list>(<argument><expr><name>bitDPtr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BIT_DStream_unfinished</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>p</name> <operator>&lt;</operator> <name>pEnd</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX1_0</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bitDPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while></block_content></block></if></if_stmt>

    <comment type="block">/* no more data to retrieve from bitstream, no need to reload */</comment>
    <while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>pEnd</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX1_0</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bitDPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

    <return>return <expr><name>pEnd</name><operator>-</operator><name>pStart</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>size_t</name></type>
<name>HUF_decompress1X1_usingDTable_internal_body</name><parameter_list>(
          <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>,  <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>HUF_DTable</name><modifier>*</modifier></type> <name>DTable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend</name> <init>= <expr><name>op</name> <operator>+</operator> <name>dstSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dtPtr</name> <init>= <expr><name>DTable</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>HUF_DEltX1</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dt</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>HUF_DEltX1</name><operator>*</operator><operator>)</operator><name>dtPtr</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BIT_DStream_t</name></type> <name>bitD</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DTableDesc</name> <specifier>const</specifier></type> <name>dtd</name> <init>= <expr><call><name>HUF_getDTableDesc</name><argument_list>(<argument><expr><name>DTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>dtLog</name> <init>= <expr><name><name>dtd</name><operator>.</operator><name>tableLog</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK_F</name><argument_list>( <argument><expr><call><name>BIT_initDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitD</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>HUF_decodeStreamX1</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>, <argument><expr><name>dt</name></expr></argument>, <argument><expr><name>dtLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BIT_endOfDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitD</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>corruption_detected</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>dstSize</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>size_t</name></type>
<name>HUF_decompress4X1_usingDTable_internal_body</name><parameter_list>(
          <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>,  <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>HUF_DTable</name><modifier>*</modifier></type> <name>DTable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Check */</comment>
    <if_stmt><if>if <condition>(<expr><name>cSrcSize</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>corruption_detected</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* strict minimum : jump table + 1 byte per stream */</comment>

    <block>{<block_content>   <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>istart</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator> <name>cSrc</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ostart</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator> <name>dst</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend</name> <init>= <expr><name>ostart</name> <operator>+</operator> <name>dstSize</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>olimit</name> <init>= <expr><name>oend</name> <operator>-</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dtPtr</name> <init>= <expr><name>DTable</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>HUF_DEltX1</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dt</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>HUF_DEltX1</name><operator>*</operator><operator>)</operator><name>dtPtr</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Init */</comment>
        <decl_stmt><decl><type><name>BIT_DStream_t</name></type> <name>bitD1</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BIT_DStream_t</name></type> <name>bitD2</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BIT_DStream_t</name></type> <name>bitD3</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BIT_DStream_t</name></type> <name>bitD4</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>length1</name> <init>= <expr><call><name>MEM_readLE16</name><argument_list>(<argument><expr><name>istart</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>length2</name> <init>= <expr><call><name>MEM_readLE16</name><argument_list>(<argument><expr><name>istart</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>length3</name> <init>= <expr><call><name>MEM_readLE16</name><argument_list>(<argument><expr><name>istart</name><operator>+</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>length4</name> <init>= <expr><name>cSrcSize</name> <operator>-</operator> <operator>(</operator><name>length1</name> <operator>+</operator> <name>length2</name> <operator>+</operator> <name>length3</name> <operator>+</operator> <literal type="number">6</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>istart1</name> <init>= <expr><name>istart</name> <operator>+</operator> <literal type="number">6</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* jumpTable */</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>istart2</name> <init>= <expr><name>istart1</name> <operator>+</operator> <name>length1</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>istart3</name> <init>= <expr><name>istart2</name> <operator>+</operator> <name>length2</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>istart4</name> <init>= <expr><name>istart3</name> <operator>+</operator> <name>length3</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>segmentSize</name> <init>= <expr><operator>(</operator><name>dstSize</name><operator>+</operator><literal type="number">3</literal><operator>)</operator> <operator>/</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>opStart2</name> <init>= <expr><name>ostart</name> <operator>+</operator> <name>segmentSize</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>opStart3</name> <init>= <expr><name>opStart2</name> <operator>+</operator> <name>segmentSize</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>opStart4</name> <init>= <expr><name>opStart3</name> <operator>+</operator> <name>segmentSize</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op1</name> <init>= <expr><name>ostart</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op2</name> <init>= <expr><name>opStart2</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op3</name> <init>= <expr><name>opStart3</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op4</name> <init>= <expr><name>opStart4</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>DTableDesc</name> <specifier>const</specifier></type> <name>dtd</name> <init>= <expr><call><name>HUF_getDTableDesc</name><argument_list>(<argument><expr><name>DTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>dtLog</name> <init>= <expr><name><name>dtd</name><operator>.</operator><name>tableLog</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name></type> <name>endSignal</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>length4</name> <operator>&gt;</operator> <name>cSrcSize</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>corruption_detected</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* overflow */</comment>
        <if_stmt><if>if <condition>(<expr><name>opStart4</name> <operator>&gt;</operator> <name>oend</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>corruption_detected</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>      <comment type="block">/* overflow */</comment>
        <expr_stmt><expr><call><name>CHECK_F</name><argument_list>( <argument><expr><call><name>BIT_initDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitD1</name></expr></argument>, <argument><expr><name>istart1</name></expr></argument>, <argument><expr><name>length1</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CHECK_F</name><argument_list>( <argument><expr><call><name>BIT_initDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitD2</name></expr></argument>, <argument><expr><name>istart2</name></expr></argument>, <argument><expr><name>length2</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CHECK_F</name><argument_list>( <argument><expr><call><name>BIT_initDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitD3</name></expr></argument>, <argument><expr><name>istart3</name></expr></argument>, <argument><expr><name>length3</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CHECK_F</name><argument_list>( <argument><expr><call><name>BIT_initDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitD4</name></expr></argument>, <argument><expr><name>istart4</name></expr></argument>, <argument><expr><name>length4</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* up to 16 symbols per loop (4 symbols per stream) in 64-bit mode */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name> <operator>-</operator> <name>op4</name><operator>)</operator> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
            <for>for <control>( <init>;</init> <condition><expr><operator>(</operator><name>endSignal</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>op4</name> <operator>&lt;</operator> <name>olimit</name><operator>)</operator></expr> ;</condition> <incr/>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX1_2</name><argument_list>(<argument><expr><name>op1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX1_2</name><argument_list>(<argument><expr><name>op2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX1_2</name><argument_list>(<argument><expr><name>op3</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX1_2</name><argument_list>(<argument><expr><name>op4</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX1_1</name><argument_list>(<argument><expr><name>op1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX1_1</name><argument_list>(<argument><expr><name>op2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX1_1</name><argument_list>(<argument><expr><name>op3</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX1_1</name><argument_list>(<argument><expr><name>op4</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX1_2</name><argument_list>(<argument><expr><name>op1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX1_2</name><argument_list>(<argument><expr><name>op2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX1_2</name><argument_list>(<argument><expr><name>op3</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX1_2</name><argument_list>(<argument><expr><name>op4</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX1_0</name><argument_list>(<argument><expr><name>op1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX1_0</name><argument_list>(<argument><expr><name>op2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX1_0</name><argument_list>(<argument><expr><name>op3</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX1_0</name><argument_list>(<argument><expr><name>op4</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>endSignal</name> <operator>&amp;=</operator> <call><name>BIT_reloadDStreamFast</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitD1</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BIT_DStream_unfinished</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>endSignal</name> <operator>&amp;=</operator> <call><name>BIT_reloadDStreamFast</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitD2</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BIT_DStream_unfinished</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>endSignal</name> <operator>&amp;=</operator> <call><name>BIT_reloadDStreamFast</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitD3</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BIT_DStream_unfinished</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>endSignal</name> <operator>&amp;=</operator> <call><name>BIT_reloadDStreamFast</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitD4</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BIT_DStream_unfinished</name></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* check corruption */</comment>
        <comment type="block">/* note : should not be necessary : op# advance in lock step, and we control op4.
         *        but curiously, binary generated by gcc 7.2 &amp; 7.3 with -mbmi2 runs faster when &gt;=1 test is present */</comment>
        <if_stmt><if>if <condition>(<expr><name>op1</name> <operator>&gt;</operator> <name>opStart2</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>corruption_detected</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>op2</name> <operator>&gt;</operator> <name>opStart3</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>corruption_detected</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>op3</name> <operator>&gt;</operator> <name>opStart4</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>corruption_detected</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <comment type="block">/* note : op4 supposed already verified within main loop */</comment>

        <comment type="block">/* finish bitStreams one by one */</comment>
        <expr_stmt><expr><call><name>HUF_decodeStreamX1</name><argument_list>(<argument><expr><name>op1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD1</name></expr></argument>, <argument><expr><name>opStart2</name></expr></argument>, <argument><expr><name>dt</name></expr></argument>, <argument><expr><name>dtLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>HUF_decodeStreamX1</name><argument_list>(<argument><expr><name>op2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD2</name></expr></argument>, <argument><expr><name>opStart3</name></expr></argument>, <argument><expr><name>dt</name></expr></argument>, <argument><expr><name>dtLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>HUF_decodeStreamX1</name><argument_list>(<argument><expr><name>op3</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD3</name></expr></argument>, <argument><expr><name>opStart4</name></expr></argument>, <argument><expr><name>dt</name></expr></argument>, <argument><expr><name>dtLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>HUF_decodeStreamX1</name><argument_list>(<argument><expr><name>op4</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD4</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>,     <argument><expr><name>dt</name></expr></argument>, <argument><expr><name>dtLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* check */</comment>
        <block>{<block_content> <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>endCheck</name> <init>= <expr><call><name>BIT_endOfDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitD1</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <call><name>BIT_endOfDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitD2</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <call><name>BIT_endOfDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitD3</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <call><name>BIT_endOfDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitD4</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><name>endCheck</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>corruption_detected</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt> </block_content>}</block>

        <comment type="block">/* decoded size */</comment>
        <return>return <expr><name>dstSize</name></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HUF_NEED_BMI2_FUNCTION</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>BMI2_TARGET_ATTRIBUTE</name>
<name>size_t</name></type> <name>HUF_decompress4X1_usingDTable_internal_bmi2</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>, <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>,
                    <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>, <parameter><decl><type><name>HUF_DTable</name> <specifier>const</specifier><modifier>*</modifier></type> <name>DTable</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>HUF_decompress4X1_usingDTable_internal_body</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HUF_NEED_DEFAULT_FUNCTION</name></expr></cpp:if>
<function><type><specifier>static</specifier>
<name>size_t</name></type> <name>HUF_decompress4X1_usingDTable_internal_default</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>, <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>,
                    <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>, <parameter><decl><type><name>HUF_DTable</name> <specifier>const</specifier><modifier>*</modifier></type> <name>DTable</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>HUF_decompress4X1_usingDTable_internal_body</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ZSTD_ENABLE_ASM_X86_64_BMI2</name></expr></cpp:if>

<decl_stmt><decl><type><name>HUF_ASM_DECL</name> <name>void</name></type> <name>HUF_decompress4X1_usingDTable_internal_bmi2_asm_loop</name><argument_list>(<argument><expr><name>HUF_DecompressAsmArgs</name><operator>*</operator> <name>args</name></expr></argument>)</argument_list> <name>ZSTDLIB_HIDDEN</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>HUF_ASM_X86_64_BMI2_ATTRS</name>
<name>size_t</name></type>
<name>HUF_decompress4X1_usingDTable_internal_bmi2_asm</name><parameter_list>(
          <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>,  <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>HUF_DTable</name><modifier>*</modifier></type> <name>DTable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>dt</name> <init>= <expr><name>DTable</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>cSrc</name> <operator>+</operator> <literal type="number">6</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name> <operator>+</operator> <name>dstSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HUF_DecompressAsmArgs</name></type> <name>args</name></decl>;</decl_stmt>
    <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>ret</name> <init>= <expr><call><name>HUF_DecompressAsmArgs_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"Failed to init asm args"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>HUF_decompress4X1_usingDTable_internal_bmi2</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>args</name><operator>.</operator><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <name><name>args</name><operator>.</operator><name>ilimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HUF_decompress4X1_usingDTable_internal_bmi2_asm_loop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Our loop guarantees that ip[] &gt;= ilimit and that we haven't
    * overwritten any op[].
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>args</name><operator>.</operator><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <name>iend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>args</name><operator>.</operator><name>ip</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;=</operator> <name>iend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>args</name><operator>.</operator><name>ip</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&gt;=</operator> <name>iend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>args</name><operator>.</operator><name>ip</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&gt;=</operator> <name>iend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>args</name><operator>.</operator><name>op</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&lt;=</operator> <name>oend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>iend</name></expr>;</expr_stmt>

    <comment type="block">/* finish bit streams one by one. */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>segmentSize</name> <init>= <expr><operator>(</operator><name>dstSize</name><operator>+</operator><literal type="number">3</literal><operator>)</operator> <operator>/</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>segmentEnd</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>BIT_DStream_t</name></type> <name>bit</name></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>segmentSize</name> <operator>&lt;=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name> <operator>-</operator> <name>segmentEnd</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>segmentEnd</name> <operator>+=</operator> <name>segmentSize</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>segmentEnd</name> <operator>=</operator> <name>oend</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>HUF_initRemainingDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>segmentEnd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"corruption"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Decompress and validate that we've produced exactly the expected length. */</comment>
            <expr_stmt><expr><name><name>args</name><operator>.</operator><name>op</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+=</operator> <call><name>HUF_decodeStreamX1</name><argument_list>(<argument><expr><name><name>args</name><operator>.</operator><name>op</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bit</name></expr></argument>, <argument><expr><name>segmentEnd</name></expr></argument>, <argument><expr><operator>(</operator><name>HUF_DEltX1</name> <specifier>const</specifier><operator>*</operator><operator>)</operator><name>dt</name></expr></argument>, <argument><expr><name>HUF_DECODER_FAST_TABLELOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>args</name><operator>.</operator><name>op</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>segmentEnd</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>corruption_detected</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block>

    <comment type="block">/* decoded size */</comment>
    <return>return <expr><name>dstSize</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ZSTD_ENABLE_ASM_X86_64_BMI2 */</comment>

<typedef>typedef <function_decl><type><name>size_t</name></type> (<modifier>*</modifier><name>HUF_decompress_usingDTable_t</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
                                               <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>cSrc</name></decl></parameter>,
                                               <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>,
                                               <parameter><decl><type><specifier>const</specifier> <name>HUF_DTable</name> <modifier>*</modifier></type><name>DTable</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<macro><name>HUF_DGEN</name><argument_list>(<argument>HUF_decompress1X1_usingDTable_internal</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>HUF_decompress4X1_usingDTable_internal</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>, <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>,
                    <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>, <parameter><decl><type><name>HUF_DTable</name> <specifier>const</specifier><modifier>*</modifier></type> <name>DTable</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bmi2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DYNAMIC_BMI2</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name>bmi2</name></expr>)</condition> <block>{<block_content>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><name>ZSTD_ENABLE_ASM_X86_64_BMI2</name></expr></cpp:if>
        <return>return <expr><call><name>HUF_decompress4X1_usingDTable_internal_bmi2_asm</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
        <return>return <expr><call><name>HUF_decompress4X1_usingDTable_internal_bmi2</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>bmi2</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ZSTD_ENABLE_ASM_X86_64_BMI2</name> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__BMI2__</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <return>return <expr><call><name>HUF_decompress4X1_usingDTable_internal_bmi2_asm</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr><call><name>HUF_decompress4X1_usingDTable_internal_default</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<function><type><name>size_t</name></type> <name>HUF_decompress1X1_usingDTable</name><parameter_list>(
          <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>,  <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>HUF_DTable</name><modifier>*</modifier></type> <name>DTable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DTableDesc</name></type> <name>dtd</name> <init>= <expr><call><name>HUF_getDTableDesc</name><argument_list>(<argument><expr><name>DTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>dtd</name><operator>.</operator><name>tableType</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>GENERIC</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>HUF_decompress1X1_usingDTable_internal</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>, <comment type="block">/* bmi2 */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>HUF_decompress1X1_DCtx_wksp</name><parameter_list>(<parameter><decl><type><name>HUF_DTable</name><modifier>*</modifier></type> <name>DCtx</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>,
                                   <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workSpace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator> <name>cSrc</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>hSize</name> <init>= <expr><call><name>HUF_readDTableX1_wksp</name><argument_list>(<argument><expr><name>DCtx</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HUF_isError</name><argument_list>(<argument><expr><name>hSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>hSize</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>hSize</name> <operator>&gt;=</operator> <name>cSrcSize</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>srcSize_wrong</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>hSize</name></expr>;</expr_stmt> <expr_stmt><expr><name>cSrcSize</name> <operator>-=</operator> <name>hSize</name></expr>;</expr_stmt>

    <return>return <expr><call><name>HUF_decompress1X1_usingDTable_internal</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DCtx</name></expr></argument>, <comment type="block">/* bmi2 */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>size_t</name></type> <name>HUF_decompress4X1_usingDTable</name><parameter_list>(
          <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>,  <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>HUF_DTable</name><modifier>*</modifier></type> <name>DTable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DTableDesc</name></type> <name>dtd</name> <init>= <expr><call><name>HUF_getDTableDesc</name><argument_list>(<argument><expr><name>DTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>dtd</name><operator>.</operator><name>tableType</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>GENERIC</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>HUF_decompress4X1_usingDTable_internal</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>, <comment type="block">/* bmi2 */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>HUF_decompress4X1_DCtx_wksp_bmi2</name><parameter_list>(<parameter><decl><type><name>HUF_DTable</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>,
                                   <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workSpace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bmi2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator> <name>cSrc</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>hSize</name> <init>= <expr><call><name>HUF_readDTableX1_wksp_bmi2</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HUF_isError</name><argument_list>(<argument><expr><name>hSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>hSize</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>hSize</name> <operator>&gt;=</operator> <name>cSrcSize</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>srcSize_wrong</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>hSize</name></expr>;</expr_stmt> <expr_stmt><expr><name>cSrcSize</name> <operator>-=</operator> <name>hSize</name></expr>;</expr_stmt>

    <return>return <expr><call><name>HUF_decompress4X1_usingDTable_internal</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>HUF_decompress4X1_DCtx_wksp</name><parameter_list>(<parameter><decl><type><name>HUF_DTable</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>,
                                   <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workSpace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>HUF_decompress4X1_DCtx_wksp_bmi2</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HUF_FORCE_DECOMPRESS_X2 */</comment>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HUF_FORCE_DECOMPRESS_X1</name></cpp:ifndef>

<comment type="block">/* *************************/</comment>
<comment type="block">/* double-symbols decoding */</comment>
<comment type="block">/* *************************/</comment>

<typedef>typedef <type><struct>struct <block>{ <decl_stmt><decl><type><name>U16</name></type> <name>sequence</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>BYTE</name></type> <name>nbBits</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>BYTE</name></type> <name>length</name></decl>;</decl_stmt> }</block></struct></type> <name>HUF_DEltX2</name>;</typedef>  <comment type="block">/* double-symbols decoding */</comment>
<typedef>typedef <type><struct>struct <block>{ <decl_stmt><decl><type><name>BYTE</name></type> <name>symbol</name></decl>;</decl_stmt> }</block></struct></type> <name>sortedSymbol_t</name>;</typedef>
<typedef>typedef <type><name>U32</name></type> <name><name>rankValCol_t</name><index>[<expr><name>HUF_TABLELOG_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name>;</typedef>
<typedef>typedef <type><name>rankValCol_t</name></type> <name><name>rankVal_t</name><index>[<expr><name>HUF_TABLELOG_MAX</name></expr>]</index></name>;</typedef>

<comment type="block" format="doxygen">/**
 * Constructs a HUF_DEltX2 in a U32.
 */</comment>
<function><type><specifier>static</specifier> <name>U32</name></type> <name>HUF_buildDEltX2U32</name><parameter_list>(<parameter><decl><type><name>U32</name></type> <name>symbol</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>nbBits</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>baseSeq</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name></type> <name>seq</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUG_STATIC_ASSERT</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>HUF_DEltX2</name></expr></argument>, <argument><expr><name>sequence</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUG_STATIC_ASSERT</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>HUF_DEltX2</name></expr></argument>, <argument><expr><name>nbBits</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUG_STATIC_ASSERT</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>HUF_DEltX2</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUG_STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HUF_DEltX2</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>U32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>MEM_isLittleEndian</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>seq</name> <operator>=</operator> <ternary><condition><expr><name>level</name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name>symbol</name></expr> </then><else>: <expr><operator>(</operator><name>baseSeq</name> <operator>+</operator> <operator>(</operator><name>symbol</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
        <return>return <expr><name>seq</name> <operator>+</operator> <operator>(</operator><name>nbBits</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><name>level</name> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>seq</name> <operator>=</operator> <ternary><condition><expr><name>level</name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><operator>(</operator><name>symbol</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><name>baseSeq</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>+</operator> <name>symbol</name><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>seq</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>nbBits</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>level</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Constructs a HUF_DEltX2.
 */</comment>
<function><type><specifier>static</specifier> <name>HUF_DEltX2</name></type> <name>HUF_buildDEltX2</name><parameter_list>(<parameter><decl><type><name>U32</name></type> <name>symbol</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>nbBits</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>baseSeq</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HUF_DEltX2</name></type> <name>DElt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>val</name> <init>= <expr><call><name>HUF_buildDEltX2U32</name><argument_list>(<argument><expr><name>symbol</name></expr></argument>, <argument><expr><name>nbBits</name></expr></argument>, <argument><expr><name>baseSeq</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUG_STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DElt</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>DElt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>DElt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Constructs 2 HUF_DEltX2s and packs them into a U64.
 */</comment>
<function><type><specifier>static</specifier> <name>U64</name></type> <name>HUF_buildDEltX2U64</name><parameter_list>(<parameter><decl><type><name>U32</name></type> <name>symbol</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>nbBits</name></decl></parameter>, <parameter><decl><type><name>U16</name></type> <name>baseSeq</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name></type> <name>DElt</name> <init>= <expr><call><name>HUF_buildDEltX2U32</name><argument_list>(<argument><expr><name>symbol</name></expr></argument>, <argument><expr><name>nbBits</name></expr></argument>, <argument><expr><name>baseSeq</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><operator>(</operator><name>U64</name><operator>)</operator><name>DElt</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>U64</name><operator>)</operator><name>DElt</name> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Fills the DTable rank with all the symbols from [begin, end) that are each
 * nbBits long.
 *
 * @param DTableRank The start of the rank in the DTable.
 * @param begin The first symbol to fill (inclusive).
 * @param end The last symbol to fill (exclusive).
 * @param nbBits Each symbol is nbBits long.
 * @param tableLog The table log.
 * @param baseSeq If level == 1 { 0 } else { the first level symbol }
 * @param level The level in the table. Must be 1 or 2.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>HUF_fillDTableX2ForWeight</name><parameter_list>(
    <parameter><decl><type><name>HUF_DEltX2</name><modifier>*</modifier></type> <name>DTableRank</name></decl></parameter>,
    <parameter><decl><type><name>sortedSymbol_t</name> <specifier>const</specifier><modifier>*</modifier></type> <name>begin</name></decl></parameter>, <parameter><decl><type><name>sortedSymbol_t</name> <specifier>const</specifier><modifier>*</modifier></type> <name>end</name></decl></parameter>,
    <parameter><decl><type><name>U32</name></type> <name>nbBits</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>tableLog</name></decl></parameter>,
    <parameter><decl><type><name>U16</name></type> <name>baseSeq</name></decl></parameter>, <parameter><decl><type><name>int</name> <specifier>const</specifier></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>length</name> <init>= <expr><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <operator>(</operator><operator>(</operator><name>tableLog</name> <operator>-</operator> <name>nbBits</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x1F</literal> <comment type="block">/* quiet static-analyzer */</comment><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>sortedSymbol_t</name><modifier>*</modifier></type> <name>ptr</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>level</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>level</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name>length</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><literal type="number">1</literal></expr>:</case>
        <for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <name>begin</name></expr>;</init> <condition><expr><name>ptr</name> <operator>!=</operator> <name>end</name></expr>;</condition> <incr><expr><operator>++</operator><name>ptr</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>HUF_DEltX2</name> <specifier>const</specifier></type> <name>DElt</name> <init>= <expr><call><name>HUF_buildDEltX2</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>symbol</name></name></expr></argument>, <argument><expr><name>nbBits</name></expr></argument>, <argument><expr><name>baseSeq</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><operator>*</operator><name>DTableRank</name><operator>++</operator> <operator>=</operator> <name>DElt</name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <break>break;</break>
    <case>case <expr><literal type="number">2</literal></expr>:</case>
        <for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <name>begin</name></expr>;</init> <condition><expr><name>ptr</name> <operator>!=</operator> <name>end</name></expr>;</condition> <incr><expr><operator>++</operator><name>ptr</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>HUF_DEltX2</name> <specifier>const</specifier></type> <name>DElt</name> <init>= <expr><call><name>HUF_buildDEltX2</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>symbol</name></name></expr></argument>, <argument><expr><name>nbBits</name></expr></argument>, <argument><expr><name>baseSeq</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>DTableRank</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>DElt</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>DTableRank</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>DElt</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>DTableRank</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></for>
        <break>break;</break>
    <case>case <expr><literal type="number">4</literal></expr>:</case>
        <for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <name>begin</name></expr>;</init> <condition><expr><name>ptr</name> <operator>!=</operator> <name>end</name></expr>;</condition> <incr><expr><operator>++</operator><name>ptr</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>U64</name> <specifier>const</specifier></type> <name>DEltX2</name> <init>= <expr><call><name>HUF_buildDEltX2U64</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>symbol</name></name></expr></argument>, <argument><expr><name>nbBits</name></expr></argument>, <argument><expr><name>baseSeq</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>DTableRank</name> <operator>+</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>DEltX2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DEltX2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>DTableRank</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>DEltX2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DEltX2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>DTableRank</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        </block_content>}</block></for>
        <break>break;</break>
    <case>case <expr><literal type="number">8</literal></expr>:</case>
        <for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <name>begin</name></expr>;</init> <condition><expr><name>ptr</name> <operator>!=</operator> <name>end</name></expr>;</condition> <incr><expr><operator>++</operator><name>ptr</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>U64</name> <specifier>const</specifier></type> <name>DEltX2</name> <init>= <expr><call><name>HUF_buildDEltX2U64</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>symbol</name></name></expr></argument>, <argument><expr><name>nbBits</name></expr></argument>, <argument><expr><name>baseSeq</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>DTableRank</name> <operator>+</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>DEltX2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DEltX2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>DTableRank</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>DEltX2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DEltX2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>DTableRank</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>DEltX2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DEltX2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>DTableRank</name> <operator>+</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>DEltX2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DEltX2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>DTableRank</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
        </block_content>}</block></for>
        <break>break;</break>
    <default>default:</default>
        <for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <name>begin</name></expr>;</init> <condition><expr><name>ptr</name> <operator>!=</operator> <name>end</name></expr>;</condition> <incr><expr><operator>++</operator><name>ptr</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>U64</name> <specifier>const</specifier></type> <name>DEltX2</name> <init>= <expr><call><name>HUF_buildDEltX2U64</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>symbol</name></name></expr></argument>, <argument><expr><name>nbBits</name></expr></argument>, <argument><expr><name>baseSeq</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>HUF_DEltX2</name><modifier>*</modifier> <specifier>const</specifier></type> <name>DTableRankEnd</name> <init>= <expr><name>DTableRank</name> <operator>+</operator> <name>length</name></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init>;</init> <condition><expr><name>DTableRank</name> <operator>!=</operator> <name>DTableRankEnd</name></expr>;</condition> <incr><expr><name>DTableRank</name> <operator>+=</operator> <literal type="number">8</literal></expr></incr>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>DTableRank</name> <operator>+</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>DEltX2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DEltX2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>DTableRank</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>DEltX2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DEltX2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>DTableRank</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>DEltX2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DEltX2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>DTableRank</name> <operator>+</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>DEltX2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DEltX2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></for>
        <break>break;</break>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* HUF_fillDTableX2Level2() :
 * `rankValOrigin` must be a table of at least (HUF_TABLELOG_MAX + 1) U32 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>HUF_fillDTableX2Level2</name><parameter_list>(<parameter><decl><type><name>HUF_DEltX2</name><modifier>*</modifier></type> <name>DTable</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>targetLog</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name>consumedBits</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>U32</name><modifier>*</modifier></type> <name>rankVal</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>minWeight</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>maxWeight1</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>sortedSymbol_t</name><modifier>*</modifier></type> <name>sortedSymbols</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier><modifier>*</modifier></type> <name>rankStart</name></decl></parameter>,
                           <parameter><decl><type><name>U32</name></type> <name>nbBitsBaseline</name></decl></parameter>, <parameter><decl><type><name>U16</name></type> <name>baseSeq</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Fill skipped values (all positions up to rankVal[minWeight]).
     * These are positions only get a single symbol because the combined weight
     * is too large.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>minWeight</name><operator>&gt;</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>length</name> <init>= <expr><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <operator>(</operator><operator>(</operator><name>targetLog</name> <operator>-</operator> <name>consumedBits</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x1F</literal> <comment type="block">/* quiet static-analyzer */</comment><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U64</name> <specifier>const</specifier></type> <name>DEltX2</name> <init>= <expr><call><name>HUF_buildDEltX2U64</name><argument_list>(<argument><expr><name>baseSeq</name></expr></argument>, <argument><expr><name>consumedBits</name></expr></argument>, <comment type="block">/* baseSeq */</comment> <argument><expr><literal type="number">0</literal></expr></argument>, <comment type="block">/* level */</comment> <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>skipSize</name> <init>= <expr><name><name>rankVal</name><index>[<expr><name>minWeight</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>length</name> <operator>&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>skipSize</name> <operator>&lt;</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name>length</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><literal type="number">2</literal></expr>:</case>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>skipSize</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>DTable</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>DEltX2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DEltX2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="number">4</literal></expr>:</case>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>skipSize</name> <operator>&lt;=</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>DTable</name> <operator>+</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>DEltX2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DEltX2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>DTable</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>DEltX2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DEltX2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>skipSize</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">8</literal></expr></incr>)</control> <block>{<block_content>
                    <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>DTable</name> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>DEltX2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DEltX2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>DTable</name> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>DEltX2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DEltX2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>DTable</name> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>DEltX2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DEltX2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>DTable</name> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>DEltX2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DEltX2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block>
        </block_content>}</block></switch>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Fill each of the second level symbols by weight. */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>w</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>w</name> <operator>=</operator> <name>minWeight</name></expr>;</init> <condition><expr><name>w</name> <operator>&lt;</operator> <name>maxWeight1</name></expr>;</condition> <incr><expr><operator>++</operator><name>w</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>begin</name> <init>= <expr><name><name>rankStart</name><index>[<expr><name>w</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>end</name> <init>= <expr><name><name>rankStart</name><index>[<expr><name>w</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>nbBits</name> <init>= <expr><name>nbBitsBaseline</name> <operator>-</operator> <name>w</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>totalBits</name> <init>= <expr><name>nbBits</name> <operator>+</operator> <name>consumedBits</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>HUF_fillDTableX2ForWeight</name><argument_list>(
                <argument><expr><name>DTable</name> <operator>+</operator> <name><name>rankVal</name><index>[<expr><name>w</name></expr>]</index></name></expr></argument>,
                <argument><expr><name>sortedSymbols</name> <operator>+</operator> <name>begin</name></expr></argument>, <argument><expr><name>sortedSymbols</name> <operator>+</operator> <name>end</name></expr></argument>,
                <argument><expr><name>totalBits</name></expr></argument>, <argument><expr><name>targetLog</name></expr></argument>,
                <argument><expr><name>baseSeq</name></expr></argument>, <comment type="block">/* level */</comment> <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>HUF_fillDTableX2</name><parameter_list>(<parameter><decl><type><name>HUF_DEltX2</name><modifier>*</modifier></type> <name>DTable</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name>targetLog</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>sortedSymbol_t</name><modifier>*</modifier></type> <name>sortedList</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>U32</name><modifier>*</modifier></type> <name>rankStart</name></decl></parameter>, <parameter><decl><type><name>rankVal_t</name></type> <name>rankValOrigin</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name>maxWeight</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name>nbBitsBaseline</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>rankVal</name> <init>= <expr><name><name>rankValOrigin</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>scaleLog</name> <init>= <expr><name>nbBitsBaseline</name> <operator>-</operator> <name>targetLog</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* note : targetLog &gt;= srcLog, hence scaleLog &lt;= 1 */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>minBits</name>  <init>= <expr><name>nbBitsBaseline</name> <operator>-</operator> <name>maxWeight</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>w</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>wEnd</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name>maxWeight</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Fill DTable in order of weight. */</comment>
    <for>for <control>(<init><expr><name>w</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>w</name> <operator>&lt;</operator> <name>wEnd</name></expr>;</condition> <incr><expr><operator>++</operator><name>w</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>begin</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>rankStart</name><index>[<expr><name>w</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>end</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>rankStart</name><index>[<expr><name>w</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>nbBits</name> <init>= <expr><name>nbBitsBaseline</name> <operator>-</operator> <name>w</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>targetLog</name><operator>-</operator><name>nbBits</name> <operator>&gt;=</operator> <name>minBits</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Enough room for a second symbol. */</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>start</name> <init>= <expr><name><name>rankVal</name><index>[<expr><name>w</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>length</name> <init>= <expr><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <operator>(</operator><operator>(</operator><name>targetLog</name> <operator>-</operator> <name>nbBits</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x1F</literal> <comment type="block">/* quiet static-analyzer */</comment><operator>)</operator></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>minWeight</name> <init>= <expr><name>nbBits</name> <operator>+</operator> <name>scaleLog</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>s</name></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>minWeight</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>minWeight</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <comment type="block">/* Fill the DTable for every symbol of weight w.
             * These symbols get at least 1 second symbol.
             */</comment>
            <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>begin</name></expr>;</init> <condition><expr><name>s</name> <operator>!=</operator> <name>end</name></expr>;</condition> <incr><expr><operator>++</operator><name>s</name></expr></incr>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name>HUF_fillDTableX2Level2</name><argument_list>(
                    <argument><expr><name>DTable</name> <operator>+</operator> <name>start</name></expr></argument>, <argument><expr><name>targetLog</name></expr></argument>, <argument><expr><name>nbBits</name></expr></argument>,
                    <argument><expr><name><name>rankValOrigin</name><index>[<expr><name>nbBits</name></expr>]</index></name></expr></argument>, <argument><expr><name>minWeight</name></expr></argument>, <argument><expr><name>wEnd</name></expr></argument>,
                    <argument><expr><name>sortedList</name></expr></argument>, <argument><expr><name>rankStart</name></expr></argument>,
                    <argument><expr><name>nbBitsBaseline</name></expr></argument>, <argument><expr><name><name>sortedList</name><index>[<expr><name>s</name></expr>]</index></name><operator>.</operator><name>symbol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>start</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* Only a single symbol. */</comment>
            <expr_stmt><expr><call><name>HUF_fillDTableX2ForWeight</name><argument_list>(
                <argument><expr><name>DTable</name> <operator>+</operator> <name><name>rankVal</name><index>[<expr><name>w</name></expr>]</index></name></expr></argument>,
                <argument><expr><name>sortedList</name> <operator>+</operator> <name>begin</name></expr></argument>, <argument><expr><name>sortedList</name> <operator>+</operator> <name>end</name></expr></argument>,
                <argument><expr><name>nbBits</name></expr></argument>, <argument><expr><name>targetLog</name></expr></argument>,
                <comment type="block">/* baseSeq */</comment> <argument><expr><literal type="number">0</literal></expr></argument>, <comment type="block">/* level */</comment> <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>rankValCol_t</name></type> <name><name>rankVal</name><index>[<expr><name>HUF_TABLELOG_MAX</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name><name>rankStats</name><index>[<expr><name>HUF_TABLELOG_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name><name>rankStart0</name><index>[<expr><name>HUF_TABLELOG_MAX</name> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sortedSymbol_t</name></type> <name><name>sortedSymbol</name><index>[<expr><name>HUF_SYMBOLVALUE_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name></type> <name><name>weightList</name><index>[<expr><name>HUF_SYMBOLVALUE_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name><name>calleeWksp</name><index>[<expr><name>HUF_READ_STATS_WORKSPACE_SIZE_U32</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>HUF_ReadDTableX2_Workspace</name>;</typedef>

<function><type><name>size_t</name></type> <name>HUF_readDTableX2_wksp</name><parameter_list>(<parameter><decl><type><name>HUF_DTable</name><modifier>*</modifier></type> <name>DTable</name></decl></parameter>,
                       <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                             <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workSpace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>HUF_readDTableX2_wksp_bmi2</name><argument_list>(<argument><expr><name>DTable</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>, <comment type="block">/* bmi2 */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>HUF_readDTableX2_wksp_bmi2</name><parameter_list>(<parameter><decl><type><name>HUF_DTable</name><modifier>*</modifier></type> <name>DTable</name></decl></parameter>,
                       <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                             <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workSpace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bmi2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name></type> <name>tableLog</name></decl>, <decl><type ref="prev"/><name>maxW</name></decl>, <decl><type ref="prev"/><name>nbSymbols</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DTableDesc</name></type> <name>dtd</name> <init>= <expr><call><name>HUF_getDTableDesc</name><argument_list>(<argument><expr><name>DTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>maxTableLog</name> <init>= <expr><name><name>dtd</name><operator>.</operator><name>maxTableLog</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>iSize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>dtPtr</name> <init>= <expr><name>DTable</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* force compiler to avoid strict-aliasing */</comment>
    <decl_stmt><decl><type><name>HUF_DEltX2</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dt</name> <init>= <expr><operator>(</operator><name>HUF_DEltX2</name><operator>*</operator><operator>)</operator><name>dtPtr</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <modifier>*</modifier></type><name>rankStart</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>HUF_ReadDTableX2_Workspace</name><modifier>*</modifier> <specifier>const</specifier></type> <name>wksp</name> <init>= <expr><operator>(</operator><name>HUF_ReadDTableX2_Workspace</name><operator>*</operator><operator>)</operator><name>workSpace</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>wksp</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name>wkspSize</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>GENERIC</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>rankStart</name> <operator>=</operator> <name><name>wksp</name><operator>-&gt;</operator><name>rankStart0</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>rankStats</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>rankStats</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>rankStart0</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>rankStart0</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>DEBUG_STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HUF_DEltX2</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HUF_DTable</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* if compiler fails here, assertion is wrong */</comment>
    <if_stmt><if>if <condition>(<expr><name>maxTableLog</name> <operator>&gt;</operator> <name>HUF_TABLELOG_MAX</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>tableLog_tooLarge</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* ZSTD_memset(weightList, 0, sizeof(weightList)); */</comment>  <comment type="block">/* is not necessary, even though some analyzer complain ... */</comment>

    <expr_stmt><expr><name>iSize</name> <operator>=</operator> <call><name>HUF_readStats_wksp</name><argument_list>(<argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>weightList</name></name></expr></argument>, <argument><expr><name>HUF_SYMBOLVALUE_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>rankStats</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbSymbols</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tableLog</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>calleeWksp</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>calleeWksp</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HUF_isError</name><argument_list>(<argument><expr><name>iSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>iSize</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* check result */</comment>
    <if_stmt><if>if <condition>(<expr><name>tableLog</name> <operator>&gt;</operator> <name>maxTableLog</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>tableLog_tooLarge</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* DTable can't fit code depth */</comment>
    <if_stmt><if>if <condition>(<expr><name>tableLog</name> <operator>&lt;=</operator> <name>HUF_DECODER_FAST_TABLELOG</name> <operator>&amp;&amp;</operator> <name>maxTableLog</name> <operator>&gt;</operator> <name>HUF_DECODER_FAST_TABLELOG</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>maxTableLog</name> <operator>=</operator> <name>HUF_DECODER_FAST_TABLELOG</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* find maxWeight */</comment>
    <for>for <control>(<init><expr><name>maxW</name> <operator>=</operator> <name>tableLog</name></expr>;</init> <condition><expr><name><name>wksp</name><operator>-&gt;</operator><name>rankStats</name><index>[<expr><name>maxW</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>maxW</name><operator>--</operator></expr></incr>)</control> <block>{<block_content/>}</block></for>  <comment type="block">/* necessarily finds a solution before 0 */</comment>

    <comment type="block">/* Get start index of each weight */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>U32</name></type> <name>w</name></decl>, <decl><type ref="prev"/><name>nextRankStart</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>w</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>w</name><operator>&lt;</operator><name>maxW</name><operator>+</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>w</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>U32</name></type> <name>curr</name> <init>= <expr><name>nextRankStart</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>nextRankStart</name> <operator>+=</operator> <name><name>wksp</name><operator>-&gt;</operator><name>rankStats</name><index>[<expr><name>w</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rankStart</name><index>[<expr><name>w</name></expr>]</index></name> <operator>=</operator> <name>curr</name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>rankStart</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>nextRankStart</name></expr>;</expr_stmt>   <comment type="block">/* put all 0w symbols at the end of sorted list*/</comment>
        <expr_stmt><expr><name><name>rankStart</name><index>[<expr><name>maxW</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>nextRankStart</name></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* sort symbols by weight */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>U32</name></type> <name>s</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>s</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>s</name><operator>&lt;</operator><name>nbSymbols</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>w</name> <init>= <expr><name><name>wksp</name><operator>-&gt;</operator><name>weightList</name><index>[<expr><name>s</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>r</name> <init>= <expr><name><name>rankStart</name><index>[<expr><name>w</name></expr>]</index></name><operator>++</operator></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>wksp</name><operator>-&gt;</operator><name>sortedSymbol</name><index>[<expr><name>r</name></expr>]</index></name><operator>.</operator><name>symbol</name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><name>s</name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>rankStart</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>   <comment type="block">/* forget 0w symbols; this is beginning of weight(1) */</comment>
    </block_content>}</block>

    <comment type="block">/* Build rankVal */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>rankVal0</name> <init>= <expr><name><name>wksp</name><operator>-&gt;</operator><name>rankVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <block>{<block_content>   <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>rescale</name> <init>= <expr><operator>(</operator><name>maxTableLog</name><operator>-</operator><name>tableLog</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* tableLog &lt;= maxTableLog */</comment>
            <decl_stmt><decl><type><name>U32</name></type> <name>nextRankVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name></type> <name>w</name></decl>;</decl_stmt>
            <for>for <control>(<init><expr><name>w</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>w</name><operator>&lt;</operator><name>maxW</name><operator>+</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>w</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>U32</name></type> <name>curr</name> <init>= <expr><name>nextRankVal</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>nextRankVal</name> <operator>+=</operator> <name><name>wksp</name><operator>-&gt;</operator><name>rankStats</name><index>[<expr><name>w</name></expr>]</index></name> <operator>&lt;&lt;</operator> <operator>(</operator><name>w</name><operator>+</operator><name>rescale</name><operator>)</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>rankVal0</name><index>[<expr><name>w</name></expr>]</index></name> <operator>=</operator> <name>curr</name></expr>;</expr_stmt>
        </block_content>}</block></for>   </block_content>}</block>
        <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>minBits</name> <init>= <expr><name>tableLog</name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name>maxW</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name></type> <name>consumed</name></decl>;</decl_stmt>
            <for>for <control>(<init><expr><name>consumed</name> <operator>=</operator> <name>minBits</name></expr>;</init> <condition><expr><name>consumed</name> <operator>&lt;</operator> <name>maxTableLog</name> <operator>-</operator> <name>minBits</name> <operator>+</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>consumed</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>rankValPtr</name> <init>= <expr><name><name>wksp</name><operator>-&gt;</operator><name>rankVal</name><index>[<expr><name>consumed</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>U32</name></type> <name>w</name></decl>;</decl_stmt>
                <for>for <control>(<init><expr><name>w</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>w</name> <operator>&lt;</operator> <name>maxW</name><operator>+</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>w</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <expr_stmt><expr><name><name>rankValPtr</name><index>[<expr><name>w</name></expr>]</index></name> <operator>=</operator> <name><name>rankVal0</name><index>[<expr><name>w</name></expr>]</index></name> <operator>&gt;&gt;</operator> <name>consumed</name></expr>;</expr_stmt>
    </block_content>}</block></for>   </block_content>}</block></for>   </block_content>}</block>   </block_content>}</block>

    <expr_stmt><expr><call><name>HUF_fillDTableX2</name><argument_list>(<argument><expr><name>dt</name></expr></argument>, <argument><expr><name>maxTableLog</name></expr></argument>,
                   <argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>sortedSymbol</name></name></expr></argument>,
                   <argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>rankStart0</name></name></expr></argument>, <argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>rankVal</name></name></expr></argument>, <argument><expr><name>maxW</name></expr></argument>,
                   <argument><expr><name>tableLog</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>dtd</name><operator>.</operator><name>tableLog</name></name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><name>maxTableLog</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dtd</name><operator>.</operator><name>tableType</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>DTable</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dtd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dtd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>iSize</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>U32</name></type>
<name>HUF_decodeSymbolX2</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>BIT_DStream_t</name><modifier>*</modifier></type> <name>DStream</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>HUF_DEltX2</name><modifier>*</modifier></type> <name>dt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dtLog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>val</name> <init>= <expr><call><name>BIT_lookBitsFast</name><argument_list>(<argument><expr><name>DStream</name></expr></argument>, <argument><expr><name>dtLog</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>   <comment type="block">/* note : dtLog &gt;= 1 */</comment>
    <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dt</name><index>[<expr><name>val</name></expr>]</index></name><operator>.</operator><name>sequence</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BIT_skipBits</name><argument_list>(<argument><expr><name>DStream</name></expr></argument>, <argument><expr><name><name>dt</name><index>[<expr><name>val</name></expr>]</index></name><operator>.</operator><name>nbBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>dt</name><index>[<expr><name>val</name></expr>]</index></name><operator>.</operator><name>length</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>U32</name></type>
<name>HUF_decodeLastSymbolX2</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>BIT_DStream_t</name><modifier>*</modifier></type> <name>DStream</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>HUF_DEltX2</name><modifier>*</modifier></type> <name>dt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dtLog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>val</name> <init>= <expr><call><name>BIT_lookBitsFast</name><argument_list>(<argument><expr><name>DStream</name></expr></argument>, <argument><expr><name>dtLog</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>   <comment type="block">/* note : dtLog &gt;= 1 */</comment>
    <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dt</name><index>[<expr><name>val</name></expr>]</index></name><operator>.</operator><name>sequence</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>dt</name><index>[<expr><name>val</name></expr>]</index></name><operator>.</operator><name>length</name><operator>==</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>BIT_skipBits</name><argument_list>(<argument><expr><name>DStream</name></expr></argument>, <argument><expr><name><name>dt</name><index>[<expr><name>val</name></expr>]</index></name><operator>.</operator><name>nbBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>DStream</name><operator>-&gt;</operator><name>bitsConsumed</name></name> <operator>&lt;</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>DStream</name><operator>-&gt;</operator><name>bitContainer</name></name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">8</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>BIT_skipBits</name><argument_list>(<argument><expr><name>DStream</name></expr></argument>, <argument><expr><name><name>dt</name><index>[<expr><name>val</name></expr>]</index></name><operator>.</operator><name>nbBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>DStream</name><operator>-&gt;</operator><name>bitsConsumed</name></name> <operator>&gt;</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>DStream</name><operator>-&gt;</operator><name>bitContainer</name></name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">8</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <comment type="block">/* ugly hack; works only because it's the last symbol. Note : can't easily extract nbBits from just this symbol */</comment>
                <expr_stmt><expr><name><name>DStream</name><operator>-&gt;</operator><name>bitsConsumed</name></name> <operator>=</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>DStream</name><operator>-&gt;</operator><name>bitContainer</name></name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_DECODE_SYMBOLX2_0</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>DStreamPtr</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>ptr += HUF_decodeSymbolX2(ptr, DStreamPtr, dt, dtLog)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_DECODE_SYMBOLX2_1</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>DStreamPtr</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>if (MEM_64bits() || (HUF_TABLELOG_MAX&lt;=12)) \
        ptr += HUF_decodeSymbolX2(ptr, DStreamPtr, dt, dtLog)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_DECODE_SYMBOLX2_2</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>DStreamPtr</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>if (MEM_64bits()) \
        ptr += HUF_decodeSymbolX2(ptr, DStreamPtr, dt, dtLog)</cpp:value></cpp:define>

<function><type><name>HINT_INLINE</name> <name>size_t</name></type>
<name>HUF_decodeStreamX2</name><parameter_list>(<parameter><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>BIT_DStream_t</name><modifier>*</modifier></type> <name>bitDPtr</name></decl></parameter>, <parameter><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>pEnd</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>HUF_DEltX2</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dtLog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>pStart</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* up to 8 symbols at a time */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>pEnd</name> <operator>-</operator> <name>p</name><operator>)</operator> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>bitDPtr</name><operator>-&gt;</operator><name>bitContainer</name></name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>dtLog</name> <operator>&lt;=</operator> <literal type="number">11</literal> <operator>&amp;&amp;</operator> <call><name>MEM_64bits</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="block">/* up to 10 symbols at a time */</comment>
            <while>while <condition>(<expr><operator>(</operator><call><name>BIT_reloadDStream</name><argument_list>(<argument><expr><name>bitDPtr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BIT_DStream_unfinished</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>p</name> <operator>&lt;</operator> <name>pEnd</name><operator>-</operator><literal type="number">9</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_0</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bitDPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_0</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bitDPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_0</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bitDPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_0</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bitDPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_0</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bitDPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* up to 8 symbols at a time */</comment>
            <while>while <condition>(<expr><operator>(</operator><call><name>BIT_reloadDStream</name><argument_list>(<argument><expr><name>bitDPtr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BIT_DStream_unfinished</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>p</name> <operator>&lt;</operator> <name>pEnd</name><operator>-</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>bitDPtr</name><operator>-&gt;</operator><name>bitContainer</name></name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_2</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bitDPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_1</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bitDPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_2</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bitDPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_0</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bitDPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>BIT_reloadDStream</name><argument_list>(<argument><expr><name>bitDPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* closer to end : up to 2 symbols at a time */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>pEnd</name> <operator>-</operator> <name>p</name><operator>)</operator> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <while>while <condition>(<expr><operator>(</operator><call><name>BIT_reloadDStream</name><argument_list>(<argument><expr><name>bitDPtr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BIT_DStream_unfinished</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>p</name> <operator>&lt;=</operator> <name>pEnd</name><operator>-</operator><literal type="number">2</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_0</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bitDPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

        <while>while <condition>(<expr><name>p</name> <operator>&lt;=</operator> <name>pEnd</name><operator>-</operator><literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_0</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bitDPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>   <comment type="block">/* no need to reload : reached the end of DStream */</comment>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>pEnd</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>HUF_decodeLastSymbolX2</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bitDPtr</name></expr></argument>, <argument><expr><name>dt</name></expr></argument>, <argument><expr><name>dtLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>p</name><operator>-</operator><name>pStart</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>size_t</name></type>
<name>HUF_decompress1X2_usingDTable_internal_body</name><parameter_list>(
          <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>,  <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>HUF_DTable</name><modifier>*</modifier></type> <name>DTable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BIT_DStream_t</name></type> <name>bitD</name></decl>;</decl_stmt>

    <comment type="block">/* Init */</comment>
    <expr_stmt><expr><call><name>CHECK_F</name><argument_list>( <argument><expr><call><name>BIT_initDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitD</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* decode */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ostart</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator> <name>dst</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend</name> <init>= <expr><name>ostart</name> <operator>+</operator> <name>dstSize</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dtPtr</name> <init>= <expr><name>DTable</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* force compiler to not use strict-aliasing */</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>HUF_DEltX2</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dt</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>HUF_DEltX2</name><operator>*</operator><operator>)</operator><name>dtPtr</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>DTableDesc</name> <specifier>const</specifier></type> <name>dtd</name> <init>= <expr><call><name>HUF_getDTableDesc</name><argument_list>(<argument><expr><name>DTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>HUF_decodeStreamX2</name><argument_list>(<argument><expr><name>ostart</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>, <argument><expr><name>dt</name></expr></argument>, <argument><expr><name><name>dtd</name><operator>.</operator><name>tableLog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* check */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BIT_endOfDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitD</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>corruption_detected</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* decoded size */</comment>
    <return>return <expr><name>dstSize</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>size_t</name></type>
<name>HUF_decompress4X2_usingDTable_internal_body</name><parameter_list>(
          <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>,  <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>HUF_DTable</name><modifier>*</modifier></type> <name>DTable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>cSrcSize</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>corruption_detected</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* strict minimum : jump table + 1 byte per stream */</comment>

    <block>{<block_content>   <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>istart</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator> <name>cSrc</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ostart</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator> <name>dst</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend</name> <init>= <expr><name>ostart</name> <operator>+</operator> <name>dstSize</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>olimit</name> <init>= <expr><name>oend</name> <operator>-</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dtPtr</name> <init>= <expr><name>DTable</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>HUF_DEltX2</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dt</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>HUF_DEltX2</name><operator>*</operator><operator>)</operator><name>dtPtr</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Init */</comment>
        <decl_stmt><decl><type><name>BIT_DStream_t</name></type> <name>bitD1</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BIT_DStream_t</name></type> <name>bitD2</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BIT_DStream_t</name></type> <name>bitD3</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BIT_DStream_t</name></type> <name>bitD4</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>length1</name> <init>= <expr><call><name>MEM_readLE16</name><argument_list>(<argument><expr><name>istart</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>length2</name> <init>= <expr><call><name>MEM_readLE16</name><argument_list>(<argument><expr><name>istart</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>length3</name> <init>= <expr><call><name>MEM_readLE16</name><argument_list>(<argument><expr><name>istart</name><operator>+</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>length4</name> <init>= <expr><name>cSrcSize</name> <operator>-</operator> <operator>(</operator><name>length1</name> <operator>+</operator> <name>length2</name> <operator>+</operator> <name>length3</name> <operator>+</operator> <literal type="number">6</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>istart1</name> <init>= <expr><name>istart</name> <operator>+</operator> <literal type="number">6</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* jumpTable */</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>istart2</name> <init>= <expr><name>istart1</name> <operator>+</operator> <name>length1</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>istart3</name> <init>= <expr><name>istart2</name> <operator>+</operator> <name>length2</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>istart4</name> <init>= <expr><name>istart3</name> <operator>+</operator> <name>length3</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>segmentSize</name> <init>= <expr><operator>(</operator><name>dstSize</name><operator>+</operator><literal type="number">3</literal><operator>)</operator> <operator>/</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>opStart2</name> <init>= <expr><name>ostart</name> <operator>+</operator> <name>segmentSize</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>opStart3</name> <init>= <expr><name>opStart2</name> <operator>+</operator> <name>segmentSize</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>opStart4</name> <init>= <expr><name>opStart3</name> <operator>+</operator> <name>segmentSize</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op1</name> <init>= <expr><name>ostart</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op2</name> <init>= <expr><name>opStart2</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op3</name> <init>= <expr><name>opStart3</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op4</name> <init>= <expr><name>opStart4</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name></type> <name>endSignal</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>DTableDesc</name> <specifier>const</specifier></type> <name>dtd</name> <init>= <expr><call><name>HUF_getDTableDesc</name><argument_list>(<argument><expr><name>DTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>dtLog</name> <init>= <expr><name><name>dtd</name><operator>.</operator><name>tableLog</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>length4</name> <operator>&gt;</operator> <name>cSrcSize</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>corruption_detected</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* overflow */</comment>
        <if_stmt><if>if <condition>(<expr><name>opStart4</name> <operator>&gt;</operator> <name>oend</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>corruption_detected</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>      <comment type="block">/* overflow */</comment>
        <expr_stmt><expr><call><name>CHECK_F</name><argument_list>( <argument><expr><call><name>BIT_initDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitD1</name></expr></argument>, <argument><expr><name>istart1</name></expr></argument>, <argument><expr><name>length1</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CHECK_F</name><argument_list>( <argument><expr><call><name>BIT_initDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitD2</name></expr></argument>, <argument><expr><name>istart2</name></expr></argument>, <argument><expr><name>length2</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CHECK_F</name><argument_list>( <argument><expr><call><name>BIT_initDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitD3</name></expr></argument>, <argument><expr><name>istart3</name></expr></argument>, <argument><expr><name>length3</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CHECK_F</name><argument_list>( <argument><expr><call><name>BIT_initDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitD4</name></expr></argument>, <argument><expr><name>istart4</name></expr></argument>, <argument><expr><name>length4</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* 16-32 symbols per loop (4-8 symbols per stream) */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name> <operator>-</operator> <name>op4</name><operator>)</operator> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
            <for>for <control>( <init>;</init> <condition><expr><operator>(</operator><name>endSignal</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>op4</name> <operator>&lt;</operator> <name>olimit</name><operator>)</operator></expr>;</condition> <incr/>)</control> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__x86_64__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__i386__</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_2</name><argument_list>(<argument><expr><name>op1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_1</name><argument_list>(<argument><expr><name>op1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_2</name><argument_list>(<argument><expr><name>op1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_0</name><argument_list>(<argument><expr><name>op1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_2</name><argument_list>(<argument><expr><name>op2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_1</name><argument_list>(<argument><expr><name>op2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_2</name><argument_list>(<argument><expr><name>op2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_0</name><argument_list>(<argument><expr><name>op2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>endSignal</name> <operator>&amp;=</operator> <call><name>BIT_reloadDStreamFast</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitD1</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BIT_DStream_unfinished</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>endSignal</name> <operator>&amp;=</operator> <call><name>BIT_reloadDStreamFast</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitD2</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BIT_DStream_unfinished</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_2</name><argument_list>(<argument><expr><name>op3</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_1</name><argument_list>(<argument><expr><name>op3</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_2</name><argument_list>(<argument><expr><name>op3</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_0</name><argument_list>(<argument><expr><name>op3</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_2</name><argument_list>(<argument><expr><name>op4</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_1</name><argument_list>(<argument><expr><name>op4</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_2</name><argument_list>(<argument><expr><name>op4</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_0</name><argument_list>(<argument><expr><name>op4</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>endSignal</name> <operator>&amp;=</operator> <call><name>BIT_reloadDStreamFast</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitD3</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BIT_DStream_unfinished</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>endSignal</name> <operator>&amp;=</operator> <call><name>BIT_reloadDStreamFast</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitD4</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BIT_DStream_unfinished</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_2</name><argument_list>(<argument><expr><name>op1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_2</name><argument_list>(<argument><expr><name>op2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_2</name><argument_list>(<argument><expr><name>op3</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_2</name><argument_list>(<argument><expr><name>op4</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_1</name><argument_list>(<argument><expr><name>op1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_1</name><argument_list>(<argument><expr><name>op2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_1</name><argument_list>(<argument><expr><name>op3</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_1</name><argument_list>(<argument><expr><name>op4</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_2</name><argument_list>(<argument><expr><name>op1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_2</name><argument_list>(<argument><expr><name>op2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_2</name><argument_list>(<argument><expr><name>op3</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_2</name><argument_list>(<argument><expr><name>op4</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_0</name><argument_list>(<argument><expr><name>op1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_0</name><argument_list>(<argument><expr><name>op2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_0</name><argument_list>(<argument><expr><name>op3</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HUF_DECODE_SYMBOLX2_0</name><argument_list>(<argument><expr><name>op4</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>endSignal</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><call><name>LIKELY</name><argument_list>(<argument><expr><operator>(</operator><name>U32</name><operator>)</operator>
                            <operator>(</operator><call><name>BIT_reloadDStreamFast</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitD1</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BIT_DStream_unfinished</name><operator>)</operator>
                        <operator>&amp;</operator> <operator>(</operator><call><name>BIT_reloadDStreamFast</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitD2</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BIT_DStream_unfinished</name><operator>)</operator>
                        <operator>&amp;</operator> <operator>(</operator><call><name>BIT_reloadDStreamFast</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitD3</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BIT_DStream_unfinished</name><operator>)</operator>
                        <operator>&amp;</operator> <operator>(</operator><call><name>BIT_reloadDStreamFast</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitD4</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BIT_DStream_unfinished</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* check corruption */</comment>
        <if_stmt><if>if <condition>(<expr><name>op1</name> <operator>&gt;</operator> <name>opStart2</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>corruption_detected</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>op2</name> <operator>&gt;</operator> <name>opStart3</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>corruption_detected</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>op3</name> <operator>&gt;</operator> <name>opStart4</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>corruption_detected</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <comment type="block">/* note : op4 already verified within main loop */</comment>

        <comment type="block">/* finish bitStreams one by one */</comment>
        <expr_stmt><expr><call><name>HUF_decodeStreamX2</name><argument_list>(<argument><expr><name>op1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD1</name></expr></argument>, <argument><expr><name>opStart2</name></expr></argument>, <argument><expr><name>dt</name></expr></argument>, <argument><expr><name>dtLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>HUF_decodeStreamX2</name><argument_list>(<argument><expr><name>op2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD2</name></expr></argument>, <argument><expr><name>opStart3</name></expr></argument>, <argument><expr><name>dt</name></expr></argument>, <argument><expr><name>dtLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>HUF_decodeStreamX2</name><argument_list>(<argument><expr><name>op3</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD3</name></expr></argument>, <argument><expr><name>opStart4</name></expr></argument>, <argument><expr><name>dt</name></expr></argument>, <argument><expr><name>dtLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>HUF_decodeStreamX2</name><argument_list>(<argument><expr><name>op4</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bitD4</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>,     <argument><expr><name>dt</name></expr></argument>, <argument><expr><name>dtLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* check */</comment>
        <block>{<block_content> <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>endCheck</name> <init>= <expr><call><name>BIT_endOfDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitD1</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <call><name>BIT_endOfDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitD2</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <call><name>BIT_endOfDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitD3</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <call><name>BIT_endOfDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitD4</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><name>endCheck</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>corruption_detected</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt> </block_content>}</block>

        <comment type="block">/* decoded size */</comment>
        <return>return <expr><name>dstSize</name></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HUF_NEED_BMI2_FUNCTION</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>BMI2_TARGET_ATTRIBUTE</name>
<name>size_t</name></type> <name>HUF_decompress4X2_usingDTable_internal_bmi2</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>, <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>,
                    <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>, <parameter><decl><type><name>HUF_DTable</name> <specifier>const</specifier><modifier>*</modifier></type> <name>DTable</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>HUF_decompress4X2_usingDTable_internal_body</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HUF_NEED_DEFAULT_FUNCTION</name></expr></cpp:if>
<function><type><specifier>static</specifier>
<name>size_t</name></type> <name>HUF_decompress4X2_usingDTable_internal_default</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>, <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>,
                    <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>, <parameter><decl><type><name>HUF_DTable</name> <specifier>const</specifier><modifier>*</modifier></type> <name>DTable</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>HUF_decompress4X2_usingDTable_internal_body</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ZSTD_ENABLE_ASM_X86_64_BMI2</name></expr></cpp:if>

<decl_stmt><decl><type><name>HUF_ASM_DECL</name> <name>void</name></type> <name>HUF_decompress4X2_usingDTable_internal_bmi2_asm_loop</name><argument_list>(<argument><expr><name>HUF_DecompressAsmArgs</name><operator>*</operator> <name>args</name></expr></argument>)</argument_list> <name>ZSTDLIB_HIDDEN</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>HUF_ASM_X86_64_BMI2_ATTRS</name> <name>size_t</name></type>
<name>HUF_decompress4X2_usingDTable_internal_bmi2_asm</name><parameter_list>(
          <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>,  <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>HUF_DTable</name><modifier>*</modifier></type> <name>DTable</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>dt</name> <init>= <expr><name>DTable</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>cSrc</name> <operator>+</operator> <literal type="number">6</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name> <operator>+</operator> <name>dstSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HUF_DecompressAsmArgs</name></type> <name>args</name></decl>;</decl_stmt>
    <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>ret</name> <init>= <expr><call><name>HUF_DecompressAsmArgs_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"Failed to init asm args"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>HUF_decompress4X2_usingDTable_internal_bmi2</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>args</name><operator>.</operator><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <name><name>args</name><operator>.</operator><name>ilimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HUF_decompress4X2_usingDTable_internal_bmi2_asm_loop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* note : op4 already verified within main loop */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>args</name><operator>.</operator><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <name>iend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>args</name><operator>.</operator><name>ip</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;=</operator> <name>iend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>args</name><operator>.</operator><name>ip</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&gt;=</operator> <name>iend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>args</name><operator>.</operator><name>ip</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&gt;=</operator> <name>iend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>args</name><operator>.</operator><name>op</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&lt;=</operator> <name>oend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>iend</name></expr>;</expr_stmt>

    <comment type="block">/* finish bitStreams one by one */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>segmentSize</name> <init>= <expr><operator>(</operator><name>dstSize</name><operator>+</operator><literal type="number">3</literal><operator>)</operator> <operator>/</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>segmentEnd</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>BIT_DStream_t</name></type> <name>bit</name></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>segmentSize</name> <operator>&lt;=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name> <operator>-</operator> <name>segmentEnd</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>segmentEnd</name> <operator>+=</operator> <name>segmentSize</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>segmentEnd</name> <operator>=</operator> <name>oend</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>HUF_initRemainingDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>segmentEnd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"corruption"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>args</name><operator>.</operator><name>op</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+=</operator> <call><name>HUF_decodeStreamX2</name><argument_list>(<argument><expr><name><name>args</name><operator>.</operator><name>op</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bit</name></expr></argument>, <argument><expr><name>segmentEnd</name></expr></argument>, <argument><expr><operator>(</operator><name>HUF_DEltX2</name> <specifier>const</specifier><operator>*</operator><operator>)</operator><name>dt</name></expr></argument>, <argument><expr><name>HUF_DECODER_FAST_TABLELOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>args</name><operator>.</operator><name>op</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>segmentEnd</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>corruption_detected</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block>

    <comment type="block">/* decoded size */</comment>
    <return>return <expr><name>dstSize</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ZSTD_ENABLE_ASM_X86_64_BMI2 */</comment>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>HUF_decompress4X2_usingDTable_internal</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>, <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>,
                    <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>, <parameter><decl><type><name>HUF_DTable</name> <specifier>const</specifier><modifier>*</modifier></type> <name>DTable</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bmi2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DYNAMIC_BMI2</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name>bmi2</name></expr>)</condition> <block>{<block_content>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><name>ZSTD_ENABLE_ASM_X86_64_BMI2</name></expr></cpp:if>
        <return>return <expr><call><name>HUF_decompress4X2_usingDTable_internal_bmi2_asm</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
        <return>return <expr><call><name>HUF_decompress4X2_usingDTable_internal_bmi2</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>bmi2</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ZSTD_ENABLE_ASM_X86_64_BMI2</name> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__BMI2__</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <return>return <expr><call><name>HUF_decompress4X2_usingDTable_internal_bmi2_asm</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr><call><name>HUF_decompress4X2_usingDTable_internal_default</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<macro><name>HUF_DGEN</name><argument_list>(<argument>HUF_decompress1X2_usingDTable_internal</argument>)</argument_list></macro>

<function><type><name>size_t</name></type> <name>HUF_decompress1X2_usingDTable</name><parameter_list>(
          <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>,  <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>HUF_DTable</name><modifier>*</modifier></type> <name>DTable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DTableDesc</name></type> <name>dtd</name> <init>= <expr><call><name>HUF_getDTableDesc</name><argument_list>(<argument><expr><name>DTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>dtd</name><operator>.</operator><name>tableType</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>GENERIC</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>HUF_decompress1X2_usingDTable_internal</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>, <comment type="block">/* bmi2 */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>HUF_decompress1X2_DCtx_wksp</name><parameter_list>(<parameter><decl><type><name>HUF_DTable</name><modifier>*</modifier></type> <name>DCtx</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>,
                                   <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workSpace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator> <name>cSrc</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>hSize</name> <init>= <expr><call><name>HUF_readDTableX2_wksp</name><argument_list>(<argument><expr><name>DCtx</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>,
                                               <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HUF_isError</name><argument_list>(<argument><expr><name>hSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>hSize</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>hSize</name> <operator>&gt;=</operator> <name>cSrcSize</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>srcSize_wrong</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>hSize</name></expr>;</expr_stmt> <expr_stmt><expr><name>cSrcSize</name> <operator>-=</operator> <name>hSize</name></expr>;</expr_stmt>

    <return>return <expr><call><name>HUF_decompress1X2_usingDTable_internal</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DCtx</name></expr></argument>, <comment type="block">/* bmi2 */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>size_t</name></type> <name>HUF_decompress4X2_usingDTable</name><parameter_list>(
          <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>,  <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>HUF_DTable</name><modifier>*</modifier></type> <name>DTable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DTableDesc</name></type> <name>dtd</name> <init>= <expr><call><name>HUF_getDTableDesc</name><argument_list>(<argument><expr><name>DTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>dtd</name><operator>.</operator><name>tableType</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>GENERIC</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>HUF_decompress4X2_usingDTable_internal</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>, <comment type="block">/* bmi2 */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>HUF_decompress4X2_DCtx_wksp_bmi2</name><parameter_list>(<parameter><decl><type><name>HUF_DTable</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>,
                                   <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workSpace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bmi2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator> <name>cSrc</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>size_t</name></type> <name>hSize</name> <init>= <expr><call><name>HUF_readDTableX2_wksp</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>,
                                         <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HUF_isError</name><argument_list>(<argument><expr><name>hSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>hSize</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>hSize</name> <operator>&gt;=</operator> <name>cSrcSize</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>srcSize_wrong</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>hSize</name></expr>;</expr_stmt> <expr_stmt><expr><name>cSrcSize</name> <operator>-=</operator> <name>hSize</name></expr>;</expr_stmt>

    <return>return <expr><call><name>HUF_decompress4X2_usingDTable_internal</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>HUF_decompress4X2_DCtx_wksp</name><parameter_list>(<parameter><decl><type><name>HUF_DTable</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>,
                                   <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workSpace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>HUF_decompress4X2_DCtx_wksp_bmi2</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>, <comment type="block">/* bmi2 */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HUF_FORCE_DECOMPRESS_X1 */</comment>


<comment type="block">/* ***********************************/</comment>
<comment type="block">/* Universal decompression selectors */</comment>
<comment type="block">/* ***********************************/</comment>

<function><type><name>size_t</name></type> <name>HUF_decompress1X_usingDTable</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>maxDstSize</name></decl></parameter>,
                                    <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>,
                                    <parameter><decl><type><specifier>const</specifier> <name>HUF_DTable</name><modifier>*</modifier></type> <name>DTable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DTableDesc</name> <specifier>const</specifier></type> <name>dtd</name> <init>= <expr><call><name>HUF_getDTableDesc</name><argument_list>(<argument><expr><name>DTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HUF_FORCE_DECOMPRESS_X1</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>dtd</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dtd</name><operator>.</operator><name>tableType</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>HUF_decompress1X1_usingDTable_internal</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>, <comment type="block">/* bmi2 */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HUF_FORCE_DECOMPRESS_X2</name></expr></argument>)</argument_list></call></expr></cpp:elif>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>dtd</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dtd</name><operator>.</operator><name>tableType</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>HUF_decompress1X2_usingDTable_internal</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>, <comment type="block">/* bmi2 */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr><ternary><condition><expr><name><name>dtd</name><operator>.</operator><name>tableType</name></name></expr> ?</condition><then> <expr><call><name>HUF_decompress1X2_usingDTable_internal</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>, <comment type="block">/* bmi2 */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>:
                           <expr><call><name>HUF_decompress1X1_usingDTable_internal</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>, <comment type="block">/* bmi2 */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>HUF_decompress4X_usingDTable</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>maxDstSize</name></decl></parameter>,
                                    <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>,
                                    <parameter><decl><type><specifier>const</specifier> <name>HUF_DTable</name><modifier>*</modifier></type> <name>DTable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DTableDesc</name> <specifier>const</specifier></type> <name>dtd</name> <init>= <expr><call><name>HUF_getDTableDesc</name><argument_list>(<argument><expr><name>DTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HUF_FORCE_DECOMPRESS_X1</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>dtd</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dtd</name><operator>.</operator><name>tableType</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>HUF_decompress4X1_usingDTable_internal</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>, <comment type="block">/* bmi2 */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HUF_FORCE_DECOMPRESS_X2</name></expr></argument>)</argument_list></call></expr></cpp:elif>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>dtd</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dtd</name><operator>.</operator><name>tableType</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>HUF_decompress4X2_usingDTable_internal</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>, <comment type="block">/* bmi2 */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr><ternary><condition><expr><name><name>dtd</name><operator>.</operator><name>tableType</name></name></expr> ?</condition><then> <expr><call><name>HUF_decompress4X2_usingDTable_internal</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>, <comment type="block">/* bmi2 */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>:
                           <expr><call><name>HUF_decompress4X1_usingDTable_internal</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>, <comment type="block">/* bmi2 */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HUF_FORCE_DECOMPRESS_X1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HUF_FORCE_DECOMPRESS_X2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<typedef>typedef <type><struct>struct <block>{ <decl_stmt><decl><type><name>U32</name></type> <name>tableTime</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>U32</name></type> <name>decode256Time</name></decl>;</decl_stmt> }</block></struct></type> <name>algo_time_t</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>algo_time_t</name></type> <name><name>algoTime</name><index>[<expr><literal type="number">16</literal></expr> <comment type="block">/* Quantization */</comment>]</index><index>[<expr><literal type="number">2</literal></expr> <comment type="block">/* single, double */</comment>]</index></name> <init>=
<expr><block>{
    <comment type="block">/* single, double, quad */</comment>
    <expr><block>{<expr><block>{<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>}</block></expr>}</block></expr>,  <comment type="block">/* Q==0 : impossible */</comment>
    <expr><block>{<expr><block>{<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>}</block></expr>}</block></expr>,  <comment type="block">/* Q==1 : impossible */</comment>
    <expr><block>{<expr><block>{ <expr><literal type="number">150</literal></expr>,<expr><literal type="number">216</literal></expr>}</block></expr>, <expr><block>{ <expr><literal type="number">381</literal></expr>,<expr><literal type="number">119</literal></expr>}</block></expr>}</block></expr>,   <comment type="block">/* Q == 2 : 12-18% */</comment>
    <expr><block>{<expr><block>{ <expr><literal type="number">170</literal></expr>,<expr><literal type="number">205</literal></expr>}</block></expr>, <expr><block>{ <expr><literal type="number">514</literal></expr>,<expr><literal type="number">112</literal></expr>}</block></expr>}</block></expr>,   <comment type="block">/* Q == 3 : 18-25% */</comment>
    <expr><block>{<expr><block>{ <expr><literal type="number">177</literal></expr>,<expr><literal type="number">199</literal></expr>}</block></expr>, <expr><block>{ <expr><literal type="number">539</literal></expr>,<expr><literal type="number">110</literal></expr>}</block></expr>}</block></expr>,   <comment type="block">/* Q == 4 : 25-32% */</comment>
    <expr><block>{<expr><block>{ <expr><literal type="number">197</literal></expr>,<expr><literal type="number">194</literal></expr>}</block></expr>, <expr><block>{ <expr><literal type="number">644</literal></expr>,<expr><literal type="number">107</literal></expr>}</block></expr>}</block></expr>,   <comment type="block">/* Q == 5 : 32-38% */</comment>
    <expr><block>{<expr><block>{ <expr><literal type="number">221</literal></expr>,<expr><literal type="number">192</literal></expr>}</block></expr>, <expr><block>{ <expr><literal type="number">735</literal></expr>,<expr><literal type="number">107</literal></expr>}</block></expr>}</block></expr>,   <comment type="block">/* Q == 6 : 38-44% */</comment>
    <expr><block>{<expr><block>{ <expr><literal type="number">256</literal></expr>,<expr><literal type="number">189</literal></expr>}</block></expr>, <expr><block>{ <expr><literal type="number">881</literal></expr>,<expr><literal type="number">106</literal></expr>}</block></expr>}</block></expr>,   <comment type="block">/* Q == 7 : 44-50% */</comment>
    <expr><block>{<expr><block>{ <expr><literal type="number">359</literal></expr>,<expr><literal type="number">188</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">1167</literal></expr>,<expr><literal type="number">109</literal></expr>}</block></expr>}</block></expr>,   <comment type="block">/* Q == 8 : 50-56% */</comment>
    <expr><block>{<expr><block>{ <expr><literal type="number">582</literal></expr>,<expr><literal type="number">187</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">1570</literal></expr>,<expr><literal type="number">114</literal></expr>}</block></expr>}</block></expr>,   <comment type="block">/* Q == 9 : 56-62% */</comment>
    <expr><block>{<expr><block>{ <expr><literal type="number">688</literal></expr>,<expr><literal type="number">187</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">1712</literal></expr>,<expr><literal type="number">122</literal></expr>}</block></expr>}</block></expr>,   <comment type="block">/* Q ==10 : 62-69% */</comment>
    <expr><block>{<expr><block>{ <expr><literal type="number">825</literal></expr>,<expr><literal type="number">186</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">1965</literal></expr>,<expr><literal type="number">136</literal></expr>}</block></expr>}</block></expr>,   <comment type="block">/* Q ==11 : 69-75% */</comment>
    <expr><block>{<expr><block>{ <expr><literal type="number">976</literal></expr>,<expr><literal type="number">185</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">2131</literal></expr>,<expr><literal type="number">150</literal></expr>}</block></expr>}</block></expr>,   <comment type="block">/* Q ==12 : 75-81% */</comment>
    <expr><block>{<expr><block>{<expr><literal type="number">1180</literal></expr>,<expr><literal type="number">186</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">2070</literal></expr>,<expr><literal type="number">175</literal></expr>}</block></expr>}</block></expr>,   <comment type="block">/* Q ==13 : 81-87% */</comment>
    <expr><block>{<expr><block>{<expr><literal type="number">1377</literal></expr>,<expr><literal type="number">185</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">1731</literal></expr>,<expr><literal type="number">202</literal></expr>}</block></expr>}</block></expr>,   <comment type="block">/* Q ==14 : 87-93% */</comment>
    <expr><block>{<expr><block>{<expr><literal type="number">1412</literal></expr>,<expr><literal type="number">185</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">1695</literal></expr>,<expr><literal type="number">202</literal></expr>}</block></expr>}</block></expr>,   <comment type="block">/* Q ==15 : 93-99% */</comment>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/** HUF_selectDecoder() :
 *  Tells which decoder is likely to decode faster,
 *  based on a set of pre-computed metrics.
 * @return : 0==HUF_decompress4X1, 1==HUF_decompress4X2 .
 *  Assumption : 0 &lt; dstSize &lt;= 128 KB */</comment>
<function><type><name>U32</name></type> <name>HUF_selectDecoder</name> <parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dstSize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dstSize</name> <operator>&lt;=</operator> <literal type="number">128</literal><operator>*</operator><literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HUF_FORCE_DECOMPRESS_X1</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>dstSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>cSrcSize</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HUF_FORCE_DECOMPRESS_X2</name></expr></argument>)</argument_list></call></expr></cpp:elif>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>dstSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>cSrcSize</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* decoder timing evaluation */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>Q</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>cSrcSize</name> <operator>&gt;=</operator> <name>dstSize</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">15</literal></expr> </then><else>: <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>cSrcSize</name> <operator>*</operator> <literal type="number">16</literal> <operator>/</operator> <name>dstSize</name><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>   <comment type="block">/* Q &lt; 16 */</comment>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>D256</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>dstSize</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>DTime0</name> <init>= <expr><name><name>algoTime</name><index>[<expr><name>Q</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tableTime</name> <operator>+</operator> <operator>(</operator><name><name>algoTime</name><index>[<expr><name>Q</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>decode256Time</name> <operator>*</operator> <name>D256</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name></type> <name>DTime1</name> <init>= <expr><name><name>algoTime</name><index>[<expr><name>Q</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>tableTime</name> <operator>+</operator> <operator>(</operator><name><name>algoTime</name><index>[<expr><name>Q</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>decode256Time</name> <operator>*</operator> <name>D256</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>DTime1</name> <operator>+=</operator> <name>DTime1</name> <operator>&gt;&gt;</operator> <literal type="number">5</literal></expr>;</expr_stmt>  <comment type="block">/* small advantage to algorithm using less memory, to reduce cache eviction */</comment>
        <return>return <expr><name>DTime1</name> <operator>&lt;</operator> <name>DTime0</name></expr>;</return>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<function><type><name>size_t</name></type> <name>HUF_decompress4X_hufOnly_wksp</name><parameter_list>(<parameter><decl><type><name>HUF_DTable</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>,
                                     <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>,
                                     <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workSpace</name></decl></parameter>,
                                     <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* validation checks */</comment>
    <if_stmt><if>if <condition>(<expr><name>dstSize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>dstSize_tooSmall</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>cSrcSize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>corruption_detected</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>algoNb</name> <init>= <expr><call><name>HUF_selectDecoder</name><argument_list>(<argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HUF_FORCE_DECOMPRESS_X1</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>algoNb</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>algoNb</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>HUF_decompress4X1_DCtx_wksp</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HUF_FORCE_DECOMPRESS_X2</name></expr></argument>)</argument_list></call></expr></cpp:elif>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>algoNb</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>algoNb</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>HUF_decompress4X2_DCtx_wksp</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <return>return <expr><ternary><condition><expr><name>algoNb</name></expr> ?</condition><then> <expr><call><name>HUF_decompress4X2_DCtx_wksp</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>,
                            <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>)</argument_list></call></expr></then><else>:
                        <expr><call><name>HUF_decompress4X1_DCtx_wksp</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>HUF_decompress1X_DCtx_wksp</name><parameter_list>(<parameter><decl><type><name>HUF_DTable</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
                                  <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>,
                                  <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workSpace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* validation checks */</comment>
    <if_stmt><if>if <condition>(<expr><name>dstSize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>dstSize_tooSmall</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>cSrcSize</name> <operator>&gt;</operator> <name>dstSize</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>corruption_detected</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* invalid */</comment>
    <if_stmt><if>if <condition>(<expr><name>cSrcSize</name> <operator>==</operator> <name>dstSize</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>dstSize</name></expr>;</return> </block_content>}</block></if></if_stmt>   <comment type="block">/* not compressed */</comment>
    <if_stmt><if>if <condition>(<expr><name>cSrcSize</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>cSrc</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>dstSize</name></expr>;</return> </block_content>}</block></if></if_stmt>   <comment type="block">/* RLE */</comment>

    <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>algoNb</name> <init>= <expr><call><name>HUF_selectDecoder</name><argument_list>(<argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HUF_FORCE_DECOMPRESS_X1</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>algoNb</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>algoNb</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>HUF_decompress1X1_DCtx_wksp</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>,
                                <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HUF_FORCE_DECOMPRESS_X2</name></expr></argument>)</argument_list></call></expr></cpp:elif>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>algoNb</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>algoNb</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>HUF_decompress1X2_DCtx_wksp</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>,
                                <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <return>return <expr><ternary><condition><expr><name>algoNb</name></expr> ?</condition><then> <expr><call><name>HUF_decompress1X2_DCtx_wksp</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>,
                                <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>)</argument_list></call></expr></then><else>:
                        <expr><call><name>HUF_decompress1X1_DCtx_wksp</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>,
                                <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block>
</block_content>}</block></function>


<function><type><name>size_t</name></type> <name>HUF_decompress1X_usingDTable_bmi2</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>maxDstSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>HUF_DTable</name><modifier>*</modifier></type> <name>DTable</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bmi2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DTableDesc</name> <specifier>const</specifier></type> <name>dtd</name> <init>= <expr><call><name>HUF_getDTableDesc</name><argument_list>(<argument><expr><name>DTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HUF_FORCE_DECOMPRESS_X1</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>dtd</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dtd</name><operator>.</operator><name>tableType</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>HUF_decompress1X1_usingDTable_internal</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HUF_FORCE_DECOMPRESS_X2</name></expr></argument>)</argument_list></call></expr></cpp:elif>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>dtd</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dtd</name><operator>.</operator><name>tableType</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>HUF_decompress1X2_usingDTable_internal</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr><ternary><condition><expr><name><name>dtd</name><operator>.</operator><name>tableType</name></name></expr> ?</condition><then> <expr><call><name>HUF_decompress1X2_usingDTable_internal</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr> </then><else>:
                           <expr><call><name>HUF_decompress1X1_usingDTable_internal</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HUF_FORCE_DECOMPRESS_X2</name></cpp:ifndef>
<function><type><name>size_t</name></type> <name>HUF_decompress1X1_DCtx_wksp_bmi2</name><parameter_list>(<parameter><decl><type><name>HUF_DTable</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workSpace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bmi2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator> <name>cSrc</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>hSize</name> <init>= <expr><call><name>HUF_readDTableX1_wksp_bmi2</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HUF_isError</name><argument_list>(<argument><expr><name>hSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>hSize</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>hSize</name> <operator>&gt;=</operator> <name>cSrcSize</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>srcSize_wrong</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>hSize</name></expr>;</expr_stmt> <expr_stmt><expr><name>cSrcSize</name> <operator>-=</operator> <name>hSize</name></expr>;</expr_stmt>

    <return>return <expr><call><name>HUF_decompress1X1_usingDTable_internal</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>size_t</name></type> <name>HUF_decompress4X_usingDTable_bmi2</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>maxDstSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>HUF_DTable</name><modifier>*</modifier></type> <name>DTable</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bmi2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DTableDesc</name> <specifier>const</specifier></type> <name>dtd</name> <init>= <expr><call><name>HUF_getDTableDesc</name><argument_list>(<argument><expr><name>DTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HUF_FORCE_DECOMPRESS_X1</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>dtd</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dtd</name><operator>.</operator><name>tableType</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>HUF_decompress4X1_usingDTable_internal</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HUF_FORCE_DECOMPRESS_X2</name></expr></argument>)</argument_list></call></expr></cpp:elif>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>dtd</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dtd</name><operator>.</operator><name>tableType</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>HUF_decompress4X2_usingDTable_internal</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr><ternary><condition><expr><name><name>dtd</name><operator>.</operator><name>tableType</name></name></expr> ?</condition><then> <expr><call><name>HUF_decompress4X2_usingDTable_internal</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr> </then><else>:
                           <expr><call><name>HUF_decompress4X1_usingDTable_internal</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>DTable</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>HUF_decompress4X_hufOnly_wksp_bmi2</name><parameter_list>(<parameter><decl><type><name>HUF_DTable</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workSpace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bmi2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* validation checks */</comment>
    <if_stmt><if>if <condition>(<expr><name>dstSize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>dstSize_tooSmall</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>cSrcSize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>corruption_detected</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>algoNb</name> <init>= <expr><call><name>HUF_selectDecoder</name><argument_list>(<argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HUF_FORCE_DECOMPRESS_X1</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>algoNb</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>algoNb</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>HUF_decompress4X1_DCtx_wksp_bmi2</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HUF_FORCE_DECOMPRESS_X2</name></expr></argument>)</argument_list></call></expr></cpp:elif>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>algoNb</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>algoNb</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>HUF_decompress4X2_DCtx_wksp_bmi2</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <return>return <expr><ternary><condition><expr><name>algoNb</name></expr> ?</condition><then> <expr><call><name>HUF_decompress4X2_DCtx_wksp_bmi2</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr> </then><else>:
                        <expr><call><name>HUF_decompress4X1_DCtx_wksp_bmi2</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>, <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ZSTD_NO_UNUSED_FUNCTIONS</name></cpp:ifndef>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HUF_FORCE_DECOMPRESS_X2</name></cpp:ifndef>
<function><type><name>size_t</name></type> <name>HUF_readDTableX1</name><parameter_list>(<parameter><decl><type><name>HUF_DTable</name><modifier>*</modifier></type> <name>DTable</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name></type> <name><name>workSpace</name><index>[<expr><name>HUF_DECOMPRESS_WORKSPACE_SIZE_U32</name></expr>]</index></name></decl>;</decl_stmt>
    <return>return <expr><call><name>HUF_readDTableX1_wksp</name><argument_list>(<argument><expr><name>DTable</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>,
                                 <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>workSpace</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>HUF_decompress1X1_DCtx</name><parameter_list>(<parameter><decl><type><name>HUF_DTable</name><modifier>*</modifier></type> <name>DCtx</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
                              <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name></type> <name><name>workSpace</name><index>[<expr><name>HUF_DECOMPRESS_WORKSPACE_SIZE_U32</name></expr>]</index></name></decl>;</decl_stmt>
    <return>return <expr><call><name>HUF_decompress1X1_DCtx_wksp</name><argument_list>(<argument><expr><name>DCtx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>,
                                       <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>workSpace</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>HUF_decompress1X1</name> <parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>HUF_CREATE_STATIC_DTABLEX1</name><argument_list>(<argument><expr><name>DTable</name></expr></argument>, <argument><expr><name>HUF_TABLELOG_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>HUF_decompress1X1_DCtx</name> <argument_list>(<argument><expr><name>DTable</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HUF_FORCE_DECOMPRESS_X1</name></cpp:ifndef>
<function><type><name>size_t</name></type> <name>HUF_readDTableX2</name><parameter_list>(<parameter><decl><type><name>HUF_DTable</name><modifier>*</modifier></type> <name>DTable</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>U32</name></type> <name><name>workSpace</name><index>[<expr><name>HUF_DECOMPRESS_WORKSPACE_SIZE_U32</name></expr>]</index></name></decl>;</decl_stmt>
  <return>return <expr><call><name>HUF_readDTableX2_wksp</name><argument_list>(<argument><expr><name>DTable</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>,
                               <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>workSpace</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>HUF_decompress1X2_DCtx</name><parameter_list>(<parameter><decl><type><name>HUF_DTable</name><modifier>*</modifier></type> <name>DCtx</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
                              <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name></type> <name><name>workSpace</name><index>[<expr><name>HUF_DECOMPRESS_WORKSPACE_SIZE_U32</name></expr>]</index></name></decl>;</decl_stmt>
    <return>return <expr><call><name>HUF_decompress1X2_DCtx_wksp</name><argument_list>(<argument><expr><name>DCtx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>,
                                       <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>workSpace</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>HUF_decompress1X2</name> <parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>HUF_CREATE_STATIC_DTABLEX2</name><argument_list>(<argument><expr><name>DTable</name></expr></argument>, <argument><expr><name>HUF_TABLELOG_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>HUF_decompress1X2_DCtx</name><argument_list>(<argument><expr><name>DTable</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HUF_FORCE_DECOMPRESS_X2</name></cpp:ifndef>
<function><type><name>size_t</name></type> <name>HUF_decompress4X1_DCtx</name> <parameter_list>(<parameter><decl><type><name>HUF_DTable</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name></type> <name><name>workSpace</name><index>[<expr><name>HUF_DECOMPRESS_WORKSPACE_SIZE_U32</name></expr>]</index></name></decl>;</decl_stmt>
    <return>return <expr><call><name>HUF_decompress4X1_DCtx_wksp</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>,
                                       <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>workSpace</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>size_t</name></type> <name>HUF_decompress4X1</name> <parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>HUF_CREATE_STATIC_DTABLEX1</name><argument_list>(<argument><expr><name>DTable</name></expr></argument>, <argument><expr><name>HUF_TABLELOG_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>HUF_decompress4X1_DCtx</name><argument_list>(<argument><expr><name>DTable</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HUF_FORCE_DECOMPRESS_X1</name></cpp:ifndef>
<function><type><name>size_t</name></type> <name>HUF_decompress4X2_DCtx</name><parameter_list>(<parameter><decl><type><name>HUF_DTable</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
                              <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name></type> <name><name>workSpace</name><index>[<expr><name>HUF_DECOMPRESS_WORKSPACE_SIZE_U32</name></expr>]</index></name></decl>;</decl_stmt>
    <return>return <expr><call><name>HUF_decompress4X2_DCtx_wksp</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>,
                                       <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>workSpace</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>HUF_decompress4X2</name> <parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>HUF_CREATE_STATIC_DTABLEX2</name><argument_list>(<argument><expr><name>DTable</name></expr></argument>, <argument><expr><name>HUF_TABLELOG_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>HUF_decompress4X2_DCtx</name><argument_list>(<argument><expr><name>DTable</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <function_decl><type><name>size_t</name></type> (<modifier>*</modifier><name>decompressionAlgo</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<function><type><name>size_t</name></type> <name>HUF_decompress</name> <parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HUF_FORCE_DECOMPRESS_X1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HUF_FORCE_DECOMPRESS_X2</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>decompressionAlgo</name></type> <name><name>decompress</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><name>HUF_decompress4X1</name></expr>, <expr><name>HUF_decompress4X2</name></expr> }</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* validation checks */</comment>
    <if_stmt><if>if <condition>(<expr><name>dstSize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>dstSize_tooSmall</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>cSrcSize</name> <operator>&gt;</operator> <name>dstSize</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>corruption_detected</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* invalid */</comment>
    <if_stmt><if>if <condition>(<expr><name>cSrcSize</name> <operator>==</operator> <name>dstSize</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>dstSize</name></expr>;</return> </block_content>}</block></if></if_stmt>   <comment type="block">/* not compressed */</comment>
    <if_stmt><if>if <condition>(<expr><name>cSrcSize</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>cSrc</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>dstSize</name></expr>;</return> </block_content>}</block></if></if_stmt>   <comment type="block">/* RLE */</comment>

    <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>algoNb</name> <init>= <expr><call><name>HUF_selectDecoder</name><argument_list>(<argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HUF_FORCE_DECOMPRESS_X1</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>algoNb</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>algoNb</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>HUF_decompress4X1</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HUF_FORCE_DECOMPRESS_X2</name></expr></argument>)</argument_list></call></expr></cpp:elif>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>algoNb</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>algoNb</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>HUF_decompress4X2</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <return>return <expr><name><name>decompress</name><index>[<expr><name>algoNb</name></expr>]</index></name><operator>(</operator><name>dst</name><operator>,</operator> <name>dstSize</name><operator>,</operator> <name>cSrc</name><operator>,</operator> <name>cSrcSize</name><operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>HUF_decompress4X_DCtx</name> <parameter_list>(<parameter><decl><type><name>HUF_DTable</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* validation checks */</comment>
    <if_stmt><if>if <condition>(<expr><name>dstSize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>dstSize_tooSmall</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>cSrcSize</name> <operator>&gt;</operator> <name>dstSize</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>corruption_detected</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* invalid */</comment>
    <if_stmt><if>if <condition>(<expr><name>cSrcSize</name> <operator>==</operator> <name>dstSize</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>dstSize</name></expr>;</return> </block_content>}</block></if></if_stmt>   <comment type="block">/* not compressed */</comment>
    <if_stmt><if>if <condition>(<expr><name>cSrcSize</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>cSrc</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>dstSize</name></expr>;</return> </block_content>}</block></if></if_stmt>   <comment type="block">/* RLE */</comment>

    <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>algoNb</name> <init>= <expr><call><name>HUF_selectDecoder</name><argument_list>(<argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HUF_FORCE_DECOMPRESS_X1</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>algoNb</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>algoNb</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>HUF_decompress4X1_DCtx</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HUF_FORCE_DECOMPRESS_X2</name></expr></argument>)</argument_list></call></expr></cpp:elif>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>algoNb</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>algoNb</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>HUF_decompress4X2_DCtx</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <return>return <expr><ternary><condition><expr><name>algoNb</name></expr> ?</condition><then> <expr><call><name>HUF_decompress4X2_DCtx</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>)</argument_list></call></expr> </then><else>:
                        <expr><call><name>HUF_decompress4X1_DCtx</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>)</argument_list></call></expr></else></ternary></expr> ;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>HUF_decompress4X_hufOnly</name><parameter_list>(<parameter><decl><type><name>HUF_DTable</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name></type> <name><name>workSpace</name><index>[<expr><name>HUF_DECOMPRESS_WORKSPACE_SIZE_U32</name></expr>]</index></name></decl>;</decl_stmt>
    <return>return <expr><call><name>HUF_decompress4X_hufOnly_wksp</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>,
                                         <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>workSpace</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>HUF_decompress1X_DCtx</name><parameter_list>(<parameter><decl><type><name>HUF_DTable</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
                             <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>cSrc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSrcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name></type> <name><name>workSpace</name><index>[<expr><name>HUF_DECOMPRESS_WORKSPACE_SIZE_U32</name></expr>]</index></name></decl>;</decl_stmt>
    <return>return <expr><call><name>HUF_decompress1X_DCtx_wksp</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>cSrc</name></expr></argument>, <argument><expr><name>cSrcSize</name></expr></argument>,
                                      <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>workSpace</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
