<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/zstd/zstd_subset/compress/zstd_compress_sequences.c"><comment type="block">/*
 * Copyright (c) Yann Collet, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
 */</comment>

 <comment type="block">/*-*************************************
 *  Dependencies
 ***************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_compress_sequences.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/**
 * -log2(x / 256) lookup table for x in [0, 256).
 * If x == 0: Return 0
 * Else: Return floor(-log2(x / 256) * 256)
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <specifier>const</specifier></type> <name><name>kInverseProbabilityLog256</name><index>[<expr><literal type="number">256</literal></expr>]</index></name> <init>= <expr><block>{
    <expr><literal type="number">0</literal></expr>,    <expr><literal type="number">2048</literal></expr>, <expr><literal type="number">1792</literal></expr>, <expr><literal type="number">1642</literal></expr>, <expr><literal type="number">1536</literal></expr>, <expr><literal type="number">1453</literal></expr>, <expr><literal type="number">1386</literal></expr>, <expr><literal type="number">1329</literal></expr>, <expr><literal type="number">1280</literal></expr>, <expr><literal type="number">1236</literal></expr>, <expr><literal type="number">1197</literal></expr>, <expr><literal type="number">1162</literal></expr>,
    <expr><literal type="number">1130</literal></expr>, <expr><literal type="number">1100</literal></expr>, <expr><literal type="number">1073</literal></expr>, <expr><literal type="number">1047</literal></expr>, <expr><literal type="number">1024</literal></expr>, <expr><literal type="number">1001</literal></expr>, <expr><literal type="number">980</literal></expr>,  <expr><literal type="number">960</literal></expr>,  <expr><literal type="number">941</literal></expr>,  <expr><literal type="number">923</literal></expr>,  <expr><literal type="number">906</literal></expr>,  <expr><literal type="number">889</literal></expr>,
    <expr><literal type="number">874</literal></expr>,  <expr><literal type="number">859</literal></expr>,  <expr><literal type="number">844</literal></expr>,  <expr><literal type="number">830</literal></expr>,  <expr><literal type="number">817</literal></expr>,  <expr><literal type="number">804</literal></expr>,  <expr><literal type="number">791</literal></expr>,  <expr><literal type="number">779</literal></expr>,  <expr><literal type="number">768</literal></expr>,  <expr><literal type="number">756</literal></expr>,  <expr><literal type="number">745</literal></expr>,  <expr><literal type="number">734</literal></expr>,
    <expr><literal type="number">724</literal></expr>,  <expr><literal type="number">714</literal></expr>,  <expr><literal type="number">704</literal></expr>,  <expr><literal type="number">694</literal></expr>,  <expr><literal type="number">685</literal></expr>,  <expr><literal type="number">676</literal></expr>,  <expr><literal type="number">667</literal></expr>,  <expr><literal type="number">658</literal></expr>,  <expr><literal type="number">650</literal></expr>,  <expr><literal type="number">642</literal></expr>,  <expr><literal type="number">633</literal></expr>,  <expr><literal type="number">626</literal></expr>,
    <expr><literal type="number">618</literal></expr>,  <expr><literal type="number">610</literal></expr>,  <expr><literal type="number">603</literal></expr>,  <expr><literal type="number">595</literal></expr>,  <expr><literal type="number">588</literal></expr>,  <expr><literal type="number">581</literal></expr>,  <expr><literal type="number">574</literal></expr>,  <expr><literal type="number">567</literal></expr>,  <expr><literal type="number">561</literal></expr>,  <expr><literal type="number">554</literal></expr>,  <expr><literal type="number">548</literal></expr>,  <expr><literal type="number">542</literal></expr>,
    <expr><literal type="number">535</literal></expr>,  <expr><literal type="number">529</literal></expr>,  <expr><literal type="number">523</literal></expr>,  <expr><literal type="number">517</literal></expr>,  <expr><literal type="number">512</literal></expr>,  <expr><literal type="number">506</literal></expr>,  <expr><literal type="number">500</literal></expr>,  <expr><literal type="number">495</literal></expr>,  <expr><literal type="number">489</literal></expr>,  <expr><literal type="number">484</literal></expr>,  <expr><literal type="number">478</literal></expr>,  <expr><literal type="number">473</literal></expr>,
    <expr><literal type="number">468</literal></expr>,  <expr><literal type="number">463</literal></expr>,  <expr><literal type="number">458</literal></expr>,  <expr><literal type="number">453</literal></expr>,  <expr><literal type="number">448</literal></expr>,  <expr><literal type="number">443</literal></expr>,  <expr><literal type="number">438</literal></expr>,  <expr><literal type="number">434</literal></expr>,  <expr><literal type="number">429</literal></expr>,  <expr><literal type="number">424</literal></expr>,  <expr><literal type="number">420</literal></expr>,  <expr><literal type="number">415</literal></expr>,
    <expr><literal type="number">411</literal></expr>,  <expr><literal type="number">407</literal></expr>,  <expr><literal type="number">402</literal></expr>,  <expr><literal type="number">398</literal></expr>,  <expr><literal type="number">394</literal></expr>,  <expr><literal type="number">390</literal></expr>,  <expr><literal type="number">386</literal></expr>,  <expr><literal type="number">382</literal></expr>,  <expr><literal type="number">377</literal></expr>,  <expr><literal type="number">373</literal></expr>,  <expr><literal type="number">370</literal></expr>,  <expr><literal type="number">366</literal></expr>,
    <expr><literal type="number">362</literal></expr>,  <expr><literal type="number">358</literal></expr>,  <expr><literal type="number">354</literal></expr>,  <expr><literal type="number">350</literal></expr>,  <expr><literal type="number">347</literal></expr>,  <expr><literal type="number">343</literal></expr>,  <expr><literal type="number">339</literal></expr>,  <expr><literal type="number">336</literal></expr>,  <expr><literal type="number">332</literal></expr>,  <expr><literal type="number">329</literal></expr>,  <expr><literal type="number">325</literal></expr>,  <expr><literal type="number">322</literal></expr>,
    <expr><literal type="number">318</literal></expr>,  <expr><literal type="number">315</literal></expr>,  <expr><literal type="number">311</literal></expr>,  <expr><literal type="number">308</literal></expr>,  <expr><literal type="number">305</literal></expr>,  <expr><literal type="number">302</literal></expr>,  <expr><literal type="number">298</literal></expr>,  <expr><literal type="number">295</literal></expr>,  <expr><literal type="number">292</literal></expr>,  <expr><literal type="number">289</literal></expr>,  <expr><literal type="number">286</literal></expr>,  <expr><literal type="number">282</literal></expr>,
    <expr><literal type="number">279</literal></expr>,  <expr><literal type="number">276</literal></expr>,  <expr><literal type="number">273</literal></expr>,  <expr><literal type="number">270</literal></expr>,  <expr><literal type="number">267</literal></expr>,  <expr><literal type="number">264</literal></expr>,  <expr><literal type="number">261</literal></expr>,  <expr><literal type="number">258</literal></expr>,  <expr><literal type="number">256</literal></expr>,  <expr><literal type="number">253</literal></expr>,  <expr><literal type="number">250</literal></expr>,  <expr><literal type="number">247</literal></expr>,
    <expr><literal type="number">244</literal></expr>,  <expr><literal type="number">241</literal></expr>,  <expr><literal type="number">239</literal></expr>,  <expr><literal type="number">236</literal></expr>,  <expr><literal type="number">233</literal></expr>,  <expr><literal type="number">230</literal></expr>,  <expr><literal type="number">228</literal></expr>,  <expr><literal type="number">225</literal></expr>,  <expr><literal type="number">222</literal></expr>,  <expr><literal type="number">220</literal></expr>,  <expr><literal type="number">217</literal></expr>,  <expr><literal type="number">215</literal></expr>,
    <expr><literal type="number">212</literal></expr>,  <expr><literal type="number">209</literal></expr>,  <expr><literal type="number">207</literal></expr>,  <expr><literal type="number">204</literal></expr>,  <expr><literal type="number">202</literal></expr>,  <expr><literal type="number">199</literal></expr>,  <expr><literal type="number">197</literal></expr>,  <expr><literal type="number">194</literal></expr>,  <expr><literal type="number">192</literal></expr>,  <expr><literal type="number">190</literal></expr>,  <expr><literal type="number">187</literal></expr>,  <expr><literal type="number">185</literal></expr>,
    <expr><literal type="number">182</literal></expr>,  <expr><literal type="number">180</literal></expr>,  <expr><literal type="number">178</literal></expr>,  <expr><literal type="number">175</literal></expr>,  <expr><literal type="number">173</literal></expr>,  <expr><literal type="number">171</literal></expr>,  <expr><literal type="number">168</literal></expr>,  <expr><literal type="number">166</literal></expr>,  <expr><literal type="number">164</literal></expr>,  <expr><literal type="number">162</literal></expr>,  <expr><literal type="number">159</literal></expr>,  <expr><literal type="number">157</literal></expr>,
    <expr><literal type="number">155</literal></expr>,  <expr><literal type="number">153</literal></expr>,  <expr><literal type="number">151</literal></expr>,  <expr><literal type="number">149</literal></expr>,  <expr><literal type="number">146</literal></expr>,  <expr><literal type="number">144</literal></expr>,  <expr><literal type="number">142</literal></expr>,  <expr><literal type="number">140</literal></expr>,  <expr><literal type="number">138</literal></expr>,  <expr><literal type="number">136</literal></expr>,  <expr><literal type="number">134</literal></expr>,  <expr><literal type="number">132</literal></expr>,
    <expr><literal type="number">130</literal></expr>,  <expr><literal type="number">128</literal></expr>,  <expr><literal type="number">126</literal></expr>,  <expr><literal type="number">123</literal></expr>,  <expr><literal type="number">121</literal></expr>,  <expr><literal type="number">119</literal></expr>,  <expr><literal type="number">117</literal></expr>,  <expr><literal type="number">115</literal></expr>,  <expr><literal type="number">114</literal></expr>,  <expr><literal type="number">112</literal></expr>,  <expr><literal type="number">110</literal></expr>,  <expr><literal type="number">108</literal></expr>,
    <expr><literal type="number">106</literal></expr>,  <expr><literal type="number">104</literal></expr>,  <expr><literal type="number">102</literal></expr>,  <expr><literal type="number">100</literal></expr>,  <expr><literal type="number">98</literal></expr>,   <expr><literal type="number">96</literal></expr>,   <expr><literal type="number">94</literal></expr>,   <expr><literal type="number">93</literal></expr>,   <expr><literal type="number">91</literal></expr>,   <expr><literal type="number">89</literal></expr>,   <expr><literal type="number">87</literal></expr>,   <expr><literal type="number">85</literal></expr>,
    <expr><literal type="number">83</literal></expr>,   <expr><literal type="number">82</literal></expr>,   <expr><literal type="number">80</literal></expr>,   <expr><literal type="number">78</literal></expr>,   <expr><literal type="number">76</literal></expr>,   <expr><literal type="number">74</literal></expr>,   <expr><literal type="number">73</literal></expr>,   <expr><literal type="number">71</literal></expr>,   <expr><literal type="number">69</literal></expr>,   <expr><literal type="number">67</literal></expr>,   <expr><literal type="number">66</literal></expr>,   <expr><literal type="number">64</literal></expr>,
    <expr><literal type="number">62</literal></expr>,   <expr><literal type="number">61</literal></expr>,   <expr><literal type="number">59</literal></expr>,   <expr><literal type="number">57</literal></expr>,   <expr><literal type="number">55</literal></expr>,   <expr><literal type="number">54</literal></expr>,   <expr><literal type="number">52</literal></expr>,   <expr><literal type="number">50</literal></expr>,   <expr><literal type="number">49</literal></expr>,   <expr><literal type="number">47</literal></expr>,   <expr><literal type="number">46</literal></expr>,   <expr><literal type="number">44</literal></expr>,
    <expr><literal type="number">42</literal></expr>,   <expr><literal type="number">41</literal></expr>,   <expr><literal type="number">39</literal></expr>,   <expr><literal type="number">37</literal></expr>,   <expr><literal type="number">36</literal></expr>,   <expr><literal type="number">34</literal></expr>,   <expr><literal type="number">33</literal></expr>,   <expr><literal type="number">31</literal></expr>,   <expr><literal type="number">30</literal></expr>,   <expr><literal type="number">28</literal></expr>,   <expr><literal type="number">26</literal></expr>,   <expr><literal type="number">25</literal></expr>,
    <expr><literal type="number">23</literal></expr>,   <expr><literal type="number">22</literal></expr>,   <expr><literal type="number">20</literal></expr>,   <expr><literal type="number">19</literal></expr>,   <expr><literal type="number">17</literal></expr>,   <expr><literal type="number">16</literal></expr>,   <expr><literal type="number">14</literal></expr>,   <expr><literal type="number">13</literal></expr>,   <expr><literal type="number">11</literal></expr>,   <expr><literal type="number">10</literal></expr>,   <expr><literal type="number">8</literal></expr>,    <expr><literal type="number">7</literal></expr>,
    <expr><literal type="number">5</literal></expr>,    <expr><literal type="number">4</literal></expr>,    <expr><literal type="number">2</literal></expr>,    <expr><literal type="number">1</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>unsigned</name></type> <name>ZSTD_getFSEMaxSymbolValue</name><parameter_list>(<parameter><decl><type><name>FSE_CTable</name> <specifier>const</specifier><modifier>*</modifier></type> <name>ctable</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>ptr</name> <init>= <expr><name>ctable</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>U16</name> <specifier>const</specifier><modifier>*</modifier></type> <name>u16ptr</name> <init>= <expr><operator>(</operator><name>U16</name> <specifier>const</specifier><operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>maxSymbolValue</name> <init>= <expr><call><name>MEM_read16</name><argument_list>(<argument><expr><name>u16ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><name>maxSymbolValue</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Returns true if we should use ncount=-1 else we should
 * use ncount=1 for low probability symbols instead.
 */</comment>
<function><type><specifier>static</specifier> <name>unsigned</name></type> <name>ZSTD_useLowProbCount</name><parameter_list>(<parameter><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>nbSeq</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Heuristic: This should cover most blocks &lt;= 16K and
     * start to fade out after 16K to about 32K depending on
     * compressibility.
     */</comment>
    <return>return <expr><name>nbSeq</name> <operator>&gt;=</operator> <literal type="number">2048</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Returns the cost in bytes of encoding the normalized count header.
 * Returns an error if any of the helper functions return an error.
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_NCountCost</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <specifier>const</specifier><modifier>*</modifier></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>max</name></decl></parameter>,
                              <parameter><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>nbSeq</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>FSELog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BYTE</name></type> <name><name>wksp</name><index>[<expr><name>FSE_NCOUNTBOUND</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>S16</name></type> <name><name>norm</name><index>[<expr><name>MaxSeq</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>tableLog</name> <init>= <expr><call><name>FSE_optimalTableLog</name><argument_list>(<argument><expr><name>FSELog</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>FSE_normalizeCount</name><argument_list>(<argument><expr><name>norm</name></expr></argument>, <argument><expr><name>tableLog</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><call><name>ZSTD_useLowProbCount</name><argument_list>(<argument><expr><name>nbSeq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>FSE_writeNCount</name><argument_list>(<argument><expr><name>wksp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>wksp</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>norm</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name>tableLog</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Returns the cost in bits of encoding the distribution described by count
 * using the entropy bound.
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_entropyCost</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <specifier>const</specifier><modifier>*</modifier></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>max</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>total</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>s</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>total</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>s</name> <operator>&lt;=</operator> <name>max</name></expr>;</condition> <incr><expr><operator>++</operator><name>s</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name></type> <name>norm</name> <init>= <expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><operator>(</operator><literal type="number">256</literal> <operator>*</operator> <name><name>count</name><index>[<expr><name>s</name></expr>]</index></name><operator>)</operator> <operator>/</operator> <name>total</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>count</name><index>[<expr><name>s</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>norm</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>norm</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>count</name><index>[<expr><name>s</name></expr>]</index></name> <operator>&lt;</operator> <name>total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cost</name> <operator>+=</operator> <name><name>count</name><index>[<expr><name>s</name></expr>]</index></name> <operator>*</operator> <name><name>kInverseProbabilityLog256</name><index>[<expr><name>norm</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>cost</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Returns the cost in bits of encoding the distribution in count using ctable.
 * Returns an error if ctable cannot represent all the symbols in count.
 */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_fseBitCost</name><parameter_list>(
    <parameter><decl><type><name>FSE_CTable</name> <specifier>const</specifier><modifier>*</modifier></type> <name>ctable</name></decl></parameter>,
    <parameter><decl><type><name>unsigned</name> <specifier>const</specifier><modifier>*</modifier></type> <name>count</name></decl></parameter>,
    <parameter><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>max</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>kAccuracyLog</name> <init>= <expr><literal type="number">8</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FSE_CState_t</name></type> <name>cstate</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>FSE_initCState</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cstate</name></expr></argument>, <argument><expr><name>ctable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ZSTD_getFSEMaxSymbolValue</name><argument_list>(<argument><expr><name>ctable</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>max</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Repeat FSE_CTable has maxSymbolValue %u &lt; %u"</literal></expr></argument>,
                    <argument><expr><call><name>ZSTD_getFSEMaxSymbolValue</name><argument_list>(<argument><expr><name>ctable</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>GENERIC</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>s</name> <operator>&lt;=</operator> <name>max</name></expr>;</condition> <incr><expr><operator>++</operator><name>s</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>tableLog</name> <init>= <expr><name><name>cstate</name><operator>.</operator><name>stateLog</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>badCost</name> <init>= <expr><operator>(</operator><name>tableLog</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>kAccuracyLog</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>bitCost</name> <init>= <expr><call><name>FSE_bitCost</name><argument_list>(<argument><expr><name><name>cstate</name><operator>.</operator><name>symbolTT</name></name></expr></argument>, <argument><expr><name>tableLog</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>kAccuracyLog</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>count</name><index>[<expr><name>s</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>bitCost</name> <operator>&gt;=</operator> <name>badCost</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Repeat FSE_CTable has Prob[%u] == 0"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>GENERIC</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>cost</name> <operator>+=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name><name>count</name><index>[<expr><name>s</name></expr>]</index></name> <operator>*</operator> <name>bitCost</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>cost</name> <operator>&gt;&gt;</operator> <name>kAccuracyLog</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Returns the cost in bits of encoding the distribution in count using the
 * table described by norm. The max symbol support by norm is assumed &gt;= max.
 * norm must be valid for every symbol with non-zero probability in count.
 */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_crossEntropyCost</name><parameter_list>(<parameter><decl><type><name>short</name> <specifier>const</specifier><modifier>*</modifier></type> <name>norm</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>accuracyLog</name></decl></parameter>,
                             <parameter><decl><type><name>unsigned</name> <specifier>const</specifier><modifier>*</modifier></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>max</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>shift</name> <init>= <expr><literal type="number">8</literal> <operator>-</operator> <name>accuracyLog</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>s</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>accuracyLog</name> <operator>&lt;=</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>s</name> <operator>&lt;=</operator> <name>max</name></expr>;</condition> <incr><expr><operator>++</operator><name>s</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>normAcc</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>norm</name><index>[<expr><name>s</name></expr>]</index></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>norm</name><index>[<expr><name>s</name></expr>]</index></name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>norm256</name> <init>= <expr><name>normAcc</name> <operator>&lt;&lt;</operator> <name>shift</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>norm256</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>norm256</name> <operator>&lt;</operator> <literal type="number">256</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cost</name> <operator>+=</operator> <name><name>count</name><index>[<expr><name>s</name></expr>]</index></name> <operator>*</operator> <name><name>kInverseProbabilityLog256</name><index>[<expr><name>norm256</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>cost</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>symbolEncodingType_e</name></type>
<name>ZSTD_selectEncodingType</name><parameter_list>(
        <parameter><decl><type><name>FSE_repeat</name><modifier>*</modifier></type> <name>repeatMode</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <specifier>const</specifier><modifier>*</modifier></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>max</name></decl></parameter>,
        <parameter><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>mostFrequent</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nbSeq</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>FSELog</name></decl></parameter>,
        <parameter><decl><type><name>FSE_CTable</name> <specifier>const</specifier><modifier>*</modifier></type> <name>prevCTable</name></decl></parameter>,
        <parameter><decl><type><name>short</name> <specifier>const</specifier><modifier>*</modifier></type> <name>defaultNorm</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>defaultNormLog</name></decl></parameter>,
        <parameter><decl><type><name>ZSTD_defaultPolicy_e</name> <specifier>const</specifier></type> <name>isDefaultAllowed</name></decl></parameter>,
        <parameter><decl><type><name>ZSTD_strategy</name> <specifier>const</specifier></type> <name>strategy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>ZSTD_STATIC_ASSERT</name><argument_list>(<argument><expr><name>ZSTD_defaultDisallowed</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ZSTD_defaultAllowed</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>mostFrequent</name> <operator>==</operator> <name>nbSeq</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>repeatMode</name> <operator>=</operator> <name>FSE_repeat_none</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>isDefaultAllowed</name> <operator>&amp;&amp;</operator> <name>nbSeq</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Prefer set_basic over set_rle when there are 2 or fewer symbols,
             * since RLE uses 1 byte, but set_basic uses 5-6 bits per symbol.
             * If basic encoding isn't possible, always choose RLE.
             */</comment>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Selected set_basic"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>set_basic</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Selected set_rle"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>set_rle</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>strategy</name> <operator>&lt;</operator> <name>ZSTD_lazy</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>isDefaultAllowed</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>staticFse_nbSeq_max</name> <init>= <expr><literal type="number">1000</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>mult</name> <init>= <expr><literal type="number">10</literal> <operator>-</operator> <name>strategy</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>baseLog</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>dynamicFse_nbSeq_min</name> <init>= <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>defaultNormLog</name><operator>)</operator> <operator>*</operator> <name>mult</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>baseLog</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* 28-36 for offset, 56-72 for lengths */</comment>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>defaultNormLog</name> <operator>&gt;=</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator> <name>defaultNormLog</name> <operator>&lt;=</operator> <literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* xx_DEFAULTNORMLOG */</comment>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>mult</name> <operator>&lt;=</operator> <literal type="number">9</literal> <operator>&amp;&amp;</operator> <name>mult</name> <operator>&gt;=</operator> <literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>( <expr><operator>(</operator><operator>*</operator><name>repeatMode</name> <operator>==</operator> <name>FSE_repeat_valid</name><operator>)</operator>
              <operator>&amp;&amp;</operator> <operator>(</operator><name>nbSeq</name> <operator>&lt;</operator> <name>staticFse_nbSeq_max</name><operator>)</operator></expr> )</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Selected set_repeat"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>set_repeat</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>( <expr><operator>(</operator><name>nbSeq</name> <operator>&lt;</operator> <name>dynamicFse_nbSeq_min</name><operator>)</operator>
              <operator>||</operator> <operator>(</operator><name>mostFrequent</name> <operator>&lt;</operator> <operator>(</operator><name>nbSeq</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>defaultNormLog</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>)</operator></expr> )</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Selected set_basic"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* The format allows default tables to be repeated, but it isn't useful.
                 * When using simple heuristics to select encoding type, we don't want
                 * to confuse these tables with dictionaries. When running more careful
                 * analysis, we don't need to waste time checking both repeating tables
                 * and default tables.
                 */</comment>
                <expr_stmt><expr><operator>*</operator><name>repeatMode</name> <operator>=</operator> <name>FSE_repeat_none</name></expr>;</expr_stmt>
                <return>return <expr><name>set_basic</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>basicCost</name> <init>= <expr><ternary><condition><expr><name>isDefaultAllowed</name></expr> ?</condition><then> <expr><call><name>ZSTD_crossEntropyCost</name><argument_list>(<argument><expr><name>defaultNorm</name></expr></argument>, <argument><expr><name>defaultNormLog</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>GENERIC</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>repeatCost</name> <init>= <expr><ternary><condition><expr><operator>*</operator><name>repeatMode</name> <operator>!=</operator> <name>FSE_repeat_none</name></expr> ?</condition><then> <expr><call><name>ZSTD_fseBitCost</name><argument_list>(<argument><expr><name>prevCTable</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>GENERIC</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>NCountCost</name> <init>= <expr><call><name>ZSTD_NCountCost</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>FSELog</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>compressedCost</name> <init>= <expr><operator>(</operator><name>NCountCost</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>+</operator> <call><name>ZSTD_entropyCost</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>isDefaultAllowed</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>basicCost</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><operator>*</operator><name>repeatMode</name> <operator>==</operator> <name>FSE_repeat_valid</name> <operator>&amp;&amp;</operator> <call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>repeatCost</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>NCountCost</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>compressedCost</name> <operator>&lt;</operator> <call><name>ERROR</name><argument_list>(<argument><expr><name>maxCode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Estimated bit costs: basic=%u\trepeat=%u\tcompressed=%u"</literal></expr></argument>,
                    <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>basicCost</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>repeatCost</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>compressedCost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>basicCost</name> <operator>&lt;=</operator> <name>repeatCost</name> <operator>&amp;&amp;</operator> <name>basicCost</name> <operator>&lt;=</operator> <name>compressedCost</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Selected set_basic"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>isDefaultAllowed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>repeatMode</name> <operator>=</operator> <name>FSE_repeat_none</name></expr>;</expr_stmt>
            <return>return <expr><name>set_basic</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>repeatCost</name> <operator>&lt;=</operator> <name>compressedCost</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Selected set_repeat"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>repeatCost</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>set_repeat</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>compressedCost</name> <operator>&lt;</operator> <name>basicCost</name> <operator>&amp;&amp;</operator> <name>compressedCost</name> <operator>&lt;</operator> <name>repeatCost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Selected set_compressed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>repeatMode</name> <operator>=</operator> <name>FSE_repeat_check</name></expr>;</expr_stmt>
    <return>return <expr><name>set_compressed</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>S16</name></type> <name><name>norm</name><index>[<expr><name>MaxSeq</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name><name>wksp</name><index>[<expr><call><name>FSE_BUILD_CTABLE_WORKSPACE_SIZE_U32</name><argument_list>(<argument><expr><name>MaxSeq</name></expr></argument>, <argument><expr><name>MaxFSELog</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>ZSTD_BuildCTableWksp</name>;</typedef>

<function><type><name>size_t</name></type>
<name>ZSTD_buildCTable</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                <parameter><decl><type><name>FSE_CTable</name><modifier>*</modifier></type> <name>nextCTable</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>FSELog</name></decl></parameter>, <parameter><decl><type><name>symbolEncodingType_e</name></type> <name>type</name></decl></parameter>,
                <parameter><decl><type><name>unsigned</name><modifier>*</modifier></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>max</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>codeTable</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nbSeq</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>S16</name><modifier>*</modifier></type> <name>defaultNorm</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>defaultNormLog</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>defaultMax</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>FSE_CTable</name><modifier>*</modifier></type> <name>prevCTable</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>prevCTableSize</name></decl></parameter>,
                <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>entropyWorkspace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>entropyWorkspaceSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend</name> <init>= <expr><name>op</name> <operator>+</operator> <name>dstCapacity</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_buildCTable (dstCapacity=%u)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>dstCapacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>set_rle</name></expr>:</case>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>FSE_buildCTable_rle</name><argument_list>(<argument><expr><name>nextCTable</name></expr></argument>, <argument><expr><operator>(</operator><name>BYTE</name><operator>)</operator><name>max</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>dstCapacity</name><operator>==</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">"not enough space"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>op</name> <operator>=</operator> <name><name>codeTable</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    <case>case <expr><name>set_repeat</name></expr>:</case>
        <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>nextCTable</name></expr></argument>, <argument><expr><name>prevCTable</name></expr></argument>, <argument><expr><name>prevCTableSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    <case>case <expr><name>set_basic</name></expr>:</case>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>FSE_buildCTable_wksp</name><argument_list>(<argument><expr><name>nextCTable</name></expr></argument>, <argument><expr><name>defaultNorm</name></expr></argument>, <argument><expr><name>defaultMax</name></expr></argument>, <argument><expr><name>defaultNormLog</name></expr></argument>, <argument><expr><name>entropyWorkspace</name></expr></argument>, <argument><expr><name>entropyWorkspaceSize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* note : could be pre-calculated */</comment>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    <case>case <expr><name>set_compressed</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>ZSTD_BuildCTableWksp</name><modifier>*</modifier></type> <name>wksp</name> <init>= <expr><operator>(</operator><name>ZSTD_BuildCTableWksp</name><operator>*</operator><operator>)</operator><name>entropyWorkspace</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>nbSeq_1</name> <init>= <expr><name>nbSeq</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>tableLog</name> <init>= <expr><call><name>FSE_optimalTableLog</name><argument_list>(<argument><expr><name>FSELog</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>count</name><index>[<expr><name><name>codeTable</name><index>[<expr><name>nbSeq</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>count</name><index>[<expr><name><name>codeTable</name><index>[<expr><name>nbSeq</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>nbSeq_1</name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nbSeq_1</name> <operator>&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>entropyWorkspaceSize</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_BuildCTableWksp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>entropyWorkspaceSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>FSE_normalizeCount</name><argument_list>(<argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>norm</name></name></expr></argument>, <argument><expr><name>tableLog</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>nbSeq_1</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><call><name>ZSTD_useLowProbCount</name><argument_list>(<argument><expr><name>nbSeq_1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"FSE_normalizeCount failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>oend</name> <operator>&gt;=</operator> <name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>NCountSize</name> <init>= <expr><call><name>FSE_writeNCount</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name> <operator>-</operator> <name>op</name><operator>)</operator></expr></argument>, <argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>norm</name></name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name>tableLog</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>   <comment type="block">/* overflow protected */</comment>
            <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>NCountSize</name></expr></argument>, <argument><expr><literal type="string">"FSE_writeNCount failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>FSE_buildCTable_wksp</name><argument_list>(<argument><expr><name>nextCTable</name></expr></argument>, <argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>norm</name></name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name>tableLog</name></expr></argument>, <argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>wksp</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>wksp</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"FSE_buildCTable_wksp failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NCountSize</name></expr>;</return>
        </block_content>}</block>
    </block_content>}</block>
    <default>default:</default> <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr><name>GENERIC</name></expr></argument>, <argument><expr><literal type="string">"impossible to reach"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>size_t</name></type>
<name>ZSTD_encodeSequences_body</name><parameter_list>(
            <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
            <parameter><decl><type><name>FSE_CTable</name> <specifier>const</specifier><modifier>*</modifier></type> <name>CTable_MatchLength</name></decl></parameter>, <parameter><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>mlCodeTable</name></decl></parameter>,
            <parameter><decl><type><name>FSE_CTable</name> <specifier>const</specifier><modifier>*</modifier></type> <name>CTable_OffsetBits</name></decl></parameter>, <parameter><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>ofCodeTable</name></decl></parameter>,
            <parameter><decl><type><name>FSE_CTable</name> <specifier>const</specifier><modifier>*</modifier></type> <name>CTable_LitLength</name></decl></parameter>, <parameter><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>llCodeTable</name></decl></parameter>,
            <parameter><decl><type><name>seqDef</name> <specifier>const</specifier><modifier>*</modifier></type> <name>sequences</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nbSeq</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>longOffsets</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BIT_CStream_t</name></type> <name>blockStream</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FSE_CState_t</name></type>  <name>stateMatchLength</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FSE_CState_t</name></type>  <name>stateOffsetBits</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FSE_CState_t</name></type>  <name>stateLitLength</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(
        <argument><expr><call><name>ERR_isError</name><argument_list>(<argument><expr><call><name>BIT_initCStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockStream</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">"not enough space remaining"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"available space for bitstream : %i  (dstCapacity=%u)"</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>blockStream</name><operator>.</operator><name>endPtr</name></name> <operator>-</operator> <name><name>blockStream</name><operator>.</operator><name>startPtr</name></name><operator>)</operator></expr></argument>,
                <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>dstCapacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* first symbols */</comment>
    <expr_stmt><expr><call><name>FSE_initCState2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stateMatchLength</name></expr></argument>, <argument><expr><name>CTable_MatchLength</name></expr></argument>, <argument><expr><name><name>mlCodeTable</name><index>[<expr><name>nbSeq</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FSE_initCState2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stateOffsetBits</name></expr></argument>,  <argument><expr><name>CTable_OffsetBits</name></expr></argument>,  <argument><expr><name><name>ofCodeTable</name><index>[<expr><name>nbSeq</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FSE_initCState2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stateLitLength</name></expr></argument>,   <argument><expr><name>CTable_LitLength</name></expr></argument>,   <argument><expr><name><name>llCodeTable</name><index>[<expr><name>nbSeq</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BIT_addBits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockStream</name></expr></argument>, <argument><expr><name><name>sequences</name><index>[<expr><name>nbSeq</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>litLength</name></expr></argument>, <argument><expr><name><name>LL_bits</name><index>[<expr><name><name>llCodeTable</name><index>[<expr><name>nbSeq</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>MEM_32bits</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>BIT_flushBits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockStream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>BIT_addBits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockStream</name></expr></argument>, <argument><expr><name><name>sequences</name><index>[<expr><name>nbSeq</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>mlBase</name></expr></argument>, <argument><expr><name><name>ML_bits</name><index>[<expr><name><name>mlCodeTable</name><index>[<expr><name>nbSeq</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>MEM_32bits</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>BIT_flushBits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockStream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>longOffsets</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>ofBits</name> <init>= <expr><name><name>ofCodeTable</name><index>[<expr><name>nbSeq</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>extraBits</name> <init>= <expr><name>ofBits</name> <operator>-</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>ofBits</name></expr></argument>, <argument><expr><name>STREAM_ACCUMULATOR_MIN</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>extraBits</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>BIT_addBits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockStream</name></expr></argument>, <argument><expr><name><name>sequences</name><index>[<expr><name>nbSeq</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>offBase</name></expr></argument>, <argument><expr><name>extraBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>BIT_flushBits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockStream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>BIT_addBits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockStream</name></expr></argument>, <argument><expr><name><name>sequences</name><index>[<expr><name>nbSeq</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>offBase</name> <operator>&gt;&gt;</operator> <name>extraBits</name></expr></argument>,
                    <argument><expr><name>ofBits</name> <operator>-</operator> <name>extraBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>BIT_addBits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockStream</name></expr></argument>, <argument><expr><name><name>sequences</name><index>[<expr><name>nbSeq</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>offBase</name></expr></argument>, <argument><expr><name><name>ofCodeTable</name><index>[<expr><name>nbSeq</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>BIT_flushBits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockStream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>n</name><operator>=</operator><name>nbSeq</name><operator>-</operator><literal type="number">2</literal></expr> ;</init> <condition><expr><name>n</name><operator>&lt;</operator><name>nbSeq</name></expr> ;</condition> <incr><expr><name>n</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>      <comment type="block">/* intentional underflow */</comment>
            <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier></type> <name>llCode</name> <init>= <expr><name><name>llCodeTable</name><index>[<expr><name>n</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier></type> <name>ofCode</name> <init>= <expr><name><name>ofCodeTable</name><index>[<expr><name>n</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier></type> <name>mlCode</name> <init>= <expr><name><name>mlCodeTable</name><index>[<expr><name>n</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name>  <specifier>const</specifier></type> <name>llBits</name> <init>= <expr><name><name>LL_bits</name><index>[<expr><name>llCode</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name>  <specifier>const</specifier></type> <name>ofBits</name> <init>= <expr><name>ofCode</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name>  <specifier>const</specifier></type> <name>mlBits</name> <init>= <expr><name><name>ML_bits</name><index>[<expr><name>mlCode</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"encoding: litlen:%2u - matchlen:%2u - offCode:%7u"</literal></expr></argument>,
                        <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>sequences</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>litLength</name></expr></argument>,
                        <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>sequences</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>mlBase</name> <operator>+</operator> <name>MINMATCH</name></expr></argument>,
                        <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>sequences</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>offBase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                                                            <comment type="block">/* 32b*/</comment>  <comment type="block">/* 64b*/</comment>
                                                                            <comment type="block">/* (7)*/</comment>  <comment type="block">/* (7)*/</comment>
            <expr_stmt><expr><call><name>FSE_encodeSymbol</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockStream</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stateOffsetBits</name></expr></argument>, <argument><expr><name>ofCode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>       <comment type="block">/* 15 */</comment>  <comment type="block">/* 15 */</comment>
            <expr_stmt><expr><call><name>FSE_encodeSymbol</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockStream</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stateMatchLength</name></expr></argument>, <argument><expr><name>mlCode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>      <comment type="block">/* 24 */</comment>  <comment type="block">/* 24 */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>MEM_32bits</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>BIT_flushBits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockStream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>                  <comment type="block">/* (7)*/</comment>
            <expr_stmt><expr><call><name>FSE_encodeSymbol</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockStream</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stateLitLength</name></expr></argument>, <argument><expr><name>llCode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* 16 */</comment>  <comment type="block">/* 33 */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>MEM_32bits</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>(</operator><name>ofBits</name><operator>+</operator><name>mlBits</name><operator>+</operator><name>llBits</name> <operator>&gt;=</operator> <literal type="number">64</literal><operator>-</operator><literal type="number">7</literal><operator>-</operator><operator>(</operator><name>LLFSELog</name><operator>+</operator><name>MLFSELog</name><operator>+</operator><name>OffFSELog</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>BIT_flushBits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockStream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>                                <comment type="block">/* (7)*/</comment>
            <expr_stmt><expr><call><name>BIT_addBits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockStream</name></expr></argument>, <argument><expr><name><name>sequences</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>litLength</name></expr></argument>, <argument><expr><name>llBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>MEM_32bits</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>llBits</name><operator>+</operator><name>mlBits</name><operator>)</operator><operator>&gt;</operator><literal type="number">24</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>BIT_flushBits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockStream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>BIT_addBits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockStream</name></expr></argument>, <argument><expr><name><name>sequences</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>mlBase</name></expr></argument>, <argument><expr><name>mlBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>MEM_32bits</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>(</operator><name>ofBits</name><operator>+</operator><name>mlBits</name><operator>+</operator><name>llBits</name> <operator>&gt;</operator> <literal type="number">56</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>BIT_flushBits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockStream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>longOffsets</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>extraBits</name> <init>= <expr><name>ofBits</name> <operator>-</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>ofBits</name></expr></argument>, <argument><expr><name>STREAM_ACCUMULATOR_MIN</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>extraBits</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>BIT_addBits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockStream</name></expr></argument>, <argument><expr><name><name>sequences</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>offBase</name></expr></argument>, <argument><expr><name>extraBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>BIT_flushBits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockStream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                            <comment type="block">/* (7)*/</comment>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name>BIT_addBits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockStream</name></expr></argument>, <argument><expr><name><name>sequences</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>offBase</name> <operator>&gt;&gt;</operator> <name>extraBits</name></expr></argument>,
                            <argument><expr><name>ofBits</name> <operator>-</operator> <name>extraBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                            <comment type="block">/* 31 */</comment>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>BIT_addBits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockStream</name></expr></argument>, <argument><expr><name><name>sequences</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>offBase</name></expr></argument>, <argument><expr><name>ofBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>     <comment type="block">/* 31 */</comment>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><call><name>BIT_flushBits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockStream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                    <comment type="block">/* (7)*/</comment>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"remaining space : %i"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>blockStream</name><operator>.</operator><name>endPtr</name></name> <operator>-</operator> <name><name>blockStream</name><operator>.</operator><name>ptr</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>   </block_content>}</block>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_encodeSequences: flushing ML state with %u bits"</literal></expr></argument>, <argument><expr><name><name>stateMatchLength</name><operator>.</operator><name>stateLog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FSE_flushCState</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockStream</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stateMatchLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_encodeSequences: flushing Off state with %u bits"</literal></expr></argument>, <argument><expr><name><name>stateOffsetBits</name><operator>.</operator><name>stateLog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FSE_flushCState</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockStream</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stateOffsetBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_encodeSequences: flushing LL state with %u bits"</literal></expr></argument>, <argument><expr><name><name>stateLitLength</name><operator>.</operator><name>stateLog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FSE_flushCState</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockStream</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stateLitLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>streamSize</name> <init>= <expr><call><name>BIT_closeCStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockStream</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>streamSize</name><operator>==</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">"not enough space"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>streamSize</name></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>ZSTD_encodeSequences_default</name><parameter_list>(
            <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
            <parameter><decl><type><name>FSE_CTable</name> <specifier>const</specifier><modifier>*</modifier></type> <name>CTable_MatchLength</name></decl></parameter>, <parameter><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>mlCodeTable</name></decl></parameter>,
            <parameter><decl><type><name>FSE_CTable</name> <specifier>const</specifier><modifier>*</modifier></type> <name>CTable_OffsetBits</name></decl></parameter>, <parameter><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>ofCodeTable</name></decl></parameter>,
            <parameter><decl><type><name>FSE_CTable</name> <specifier>const</specifier><modifier>*</modifier></type> <name>CTable_LitLength</name></decl></parameter>, <parameter><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>llCodeTable</name></decl></parameter>,
            <parameter><decl><type><name>seqDef</name> <specifier>const</specifier><modifier>*</modifier></type> <name>sequences</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nbSeq</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>longOffsets</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_encodeSequences_body</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>,
                                    <argument><expr><name>CTable_MatchLength</name></expr></argument>, <argument><expr><name>mlCodeTable</name></expr></argument>,
                                    <argument><expr><name>CTable_OffsetBits</name></expr></argument>, <argument><expr><name>ofCodeTable</name></expr></argument>,
                                    <argument><expr><name>CTable_LitLength</name></expr></argument>, <argument><expr><name>llCodeTable</name></expr></argument>,
                                    <argument><expr><name>sequences</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>longOffsets</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DYNAMIC_BMI2</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>BMI2_TARGET_ATTRIBUTE</name> <name>size_t</name></type>
<name>ZSTD_encodeSequences_bmi2</name><parameter_list>(
            <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
            <parameter><decl><type><name>FSE_CTable</name> <specifier>const</specifier><modifier>*</modifier></type> <name>CTable_MatchLength</name></decl></parameter>, <parameter><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>mlCodeTable</name></decl></parameter>,
            <parameter><decl><type><name>FSE_CTable</name> <specifier>const</specifier><modifier>*</modifier></type> <name>CTable_OffsetBits</name></decl></parameter>, <parameter><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>ofCodeTable</name></decl></parameter>,
            <parameter><decl><type><name>FSE_CTable</name> <specifier>const</specifier><modifier>*</modifier></type> <name>CTable_LitLength</name></decl></parameter>, <parameter><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>llCodeTable</name></decl></parameter>,
            <parameter><decl><type><name>seqDef</name> <specifier>const</specifier><modifier>*</modifier></type> <name>sequences</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nbSeq</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>longOffsets</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_encodeSequences_body</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>,
                                    <argument><expr><name>CTable_MatchLength</name></expr></argument>, <argument><expr><name>mlCodeTable</name></expr></argument>,
                                    <argument><expr><name>CTable_OffsetBits</name></expr></argument>, <argument><expr><name>ofCodeTable</name></expr></argument>,
                                    <argument><expr><name>CTable_LitLength</name></expr></argument>, <argument><expr><name>llCodeTable</name></expr></argument>,
                                    <argument><expr><name>sequences</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>longOffsets</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>size_t</name></type> <name>ZSTD_encodeSequences</name><parameter_list>(
            <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
            <parameter><decl><type><name>FSE_CTable</name> <specifier>const</specifier><modifier>*</modifier></type> <name>CTable_MatchLength</name></decl></parameter>, <parameter><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>mlCodeTable</name></decl></parameter>,
            <parameter><decl><type><name>FSE_CTable</name> <specifier>const</specifier><modifier>*</modifier></type> <name>CTable_OffsetBits</name></decl></parameter>, <parameter><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>ofCodeTable</name></decl></parameter>,
            <parameter><decl><type><name>FSE_CTable</name> <specifier>const</specifier><modifier>*</modifier></type> <name>CTable_LitLength</name></decl></parameter>, <parameter><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>llCodeTable</name></decl></parameter>,
            <parameter><decl><type><name>seqDef</name> <specifier>const</specifier><modifier>*</modifier></type> <name>sequences</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nbSeq</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>longOffsets</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bmi2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_encodeSequences: dstCapacity = %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>dstCapacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DYNAMIC_BMI2</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name>bmi2</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>ZSTD_encodeSequences_bmi2</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>,
                                         <argument><expr><name>CTable_MatchLength</name></expr></argument>, <argument><expr><name>mlCodeTable</name></expr></argument>,
                                         <argument><expr><name>CTable_OffsetBits</name></expr></argument>, <argument><expr><name>ofCodeTable</name></expr></argument>,
                                         <argument><expr><name>CTable_LitLength</name></expr></argument>, <argument><expr><name>llCodeTable</name></expr></argument>,
                                         <argument><expr><name>sequences</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>longOffsets</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>bmi2</name></expr>;</expr_stmt>
    <return>return <expr><call><name>ZSTD_encodeSequences_default</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>,
                                        <argument><expr><name>CTable_MatchLength</name></expr></argument>, <argument><expr><name>mlCodeTable</name></expr></argument>,
                                        <argument><expr><name>CTable_OffsetBits</name></expr></argument>, <argument><expr><name>ofCodeTable</name></expr></argument>,
                                        <argument><expr><name>CTable_LitLength</name></expr></argument>, <argument><expr><name>llCodeTable</name></expr></argument>,
                                        <argument><expr><name>sequences</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>longOffsets</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
