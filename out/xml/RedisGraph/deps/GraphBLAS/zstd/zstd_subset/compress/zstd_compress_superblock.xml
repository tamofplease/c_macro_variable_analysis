<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/zstd/zstd_subset/compress/zstd_compress_superblock.c"><comment type="block">/*
 * Copyright (c) Yann Collet, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
 */</comment>

 <comment type="block">/*-*************************************
 *  Dependencies
 ***************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_compress_superblock.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/zstd_internal.h"</cpp:file></cpp:include>  <comment type="block">/* ZSTD_getSequenceLength */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hist.h"</cpp:file></cpp:include>                     <comment type="block">/* HIST_countFast_wksp */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_compress_internal.h"</cpp:file></cpp:include>   <comment type="block">/* ZSTD_[huf|fse|entropy]CTablesMetadata_t */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_compress_sequences.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_compress_literals.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/** ZSTD_compressSubBlock_literal() :
 *  Compresses literals section for a sub-block.
 *  When we have to write the Huffman table we will sometimes choose a header
 *  size larger than necessary. This is because we have to pick the header size
 *  before we know the table size + compressed size, so we have a bound on the
 *  table size. If we guessed incorrectly, we fall back to uncompressed literals.
 *
 *  We write the header when writeEntropy=1 and set entropyWritten=1 when we succeeded
 *  in writing the header, otherwise it is set to 0.
 *
 *  hufMetadata-&gt;hType has literals block type info.
 *      If it is set_basic, all sub-blocks literals section will be Raw_Literals_Block.
 *      If it is set_rle, all sub-blocks literals section will be RLE_Literals_Block.
 *      If it is set_compressed, first sub-block's literals section will be Compressed_Literals_Block
 *      If it is set_compressed, first sub-block's literals section will be Treeless_Literals_Block
 *      and the following sub-blocks' literals sections will be Treeless_Literals_Block.
 *  @return : compressed size of literals section of a sub-block
 *            Or 0 if unable to compress.
 *            Or error code */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>ZSTD_compressSubBlock_literal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>HUF_CElt</name><modifier>*</modifier></type> <name>hufTable</name></decl></parameter>,
                              <parameter><decl><type><specifier>const</specifier> <name>ZSTD_hufCTablesMetadata_t</name><modifier>*</modifier></type> <name>hufMetadata</name></decl></parameter>,
                              <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>literals</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>litSize</name></decl></parameter>,
                              <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
                              <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>bmi2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>writeEntropy</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>entropyWritten</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>header</name> <init>= <expr><ternary><condition><expr><name>writeEntropy</name></expr> ?</condition><then> <expr><literal type="number">200</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>lhSize</name> <init>= <expr><literal type="number">3</literal> <operator>+</operator> <operator>(</operator><name>litSize</name> <operator>&gt;=</operator> <operator>(</operator><literal type="number">1</literal> <name>KB</name> <operator>-</operator> <name>header</name><operator>)</operator><operator>)</operator> <operator>+</operator> <operator>(</operator><name>litSize</name> <operator>&gt;=</operator> <operator>(</operator><literal type="number">16</literal> <name>KB</name> <operator>-</operator> <name>header</name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ostart</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend</name> <init>= <expr><name>ostart</name> <operator>+</operator> <name>dstSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><name>ostart</name> <operator>+</operator> <name>lhSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>singleStream</name> <init>= <expr><name>lhSize</name> <operator>==</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>symbolEncodingType_e</name></type> <name>hType</name> <init>= <expr><ternary><condition><expr><name>writeEntropy</name></expr> ?</condition><then> <expr><name><name>hufMetadata</name><operator>-&gt;</operator><name>hType</name></name></expr> </then><else>: <expr><name>set_repeat</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>cLitSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>bmi2</name></expr>;</expr_stmt> <comment type="block">/* TODO bmi2... */</comment>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressSubBlock_literal (litSize=%zu, lhSize=%zu, writeEntropy=%d)"</literal></expr></argument>, <argument><expr><name>litSize</name></expr></argument>, <argument><expr><name>lhSize</name></expr></argument>, <argument><expr><name>writeEntropy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>entropyWritten</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>litSize</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>hufMetadata</name><operator>-&gt;</operator><name>hType</name></name> <operator>==</operator> <name>set_basic</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressSubBlock_literal using raw literal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>ZSTD_noCompressLiterals</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>literals</name></expr></argument>, <argument><expr><name>litSize</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>hufMetadata</name><operator>-&gt;</operator><name>hType</name></name> <operator>==</operator> <name>set_rle</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressSubBlock_literal using rle literal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>ZSTD_compressRleLiteralsBlock</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>literals</name></expr></argument>, <argument><expr><name>litSize</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>litSize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>hufMetadata</name><operator>-&gt;</operator><name>hType</name></name> <operator>==</operator> <name>set_compressed</name> <operator>||</operator> <name><name>hufMetadata</name><operator>-&gt;</operator><name>hType</name></name> <operator>==</operator> <name>set_repeat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>writeEntropy</name> <operator>&amp;&amp;</operator> <name><name>hufMetadata</name><operator>-&gt;</operator><name>hType</name></name> <operator>==</operator> <name>set_compressed</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name><name>hufMetadata</name><operator>-&gt;</operator><name>hufDesBuffer</name></name></expr></argument>, <argument><expr><name><name>hufMetadata</name><operator>-&gt;</operator><name>hufDesSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> <operator>+=</operator> <name><name>hufMetadata</name><operator>-&gt;</operator><name>hufDesSize</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>cLitSize</name> <operator>+=</operator> <name><name>hufMetadata</name><operator>-&gt;</operator><name>hufDesSize</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressSubBlock_literal (hSize=%zu)"</literal></expr></argument>, <argument><expr><name><name>hufMetadata</name><operator>-&gt;</operator><name>hufDesSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* TODO bmi2 */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>cSize</name> <init>= <expr><ternary><condition><expr><name>singleStream</name></expr> ?</condition><then> <expr><call><name>HUF_compress1X_usingCTable</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name><operator>-</operator><name>op</name></expr></argument>, <argument><expr><name>literals</name></expr></argument>, <argument><expr><name>litSize</name></expr></argument>, <argument><expr><name>hufTable</name></expr></argument>)</argument_list></call></expr>
                                          </then><else>: <expr><call><name>HUF_compress4X_usingCTable</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name><operator>-</operator><name>op</name></expr></argument>, <argument><expr><name>literals</name></expr></argument>, <argument><expr><name>litSize</name></expr></argument>, <argument><expr><name>hufTable</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>cSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>cLitSize</name> <operator>+=</operator> <name>cSize</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>cSize</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>ERR_isError</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Failed to write entropy tables %s"</literal></expr></argument>, <argument><expr><call><name>ZSTD_getErrorName</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* If we expand and we aren't writing a header then emit uncompressed */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>writeEntropy</name> <operator>&amp;&amp;</operator> <name>cLitSize</name> <operator>&gt;=</operator> <name>litSize</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressSubBlock_literal using raw literal because uncompressible"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name>ZSTD_noCompressLiterals</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>literals</name></expr></argument>, <argument><expr><name>litSize</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* If we are writing headers then allow expansion that doesn't change our header size. */</comment>
        <if_stmt><if>if <condition>(<expr><name>lhSize</name> <operator>&lt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><literal type="number">3</literal> <operator>+</operator> <operator>(</operator><name>cLitSize</name> <operator>&gt;=</operator> <literal type="number">1</literal> <name>KB</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>cLitSize</name> <operator>&gt;=</operator> <literal type="number">16</literal> <name>KB</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>cLitSize</name> <operator>&gt;</operator> <name>litSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Literals expanded beyond allowed header size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name>ZSTD_noCompressLiterals</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>literals</name></expr></argument>, <argument><expr><name>litSize</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressSubBlock_literal (cSize=%zu)"</literal></expr></argument>, <argument><expr><name>cSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* Build header */</comment>
    <switch>switch<condition>(<expr><name>lhSize</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><literal type="number">3</literal></expr>:</case> <comment type="block">/* 2 - 2 - 10 - 10 */</comment>
        <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>lhc</name> <init>= <expr><name>hType</name> <operator>+</operator> <operator>(</operator><operator>(</operator><operator>!</operator><name>singleStream</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><name>litSize</name><operator>&lt;&lt;</operator><literal type="number">4</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><name>cLitSize</name><operator>&lt;&lt;</operator><literal type="number">14</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>MEM_writeLE24</name><argument_list>(<argument><expr><name>ostart</name></expr></argument>, <argument><expr><name>lhc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>
    <case>case <expr><literal type="number">4</literal></expr>:</case> <comment type="block">/* 2 - 2 - 14 - 14 */</comment>
        <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>lhc</name> <init>= <expr><name>hType</name> <operator>+</operator> <operator>(</operator><literal type="number">2</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><name>litSize</name><operator>&lt;&lt;</operator><literal type="number">4</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><name>cLitSize</name><operator>&lt;&lt;</operator><literal type="number">18</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>MEM_writeLE32</name><argument_list>(<argument><expr><name>ostart</name></expr></argument>, <argument><expr><name>lhc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>
    <case>case <expr><literal type="number">5</literal></expr>:</case> <comment type="block">/* 2 - 2 - 18 - 18 */</comment>
        <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>lhc</name> <init>= <expr><name>hType</name> <operator>+</operator> <operator>(</operator><literal type="number">3</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><name>litSize</name><operator>&lt;&lt;</operator><literal type="number">4</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><name>cLitSize</name><operator>&lt;&lt;</operator><literal type="number">22</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>MEM_writeLE32</name><argument_list>(<argument><expr><name>ostart</name></expr></argument>, <argument><expr><name>lhc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ostart</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><operator>(</operator><name>cLitSize</name> <operator>&gt;&gt;</operator> <literal type="number">10</literal><operator>)</operator></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>
    <default>default:</default>  <comment type="block">/* not possible : lhSize is {3,4,5} */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
    <expr_stmt><expr><operator>*</operator><name>entropyWritten</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Compressed literals: %u -&gt; %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>litSize</name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>op</name><operator>-</operator><name>ostart</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>op</name><operator>-</operator><name>ostart</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>ZSTD_seqDecompressedSize</name><parameter_list>(<parameter><decl><type><name>seqStore_t</name> <specifier>const</specifier><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>,
                   <parameter><decl><type><specifier>const</specifier> <name>seqDef</name><modifier>*</modifier></type> <name>sequences</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nbSeq</name></decl></parameter>,
                         <parameter><decl><type><name>size_t</name></type> <name>litSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lastSequence</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>seqDef</name><modifier>*</modifier> <specifier>const</specifier></type> <name>sstart</name> <init>= <expr><name>sequences</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>seqDef</name><modifier>*</modifier> <specifier>const</specifier></type> <name>send</name> <init>= <expr><name>sequences</name> <operator>+</operator> <name>nbSeq</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>seqDef</name><modifier>*</modifier></type> <name>sp</name> <init>= <expr><name>sstart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>matchLengthSum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>litLengthSum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><operator>(</operator><name>litLengthSum</name><operator>)</operator></expr>;</expr_stmt> <comment type="block">/* suppress unused variable warning on some environments */</comment>
    <while>while <condition>(<expr><name>send</name><operator>-</operator><name>sp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>ZSTD_sequenceLength</name> <specifier>const</specifier></type> <name>seqLen</name> <init>= <expr><call><name>ZSTD_getSequenceLength</name><argument_list>(<argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>litLengthSum</name> <operator>+=</operator> <name><name>seqLen</name><operator>.</operator><name>litLength</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>matchLengthSum</name> <operator>+=</operator> <name><name>seqLen</name><operator>.</operator><name>matchLength</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sp</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>litLengthSum</name> <operator>&lt;=</operator> <name>litSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>lastSequence</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>litLengthSum</name> <operator>==</operator> <name>litSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>matchLengthSum</name> <operator>+</operator> <name>litSize</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** ZSTD_compressSubBlock_sequences() :
 *  Compresses sequences section for a sub-block.
 *  fseMetadata-&gt;llType, fseMetadata-&gt;ofType, and fseMetadata-&gt;mlType have
 *  symbol compression modes for the super-block.
 *  The first successfully compressed block will have these in its header.
 *  We set entropyWritten=1 when we succeed in compressing the sequences.
 *  The following sub-blocks will always have repeat mode.
 *  @return : compressed size of sequences section of a sub-block
 *            Or 0 if it is unable to compress
 *            Or error code. */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>ZSTD_compressSubBlock_sequences</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ZSTD_fseCTables_t</name><modifier>*</modifier></type> <name>fseTables</name></decl></parameter>,
                                <parameter><decl><type><specifier>const</specifier> <name>ZSTD_fseCTablesMetadata_t</name><modifier>*</modifier></type> <name>fseMetadata</name></decl></parameter>,
                                <parameter><decl><type><specifier>const</specifier> <name>seqDef</name><modifier>*</modifier></type> <name>sequences</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nbSeq</name></decl></parameter>,
                                <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>llCode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>mlCode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ofCode</name></decl></parameter>,
                                <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>cctxParams</name></decl></parameter>,
                                <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                                <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>bmi2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>writeEntropy</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>entropyWritten</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>longOffsets</name> <init>= <expr><name><name>cctxParams</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>windowLog</name></name> <operator>&gt;</operator> <name>STREAM_ACCUMULATOR_MIN</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ostart</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend</name> <init>= <expr><name>ostart</name> <operator>+</operator> <name>dstCapacity</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><name>ostart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>seqHead</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressSubBlock_sequences (nbSeq=%zu, writeEntropy=%d, longOffsets=%d)"</literal></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>writeEntropy</name></expr></argument>, <argument><expr><name>longOffsets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>entropyWritten</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <comment type="block">/* Sequences Header */</comment>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><operator>(</operator><name>oend</name><operator>-</operator><name>op</name><operator>)</operator> <operator>&lt;</operator> <literal type="number">3</literal> <comment type="block">/*max nbSeq Size*/</comment> <operator>+</operator> <literal type="number">1</literal></expr></argument> <comment type="block">/*seqHead*/</comment>,
                    <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nbSeq</name> <operator>&lt;</operator> <literal type="number">0x7F</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>op</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><name>nbSeq</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>nbSeq</name> <operator>&lt;</operator> <name>LONGNBSEQ</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><operator>(</operator><operator>(</operator><name>nbSeq</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator> <operator>+</operator> <literal type="number">0x80</literal><operator>)</operator></expr><operator>,</operator> <expr><name><name>op</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><name>nbSeq</name></expr><operator>,</operator> <expr><name>op</name><operator>+=</operator><literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>=</operator><literal type="number">0xFF</literal></expr><operator>,</operator> <expr><call><name>MEM_writeLE16</name><argument_list>(<argument><expr><name>op</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>U16</name><operator>)</operator><operator>(</operator><name>nbSeq</name> <operator>-</operator> <name>LONGNBSEQ</name><operator>)</operator></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><name>op</name><operator>+=</operator><literal type="number">3</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>nbSeq</name><operator>==</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>op</name> <operator>-</operator> <name>ostart</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* seqHead : flags for FSE encoding type */</comment>
    <expr_stmt><expr><name>seqHead</name> <operator>=</operator> <name>op</name><operator>++</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressSubBlock_sequences (seqHeadSize=%u)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name>op</name><operator>-</operator><name>ostart</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>writeEntropy</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>LLtype</name> <init>= <expr><name><name>fseMetadata</name><operator>-&gt;</operator><name>llType</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>Offtype</name> <init>= <expr><name><name>fseMetadata</name><operator>-&gt;</operator><name>ofType</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>MLtype</name> <init>= <expr><name><name>fseMetadata</name><operator>-&gt;</operator><name>mlType</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressSubBlock_sequences (fseTablesSize=%zu)"</literal></expr></argument>, <argument><expr><name><name>fseMetadata</name><operator>-&gt;</operator><name>fseTablesSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>seqHead</name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><operator>(</operator><operator>(</operator><name>LLtype</name><operator>&lt;&lt;</operator><literal type="number">6</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>Offtype</name><operator>&lt;&lt;</operator><literal type="number">4</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>MLtype</name><operator>&lt;&lt;</operator><literal type="number">2</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name><name>fseMetadata</name><operator>-&gt;</operator><name>fseTablesBuffer</name></name></expr></argument>, <argument><expr><name><name>fseMetadata</name><operator>-&gt;</operator><name>fseTablesSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> <operator>+=</operator> <name><name>fseMetadata</name><operator>-&gt;</operator><name>fseTablesSize</name></name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>repeat</name> <init>= <expr><name>set_repeat</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><operator>*</operator><name>seqHead</name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><operator>(</operator><operator>(</operator><name>repeat</name><operator>&lt;&lt;</operator><literal type="number">6</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>repeat</name><operator>&lt;&lt;</operator><literal type="number">4</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>repeat</name><operator>&lt;&lt;</operator><literal type="number">2</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>bitstreamSize</name> <init>= <expr><call><name>ZSTD_encodeSequences</name><argument_list>(
                                        <argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name> <operator>-</operator> <name>op</name></expr></argument>,
                                        <argument><expr><name><name>fseTables</name><operator>-&gt;</operator><name>matchlengthCTable</name></name></expr></argument>, <argument><expr><name>mlCode</name></expr></argument>,
                                        <argument><expr><name><name>fseTables</name><operator>-&gt;</operator><name>offcodeCTable</name></name></expr></argument>, <argument><expr><name>ofCode</name></expr></argument>,
                                        <argument><expr><name><name>fseTables</name><operator>-&gt;</operator><name>litlengthCTable</name></name></expr></argument>, <argument><expr><name>llCode</name></expr></argument>,
                                        <argument><expr><name>sequences</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>,
                                        <argument><expr><name>longOffsets</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>bitstreamSize</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_encodeSequences failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>bitstreamSize</name></expr>;</expr_stmt>
        <comment type="block">/* zstd versions &lt;= 1.3.4 mistakenly report corruption when
         * FSE_readNCount() receives a buffer &lt; 4 bytes.
         * Fixed by https://github.com/facebook/zstd/pull/1146.
         * This can happen when the last set_compressed table present is 2
         * bytes and the bitstream is only one byte.
         * In this exceedingly rare case, we will simply emit an uncompressed
         * block, since it isn't worth optimizing.
         */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION</name></cpp:ifndef>
        <if_stmt><if>if <condition>(<expr><name>writeEntropy</name> <operator>&amp;&amp;</operator> <name><name>fseMetadata</name><operator>-&gt;</operator><name>lastCountSize</name></name> <operator>&amp;&amp;</operator> <name><name>fseMetadata</name><operator>-&gt;</operator><name>lastCountSize</name></name> <operator>+</operator> <name>bitstreamSize</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* NCountSize &gt;= 2 &amp;&amp; bitstreamSize &gt; 0 ==&gt; lastCountSize == 3 */</comment>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>fseMetadata</name><operator>-&gt;</operator><name>lastCountSize</name></name> <operator>+</operator> <name>bitstreamSize</name> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Avoiding bug in zstd decoder in versions &lt;= 1.3.4 by "</literal>
                        <literal type="string">"emitting an uncompressed block."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressSubBlock_sequences (bitstreamSize=%zu)"</literal></expr></argument>, <argument><expr><name>bitstreamSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* zstd versions &lt;= 1.4.0 mistakenly report error when
     * sequences section body size is less than 3 bytes.
     * Fixed by https://github.com/facebook/zstd/pull/1664.
     * This can happen when the previous sequences section block is compressed
     * with rle mode and the current block's sequences section is compressed
     * with repeat mode where sequences section body size can be 1 byte.
     */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION</name></cpp:ifndef>
    <if_stmt><if>if <condition>(<expr><name>op</name><operator>-</operator><name>seqHead</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Avoiding bug in zstd decoder in versions &lt;= 1.4.0 by emitting "</literal>
                    <literal type="string">"an uncompressed block when sequences are &lt; 4 bytes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><operator>*</operator><name>entropyWritten</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><name>op</name> <operator>-</operator> <name>ostart</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** ZSTD_compressSubBlock() :
 *  Compresses a single sub-block.
 *  @return : compressed size of the sub-block
 *            Or 0 if it failed to compress. */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_compressSubBlock</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ZSTD_entropyCTables_t</name><modifier>*</modifier></type> <name>entropy</name></decl></parameter>,
                                    <parameter><decl><type><specifier>const</specifier> <name>ZSTD_entropyCTablesMetadata_t</name><modifier>*</modifier></type> <name>entropyMetadata</name></decl></parameter>,
                                    <parameter><decl><type><specifier>const</specifier> <name>seqDef</name><modifier>*</modifier></type> <name>sequences</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nbSeq</name></decl></parameter>,
                                    <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>literals</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>litSize</name></decl></parameter>,
                                    <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>llCode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>mlCode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ofCode</name></decl></parameter>,
                                    <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>cctxParams</name></decl></parameter>,
                                    <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                                    <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>bmi2</name></decl></parameter>,
                                    <parameter><decl><type><name>int</name></type> <name>writeLitEntropy</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>writeSeqEntropy</name></decl></parameter>,
                                    <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>litEntropyWritten</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>seqEntropyWritten</name></decl></parameter>,
                                    <parameter><decl><type><name>U32</name></type> <name>lastBlock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ostart</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend</name> <init>= <expr><name>ostart</name> <operator>+</operator> <name>dstCapacity</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><name>ostart</name> <operator>+</operator> <name>ZSTD_blockHeaderSize</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressSubBlock (litSize=%zu, nbSeq=%zu, writeLitEntropy=%d, writeSeqEntropy=%d, lastBlock=%d)"</literal></expr></argument>,
                <argument><expr><name>litSize</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>writeLitEntropy</name></expr></argument>, <argument><expr><name>writeSeqEntropy</name></expr></argument>, <argument><expr><name>lastBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name></type> <name>cLitSize</name> <init>= <expr><call><name>ZSTD_compressSubBlock_literal</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>HUF_CElt</name><operator>*</operator><operator>)</operator><name><name>entropy</name><operator>-&gt;</operator><name>huf</name><operator>.</operator><name>CTable</name></name></expr></argument>,
                                                        <argument><expr><operator>&amp;</operator><name><name>entropyMetadata</name><operator>-&gt;</operator><name>hufMetadata</name></name></expr></argument>, <argument><expr><name>literals</name></expr></argument>, <argument><expr><name>litSize</name></expr></argument>,
                                                        <argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name><operator>-</operator><name>op</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>, <argument><expr><name>writeLitEntropy</name></expr></argument>, <argument><expr><name>litEntropyWritten</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>cLitSize</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressSubBlock_literal failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>cLitSize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>cLitSize</name></expr>;</expr_stmt>
    </block_content>}</block>
    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name></type> <name>cSeqSize</name> <init>= <expr><call><name>ZSTD_compressSubBlock_sequences</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entropy</name><operator>-&gt;</operator><name>fse</name></name></expr></argument>,
                                                  <argument><expr><operator>&amp;</operator><name><name>entropyMetadata</name><operator>-&gt;</operator><name>fseMetadata</name></name></expr></argument>,
                                                  <argument><expr><name>sequences</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>,
                                                  <argument><expr><name>llCode</name></expr></argument>, <argument><expr><name>mlCode</name></expr></argument>, <argument><expr><name>ofCode</name></expr></argument>,
                                                  <argument><expr><name>cctxParams</name></expr></argument>,
                                                  <argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name><operator>-</operator><name>op</name></expr></argument>,
                                                  <argument><expr><name>bmi2</name></expr></argument>, <argument><expr><name>writeSeqEntropy</name></expr></argument>, <argument><expr><name>seqEntropyWritten</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>cSeqSize</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressSubBlock_sequences failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>cSeqSize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>cSeqSize</name></expr>;</expr_stmt>
    </block_content>}</block>
    <comment type="block">/* Write block header */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name></type> <name>cSize</name> <init>= <expr><operator>(</operator><name>op</name><operator>-</operator><name>ostart</name><operator>)</operator><operator>-</operator><name>ZSTD_blockHeaderSize</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>cBlockHeader24</name> <init>= <expr><name>lastBlock</name> <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><name>bt_compressed</name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">1</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>cSize</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>MEM_writeLE24</name><argument_list>(<argument><expr><name>ostart</name></expr></argument>, <argument><expr><name>cBlockHeader24</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <return>return <expr><name>op</name><operator>-</operator><name>ostart</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_estimateSubBlockSize_literal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>literals</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>litSize</name></decl></parameter>,
                                                <parameter><decl><type><specifier>const</specifier> <name>ZSTD_hufCTables_t</name><modifier>*</modifier></type> <name>huf</name></decl></parameter>,
                                                <parameter><decl><type><specifier>const</specifier> <name>ZSTD_hufCTablesMetadata_t</name><modifier>*</modifier></type> <name>hufMetadata</name></decl></parameter>,
                                                <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workspace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>,
                                                <parameter><decl><type><name>int</name></type> <name>writeEntropy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name><modifier>*</modifier> <specifier>const</specifier></type> <name>countWksp</name> <init>= <expr><operator>(</operator><name>unsigned</name><operator>*</operator><operator>)</operator><name>workspace</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>maxSymbolValue</name> <init>= <expr><literal type="number">255</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>literalSectionHeaderSize</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Use hard coded size of 3 bytes */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>hufMetadata</name><operator>-&gt;</operator><name>hType</name></name> <operator>==</operator> <name>set_basic</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>litSize</name></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>hufMetadata</name><operator>-&gt;</operator><name>hType</name></name> <operator>==</operator> <name>set_rle</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>hufMetadata</name><operator>-&gt;</operator><name>hType</name></name> <operator>==</operator> <name>set_compressed</name> <operator>||</operator> <name><name>hufMetadata</name><operator>-&gt;</operator><name>hType</name></name> <operator>==</operator> <name>set_repeat</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>largest</name> <init>= <expr><call><name>HIST_count_wksp</name> <argument_list>(<argument><expr><name>countWksp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>maxSymbolValue</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>literals</name></expr></argument>, <argument><expr><name>litSize</name></expr></argument>, <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>largest</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>litSize</name></expr>;</return></block_content></block></if></if_stmt>
        <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name></type> <name>cLitSizeEstimate</name> <init>= <expr><call><name>HUF_estimateCompressedSize</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>HUF_CElt</name><operator>*</operator><operator>)</operator><name><name>huf</name><operator>-&gt;</operator><name>CTable</name></name></expr></argument>, <argument><expr><name>countWksp</name></expr></argument>, <argument><expr><name>maxSymbolValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>writeEntropy</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cLitSizeEstimate</name> <operator>+=</operator> <name><name>hufMetadata</name><operator>-&gt;</operator><name>hufDesSize</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><name>cLitSizeEstimate</name> <operator>+</operator> <name>literalSectionHeaderSize</name></expr>;</return>
    </block_content>}</block>   </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* impossible */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_estimateSubBlockSize_symbolType</name><parameter_list>(<parameter><decl><type><name>symbolEncodingType_e</name></type> <name>type</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>codeTable</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>maxCode</name></decl></parameter>,
                        <parameter><decl><type><name>size_t</name></type> <name>nbSeq</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FSE_CTable</name><modifier>*</modifier></type> <name>fseCTable</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>U8</name><modifier>*</modifier></type> <name>additionalBits</name></decl></parameter>,
                        <parameter><decl><type><name>short</name> <specifier>const</specifier><modifier>*</modifier></type> <name>defaultNorm</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>defaultNormLog</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>defaultMax</name></decl></parameter>,
                        <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workspace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name><modifier>*</modifier> <specifier>const</specifier></type> <name>countWksp</name> <init>= <expr><operator>(</operator><name>unsigned</name><operator>*</operator><operator>)</operator><name>workspace</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ctp</name> <init>= <expr><name>codeTable</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ctStart</name> <init>= <expr><name>ctp</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ctEnd</name> <init>= <expr><name>ctStart</name> <operator>+</operator> <name>nbSeq</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>cSymbolTypeSizeEstimateInBits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>max</name> <init>= <expr><name>maxCode</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>HIST_countFast_wksp</name><argument_list>(<argument><expr><name>countWksp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>max</name></expr></argument>, <argument><expr><name>codeTable</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* can't fail */</comment>
    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>set_basic</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* We selected this encoding type, so it must be valid. */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>max</name> <operator>&lt;=</operator> <name>defaultMax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cSymbolTypeSizeEstimateInBits</name> <operator>=</operator> <ternary><condition><expr><name>max</name> <operator>&lt;=</operator> <name>defaultMax</name></expr>
                ?</condition><then> <expr><call><name>ZSTD_crossEntropyCost</name><argument_list>(<argument><expr><name>defaultNorm</name></expr></argument>, <argument><expr><name>defaultNormLog</name></expr></argument>, <argument><expr><name>countWksp</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>
                </then><else>: <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>GENERIC</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>set_rle</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>cSymbolTypeSizeEstimateInBits</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>set_compressed</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>set_repeat</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>cSymbolTypeSizeEstimateInBits</name> <operator>=</operator> <call><name>ZSTD_fseBitCost</name><argument_list>(<argument><expr><name>fseCTable</name></expr></argument>, <argument><expr><name>countWksp</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>cSymbolTypeSizeEstimateInBits</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>nbSeq</name> <operator>*</operator> <literal type="number">10</literal></expr>;</return></block_content></block></if></if_stmt>
    <while>while <condition>(<expr><name>ctp</name> <operator>&lt;</operator> <name>ctEnd</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>additionalBits</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cSymbolTypeSizeEstimateInBits</name> <operator>+=</operator> <name><name>additionalBits</name><index>[<expr><operator>*</operator><name>ctp</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>cSymbolTypeSizeEstimateInBits</name> <operator>+=</operator> <operator>*</operator><name>ctp</name></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="block">/* for offset, offset code is also the number of additional bits */</comment>
        <expr_stmt><expr><name>ctp</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>cSymbolTypeSizeEstimateInBits</name> <operator>/</operator> <literal type="number">8</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_estimateSubBlockSize_sequences</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ofCodeTable</name></decl></parameter>,
                                                  <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>llCodeTable</name></decl></parameter>,
                                                  <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>mlCodeTable</name></decl></parameter>,
                                                  <parameter><decl><type><name>size_t</name></type> <name>nbSeq</name></decl></parameter>,
                                                  <parameter><decl><type><specifier>const</specifier> <name>ZSTD_fseCTables_t</name><modifier>*</modifier></type> <name>fseTables</name></decl></parameter>,
                                                  <parameter><decl><type><specifier>const</specifier> <name>ZSTD_fseCTablesMetadata_t</name><modifier>*</modifier></type> <name>fseMetadata</name></decl></parameter>,
                                                  <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workspace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>,
                                                  <parameter><decl><type><name>int</name></type> <name>writeEntropy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>sequencesSectionHeaderSize</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Use hard coded size of 3 bytes */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>cSeqSizeEstimate</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>nbSeq</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>sequencesSectionHeaderSize</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cSeqSizeEstimate</name> <operator>+=</operator> <call><name>ZSTD_estimateSubBlockSize_symbolType</name><argument_list>(<argument><expr><name><name>fseMetadata</name><operator>-&gt;</operator><name>ofType</name></name></expr></argument>, <argument><expr><name>ofCodeTable</name></expr></argument>, <argument><expr><name>MaxOff</name></expr></argument>,
                                         <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name><name>fseTables</name><operator>-&gt;</operator><name>offcodeCTable</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                         <argument><expr><name>OF_defaultNorm</name></expr></argument>, <argument><expr><name>OF_defaultNormLog</name></expr></argument>, <argument><expr><name>DefaultMaxOff</name></expr></argument>,
                                         <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cSeqSizeEstimate</name> <operator>+=</operator> <call><name>ZSTD_estimateSubBlockSize_symbolType</name><argument_list>(<argument><expr><name><name>fseMetadata</name><operator>-&gt;</operator><name>llType</name></name></expr></argument>, <argument><expr><name>llCodeTable</name></expr></argument>, <argument><expr><name>MaxLL</name></expr></argument>,
                                         <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name><name>fseTables</name><operator>-&gt;</operator><name>litlengthCTable</name></name></expr></argument>, <argument><expr><name>LL_bits</name></expr></argument>,
                                         <argument><expr><name>LL_defaultNorm</name></expr></argument>, <argument><expr><name>LL_defaultNormLog</name></expr></argument>, <argument><expr><name>MaxLL</name></expr></argument>,
                                         <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cSeqSizeEstimate</name> <operator>+=</operator> <call><name>ZSTD_estimateSubBlockSize_symbolType</name><argument_list>(<argument><expr><name><name>fseMetadata</name><operator>-&gt;</operator><name>mlType</name></name></expr></argument>, <argument><expr><name>mlCodeTable</name></expr></argument>, <argument><expr><name>MaxML</name></expr></argument>,
                                         <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name><name>fseTables</name><operator>-&gt;</operator><name>matchlengthCTable</name></name></expr></argument>, <argument><expr><name>ML_bits</name></expr></argument>,
                                         <argument><expr><name>ML_defaultNorm</name></expr></argument>, <argument><expr><name>ML_defaultNormLog</name></expr></argument>, <argument><expr><name>MaxML</name></expr></argument>,
                                         <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>writeEntropy</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cSeqSizeEstimate</name> <operator>+=</operator> <name><name>fseMetadata</name><operator>-&gt;</operator><name>fseTablesSize</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>cSeqSizeEstimate</name> <operator>+</operator> <name>sequencesSectionHeaderSize</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_estimateSubBlockSize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>literals</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>litSize</name></decl></parameter>,
                                        <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ofCodeTable</name></decl></parameter>,
                                        <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>llCodeTable</name></decl></parameter>,
                                        <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>mlCodeTable</name></decl></parameter>,
                                        <parameter><decl><type><name>size_t</name></type> <name>nbSeq</name></decl></parameter>,
                                        <parameter><decl><type><specifier>const</specifier> <name>ZSTD_entropyCTables_t</name><modifier>*</modifier></type> <name>entropy</name></decl></parameter>,
                                        <parameter><decl><type><specifier>const</specifier> <name>ZSTD_entropyCTablesMetadata_t</name><modifier>*</modifier></type> <name>entropyMetadata</name></decl></parameter>,
                                        <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workspace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>,
                                        <parameter><decl><type><name>int</name></type> <name>writeLitEntropy</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>writeSeqEntropy</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>cSizeEstimate</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>cSizeEstimate</name> <operator>+=</operator> <call><name>ZSTD_estimateSubBlockSize_literal</name><argument_list>(<argument><expr><name>literals</name></expr></argument>, <argument><expr><name>litSize</name></expr></argument>,
                                                         <argument><expr><operator>&amp;</operator><name><name>entropy</name><operator>-&gt;</operator><name>huf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entropyMetadata</name><operator>-&gt;</operator><name>hufMetadata</name></name></expr></argument>,
                                                         <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>, <argument><expr><name>writeLitEntropy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cSizeEstimate</name> <operator>+=</operator> <call><name>ZSTD_estimateSubBlockSize_sequences</name><argument_list>(<argument><expr><name>ofCodeTable</name></expr></argument>, <argument><expr><name>llCodeTable</name></expr></argument>, <argument><expr><name>mlCodeTable</name></expr></argument>,
                                                         <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entropy</name><operator>-&gt;</operator><name>fse</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entropyMetadata</name><operator>-&gt;</operator><name>fseMetadata</name></name></expr></argument>,
                                                         <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>, <argument><expr><name>writeSeqEntropy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>cSizeEstimate</name> <operator>+</operator> <name>ZSTD_blockHeaderSize</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ZSTD_needSequenceEntropyTables</name><parameter_list>(<parameter><decl><type><name>ZSTD_fseCTablesMetadata_t</name> <specifier>const</specifier><modifier>*</modifier></type> <name>fseMetadata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>fseMetadata</name><operator>-&gt;</operator><name>llType</name></name> <operator>==</operator> <name>set_compressed</name> <operator>||</operator> <name><name>fseMetadata</name><operator>-&gt;</operator><name>llType</name></name> <operator>==</operator> <name>set_rle</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>fseMetadata</name><operator>-&gt;</operator><name>mlType</name></name> <operator>==</operator> <name>set_compressed</name> <operator>||</operator> <name><name>fseMetadata</name><operator>-&gt;</operator><name>mlType</name></name> <operator>==</operator> <name>set_rle</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>fseMetadata</name><operator>-&gt;</operator><name>ofType</name></name> <operator>==</operator> <name>set_compressed</name> <operator>||</operator> <name><name>fseMetadata</name><operator>-&gt;</operator><name>ofType</name></name> <operator>==</operator> <name>set_rle</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** ZSTD_compressSubBlock_multi() :
 *  Breaks super-block into multiple sub-blocks and compresses them.
 *  Entropy will be written to the first block.
 *  The following blocks will use repeat mode to compress.
 *  All sub-blocks are compressed blocks (no raw or rle blocks).
 *  @return : compressed size of the super block (which is multiple ZSTD blocks)
 *            Or 0 if it failed to compress. */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_compressSubBlock_multi</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>seqStore_t</name><modifier>*</modifier></type> <name>seqStorePtr</name></decl></parameter>,
                            <parameter><decl><type><specifier>const</specifier> <name>ZSTD_compressedBlockState_t</name><modifier>*</modifier></type> <name>prevCBlock</name></decl></parameter>,
                            <parameter><decl><type><name>ZSTD_compressedBlockState_t</name><modifier>*</modifier></type> <name>nextCBlock</name></decl></parameter>,
                            <parameter><decl><type><specifier>const</specifier> <name>ZSTD_entropyCTablesMetadata_t</name><modifier>*</modifier></type> <name>entropyMetadata</name></decl></parameter>,
                            <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>cctxParams</name></decl></parameter>,
                                  <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                            <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                            <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>bmi2</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>lastBlock</name></decl></parameter>,
                            <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workspace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>seqDef</name><modifier>*</modifier> <specifier>const</specifier></type> <name>sstart</name> <init>= <expr><name><name>seqStorePtr</name><operator>-&gt;</operator><name>sequencesStart</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>seqDef</name><modifier>*</modifier> <specifier>const</specifier></type> <name>send</name> <init>= <expr><name><name>seqStorePtr</name><operator>-&gt;</operator><name>sequences</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>seqDef</name><modifier>*</modifier></type> <name>sp</name> <init>= <expr><name>sstart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>lstart</name> <init>= <expr><name><name>seqStorePtr</name><operator>-&gt;</operator><name>litStart</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>lend</name> <init>= <expr><name><name>seqStorePtr</name><operator>-&gt;</operator><name>lit</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>lp</name> <init>= <expr><name>lstart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>ip</name> <init>= <expr><operator>(</operator><name>BYTE</name> <specifier>const</specifier><operator>*</operator><operator>)</operator><name>src</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name> <init>= <expr><name>ip</name> <operator>+</operator> <name>srcSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ostart</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend</name> <init>= <expr><name>ostart</name> <operator>+</operator> <name>dstCapacity</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><name>ostart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>llCodePtr</name> <init>= <expr><name><name>seqStorePtr</name><operator>-&gt;</operator><name>llCode</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>mlCodePtr</name> <init>= <expr><name><name>seqStorePtr</name><operator>-&gt;</operator><name>mlCode</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ofCodePtr</name> <init>= <expr><name><name>seqStorePtr</name><operator>-&gt;</operator><name>ofCode</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>targetCBlockSize</name> <init>= <expr><name><name>cctxParams</name><operator>-&gt;</operator><name>targetCBlockSize</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>litSize</name></decl>, <decl><type ref="prev"/><name>seqCount</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>writeLitEntropy</name> <init>= <expr><name><name>entropyMetadata</name><operator>-&gt;</operator><name>hufMetadata</name><operator>.</operator><name>hType</name></name> <operator>==</operator> <name>set_compressed</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>writeSeqEntropy</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>lastSequence</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressSubBlock_multi (litSize=%u, nbSeq=%u)"</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name>lend</name><operator>-</operator><name>lp</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name>send</name><operator>-</operator><name>sstart</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>litSize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>seqCount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <do>do <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>cBlockSizeEstimate</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>sstart</name> <operator>==</operator> <name>send</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>lastSequence</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>seqDef</name><modifier>*</modifier> <specifier>const</specifier></type> <name>sequence</name> <init>= <expr><name>sp</name> <operator>+</operator> <name>seqCount</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>lastSequence</name> <operator>=</operator> <name>sequence</name> <operator>==</operator> <name>send</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>litSize</name> <operator>+=</operator> <call><name>ZSTD_getSequenceLength</name><argument_list>(<argument><expr><name>seqStorePtr</name></expr></argument>, <argument><expr><name>sequence</name></expr></argument>)</argument_list></call><operator>.</operator><name>litLength</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>seqCount</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>lastSequence</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lp</name> <operator>&lt;=</operator> <name>lend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>litSize</name> <operator>&lt;=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>lend</name> <operator>-</operator> <name>lp</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>litSize</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>lend</name> <operator>-</operator> <name>lp</name><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* I think there is an optimization opportunity here.
         * Calling ZSTD_estimateSubBlockSize for every sequence can be wasteful
         * since it recalculates estimate from scratch.
         * For example, it would recount literal distribution and symbol codes every time.
         */</comment>
        <expr_stmt><expr><name>cBlockSizeEstimate</name> <operator>=</operator> <call><name>ZSTD_estimateSubBlockSize</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>litSize</name></expr></argument>, <argument><expr><name>ofCodePtr</name></expr></argument>, <argument><expr><name>llCodePtr</name></expr></argument>, <argument><expr><name>mlCodePtr</name></expr></argument>, <argument><expr><name>seqCount</name></expr></argument>,
                                                       <argument><expr><operator>&amp;</operator><name><name>nextCBlock</name><operator>-&gt;</operator><name>entropy</name></name></expr></argument>, <argument><expr><name>entropyMetadata</name></expr></argument>,
                                                       <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>, <argument><expr><name>writeLitEntropy</name></expr></argument>, <argument><expr><name>writeSeqEntropy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>cBlockSizeEstimate</name> <operator>&gt;</operator> <name>targetCBlockSize</name> <operator>||</operator> <name>lastSequence</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>litEntropyWritten</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>seqEntropyWritten</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>decompressedSize</name> <init>= <expr><call><name>ZSTD_seqDecompressedSize</name><argument_list>(<argument><expr><name>seqStorePtr</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>seqCount</name></expr></argument>, <argument><expr><name>litSize</name></expr></argument>, <argument><expr><name>lastSequence</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>cSize</name> <init>= <expr><call><name>ZSTD_compressSubBlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nextCBlock</name><operator>-&gt;</operator><name>entropy</name></name></expr></argument>, <argument><expr><name>entropyMetadata</name></expr></argument>,
                                                       <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>seqCount</name></expr></argument>,
                                                       <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>litSize</name></expr></argument>,
                                                       <argument><expr><name>llCodePtr</name></expr></argument>, <argument><expr><name>mlCodePtr</name></expr></argument>, <argument><expr><name>ofCodePtr</name></expr></argument>,
                                                       <argument><expr><name>cctxParams</name></expr></argument>,
                                                       <argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name><operator>-</operator><name>op</name></expr></argument>,
                                                       <argument><expr><name>bmi2</name></expr></argument>, <argument><expr><name>writeLitEntropy</name></expr></argument>, <argument><expr><name>writeSeqEntropy</name></expr></argument>,
                                                       <argument><expr><operator>&amp;</operator><name>litEntropyWritten</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seqEntropyWritten</name></expr></argument>,
                                                       <argument><expr><name>lastBlock</name> <operator>&amp;&amp;</operator> <name>lastSequence</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressSubBlock failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>cSize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>cSize</name> <operator>&lt;</operator> <name>decompressedSize</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Committed the sub-block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ip</name> <operator>+</operator> <name>decompressedSize</name> <operator>&lt;=</operator> <name>iend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>decompressedSize</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>sp</name> <operator>+=</operator> <name>seqCount</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>lp</name> <operator>+=</operator> <name>litSize</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>cSize</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>llCodePtr</name> <operator>+=</operator> <name>seqCount</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>mlCodePtr</name> <operator>+=</operator> <name>seqCount</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>ofCodePtr</name> <operator>+=</operator> <name>seqCount</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>litSize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>seqCount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <comment type="block">/* Entropy only needs to be written once */</comment>
                <if_stmt><if>if <condition>(<expr><name>litEntropyWritten</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>writeLitEntropy</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>seqEntropyWritten</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>writeSeqEntropy</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block> while <condition>(<expr><operator>!</operator><name>lastSequence</name></expr>)</condition>;</do>
    <if_stmt><if>if <condition>(<expr><name>writeLitEntropy</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressSubBlock_multi has literal entropy tables unwritten"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nextCBlock</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>huf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>prevCBlock</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>huf</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>prevCBlock</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>huf</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>writeSeqEntropy</name> <operator>&amp;&amp;</operator> <call><name>ZSTD_needSequenceEntropyTables</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entropyMetadata</name><operator>-&gt;</operator><name>fseMetadata</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="block">/* If we haven't written our entropy tables, then we've violated our contract and
         * must emit an uncompressed block.
         */</comment>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressSubBlock_multi has sequence entropy tables unwritten"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>ip</name> <operator>&lt;</operator> <name>iend</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>cSize</name> <init>= <expr><call><name>ZSTD_noCompressBlock</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name> <operator>-</operator> <name>op</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iend</name> <operator>-</operator> <name>ip</name></expr></argument>, <argument><expr><name>lastBlock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressSubBlock_multi last sub-block uncompressed, %zu bytes"</literal></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>iend</name> <operator>-</operator> <name>ip</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_noCompressBlock failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>cSize</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>cSize</name></expr>;</expr_stmt>
        <comment type="block">/* We have to regenerate the repcodes because we've skipped some sequences */</comment>
        <if_stmt><if>if <condition>(<expr><name>sp</name> <operator>&lt;</operator> <name>send</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>seqDef</name> <specifier>const</specifier><modifier>*</modifier></type> <name>seq</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>repcodes_t</name></type> <name>rep</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rep</name></expr></argument>, <argument><expr><name><name>prevCBlock</name><operator>-&gt;</operator><name>rep</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rep</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>seq</name> <operator>=</operator> <name>sstart</name></expr>;</init> <condition><expr><name>seq</name> <operator>&lt;</operator> <name>sp</name></expr>;</condition> <incr><expr><operator>++</operator><name>seq</name></expr></incr>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name>ZSTD_updateRep</name><argument_list>(<argument><expr><name><name>rep</name><operator>.</operator><name>rep</name></name></expr></argument>, <argument><expr><name><name>seq</name><operator>-&gt;</operator><name>offBase</name></name></expr></argument>, <argument><expr><call><name>ZSTD_getSequenceLength</name><argument_list>(<argument><expr><name>seqStorePtr</name></expr></argument>, <argument><expr><name>seq</name></expr></argument>)</argument_list></call><operator>.</operator><name>litLength</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name><name>nextCBlock</name><operator>-&gt;</operator><name>rep</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rep</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rep</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressSubBlock_multi compressed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>op</name><operator>-</operator><name>ostart</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressSuperBlock</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>zc</name></decl></parameter>,
                               <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                               <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                               <parameter><decl><type><name>unsigned</name></type> <name>lastBlock</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_entropyCTablesMetadata_t</name></type> <name>entropyMetadata</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_buildBlockEntropyStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>seqStore</name></name></expr></argument>,
          <argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name><operator>-&gt;</operator><name>entropy</name></name></expr></argument>,
          <argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>nextCBlock</name><operator>-&gt;</operator><name>entropy</name></name></expr></argument>,
          <argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>appliedParams</name></name></expr></argument>,
          <argument><expr><operator>&amp;</operator><name>entropyMetadata</name></expr></argument>,
          <argument><expr><name><name>zc</name><operator>-&gt;</operator><name>entropyWorkspace</name></name></expr></argument>, <argument><expr><name>ENTROPY_WORKSPACE_SIZE</name></expr></argument> <comment type="block">/* statically allocated in resetCCtx */</comment>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>ZSTD_compressSubBlock_multi</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>seqStore</name></name></expr></argument>,
            <argument><expr><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name></name></expr></argument>,
            <argument><expr><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>nextCBlock</name></name></expr></argument>,
            <argument><expr><operator>&amp;</operator><name>entropyMetadata</name></expr></argument>,
            <argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>appliedParams</name></name></expr></argument>,
            <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>,
            <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>,
            <argument><expr><name><name>zc</name><operator>-&gt;</operator><name>bmi2</name></name></expr></argument>, <argument><expr><name>lastBlock</name></expr></argument>,
            <argument><expr><name><name>zc</name><operator>-&gt;</operator><name>entropyWorkspace</name></name></expr></argument>, <argument><expr><name>ENTROPY_WORKSPACE_SIZE</name></expr></argument> <comment type="block">/* statically allocated in resetCCtx */</comment>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
