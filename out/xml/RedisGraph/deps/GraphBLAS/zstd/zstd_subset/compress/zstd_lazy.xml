<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/zstd/zstd_subset/compress/zstd_lazy.c"><comment type="block">/*
 * Copyright (c) Yann Collet, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_compress_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_lazy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/bits.h"</cpp:file></cpp:include> <comment type="block">/* ZSTD_countTrailingZeros64 */</comment>


<comment type="block">/*-*************************************
*  Binary Tree search
***************************************/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ZSTD_updateDUBT</name><parameter_list>(<parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>iend</name></decl></parameter>,
                <parameter><decl><type><name>U32</name></type> <name>mls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_compressionParameters</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cParams</name> <init>= <expr><operator>&amp;</operator><name><name>ms</name><operator>-&gt;</operator><name>cParams</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>hashTable</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>hashTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>  <specifier>const</specifier></type> <name>hashLog</name> <init>= <expr><name><name>cParams</name><operator>-&gt;</operator><name>hashLog</name></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>bt</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>chainTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>  <specifier>const</specifier></type> <name>btLog</name>  <init>= <expr><name><name>cParams</name><operator>-&gt;</operator><name>chainLog</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>  <specifier>const</specifier></type> <name>btMask</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>btLog</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>base</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>target</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>idx</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>idx</name> <operator>!=</operator> <name>target</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_updateDUBT, from %u to %u (dictLimit:%u)"</literal></expr></argument>,
                    <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictLimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ip</name> <operator>+</operator> <literal type="number">8</literal> <operator>&lt;=</operator> <name>iend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* condition for ZSTD_hashPtr */</comment>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>iend</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>idx</name> <operator>&gt;=</operator> <name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictLimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* condition for valid base+idx */</comment>
    <for>for <control>( <init>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name>target</name></expr> ;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>h</name>  <init>= <expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>base</name> <operator>+</operator> <name>idx</name></expr></argument>, <argument><expr><name>hashLog</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>   <comment type="block">/* assumption : ip + 8 &lt;= iend */</comment>
        <decl_stmt><decl><type><name>U32</name>    <specifier>const</specifier></type> <name>matchIndex</name> <init>= <expr><name><name>hashTable</name><index>[<expr><name>h</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>U32</name><modifier>*</modifier>   <specifier>const</specifier></type> <name>nextCandidatePtr</name> <init>= <expr><name>bt</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><operator>(</operator><name>idx</name><operator>&amp;</operator><name>btMask</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name><modifier>*</modifier>   <specifier>const</specifier></type> <name>sortMarkPtr</name>  <init>= <expr><name>nextCandidatePtr</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_updateDUBT: insert %u"</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hashTable</name><index>[<expr><name>h</name></expr>]</index></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>   <comment type="block">/* Update Hash Table */</comment>
        <expr_stmt><expr><operator>*</operator><name>nextCandidatePtr</name> <operator>=</operator> <name>matchIndex</name></expr>;</expr_stmt>   <comment type="block">/* update BT like a chain */</comment>
        <expr_stmt><expr><operator>*</operator><name>sortMarkPtr</name> <operator>=</operator> <name>ZSTD_DUBT_UNSORTED_MARK</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/** ZSTD_insertDUBT1() :
 *  sort one already inserted but unsorted position
 *  assumption : curr &gt;= btlow == (curr - btmask)
 *  doesn't fail */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ZSTD_insertDUBT1</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>,
                 <parameter><decl><type><name>U32</name></type> <name>curr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>inputEnd</name></decl></parameter>,
                 <parameter><decl><type><name>U32</name></type> <name>nbCompares</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>btLow</name></decl></parameter>,
                 <parameter><decl><type><specifier>const</specifier> <name>ZSTD_dictMode_e</name></type> <name>dictMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_compressionParameters</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cParams</name> <init>= <expr><operator>&amp;</operator><name><name>ms</name><operator>-&gt;</operator><name>cParams</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>bt</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>chainTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>  <specifier>const</specifier></type> <name>btLog</name>  <init>= <expr><name><name>cParams</name><operator>-&gt;</operator><name>chainLog</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>  <specifier>const</specifier></type> <name>btMask</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>btLog</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>commonLengthSmaller</name><init>=<expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>commonLengthLarger</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>base</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictBase</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictBase</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dictLimit</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictLimit</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ip</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>curr</name><operator>&gt;=</operator><name>dictLimit</name><operator>)</operator></expr> ?</condition><then> <expr><name>base</name> <operator>+</operator> <name>curr</name></expr> </then><else>: <expr><name>dictBase</name> <operator>+</operator> <name>curr</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>curr</name><operator>&gt;=</operator><name>dictLimit</name><operator>)</operator></expr> ?</condition><then> <expr><name>inputEnd</name></expr> </then><else>: <expr><name>dictBase</name> <operator>+</operator> <name>dictLimit</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictEnd</name> <init>= <expr><name>dictBase</name> <operator>+</operator> <name>dictLimit</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>prefixStart</name> <init>= <expr><name>base</name> <operator>+</operator> <name>dictLimit</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>match</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier></type> <name>smallerPtr</name> <init>= <expr><name>bt</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><operator>(</operator><name>curr</name><operator>&amp;</operator><name>btMask</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier></type> <name>largerPtr</name>  <init>= <expr><name>smallerPtr</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>matchIndex</name> <init>= <expr><operator>*</operator><name>smallerPtr</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* this candidate is unsorted : next sorted candidate is reached through *smallerPtr, while *largerPtr contains previous unsorted candidate (which is already saved and can be overwritten) */</comment>
    <decl_stmt><decl><type><name>U32</name></type> <name>dummy32</name></decl>;</decl_stmt>   <comment type="block">/* to be nullified at the end */</comment>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>windowValid</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>lowLimit</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>maxDistance</name> <init>= <expr><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name><name>cParams</name><operator>-&gt;</operator><name>windowLog</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>windowLow</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>curr</name> <operator>-</operator> <name>windowValid</name> <operator>&gt;</operator> <name>maxDistance</name><operator>)</operator></expr> ?</condition><then> <expr><name>curr</name> <operator>-</operator> <name>maxDistance</name></expr> </then><else>: <expr><name>windowValid</name></expr></else></ternary></expr></init></decl>;</decl_stmt>


    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_insertDUBT1(%u) (dictLimit=%u, lowLimit=%u)"</literal></expr></argument>,
                <argument><expr><name>curr</name></expr></argument>, <argument><expr><name>dictLimit</name></expr></argument>, <argument><expr><name>windowLow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>curr</name> <operator>&gt;=</operator> <name>btLow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ip</name> <operator>&lt;</operator> <name>iend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* condition for ZSTD_count */</comment>

    <for>for <control>(<init>;</init> <condition><expr><name>nbCompares</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>matchIndex</name> <operator>&gt;</operator> <name>windowLow</name><operator>)</operator></expr>;</condition> <incr><expr><operator>--</operator><name>nbCompares</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>nextPtr</name> <init>= <expr><name>bt</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><operator>(</operator><name>matchIndex</name> <operator>&amp;</operator> <name>btMask</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>matchLength</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name>commonLengthSmaller</name></expr></argument>, <argument><expr><name>commonLengthLarger</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>   <comment type="block">/* guaranteed minimum nb of common bytes */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>matchIndex</name> <operator>&lt;</operator> <name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* note : all candidates are now supposed sorted,
         * but it's still possible to have nextPtr[1] == ZSTD_DUBT_UNSORTED_MARK
         * when a real index has the same value as ZSTD_DUBT_UNSORTED_MARK */</comment>

        <if_stmt><if>if <condition>( <expr><operator>(</operator><name>dictMode</name> <operator>!=</operator> <name>ZSTD_extDict</name><operator>)</operator>
          <operator>||</operator> <operator>(</operator><name>matchIndex</name><operator>+</operator><name>matchLength</name> <operator>&gt;=</operator> <name>dictLimit</name><operator>)</operator>  <comment type="block">/* both in current segment*/</comment>
          <operator>||</operator> <operator>(</operator><name>curr</name> <operator>&lt;</operator> <name>dictLimit</name><operator>)</operator></expr> <comment type="block">/* both in extDict */</comment>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>mBase</name> <init>= <expr><ternary><condition><expr><operator>(</operator> <operator>(</operator><name>dictMode</name> <operator>!=</operator> <name>ZSTD_extDict</name><operator>)</operator>
                                     <operator>||</operator> <operator>(</operator><name>matchIndex</name><operator>+</operator><name>matchLength</name> <operator>&gt;=</operator> <name>dictLimit</name><operator>)</operator><operator>)</operator></expr> ?</condition><then>
                                        <expr><name>base</name></expr> </then><else>: <expr><name>dictBase</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>matchIndex</name><operator>+</operator><name>matchLength</name> <operator>&gt;=</operator> <name>dictLimit</name><operator>)</operator>   <comment type="block">/* might be wrong if extDict is incorrectly set to 0 */</comment>
                 <operator>||</operator> <operator>(</operator><name>curr</name> <operator>&lt;</operator> <name>dictLimit</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>match</name> <operator>=</operator> <name>mBase</name> <operator>+</operator> <name>matchIndex</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>matchLength</name> <operator>+=</operator> <call><name>ZSTD_count</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><name>matchLength</name></expr></argument>, <argument><expr><name>match</name><operator>+</operator><name>matchLength</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>match</name> <operator>=</operator> <name>dictBase</name> <operator>+</operator> <name>matchIndex</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>matchLength</name> <operator>+=</operator> <call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><name>matchLength</name></expr></argument>, <argument><expr><name>match</name><operator>+</operator><name>matchLength</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>dictEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>matchIndex</name><operator>+</operator><name>matchLength</name> <operator>&gt;=</operator> <name>dictLimit</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>match</name> <operator>=</operator> <name>base</name> <operator>+</operator> <name>matchIndex</name></expr>;</expr_stmt></block_content></block></if></if_stmt>   <comment type="block">/* preparation for next read of match[matchLength] */</comment>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_insertDUBT1: comparing %u with %u : found %u common bytes "</literal></expr></argument>,
                    <argument><expr><name>curr</name></expr></argument>, <argument><expr><name>matchIndex</name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>matchLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>ip</name><operator>+</operator><name>matchLength</name> <operator>==</operator> <name>iend</name></expr>)</condition> <block>{<block_content>   <comment type="block">/* equal : no way to know if inf or sup */</comment>
            <break>break;</break>   <comment type="block">/* drop , to guarantee consistency ; miss a bit of compression, but other solutions can corrupt tree */</comment>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>match</name><index>[<expr><name>matchLength</name></expr>]</index></name> <operator>&lt;</operator> <name><name>ip</name><index>[<expr><name>matchLength</name></expr>]</index></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* necessarily within buffer */</comment>
            <comment type="block">/* match is smaller than current */</comment>
            <expr_stmt><expr><operator>*</operator><name>smallerPtr</name> <operator>=</operator> <name>matchIndex</name></expr>;</expr_stmt>             <comment type="block">/* update smaller idx */</comment>
            <expr_stmt><expr><name>commonLengthSmaller</name> <operator>=</operator> <name>matchLength</name></expr>;</expr_stmt>    <comment type="block">/* all smaller will now have at least this guaranteed common length */</comment>
            <if_stmt><if>if <condition>(<expr><name>matchIndex</name> <operator>&lt;=</operator> <name>btLow</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>smallerPtr</name><operator>=</operator><operator>&amp;</operator><name>dummy32</name></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>   <comment type="block">/* beyond tree size, stop searching */</comment>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_insertDUBT1: %u (&gt;btLow=%u) is smaller : next =&gt; %u"</literal></expr></argument>,
                        <argument><expr><name>matchIndex</name></expr></argument>, <argument><expr><name>btLow</name></expr></argument>, <argument><expr><name><name>nextPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>smallerPtr</name> <operator>=</operator> <name>nextPtr</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>               <comment type="block">/* new "candidate" =&gt; larger than match, which was smaller than target */</comment>
            <expr_stmt><expr><name>matchIndex</name> <operator>=</operator> <name><name>nextPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>              <comment type="block">/* new matchIndex, larger than previous and closer to current */</comment>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* match is larger than current */</comment>
            <expr_stmt><expr><operator>*</operator><name>largerPtr</name> <operator>=</operator> <name>matchIndex</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>commonLengthLarger</name> <operator>=</operator> <name>matchLength</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>matchIndex</name> <operator>&lt;=</operator> <name>btLow</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>largerPtr</name><operator>=</operator><operator>&amp;</operator><name>dummy32</name></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>   <comment type="block">/* beyond tree size, stop searching */</comment>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_insertDUBT1: %u (&gt;btLow=%u) is larger =&gt; %u"</literal></expr></argument>,
                        <argument><expr><name>matchIndex</name></expr></argument>, <argument><expr><name>btLow</name></expr></argument>, <argument><expr><name><name>nextPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>largerPtr</name> <operator>=</operator> <name>nextPtr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>matchIndex</name> <operator>=</operator> <name><name>nextPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>   </block_content>}</block></for>

    <expr_stmt><expr><operator>*</operator><name>smallerPtr</name> <operator>=</operator> <operator>*</operator><name>largerPtr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>ZSTD_DUBT_findBetterDictMatch</name> <parameter_list>(
        <parameter><decl><type><specifier>const</specifier> <name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ip</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name></decl></parameter>,
        <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>offsetPtr</name></decl></parameter>,
        <parameter><decl><type><name>size_t</name></type> <name>bestLength</name></decl></parameter>,
        <parameter><decl><type><name>U32</name></type> <name>nbCompares</name></decl></parameter>,
        <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>mls</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>ZSTD_dictMode_e</name></type> <name>dictMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_matchState_t</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>dms</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>dictMatchState</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_compressionParameters</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dmsCParams</name> <init>= <expr><operator>&amp;</operator><name><name>dms</name><operator>-&gt;</operator><name>cParams</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>dictHashTable</name> <init>= <expr><name><name>dms</name><operator>-&gt;</operator><name>hashTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>         <specifier>const</specifier></type> <name>hashLog</name> <init>= <expr><name><name>dmsCParams</name><operator>-&gt;</operator><name>hashLog</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name>      <specifier>const</specifier></type> <name>h</name>  <init>= <expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>hashLog</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type>               <name>dictMatchIndex</name> <init>= <expr><name><name>dictHashTable</name><index>[<expr><name>h</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>base</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>prefixStart</name> <init>= <expr><name>base</name> <operator>+</operator> <name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictLimit</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>         <specifier>const</specifier></type> <name>curr</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictBase</name> <init>= <expr><name><name>dms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictEnd</name> <init>= <expr><name><name>dms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>nextSrc</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>         <specifier>const</specifier></type> <name>dictHighLimit</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name><name>dms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>nextSrc</name></name> <operator>-</operator> <name><name>dms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>         <specifier>const</specifier></type> <name>dictLowLimit</name> <init>= <expr><name><name>dms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>lowLimit</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>         <specifier>const</specifier></type> <name>dictIndexDelta</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>lowLimit</name></name> <operator>-</operator> <name>dictHighLimit</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier>        <specifier>const</specifier></type> <name>dictBt</name> <init>= <expr><name><name>dms</name><operator>-&gt;</operator><name>chainTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>         <specifier>const</specifier></type> <name>btLog</name>  <init>= <expr><name><name>dmsCParams</name><operator>-&gt;</operator><name>chainLog</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>         <specifier>const</specifier></type> <name>btMask</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>btLog</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>         <specifier>const</specifier></type> <name>btLow</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>btMask</name> <operator>&gt;=</operator> <name>dictHighLimit</name> <operator>-</operator> <name>dictLowLimit</name><operator>)</operator></expr> ?</condition><then> <expr><name>dictLowLimit</name></expr> </then><else>: <expr><name>dictHighLimit</name> <operator>-</operator> <name>btMask</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>size_t</name></type> <name>commonLengthSmaller</name><init>=<expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>commonLengthLarger</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>dictMode</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_dictMatchState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init>;</init> <condition><expr><name>nbCompares</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>dictMatchIndex</name> <operator>&gt;</operator> <name>dictLowLimit</name><operator>)</operator></expr>;</condition> <incr><expr><operator>--</operator><name>nbCompares</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>nextPtr</name> <init>= <expr><name>dictBt</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><operator>(</operator><name>dictMatchIndex</name> <operator>&amp;</operator> <name>btMask</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>matchLength</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name>commonLengthSmaller</name></expr></argument>, <argument><expr><name>commonLengthLarger</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>   <comment type="block">/* guaranteed minimum nb of common bytes */</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>match</name> <init>= <expr><name>dictBase</name> <operator>+</operator> <name>dictMatchIndex</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>matchLength</name> <operator>+=</operator> <call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><name>matchLength</name></expr></argument>, <argument><expr><name>match</name><operator>+</operator><name>matchLength</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>dictEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>dictMatchIndex</name><operator>+</operator><name>matchLength</name> <operator>&gt;=</operator> <name>dictHighLimit</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>match</name> <operator>=</operator> <name>base</name> <operator>+</operator> <name>dictMatchIndex</name> <operator>+</operator> <name>dictIndexDelta</name></expr>;</expr_stmt></block_content></block></if></if_stmt>   <comment type="block">/* to prepare for next usage of match[matchLength] */</comment>

        <if_stmt><if>if <condition>(<expr><name>matchLength</name> <operator>&gt;</operator> <name>bestLength</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>U32</name></type> <name>matchIndex</name> <init>= <expr><name>dictMatchIndex</name> <operator>+</operator> <name>dictIndexDelta</name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>( <expr><operator>(</operator><literal type="number">4</literal><operator>*</operator><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>matchLength</name><operator>-</operator><name>bestLength</name><operator>)</operator><operator>)</operator> <operator>&gt;</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><name>curr</name><operator>-</operator><name>matchIndex</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>offsetPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">9</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_DUBT_findBetterDictMatch(%u) : found better match length %u -&gt; %u and offsetCode %u -&gt; %u (dictMatchIndex %u, matchIndex %u)"</literal></expr></argument>,
                    <argument><expr><name>curr</name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>bestLength</name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>matchLength</name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>*</operator><name>offsetPtr</name></expr></argument>, <argument><expr><call><name>OFFSET_TO_OFFBASE</name><argument_list>(<argument><expr><name>curr</name> <operator>-</operator> <name>matchIndex</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dictMatchIndex</name></expr></argument>, <argument><expr><name>matchIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>bestLength</name> <operator>=</operator> <name>matchLength</name></expr><operator>,</operator> <expr><operator>*</operator><name>offsetPtr</name> <operator>=</operator> <call><name>OFFSET_TO_OFFBASE</name><argument_list>(<argument><expr><name>curr</name> <operator>-</operator> <name>matchIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>ip</name><operator>+</operator><name>matchLength</name> <operator>==</operator> <name>iend</name></expr>)</condition> <block>{<block_content>   <comment type="block">/* reached end of input : ip[matchLength] is not valid, no way to know if it's larger or smaller than match */</comment>
                <break>break;</break>   <comment type="block">/* drop, to guarantee consistency (miss a little bit of compression) */</comment>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>match</name><index>[<expr><name>matchLength</name></expr>]</index></name> <operator>&lt;</operator> <name><name>ip</name><index>[<expr><name>matchLength</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>dictMatchIndex</name> <operator>&lt;=</operator> <name>btLow</name></expr>)</condition> <block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt>   <comment type="block">/* beyond tree size, stop the search */</comment>
            <expr_stmt><expr><name>commonLengthSmaller</name> <operator>=</operator> <name>matchLength</name></expr>;</expr_stmt>    <comment type="block">/* all smaller will now have at least this guaranteed common length */</comment>
            <expr_stmt><expr><name>dictMatchIndex</name> <operator>=</operator> <name><name>nextPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>              <comment type="block">/* new matchIndex larger than previous (closer to current) */</comment>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* match is larger than current */</comment>
            <if_stmt><if>if <condition>(<expr><name>dictMatchIndex</name> <operator>&lt;=</operator> <name>btLow</name></expr>)</condition> <block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt>   <comment type="block">/* beyond tree size, stop the search */</comment>
            <expr_stmt><expr><name>commonLengthLarger</name> <operator>=</operator> <name>matchLength</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>dictMatchIndex</name> <operator>=</operator> <name><name>nextPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>bestLength</name> <operator>&gt;=</operator> <name>MINMATCH</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>mIndex</name> <init>= <expr><name>curr</name> <operator>-</operator> <operator>(</operator><name>U32</name><operator>)</operator><call><name>OFFBASE_TO_OFFSET</name><argument_list>(<argument><expr><operator>*</operator><name>offsetPtr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>mIndex</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_DUBT_findBetterDictMatch(%u) : found match of length %u and offsetCode %u (pos %u)"</literal></expr></argument>,
                    <argument><expr><name>curr</name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>bestLength</name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>*</operator><name>offsetPtr</name></expr></argument>, <argument><expr><name>mIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>bestLength</name></expr>;</return>

</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>ZSTD_DUBT_findBestMatch</name><parameter_list>(<parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ip</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name></decl></parameter>,
                        <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>offBasePtr</name></decl></parameter>,
                        <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>mls</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>ZSTD_dictMode_e</name></type> <name>dictMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_compressionParameters</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cParams</name> <init>= <expr><operator>&amp;</operator><name><name>ms</name><operator>-&gt;</operator><name>cParams</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier>   <specifier>const</specifier></type> <name>hashTable</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>hashTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>    <specifier>const</specifier></type> <name>hashLog</name> <init>= <expr><name><name>cParams</name><operator>-&gt;</operator><name>hashLog</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>h</name>  <init>= <expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>hashLog</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type>          <name>matchIndex</name>  <init>= <expr><name><name>hashTable</name><index>[<expr><name>h</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>base</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>    <specifier>const</specifier></type> <name>curr</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>    <specifier>const</specifier></type> <name>windowLow</name> <init>= <expr><call><name>ZSTD_getLowestMatchIndex</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>curr</name></expr></argument>, <argument><expr><name><name>cParams</name><operator>-&gt;</operator><name>windowLog</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier>   <specifier>const</specifier></type> <name>bt</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>chainTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>    <specifier>const</specifier></type> <name>btLog</name>  <init>= <expr><name><name>cParams</name><operator>-&gt;</operator><name>chainLog</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>    <specifier>const</specifier></type> <name>btMask</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>btLog</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>    <specifier>const</specifier></type> <name>btLow</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>btMask</name> <operator>&gt;=</operator> <name>curr</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>curr</name> <operator>-</operator> <name>btMask</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>    <specifier>const</specifier></type> <name>unsortLimit</name> <init>= <expr><call><name>MAX</name><argument_list>(<argument><expr><name>btLow</name></expr></argument>, <argument><expr><name>windowLow</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier></type>         <name>nextCandidate</name> <init>= <expr><name>bt</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><operator>(</operator><name>matchIndex</name><operator>&amp;</operator><name>btMask</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier></type>         <name>unsortedMark</name> <init>= <expr><name>bt</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><operator>(</operator><name>matchIndex</name><operator>&amp;</operator><name>btMask</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type>          <name>nbCompares</name> <init>= <expr><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name><name>cParams</name><operator>-&gt;</operator><name>searchLog</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type>          <name>nbCandidates</name> <init>= <expr><name>nbCompares</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type>          <name>previousCandidate</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_DUBT_findBestMatch (%u) "</literal></expr></argument>, <argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ip</name> <operator>&lt;=</operator> <name>iend</name><operator>-</operator><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* required for h calculation */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dictMode</name> <operator>!=</operator> <name>ZSTD_dedicatedDictSearch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* reach end of unsorted candidates list */</comment>
    <while>while <condition>( <expr><operator>(</operator><name>matchIndex</name> <operator>&gt;</operator> <name>unsortLimit</name><operator>)</operator>
         <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>unsortedMark</name> <operator>==</operator> <name>ZSTD_DUBT_UNSORTED_MARK</name><operator>)</operator>
         <operator>&amp;&amp;</operator> <operator>(</operator><name>nbCandidates</name> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr> )</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_DUBT_findBestMatch: candidate %u is unsorted"</literal></expr></argument>,
                    <argument><expr><name>matchIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>unsortedMark</name> <operator>=</operator> <name>previousCandidate</name></expr>;</expr_stmt>  <comment type="block">/* the unsortedMark becomes a reversed chain, to move up back to original position */</comment>
        <expr_stmt><expr><name>previousCandidate</name> <operator>=</operator> <name>matchIndex</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>matchIndex</name> <operator>=</operator> <operator>*</operator><name>nextCandidate</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nextCandidate</name> <operator>=</operator> <name>bt</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><operator>(</operator><name>matchIndex</name><operator>&amp;</operator><name>btMask</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>unsortedMark</name> <operator>=</operator> <name>bt</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><operator>(</operator><name>matchIndex</name><operator>&amp;</operator><name>btMask</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>nbCandidates</name> <operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* nullify last candidate if it's still unsorted
     * simplification, detrimental to compression ratio, beneficial for speed */</comment>
    <if_stmt><if>if <condition>( <expr><operator>(</operator><name>matchIndex</name> <operator>&gt;</operator> <name>unsortLimit</name><operator>)</operator>
      <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>unsortedMark</name><operator>==</operator><name>ZSTD_DUBT_UNSORTED_MARK</name><operator>)</operator></expr> )</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_DUBT_findBestMatch: nullify last unsorted candidate %u"</literal></expr></argument>,
                    <argument><expr><name>matchIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>nextCandidate</name> <operator>=</operator> <operator>*</operator><name>unsortedMark</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* batch sort stacked candidates */</comment>
    <expr_stmt><expr><name>matchIndex</name> <operator>=</operator> <name>previousCandidate</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>matchIndex</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* will end on matchIndex == 0 */</comment>
        <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>nextCandidateIdxPtr</name> <init>= <expr><name>bt</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><operator>(</operator><name>matchIndex</name><operator>&amp;</operator><name>btMask</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>nextCandidateIdx</name> <init>= <expr><operator>*</operator><name>nextCandidateIdxPtr</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ZSTD_insertDUBT1</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>matchIndex</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>,
                         <argument><expr><name>nbCandidates</name></expr></argument>, <argument><expr><name>unsortLimit</name></expr></argument>, <argument><expr><name>dictMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>matchIndex</name> <operator>=</operator> <name>nextCandidateIdx</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nbCandidates</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* find longest match */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name></type> <name>commonLengthSmaller</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>commonLengthLarger</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictBase</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictBase</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dictLimit</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictLimit</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictEnd</name> <init>= <expr><name>dictBase</name> <operator>+</operator> <name>dictLimit</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>prefixStart</name> <init>= <expr><name>base</name> <operator>+</operator> <name>dictLimit</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name><modifier>*</modifier></type> <name>smallerPtr</name> <init>= <expr><name>bt</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><operator>(</operator><name>curr</name><operator>&amp;</operator><name>btMask</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name><modifier>*</modifier></type> <name>largerPtr</name>  <init>= <expr><name>bt</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><operator>(</operator><name>curr</name><operator>&amp;</operator><name>btMask</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name></type> <name>matchEndIdx</name> <init>= <expr><name>curr</name> <operator>+</operator> <literal type="number">8</literal> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name></type> <name>dummy32</name></decl>;</decl_stmt>   <comment type="block">/* to be nullified at the end */</comment>
        <decl_stmt><decl><type><name>size_t</name></type> <name>bestLength</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>matchIndex</name>  <operator>=</operator> <name><name>hashTable</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hashTable</name><index>[<expr><name>h</name></expr>]</index></name> <operator>=</operator> <name>curr</name></expr>;</expr_stmt>   <comment type="block">/* Update Hash Table */</comment>

        <for>for <control>(<init>;</init> <condition><expr><name>nbCompares</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>matchIndex</name> <operator>&gt;</operator> <name>windowLow</name><operator>)</operator></expr>;</condition> <incr><expr><operator>--</operator><name>nbCompares</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>nextPtr</name> <init>= <expr><name>bt</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><operator>(</operator><name>matchIndex</name> <operator>&amp;</operator> <name>btMask</name><operator>)</operator></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name></type> <name>matchLength</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name>commonLengthSmaller</name></expr></argument>, <argument><expr><name>commonLengthLarger</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>   <comment type="block">/* guaranteed minimum nb of common bytes */</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>match</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>dictMode</name> <operator>!=</operator> <name>ZSTD_extDict</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>matchIndex</name><operator>+</operator><name>matchLength</name> <operator>&gt;=</operator> <name>dictLimit</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>match</name> <operator>=</operator> <name>base</name> <operator>+</operator> <name>matchIndex</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>matchLength</name> <operator>+=</operator> <call><name>ZSTD_count</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><name>matchLength</name></expr></argument>, <argument><expr><name>match</name><operator>+</operator><name>matchLength</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>match</name> <operator>=</operator> <name>dictBase</name> <operator>+</operator> <name>matchIndex</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>matchLength</name> <operator>+=</operator> <call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><name>matchLength</name></expr></argument>, <argument><expr><name>match</name><operator>+</operator><name>matchLength</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>dictEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>matchIndex</name><operator>+</operator><name>matchLength</name> <operator>&gt;=</operator> <name>dictLimit</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>match</name> <operator>=</operator> <name>base</name> <operator>+</operator> <name>matchIndex</name></expr>;</expr_stmt></block_content></block></if></if_stmt>   <comment type="block">/* to prepare for next usage of match[matchLength] */</comment>
            </block_content>}</block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>matchLength</name> <operator>&gt;</operator> <name>bestLength</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>matchLength</name> <operator>&gt;</operator> <name>matchEndIdx</name> <operator>-</operator> <name>matchIndex</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>matchEndIdx</name> <operator>=</operator> <name>matchIndex</name> <operator>+</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>matchLength</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>( <expr><operator>(</operator><literal type="number">4</literal><operator>*</operator><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>matchLength</name><operator>-</operator><name>bestLength</name><operator>)</operator><operator>)</operator> <operator>&gt;</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><name>curr</name> <operator>-</operator> <name>matchIndex</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>*</operator><name>offBasePtr</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>bestLength</name> <operator>=</operator> <name>matchLength</name></expr><operator>,</operator> <expr><operator>*</operator><name>offBasePtr</name> <operator>=</operator> <call><name>OFFSET_TO_OFFBASE</name><argument_list>(<argument><expr><name>curr</name> <operator>-</operator> <name>matchIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>ip</name><operator>+</operator><name>matchLength</name> <operator>==</operator> <name>iend</name></expr>)</condition> <block>{<block_content>   <comment type="block">/* equal : no way to know if inf or sup */</comment>
                    <if_stmt><if>if <condition>(<expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_dictMatchState</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>nbCompares</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* in addition to avoiding checking any
                                         * further in this loop, make sure we
                                         * skip checking in the dictionary. */</comment>
                    </block_content>}</block></if></if_stmt>
                    <break>break;</break>   <comment type="block">/* drop, to guarantee consistency (miss a little bit of compression) */</comment>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>match</name><index>[<expr><name>matchLength</name></expr>]</index></name> <operator>&lt;</operator> <name><name>ip</name><index>[<expr><name>matchLength</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* match is smaller than current */</comment>
                <expr_stmt><expr><operator>*</operator><name>smallerPtr</name> <operator>=</operator> <name>matchIndex</name></expr>;</expr_stmt>             <comment type="block">/* update smaller idx */</comment>
                <expr_stmt><expr><name>commonLengthSmaller</name> <operator>=</operator> <name>matchLength</name></expr>;</expr_stmt>    <comment type="block">/* all smaller will now have at least this guaranteed common length */</comment>
                <if_stmt><if>if <condition>(<expr><name>matchIndex</name> <operator>&lt;=</operator> <name>btLow</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>smallerPtr</name><operator>=</operator><operator>&amp;</operator><name>dummy32</name></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>   <comment type="block">/* beyond tree size, stop the search */</comment>
                <expr_stmt><expr><name>smallerPtr</name> <operator>=</operator> <name>nextPtr</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>               <comment type="block">/* new "smaller" =&gt; larger of match */</comment>
                <expr_stmt><expr><name>matchIndex</name> <operator>=</operator> <name><name>nextPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>              <comment type="block">/* new matchIndex larger than previous (closer to current) */</comment>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <comment type="block">/* match is larger than current */</comment>
                <expr_stmt><expr><operator>*</operator><name>largerPtr</name> <operator>=</operator> <name>matchIndex</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>commonLengthLarger</name> <operator>=</operator> <name>matchLength</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>matchIndex</name> <operator>&lt;=</operator> <name>btLow</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>largerPtr</name><operator>=</operator><operator>&amp;</operator><name>dummy32</name></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>   <comment type="block">/* beyond tree size, stop the search */</comment>
                <expr_stmt><expr><name>largerPtr</name> <operator>=</operator> <name>nextPtr</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>matchIndex</name> <operator>=</operator> <name><name>nextPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>   </block_content>}</block></for>

        <expr_stmt><expr><operator>*</operator><name>smallerPtr</name> <operator>=</operator> <operator>*</operator><name>largerPtr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nbCompares</name> <operator>&lt;=</operator> <operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>ZSTD_SEARCHLOG_MAX</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Check we haven't underflowed. */</comment>
        <if_stmt><if>if <condition>(<expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_dictMatchState</name> <operator>&amp;&amp;</operator> <name>nbCompares</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>bestLength</name> <operator>=</operator> <call><name>ZSTD_DUBT_findBetterDictMatch</name><argument_list>(
                    <argument><expr><name>ms</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>,
                    <argument><expr><name>offBasePtr</name></expr></argument>, <argument><expr><name>bestLength</name></expr></argument>, <argument><expr><name>nbCompares</name></expr></argument>,
                    <argument><expr><name>mls</name></expr></argument>, <argument><expr><name>dictMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>matchEndIdx</name> <operator>&gt;</operator> <name>curr</name><operator>+</operator><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* ensure nextToUpdate is increased */</comment>
        <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name> <operator>=</operator> <name>matchEndIdx</name> <operator>-</operator> <literal type="number">8</literal></expr>;</expr_stmt>   <comment type="block">/* skip repetitive patterns */</comment>
        <if_stmt><if>if <condition>(<expr><name>bestLength</name> <operator>&gt;=</operator> <name>MINMATCH</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>mIndex</name> <init>= <expr><name>curr</name> <operator>-</operator> <operator>(</operator><name>U32</name><operator>)</operator><call><name>OFFBASE_TO_OFFSET</name><argument_list>(<argument><expr><operator>*</operator><name>offBasePtr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>mIndex</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_DUBT_findBestMatch(%u) : found match of length %u and offsetCode %u (pos %u)"</literal></expr></argument>,
                        <argument><expr><name>curr</name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>bestLength</name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>*</operator><name>offBasePtr</name></expr></argument>, <argument><expr><name>mIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>bestLength</name></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>


<comment type="block" format="doxygen">/** ZSTD_BtFindBestMatch() : Tree updater, providing best match */</comment>
<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>size_t</name></type>
<name>ZSTD_BtFindBestMatch</name><parameter_list>( <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ip</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iLimit</name></decl></parameter>,
                      <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>offBasePtr</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name>mls</name></decl></parameter> <comment type="block">/* template */</comment>,
                <parameter><decl><type><specifier>const</specifier> <name>ZSTD_dictMode_e</name></type> <name>dictMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_BtFindBestMatch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ip</name> <operator>&lt;</operator> <name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name> <operator>+</operator> <name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* skipped area */</comment>
    <expr_stmt><expr><call><name>ZSTD_updateDUBT</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>ZSTD_DUBT_findBestMatch</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>, <argument><expr><name>offBasePtr</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>, <argument><expr><name>dictMode</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************
* Dedicated dict search
***********************************/</comment>

<function><type><name>void</name></type> <name>ZSTD_dedicatedDictSearch_lazy_loadDictionary</name><parameter_list>(<parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ip</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>base</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>target</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>hashTable</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>hashTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>chainTable</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>chainTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>chainSize</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>ms</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>chainLog</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>idx</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>minChain</name> <init>= <expr><ternary><condition><expr><name>chainSize</name> <operator>&lt;</operator> <name>target</name> <operator>-</operator> <name>idx</name></expr> ?</condition><then> <expr><name>target</name> <operator>-</operator> <name>chainSize</name></expr> </then><else>: <expr><name>idx</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>bucketSize</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>ZSTD_LAZY_DDSS_BUCKET_LOG</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>cacheSize</name> <init>= <expr><name>bucketSize</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>chainAttempts</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>ms</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>searchLog</name></name><operator>)</operator> <operator>-</operator> <name>cacheSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>chainLimit</name> <init>= <expr><ternary><condition><expr><name>chainAttempts</name> <operator>&gt;</operator> <literal type="number">255</literal></expr> ?</condition><then> <expr><literal type="number">255</literal></expr> </then><else>: <expr><name>chainAttempts</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <comment type="block">/* We know the hashtable is oversized by a factor of `bucketSize`.
     * We are going to temporarily pretend `bucketSize == 1`, keeping only a
     * single entry. We will use the rest of the space to construct a temporary
     * chaintable.
     */</comment>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>hashLog</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>hashLog</name></name> <operator>-</operator> <name>ZSTD_LAZY_DDSS_BUCKET_LOG</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>tmpHashTable</name> <init>= <expr><name>hashTable</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>tmpChainTable</name> <init>= <expr><name>hashTable</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>hashLog</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>tmpChainSize</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>ZSTD_LAZY_DDSS_BUCKET_LOG</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>hashLog</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>tmpMinChain</name> <init>= <expr><ternary><condition><expr><name>tmpChainSize</name> <operator>&lt;</operator> <name>target</name></expr> ?</condition><then> <expr><name>target</name> <operator>-</operator> <name>tmpChainSize</name></expr> </then><else>: <expr><name>idx</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>hashIdx</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>chainLog</name></name> <operator>&lt;=</operator> <literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>hashLog</name></name> <operator>&gt;</operator> <name><name>ms</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>chainLog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>idx</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tmpMinChain</name> <operator>&lt;=</operator> <name>minChain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* fill conventional hash table and conventional chain table */</comment>
    <for>for <control>( <init>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name>target</name></expr>;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>h</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>base</name> <operator>+</operator> <name>idx</name></expr></argument>, <argument><expr><name>hashLog</name></expr></argument>, <argument><expr><name><name>ms</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>minMatch</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&gt;=</operator> <name>tmpMinChain</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>tmpChainTable</name><index>[<expr><name>idx</name> <operator>-</operator> <name>tmpMinChain</name></expr>]</index></name> <operator>=</operator> <name><name>hashTable</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>tmpHashTable</name><index>[<expr><name>h</name></expr>]</index></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* sort chains into ddss chain table */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name></type> <name>chainPos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>hashIdx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>hashIdx</name> <operator>&lt;</operator> <operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>hashLog</name><operator>)</operator></expr>;</condition> <incr><expr><name>hashIdx</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>U32</name></type> <name>count</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name></type> <name>countBeyondMinChain</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name></type> <name>i</name> <init>= <expr><name><name>tmpHashTable</name><index>[<expr><name>hashIdx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <name>tmpMinChain</name> <operator>&amp;&amp;</operator> <name>count</name> <operator>&lt;</operator> <name>cacheSize</name></expr>;</condition> <incr><expr><name>count</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <comment type="block">/* skip through the chain to the first position that won't be
                 * in the hash cache bucket */</comment>
                <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>minChain</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>countBeyondMinChain</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>tmpChainTable</name><index>[<expr><name>i</name> <operator>-</operator> <name>tmpMinChain</name></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></for>
            <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <name>cacheSize</name></expr>)</condition> <block>{<block_content>
                <for>for <control>(<init><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>count</name> <operator>&lt;</operator> <name>chainLimit</name></expr>;</condition><incr/>)</control> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>minChain</name></expr>)</condition> <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>i</name> <operator>||</operator> <operator>++</operator><name>countBeyondMinChain</name> <operator>&gt;</operator> <name>cacheSize</name></expr>)</condition> <block>{<block_content>
                            <comment type="block">/* only allow pulling `cacheSize` number of entries
                             * into the cache or chainTable beyond `minChain`,
                             * to replace the entries pulled out of the
                             * chainTable into the cache. This lets us reach
                             * back further without increasing the total number
                             * of entries in the chainTable, guaranteeing the
                             * DDSS chain table will fit into the space
                             * allocated for the regular one. */</comment>
                            <break>break;</break>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name><name>chainTable</name><index>[<expr><name>chainPos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>tmpMinChain</name></expr>)</condition> <block>{<block_content>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>tmpChainTable</name><index>[<expr><name>i</name> <operator>-</operator> <name>tmpMinChain</name></expr>]</index></name></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>count</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>tmpHashTable</name><index>[<expr><name>hashIdx</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>chainPos</name> <operator>-</operator> <name>count</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>+</operator> <name>count</name></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name><name>tmpHashTable</name><index>[<expr><name>hashIdx</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>chainPos</name> <operator>&lt;=</operator> <name>chainSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* I believe this is guaranteed... */</comment>
    </block_content>}</block>

    <comment type="block">/* move chain pointers into the last entry of each hash bucket */</comment>
    <for>for <control>(<init><expr><name>hashIdx</name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>hashLog</name><operator>)</operator></expr>;</init> <condition><expr><name>hashIdx</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>bucketIdx</name> <init>= <expr><operator>--</operator><name>hashIdx</name> <operator>&lt;&lt;</operator> <name>ZSTD_LAZY_DDSS_BUCKET_LOG</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>chainPackedPointer</name> <init>= <expr><name><name>tmpHashTable</name><index>[<expr><name>hashIdx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cacheSize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><name><name>hashTable</name><index>[<expr><name>bucketIdx</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>hashTable</name><index>[<expr><name>bucketIdx</name> <operator>+</operator> <name>bucketSize</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>chainPackedPointer</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* fill the buckets of the hash table */</comment>
    <for>for <control>(<init><expr><name>idx</name> <operator>=</operator> <name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name></expr>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name>target</name></expr>;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>h</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>base</name> <operator>+</operator> <name>idx</name></expr></argument>, <argument><expr><name>hashLog</name></expr></argument>, <argument><expr><name><name>ms</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>minMatch</name></name></expr></argument>)</argument_list></call>
                   <operator>&lt;&lt;</operator> <name>ZSTD_LAZY_DDSS_BUCKET_LOG</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name></type> <name>i</name></decl>;</decl_stmt>
        <comment type="block">/* Shift hash cache down 1. */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>cacheSize</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>hashTable</name><index>[<expr><name>h</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <name><name>hashTable</name><index>[<expr><name>h</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><name><name>hashTable</name><index>[<expr><name>h</name></expr>]</index></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Returns the longest match length found in the dedicated dict search structure.
 * If none are longer than the argument ml, then ml will be returned.
 */</comment>
<function><type><name>FORCE_INLINE_TEMPLATE</name>
<name>size_t</name></type> <name>ZSTD_dedicatedDictSearch_lazy_search</name><parameter_list>(<parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>offsetPtr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>ml</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>nbAttempts</name></decl></parameter>,
                                            <parameter><decl><type><specifier>const</specifier> <name>ZSTD_matchState_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dms</name></decl></parameter>,
                                            <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ip</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iLimit</name></decl></parameter>,
                                            <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>prefixStart</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name>curr</name></decl></parameter>,
                                            <parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dictLimit</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>ddsIdx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>ddsLowestIndex</name>  <init>= <expr><name><name>dms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictLimit</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ddsBase</name> <init>= <expr><name><name>dms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ddsEnd</name>  <init>= <expr><name><name>dms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>nextSrc</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>ddsSize</name>         <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ddsEnd</name> <operator>-</operator> <name>ddsBase</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>ddsIndexDelta</name>   <init>= <expr><name>dictLimit</name> <operator>-</operator> <name>ddsSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>bucketSize</name>      <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>ZSTD_LAZY_DDSS_BUCKET_LOG</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>bucketLimit</name>     <init>= <expr><ternary><condition><expr><name>nbAttempts</name> <operator>&lt;</operator> <name>bucketSize</name> <operator>-</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name>nbAttempts</name></expr> </then><else>: <expr><name>bucketSize</name> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>ddsAttempt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>matchIndex</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>ddsAttempt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ddsAttempt</name> <operator>&lt;</operator> <name>bucketSize</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>ddsAttempt</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>PREFETCH_L1</name><argument_list>(<argument><expr><name>ddsBase</name> <operator>+</operator> <name><name>dms</name><operator>-&gt;</operator><name>hashTable</name><index>[<expr><name>ddsIdx</name> <operator>+</operator> <name>ddsAttempt</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>chainPackedPointer</name> <init>= <expr><name><name>dms</name><operator>-&gt;</operator><name>hashTable</name><index>[<expr><name>ddsIdx</name> <operator>+</operator> <name>bucketSize</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>chainIndex</name> <init>= <expr><name>chainPackedPointer</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>PREFETCH_L1</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dms</name><operator>-&gt;</operator><name>chainTable</name><index>[<expr><name>chainIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <for>for <control>(<init><expr><name>ddsAttempt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ddsAttempt</name> <operator>&lt;</operator> <name>bucketLimit</name></expr>;</condition> <incr><expr><name>ddsAttempt</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>currentMl</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>match</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>matchIndex</name> <operator>=</operator> <name><name>dms</name><operator>-&gt;</operator><name>hashTable</name><index>[<expr><name>ddsIdx</name> <operator>+</operator> <name>ddsAttempt</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>match</name> <operator>=</operator> <name>ddsBase</name> <operator>+</operator> <name>matchIndex</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>matchIndex</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>ml</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* guaranteed by table construction */</comment>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>ddsLowestIndex</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>matchIndex</name> <operator>&gt;=</operator> <name>ddsLowestIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>match</name><operator>+</operator><literal type="number">4</literal> <operator>&lt;=</operator> <name>ddsEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>MEM_read32</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="block">/* assumption : matchIndex &lt;= dictLimit-4 (by table construction) */</comment>
            <expr_stmt><expr><name>currentMl</name> <operator>=</operator> <call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>match</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>, <argument><expr><name>ddsEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* save best solution */</comment>
        <if_stmt><if>if <condition>(<expr><name>currentMl</name> <operator>&gt;</operator> <name>ml</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>ml</name> <operator>=</operator> <name>currentMl</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>offsetPtr</name> <operator>=</operator> <call><name>OFFSET_TO_OFFBASE</name><argument_list>(<argument><expr><name>curr</name> <operator>-</operator> <operator>(</operator><name>matchIndex</name> <operator>+</operator> <name>ddsIndexDelta</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>ip</name><operator>+</operator><name>currentMl</name> <operator>==</operator> <name>iLimit</name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* best possible, avoids read overflow on next attempt */</comment>
                <return>return <expr><name>ml</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>chainPackedPointer</name> <init>= <expr><name><name>dms</name><operator>-&gt;</operator><name>hashTable</name><index>[<expr><name>ddsIdx</name> <operator>+</operator> <name>bucketSize</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name></type> <name>chainIndex</name> <init>= <expr><name>chainPackedPointer</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>chainLength</name> <init>= <expr><name>chainPackedPointer</name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>chainAttempts</name> <init>= <expr><name>nbAttempts</name> <operator>-</operator> <name>ddsAttempt</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>chainLimit</name> <init>= <expr><ternary><condition><expr><name>chainAttempts</name> <operator>&gt;</operator> <name>chainLength</name></expr> ?</condition><then> <expr><name>chainLength</name></expr> </then><else>: <expr><name>chainAttempts</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name></type> <name>chainAttempt</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>chainAttempt</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>chainAttempt</name> <operator>&lt;</operator> <name>chainLimit</name></expr>;</condition> <incr><expr><name>chainAttempt</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>PREFETCH_L1</name><argument_list>(<argument><expr><name>ddsBase</name> <operator>+</operator> <name><name>dms</name><operator>-&gt;</operator><name>chainTable</name><index>[<expr><name>chainIndex</name> <operator>+</operator> <name>chainAttempt</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <for>for <control>(<init><expr><name>chainAttempt</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>chainAttempt</name> <operator>&lt;</operator> <name>chainLimit</name></expr>;</condition> <incr><expr><name>chainAttempt</name><operator>++</operator></expr><operator>,</operator> <expr><name>chainIndex</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>size_t</name></type> <name>currentMl</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>match</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>matchIndex</name> <operator>=</operator> <name><name>dms</name><operator>-&gt;</operator><name>chainTable</name><index>[<expr><name>chainIndex</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>match</name> <operator>=</operator> <name>ddsBase</name> <operator>+</operator> <name>matchIndex</name></expr>;</expr_stmt>

            <comment type="block">/* guaranteed by table construction */</comment>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>matchIndex</name> <operator>&gt;=</operator> <name>ddsLowestIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>match</name><operator>+</operator><literal type="number">4</literal> <operator>&lt;=</operator> <name>ddsEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>MEM_read32</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <comment type="block">/* assumption : matchIndex &lt;= dictLimit-4 (by table construction) */</comment>
                <expr_stmt><expr><name>currentMl</name> <operator>=</operator> <call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>match</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>, <argument><expr><name>ddsEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* save best solution */</comment>
            <if_stmt><if>if <condition>(<expr><name>currentMl</name> <operator>&gt;</operator> <name>ml</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>ml</name> <operator>=</operator> <name>currentMl</name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>offsetPtr</name> <operator>=</operator> <call><name>OFFSET_TO_OFFBASE</name><argument_list>(<argument><expr><name>curr</name> <operator>-</operator> <operator>(</operator><name>matchIndex</name> <operator>+</operator> <name>ddsIndexDelta</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>ip</name><operator>+</operator><name>currentMl</name> <operator>==</operator> <name>iLimit</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt> <comment type="block">/* best possible, avoids read overflow on next attempt */</comment>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block>
    <return>return <expr><name>ml</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* *********************************
*  Hash Chain
***********************************/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEXT_IN_CHAIN</name><parameter_list>(<parameter><type><name>d</name></type></parameter>, <parameter><type><name>mask</name></type></parameter>)</parameter_list></cpp:macro>   <cpp:value>chainTable[(d) &amp; (mask)]</cpp:value></cpp:define>

<comment type="block">/* Update chains up to ip (excluded)
   Assumption : always within prefix (i.e. not within extDict) */</comment>
<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>U32</name></type> <name>ZSTD_insertAndFindFirstIndex_internal</name><parameter_list>(
                        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>ZSTD_compressionParameters</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cParams</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>mls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>hashTable</name>  <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>hashTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>hashLog</name> <init>= <expr><name><name>cParams</name><operator>-&gt;</operator><name>hashLog</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>chainTable</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>chainTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>chainMask</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>cParams</name><operator>-&gt;</operator><name>chainLog</name></name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>base</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>target</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>idx</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name></expr></init></decl>;</decl_stmt>

    <while>while<condition>(<expr><name>idx</name> <operator>&lt;</operator> <name>target</name></expr>)</condition> <block>{<block_content> <comment type="block">/* catch up */</comment>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>h</name> <init>= <expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>base</name><operator>+</operator><name>idx</name></expr></argument>, <argument><expr><name>hashLog</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>NEXT_IN_CHAIN</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>chainMask</name></expr></argument>)</argument_list></call> <operator>=</operator> <name><name>hashTable</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hashTable</name><index>[<expr><name>h</name></expr>]</index></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
    <return>return <expr><name><name>hashTable</name><index>[<expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>hashLog</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>U32</name></type> <name>ZSTD_insertAndFindFirstIndex</name><parameter_list>(<parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_compressionParameters</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cParams</name> <init>= <expr><operator>&amp;</operator><name><name>ms</name><operator>-&gt;</operator><name>cParams</name></name></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>ZSTD_insertAndFindFirstIndex_internal</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>cParams</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name><name>ms</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>minMatch</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* inlining is important to hardwire a hot branch (template emulation) */</comment>
<function><type><name>FORCE_INLINE_TEMPLATE</name>
<name>size_t</name></type> <name>ZSTD_HcFindBestMatch</name><parameter_list>(
                        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ip</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iLimit</name></decl></parameter>,
                        <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>offsetPtr</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name>mls</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ZSTD_dictMode_e</name></type> <name>dictMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_compressionParameters</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cParams</name> <init>= <expr><operator>&amp;</operator><name><name>ms</name><operator>-&gt;</operator><name>cParams</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>chainTable</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>chainTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>chainSize</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>cParams</name><operator>-&gt;</operator><name>chainLog</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>chainMask</name> <init>= <expr><name>chainSize</name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>base</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictBase</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictBase</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dictLimit</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictLimit</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>prefixStart</name> <init>= <expr><name>base</name> <operator>+</operator> <name>dictLimit</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictEnd</name> <init>= <expr><name>dictBase</name> <operator>+</operator> <name>dictLimit</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>curr</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>maxDistance</name> <init>= <expr><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name><name>cParams</name><operator>-&gt;</operator><name>windowLog</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>lowestValid</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>lowLimit</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>withinMaxDistance</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>curr</name> <operator>-</operator> <name>lowestValid</name> <operator>&gt;</operator> <name>maxDistance</name><operator>)</operator></expr> ?</condition><then> <expr><name>curr</name> <operator>-</operator> <name>maxDistance</name></expr> </then><else>: <expr><name>lowestValid</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>isDictionary</name> <init>= <expr><operator>(</operator><name><name>ms</name><operator>-&gt;</operator><name>loadedDictEnd</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>lowLimit</name> <init>= <expr><ternary><condition><expr><name>isDictionary</name></expr> ?</condition><then> <expr><name>lowestValid</name></expr> </then><else>: <expr><name>withinMaxDistance</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>minChain</name> <init>= <expr><ternary><condition><expr><name>curr</name> <operator>&gt;</operator> <name>chainSize</name></expr> ?</condition><then> <expr><name>curr</name> <operator>-</operator> <name>chainSize</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>nbAttempts</name> <init>= <expr><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name><name>cParams</name><operator>-&gt;</operator><name>searchLog</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>ml</name><init>=<expr><literal type="number">4</literal><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_matchState_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dms</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>dictMatchState</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>ddsHashLog</name> <init>= <expr><ternary><condition><expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_dedicatedDictSearch</name></expr>
                         ?</condition><then> <expr><name><name>dms</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>hashLog</name></name> <operator>-</operator> <name>ZSTD_LAZY_DDSS_BUCKET_LOG</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>ddsIdx</name> <init>= <expr><ternary><condition><expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_dedicatedDictSearch</name></expr>
                        ?</condition><then> <expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>ddsHashLog</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <name>ZSTD_LAZY_DDSS_BUCKET_LOG</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>U32</name></type> <name>matchIndex</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_dedicatedDictSearch</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name><modifier>*</modifier></type> <name>entry</name> <init>= <expr><operator>&amp;</operator><name><name>dms</name><operator>-&gt;</operator><name>hashTable</name><index>[<expr><name>ddsIdx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>PREFETCH_L1</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* HC4 match finder */</comment>
    <expr_stmt><expr><name>matchIndex</name> <operator>=</operator> <call><name>ZSTD_insertAndFindFirstIndex_internal</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>cParams</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>( <init>;</init> <condition><expr><operator>(</operator><name>matchIndex</name><operator>&gt;=</operator><name>lowLimit</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>nbAttempts</name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator></expr> ;</condition> <incr><expr><name>nbAttempts</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>currentMl</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>dictMode</name> <operator>!=</operator> <name>ZSTD_extDict</name><operator>)</operator> <operator>||</operator> <name>matchIndex</name> <operator>&gt;=</operator> <name>dictLimit</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>match</name> <init>= <expr><name>base</name> <operator>+</operator> <name>matchIndex</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>matchIndex</name> <operator>&gt;=</operator> <name>dictLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* ensures this is true if dictMode != ZSTD_extDict */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>match</name><index>[<expr><name>ml</name></expr>]</index></name> <operator>==</operator> <name><name>ip</name><index>[<expr><name>ml</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>   <comment type="block">/* potentially better */</comment>
                <expr_stmt><expr><name>currentMl</name> <operator>=</operator> <call><name>ZSTD_count</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>match</name> <init>= <expr><name>dictBase</name> <operator>+</operator> <name>matchIndex</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>match</name><operator>+</operator><literal type="number">4</literal> <operator>&lt;=</operator> <name>dictEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>MEM_read32</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>   <comment type="block">/* assumption : matchIndex &lt;= dictLimit-4 (by table construction) */</comment>
                <expr_stmt><expr><name>currentMl</name> <operator>=</operator> <call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>match</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>, <argument><expr><name>dictEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* save best solution */</comment>
        <if_stmt><if>if <condition>(<expr><name>currentMl</name> <operator>&gt;</operator> <name>ml</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>ml</name> <operator>=</operator> <name>currentMl</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>offsetPtr</name> <operator>=</operator> <call><name>OFFSET_TO_OFFBASE</name><argument_list>(<argument><expr><name>curr</name> <operator>-</operator> <name>matchIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>ip</name><operator>+</operator><name>currentMl</name> <operator>==</operator> <name>iLimit</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt> <comment type="block">/* best possible, avoids read overflow on next attempt */</comment>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>matchIndex</name> <operator>&lt;=</operator> <name>minChain</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>matchIndex</name> <operator>=</operator> <call><name>NEXT_IN_CHAIN</name><argument_list>(<argument><expr><name>matchIndex</name></expr></argument>, <argument><expr><name>chainMask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nbAttempts</name> <operator>&lt;=</operator> <operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>ZSTD_SEARCHLOG_MAX</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Check we haven't underflowed. */</comment>
    <if_stmt><if>if <condition>(<expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_dedicatedDictSearch</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>ml</name> <operator>=</operator> <call><name>ZSTD_dedicatedDictSearch_lazy_search</name><argument_list>(<argument><expr><name>offsetPtr</name></expr></argument>, <argument><expr><name>ml</name></expr></argument>, <argument><expr><name>nbAttempts</name></expr></argument>, <argument><expr><name>dms</name></expr></argument>,
                                                  <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>, <argument><expr><name>curr</name></expr></argument>, <argument><expr><name>dictLimit</name></expr></argument>, <argument><expr><name>ddsIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_dictMatchState</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dmsChainTable</name> <init>= <expr><name><name>dms</name><operator>-&gt;</operator><name>chainTable</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dmsChainSize</name>         <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>dms</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>chainLog</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dmsChainMask</name>         <init>= <expr><name>dmsChainSize</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dmsLowestIndex</name>       <init>= <expr><name><name>dms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictLimit</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dmsBase</name>      <init>= <expr><name><name>dms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dmsEnd</name>       <init>= <expr><name><name>dms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>nextSrc</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dmsSize</name>              <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>dmsEnd</name> <operator>-</operator> <name>dmsBase</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dmsIndexDelta</name>        <init>= <expr><name>dictLimit</name> <operator>-</operator> <name>dmsSize</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dmsMinChain</name> <init>= <expr><ternary><condition><expr><name>dmsSize</name> <operator>&gt;</operator> <name>dmsChainSize</name></expr> ?</condition><then> <expr><name>dmsSize</name> <operator>-</operator> <name>dmsChainSize</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>matchIndex</name> <operator>=</operator> <name><name>dms</name><operator>-&gt;</operator><name>hashTable</name><index>[<expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name><name>dms</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>hashLog</name></name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>

        <for>for <control>( <init>;</init> <condition><expr><operator>(</operator><name>matchIndex</name><operator>&gt;=</operator><name>dmsLowestIndex</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>nbAttempts</name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator></expr> ;</condition> <incr><expr><name>nbAttempts</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>size_t</name></type> <name>currentMl</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>match</name> <init>= <expr><name>dmsBase</name> <operator>+</operator> <name>matchIndex</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>match</name><operator>+</operator><literal type="number">4</literal> <operator>&lt;=</operator> <name>dmsEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>MEM_read32</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>   <comment type="block">/* assumption : matchIndex &lt;= dictLimit-4 (by table construction) */</comment>
                <expr_stmt><expr><name>currentMl</name> <operator>=</operator> <call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>match</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>, <argument><expr><name>dmsEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* save best solution */</comment>
            <if_stmt><if>if <condition>(<expr><name>currentMl</name> <operator>&gt;</operator> <name>ml</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>ml</name> <operator>=</operator> <name>currentMl</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>curr</name> <operator>&gt;</operator> <name>matchIndex</name> <operator>+</operator> <name>dmsIndexDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>offsetPtr</name> <operator>=</operator> <call><name>OFFSET_TO_OFFBASE</name><argument_list>(<argument><expr><name>curr</name> <operator>-</operator> <operator>(</operator><name>matchIndex</name> <operator>+</operator> <name>dmsIndexDelta</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>ip</name><operator>+</operator><name>currentMl</name> <operator>==</operator> <name>iLimit</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt> <comment type="block">/* best possible, avoids read overflow on next attempt */</comment>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>matchIndex</name> <operator>&lt;=</operator> <name>dmsMinChain</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>matchIndex</name> <operator>=</operator> <name><name>dmsChainTable</name><index>[<expr><name>matchIndex</name> <operator>&amp;</operator> <name>dmsChainMask</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>ml</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* *********************************
* (SIMD) Row-based matchfinder
***********************************/</comment>
<comment type="block">/* Constants for row-based hash */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZSTD_ROW_HASH_TAG_OFFSET</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>     <comment type="block">/* byte offset of hashes in the match state's tagTable from the beginning of a row */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZSTD_ROW_HASH_TAG_BITS</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>        <comment type="block">/* nb bits to use for the tag */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZSTD_ROW_HASH_TAG_MASK</name></cpp:macro> <cpp:value>((1u &lt;&lt; ZSTD_ROW_HASH_TAG_BITS) - 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZSTD_ROW_HASH_MAX_ENTRIES</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>    <comment type="block">/* absolute maximum number of entries per row, for all configurations */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZSTD_ROW_HASH_CACHE_MASK</name></cpp:macro> <cpp:value>(ZSTD_ROW_HASH_CACHE_SIZE - 1)</cpp:value></cpp:define>

<typedef>typedef <type><name>U64</name></type> <name>ZSTD_VecMask</name>;</typedef>   <comment type="block">/* Clarifies when we are interacting with a U64 representing a mask of matches */</comment>

<comment type="block">/* ZSTD_VecMask_next():
 * Starting from the LSB, returns the idx of the next non-zero bit.
 * Basically counting the nb of trailing zeroes.
 */</comment>
<function><type><name>MEM_STATIC</name> <name>U32</name></type> <name>ZSTD_VecMask_next</name><parameter_list>(<parameter><decl><type><name>ZSTD_VecMask</name></type> <name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>ZSTD_countTrailingZeros64</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ZSTD_rotateRight_*():
 * Rotates a bitfield to the right by "count" bits.
 * https://en.wikipedia.org/w/index.php?title=Circular_shift&amp;oldid=991635599#Implementing_circular_shifts
 */</comment>
<function><type><name>FORCE_INLINE_TEMPLATE</name>
<name>U64</name></type> <name>ZSTD_rotateRight_U64</name><parameter_list>(<parameter><decl><type><name>U64</name> <specifier>const</specifier></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>count</name> <operator>&lt;</operator> <literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>count</name> <operator>&amp;=</operator> <literal type="number">0x3F</literal></expr>;</expr_stmt> <comment type="block">/* for fickle pattern recognition */</comment>
    <return>return <expr><operator>(</operator><name>value</name> <operator>&gt;&gt;</operator> <name>count</name><operator>)</operator> <operator>|</operator> <operator>(</operator><name>U64</name><operator>)</operator><operator>(</operator><name>value</name> <operator>&lt;&lt;</operator> <operator>(</operator><operator>(</operator><literal type="number">0U</literal> <operator>-</operator> <name>count</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3F</literal><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>FORCE_INLINE_TEMPLATE</name>
<name>U32</name></type> <name>ZSTD_rotateRight_U32</name><parameter_list>(<parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>count</name> <operator>&lt;</operator> <literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>count</name> <operator>&amp;=</operator> <literal type="number">0x1F</literal></expr>;</expr_stmt> <comment type="block">/* for fickle pattern recognition */</comment>
    <return>return <expr><operator>(</operator><name>value</name> <operator>&gt;&gt;</operator> <name>count</name><operator>)</operator> <operator>|</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>value</name> <operator>&lt;&lt;</operator> <operator>(</operator><operator>(</operator><literal type="number">0U</literal> <operator>-</operator> <name>count</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x1F</literal><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>FORCE_INLINE_TEMPLATE</name>
<name>U16</name></type> <name>ZSTD_rotateRight_U16</name><parameter_list>(<parameter><decl><type><name>U16</name> <specifier>const</specifier></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>count</name> <operator>&lt;</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>count</name> <operator>&amp;=</operator> <literal type="number">0x0F</literal></expr>;</expr_stmt> <comment type="block">/* for fickle pattern recognition */</comment>
    <return>return <expr><operator>(</operator><name>value</name> <operator>&gt;&gt;</operator> <name>count</name><operator>)</operator> <operator>|</operator> <operator>(</operator><name>U16</name><operator>)</operator><operator>(</operator><name>value</name> <operator>&lt;&lt;</operator> <operator>(</operator><operator>(</operator><literal type="number">0U</literal> <operator>-</operator> <name>count</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x0F</literal><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ZSTD_row_nextIndex():
 * Returns the next index to insert at within a tagTable row, and updates the "head"
 * value to reflect the update. Essentially cycles backwards from [0, {entries per row})
 */</comment>
<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>U32</name></type> <name>ZSTD_row_nextIndex</name><parameter_list>(<parameter><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>tagRow</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>rowMask</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>next</name> <init>= <expr><operator>(</operator><operator>*</operator><name>tagRow</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <name>rowMask</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><name>tagRow</name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><name>next</name></expr>;</expr_stmt>
  <return>return <expr><name>next</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ZSTD_isAligned():
 * Checks that a pointer is aligned to "align" bytes which must be a power of 2.
 */</comment>
<function><type><name>MEM_STATIC</name> <name>int</name></type> <name>ZSTD_isAligned</name><parameter_list>(<parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>align</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>align</name> <operator>&amp;</operator> <operator>(</operator><name>align</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><name>ptr</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>align</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ZSTD_row_prefetch():
 * Performs prefetching for the hashTable and tagTable at a given row.
 */</comment>
<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>void</name></type> <name>ZSTD_row_prefetch</name><parameter_list>(<parameter><decl><type><name>U32</name> <specifier>const</specifier><modifier>*</modifier></type> <name>hashTable</name></decl></parameter>, <parameter><decl><type><name>U16</name> <specifier>const</specifier><modifier>*</modifier></type> <name>tagTable</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>relRow</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>rowLog</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>PREFETCH_L1</name><argument_list>(<argument><expr><name>hashTable</name> <operator>+</operator> <name>relRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rowLog</name> <operator>&gt;=</operator> <literal type="number">5</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>PREFETCH_L1</name><argument_list>(<argument><expr><name>hashTable</name> <operator>+</operator> <name>relRow</name> <operator>+</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Note: prefetching more of the hash table does not appear to be beneficial for 128-entry rows */</comment>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>PREFETCH_L1</name><argument_list>(<argument><expr><name>tagTable</name> <operator>+</operator> <name>relRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rowLog</name> <operator>==</operator> <literal type="number">6</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>PREFETCH_L1</name><argument_list>(<argument><expr><name>tagTable</name> <operator>+</operator> <name>relRow</name> <operator>+</operator> <literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rowLog</name> <operator>==</operator> <literal type="number">4</literal> <operator>||</operator> <name>rowLog</name> <operator>==</operator> <literal type="number">5</literal> <operator>||</operator> <name>rowLog</name> <operator>==</operator> <literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>ZSTD_isAligned</name><argument_list>(<argument><expr><name>hashTable</name> <operator>+</operator> <name>relRow</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>                 <comment type="block">/* prefetched hash row always 64-byte aligned */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>ZSTD_isAligned</name><argument_list>(<argument><expr><name>tagTable</name> <operator>+</operator> <name>relRow</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>rowLog</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* prefetched tagRow sits on correct multiple of bytes (32,64,128) */</comment>
</block_content>}</block></function>

<comment type="block">/* ZSTD_row_fillHashCache():
 * Fill up the hash cache starting at idx, prefetching up to ZSTD_ROW_HASH_CACHE_SIZE entries,
 * but not beyond iLimit.
 */</comment>
<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>void</name></type> <name>ZSTD_row_fillHashCache</name><parameter_list>(<parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>base</name></decl></parameter>,
                                   <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>rowLog</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>mls</name></decl></parameter>,
                                   <parameter><decl><type><name>U32</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iLimit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>hashTable</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>hashTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U16</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>tagTable</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>tagTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>hashLog</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>rowHashLog</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>maxElemsToPrefetch</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>base</name> <operator>+</operator> <name>idx</name><operator>)</operator> <operator>&gt;</operator> <name>iLimit</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>iLimit</name> <operator>-</operator> <operator>(</operator><name>base</name> <operator>+</operator> <name>idx</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>lim</name> <init>= <expr><name>idx</name> <operator>+</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>ZSTD_ROW_HASH_CACHE_SIZE</name></expr></argument>, <argument><expr><name>maxElemsToPrefetch</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name>lim</name></expr>;</condition> <incr><expr><operator>++</operator><name>idx</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>hash</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>base</name> <operator>+</operator> <name>idx</name></expr></argument>, <argument><expr><name>hashLog</name> <operator>+</operator> <name>ZSTD_ROW_HASH_TAG_BITS</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>row</name> <init>= <expr><operator>(</operator><name>hash</name> <operator>&gt;&gt;</operator> <name>ZSTD_ROW_HASH_TAG_BITS</name><operator>)</operator> <operator>&lt;&lt;</operator> <name>rowLog</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ZSTD_row_prefetch</name><argument_list>(<argument><expr><name>hashTable</name></expr></argument>, <argument><expr><name>tagTable</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>rowLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>hashCache</name><index>[<expr><name>idx</name> <operator>&amp;</operator> <name>ZSTD_ROW_HASH_CACHE_MASK</name></expr>]</index></name> <operator>=</operator> <name>hash</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_row_fillHashCache(): [%u %u %u %u %u %u %u %u]"</literal></expr></argument>, <argument><expr><name><name>ms</name><operator>-&gt;</operator><name>hashCache</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>ms</name><operator>-&gt;</operator><name>hashCache</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                                                     <argument><expr><name><name>ms</name><operator>-&gt;</operator><name>hashCache</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>ms</name><operator>-&gt;</operator><name>hashCache</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>ms</name><operator>-&gt;</operator><name>hashCache</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>,
                                                     <argument><expr><name><name>ms</name><operator>-&gt;</operator><name>hashCache</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>ms</name><operator>-&gt;</operator><name>hashCache</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>ms</name><operator>-&gt;</operator><name>hashCache</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ZSTD_row_nextCachedHash():
 * Returns the hash of base + idx, and replaces the hash in the hash cache with the byte at
 * base + idx + ZSTD_ROW_HASH_CACHE_SIZE. Also prefetches the appropriate rows from hashTable and tagTable.
 */</comment>
<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>U32</name></type> <name>ZSTD_row_nextCachedHash</name><parameter_list>(<parameter><decl><type><name>U32</name><modifier>*</modifier></type> <name>cache</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier><modifier>*</modifier></type> <name>hashTable</name></decl></parameter>,
                                                  <parameter><decl><type><name>U16</name> <specifier>const</specifier><modifier>*</modifier></type> <name>tagTable</name></decl></parameter>, <parameter><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>base</name></decl></parameter>,
                                                  <parameter><decl><type><name>U32</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>hashLog</name></decl></parameter>,
                                                  <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>rowLog</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>mls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>newHash</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>base</name><operator>+</operator><name>idx</name><operator>+</operator><name>ZSTD_ROW_HASH_CACHE_SIZE</name></expr></argument>, <argument><expr><name>hashLog</name> <operator>+</operator> <name>ZSTD_ROW_HASH_TAG_BITS</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>row</name> <init>= <expr><operator>(</operator><name>newHash</name> <operator>&gt;&gt;</operator> <name>ZSTD_ROW_HASH_TAG_BITS</name><operator>)</operator> <operator>&lt;&lt;</operator> <name>rowLog</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ZSTD_row_prefetch</name><argument_list>(<argument><expr><name>hashTable</name></expr></argument>, <argument><expr><name>tagTable</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>rowLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>hash</name> <init>= <expr><name><name>cache</name><index>[<expr><name>idx</name> <operator>&amp;</operator> <name>ZSTD_ROW_HASH_CACHE_MASK</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>cache</name><index>[<expr><name>idx</name> <operator>&amp;</operator> <name>ZSTD_ROW_HASH_CACHE_MASK</name></expr>]</index></name> <operator>=</operator> <name>newHash</name></expr>;</expr_stmt>
        <return>return <expr><name>hash</name></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/* ZSTD_row_update_internalImpl():
 * Updates the hash table with positions starting from updateStartIdx until updateEndIdx.
 */</comment>
<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>void</name></type> <name>ZSTD_row_update_internalImpl</name><parameter_list>(<parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>,
                                                        <parameter><decl><type><name>U32</name></type> <name>updateStartIdx</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>updateEndIdx</name></decl></parameter>,
                                                        <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>mls</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>rowLog</name></decl></parameter>,
                                                        <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>rowMask</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>useCache</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>hashTable</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>hashTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U16</name><modifier>*</modifier> <specifier>const</specifier></type> <name>tagTable</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>tagTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>hashLog</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>rowHashLog</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>base</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_row_update_internalImpl(): updateStartIdx=%u, updateEndIdx=%u"</literal></expr></argument>, <argument><expr><name>updateStartIdx</name></expr></argument>, <argument><expr><name>updateEndIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init>;</init> <condition><expr><name>updateStartIdx</name> <operator>&lt;</operator> <name>updateEndIdx</name></expr>;</condition> <incr><expr><operator>++</operator><name>updateStartIdx</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>hash</name> <init>= <expr><ternary><condition><expr><name>useCache</name></expr> ?</condition><then> <expr><call><name>ZSTD_row_nextCachedHash</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>hashCache</name></name></expr></argument>, <argument><expr><name>hashTable</name></expr></argument>, <argument><expr><name>tagTable</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>updateStartIdx</name></expr></argument>, <argument><expr><name>hashLog</name></expr></argument>, <argument><expr><name>rowLog</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr>
                                  </then><else>: <expr><operator>(</operator><name>U32</name><operator>)</operator><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>base</name> <operator>+</operator> <name>updateStartIdx</name></expr></argument>, <argument><expr><name>hashLog</name> <operator>+</operator> <name>ZSTD_ROW_HASH_TAG_BITS</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>relRow</name> <init>= <expr><operator>(</operator><name>hash</name> <operator>&gt;&gt;</operator> <name>ZSTD_ROW_HASH_TAG_BITS</name><operator>)</operator> <operator>&lt;&lt;</operator> <name>rowLog</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>row</name> <init>= <expr><name>hashTable</name> <operator>+</operator> <name>relRow</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>tagRow</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><operator>(</operator><name>tagTable</name> <operator>+</operator> <name>relRow</name><operator>)</operator></expr></init></decl>;</decl_stmt>  <comment type="block">/* Though tagTable is laid out as a table of U16, each tag is only 1 byte.
                                                       Explicit cast allows us to get exact desired position within each row */</comment>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>pos</name> <init>= <expr><call><name>ZSTD_row_nextIndex</name><argument_list>(<argument><expr><name>tagRow</name></expr></argument>, <argument><expr><name>rowMask</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>hash</name> <operator>==</operator> <call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>base</name> <operator>+</operator> <name>updateStartIdx</name></expr></argument>, <argument><expr><name>hashLog</name> <operator>+</operator> <name>ZSTD_ROW_HASH_TAG_BITS</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>tagRow</name><operator>)</operator><index>[<expr><name>pos</name> <operator>+</operator> <name>ZSTD_ROW_HASH_TAG_OFFSET</name></expr>]</index> <operator>=</operator> <name>hash</name> <operator>&amp;</operator> <name>ZSTD_ROW_HASH_TAG_MASK</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>row</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>=</operator> <name>updateStartIdx</name></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* ZSTD_row_update_internal():
 * Inserts the byte at ip into the appropriate position in the hash table, and updates ms-&gt;nextToUpdate.
 * Skips sections of long matches as is necessary.
 */</comment>
<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>void</name></type> <name>ZSTD_row_update_internal</name><parameter_list>(<parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name></decl></parameter>,
                                                    <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>mls</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>rowLog</name></decl></parameter>,
                                                    <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>rowMask</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>useCache</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name></type> <name>idx</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>base</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>target</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>kSkipThreshold</name> <init>= <expr><literal type="number">384</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>kMaxMatchStartPositionsToUpdate</name> <init>= <expr><literal type="number">96</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>kMaxMatchEndPositionsToUpdate</name> <init>= <expr><literal type="number">32</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>useCache</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Only skip positions when using hash cache, i.e.
         * if we are loading a dict, don't skip anything.
         * If we decide to skip, then we only update a set number
         * of positions at the beginning and end of the match.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><name>target</name> <operator>-</operator> <name>idx</name> <operator>&gt;</operator> <name>kSkipThreshold</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>bound</name> <init>= <expr><name>idx</name> <operator>+</operator> <name>kMaxMatchStartPositionsToUpdate</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ZSTD_row_update_internalImpl</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>bound</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>, <argument><expr><name>rowLog</name></expr></argument>, <argument><expr><name>rowMask</name></expr></argument>, <argument><expr><name>useCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>idx</name> <operator>=</operator> <name>target</name> <operator>-</operator> <name>kMaxMatchEndPositionsToUpdate</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ZSTD_row_fillHashCache</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>rowLog</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>ip</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>target</name> <operator>&gt;=</operator> <name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_row_update_internalImpl</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>, <argument><expr><name>rowLog</name></expr></argument>, <argument><expr><name>rowMask</name></expr></argument>, <argument><expr><name>useCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ZSTD_row_update():
 * External wrapper for ZSTD_row_update_internal(). Used for filling the hashtable during dictionary
 * processing.
 */</comment>
<function><type><name>void</name></type> <name>ZSTD_row_update</name><parameter_list>(<parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>rowLog</name> <init>= <expr><call><name>BOUNDED</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name><name>ms</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>searchLog</name></name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>rowMask</name> <init>= <expr><operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>rowLog</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>mls</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>minMatch</name></name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument> <comment type="block">/* mls caps out at 6 */</comment>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_row_update(), rowLog=%u"</literal></expr></argument>, <argument><expr><name>rowLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_row_update_internal</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>, <argument><expr><name>rowLog</name></expr></argument>, <argument><expr><name>rowMask</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* don't use cache */</comment>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Returns the mask width of bits group of which will be set to 1. Given not all
 * architectures have easy movemask instruction, this helps to iterate over
 * groups of bits easier and faster.
 */</comment>
<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>U32</name></type>
<name>ZSTD_row_matchMaskGroupWidth</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name>rowEntries</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>rowEntries</name> <operator>==</operator> <literal type="number">16</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>rowEntries</name> <operator>==</operator> <literal type="number">32</literal><operator>)</operator> <operator>||</operator> <name>rowEntries</name> <operator>==</operator> <literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rowEntries</name> <operator>&lt;=</operator> <name>ZSTD_ROW_HASH_MAX_ENTRIES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>rowEntries</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ZSTD_ARCH_ARM_NEON</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="block">/* NEON path only works for little endian */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MEM_isLittleEndian</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>rowEntries</name> <operator>==</operator> <literal type="number">16</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">4</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>rowEntries</name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">2</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>rowEntries</name> <operator>==</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ZSTD_ARCH_X86_SSE2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>ZSTD_VecMask</name></type>
<name>ZSTD_row_getSSEMask</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nbChunks</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name>head</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>__m128i</name></type> <name>comparisonMask</name> <init>= <expr><call><name>_mm_set1_epi8</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>)</operator><name>tag</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name><name>matches</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nbChunks</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <name>nbChunks</name> <operator>==</operator> <literal type="number">2</literal> <operator>||</operator> <name>nbChunks</name> <operator>==</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nbChunks</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>__m128i</name></type> <name>chunk</name> <init>= <expr><call><name>_mm_loadu_si128</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>__m128i</name><operator>*</operator><operator>)</operator><operator>(</operator><specifier>const</specifier> <name>void</name><operator>*</operator><operator>)</operator><operator>(</operator><name>src</name> <operator>+</operator> <literal type="number">16</literal><operator>*</operator><name>i</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>__m128i</name></type> <name>equalMask</name> <init>= <expr><call><name>_mm_cmpeq_epi8</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>comparisonMask</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>matches</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>_mm_movemask_epi8</name><argument_list>(<argument><expr><name>equalMask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>nbChunks</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ZSTD_rotateRight_U16</name><argument_list>(<argument><expr><operator>(</operator><name>U16</name><operator>)</operator><name><name>matches</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>nbChunks</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ZSTD_rotateRight_U32</name><argument_list>(<argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>matches</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal> <operator>|</operator> <operator>(</operator><name>U32</name><operator>)</operator><name><name>matches</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nbChunks</name> <operator>==</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>ZSTD_rotateRight_U64</name><argument_list>(<argument><expr><operator>(</operator><name>U64</name><operator>)</operator><name><name>matches</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">48</literal> <operator>|</operator> <operator>(</operator><name>U64</name><operator>)</operator><name><name>matches</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>|</operator> <operator>(</operator><name>U64</name><operator>)</operator><name><name>matches</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal> <operator>|</operator> <operator>(</operator><name>U64</name><operator>)</operator><name><name>matches</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ZSTD_ARCH_ARM_NEON</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>ZSTD_VecMask</name></type>
<name>ZSTD_row_getNEONMask</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name>rowEntries</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name>headGrouped</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>rowEntries</name> <operator>==</operator> <literal type="number">16</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>rowEntries</name> <operator>==</operator> <literal type="number">32</literal><operator>)</operator> <operator>||</operator> <name>rowEntries</name> <operator>==</operator> <literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rowEntries</name> <operator>==</operator> <literal type="number">16</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* vshrn_n_u16 shifts by 4 every u16 and narrows to 8 lower bits.
         * After that groups of 4 bits represent the equalMask. We lower
         * all bits except the highest in these groups by doing AND with
         * 0x88 = 0b10001000.
         */</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint8x16_t</name></type> <name>chunk</name> <init>= <expr><call><name>vld1q_u8</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint16x8_t</name></type> <name>equalMask</name> <init>= <expr><call><name>vreinterpretq_u16_u8</name><argument_list>(<argument><expr><call><name>vceqq_u8</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><call><name>vdupq_n_u8</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint8x8_t</name></type> <name>res</name> <init>= <expr><call><name>vshrn_n_u16</name><argument_list>(<argument><expr><name>equalMask</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U64</name></type> <name>matches</name> <init>= <expr><call><name>vget_lane_u64</name><argument_list>(<argument><expr><call><name>vreinterpret_u64_u8</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>ZSTD_rotateRight_U64</name><argument_list>(<argument><expr><name>matches</name></expr></argument>, <argument><expr><name>headGrouped</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">0x8888888888888888ull</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>rowEntries</name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Same idea as with rowEntries == 16 but doing AND with
         * 0x55 = 0b01010101.
         */</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint16x8x2_t</name></type> <name>chunk</name> <init>= <expr><call><name>vld2q_u16</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>uint16_t</name><operator>*</operator><operator>)</operator><operator>(</operator><specifier>const</specifier> <name>void</name><operator>*</operator><operator>)</operator><name>src</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint8x16_t</name></type> <name>chunk0</name> <init>= <expr><call><name>vreinterpretq_u8_u16</name><argument_list>(<argument><expr><name><name>chunk</name><operator>.</operator><name>val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint8x16_t</name></type> <name>chunk1</name> <init>= <expr><call><name>vreinterpretq_u8_u16</name><argument_list>(<argument><expr><name><name>chunk</name><operator>.</operator><name>val</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint8x16_t</name></type> <name>dup</name> <init>= <expr><call><name>vdupq_n_u8</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint8x8_t</name></type> <name>t0</name> <init>= <expr><call><name>vshrn_n_u16</name><argument_list>(<argument><expr><call><name>vreinterpretq_u16_u8</name><argument_list>(<argument><expr><call><name>vceqq_u8</name><argument_list>(<argument><expr><name>chunk0</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint8x8_t</name></type> <name>t1</name> <init>= <expr><call><name>vshrn_n_u16</name><argument_list>(<argument><expr><call><name>vreinterpretq_u16_u8</name><argument_list>(<argument><expr><call><name>vceqq_u8</name><argument_list>(<argument><expr><name>chunk1</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint8x8_t</name></type> <name>res</name> <init>= <expr><call><name>vsli_n_u8</name><argument_list>(<argument><expr><name>t0</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U64</name></type> <name>matches</name> <init>= <expr><call><name>vget_lane_u64</name><argument_list>(<argument><expr><call><name>vreinterpret_u64_u8</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
        <return>return <expr><call><name>ZSTD_rotateRight_U64</name><argument_list>(<argument><expr><name>matches</name></expr></argument>, <argument><expr><name>headGrouped</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">0x5555555555555555ull</literal></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content> <comment type="block">/* rowEntries == 64 */</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint8x16x4_t</name></type> <name>chunk</name> <init>= <expr><call><name>vld4q_u8</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint8x16_t</name></type> <name>dup</name> <init>= <expr><call><name>vdupq_n_u8</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint8x16_t</name></type> <name>cmp0</name> <init>= <expr><call><name>vceqq_u8</name><argument_list>(<argument><expr><name><name>chunk</name><operator>.</operator><name>val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint8x16_t</name></type> <name>cmp1</name> <init>= <expr><call><name>vceqq_u8</name><argument_list>(<argument><expr><name><name>chunk</name><operator>.</operator><name>val</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint8x16_t</name></type> <name>cmp2</name> <init>= <expr><call><name>vceqq_u8</name><argument_list>(<argument><expr><name><name>chunk</name><operator>.</operator><name>val</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint8x16_t</name></type> <name>cmp3</name> <init>= <expr><call><name>vceqq_u8</name><argument_list>(<argument><expr><name><name>chunk</name><operator>.</operator><name>val</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>const</specifier> <name>uint8x16_t</name></type> <name>t0</name> <init>= <expr><call><name>vsriq_n_u8</name><argument_list>(<argument><expr><name>cmp1</name></expr></argument>, <argument><expr><name>cmp0</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint8x16_t</name></type> <name>t1</name> <init>= <expr><call><name>vsriq_n_u8</name><argument_list>(<argument><expr><name>cmp3</name></expr></argument>, <argument><expr><name>cmp2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint8x16_t</name></type> <name>t2</name> <init>= <expr><call><name>vsriq_n_u8</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t0</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint8x16_t</name></type> <name>t3</name> <init>= <expr><call><name>vsriq_n_u8</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint8x8_t</name></type> <name>t4</name> <init>= <expr><call><name>vshrn_n_u16</name><argument_list>(<argument><expr><call><name>vreinterpretq_u16_u8</name><argument_list>(<argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U64</name></type> <name>matches</name> <init>= <expr><call><name>vget_lane_u64</name><argument_list>(<argument><expr><call><name>vreinterpret_u64_u8</name><argument_list>(<argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>ZSTD_rotateRight_U64</name><argument_list>(<argument><expr><name>matches</name></expr></argument>, <argument><expr><name>headGrouped</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Returns a ZSTD_VecMask (U64) that has the nth group (determined by
 * ZSTD_row_matchMaskGroupWidth) of bits set to 1 if the newly-computed "tag"
 * matches the hash at the nth position in a row of the tagTable.
 * Each row is a circular buffer beginning at the value of "headGrouped". So we
 * must rotate the "matches" bitfield to match up with the actual layout of the
 * entries within the hashTable */</comment>
<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>ZSTD_VecMask</name></type>
<name>ZSTD_row_getMatchMask</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>tagRow</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name>headGrouped</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name>rowEntries</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>src</name> <init>= <expr><name>tagRow</name> <operator>+</operator> <name>ZSTD_ROW_HASH_TAG_OFFSET</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>rowEntries</name> <operator>==</operator> <literal type="number">16</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>rowEntries</name> <operator>==</operator> <literal type="number">32</literal><operator>)</operator> <operator>||</operator> <name>rowEntries</name> <operator>==</operator> <literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rowEntries</name> <operator>&lt;=</operator> <name>ZSTD_ROW_HASH_MAX_ENTRIES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>ZSTD_row_matchMaskGroupWidth</name><argument_list>(<argument><expr><name>rowEntries</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>rowEntries</name> <operator>&lt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_VecMask</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ZSTD_ARCH_X86_SSE2</name></expr></argument>)</argument_list></call></expr></cpp:if>

    <return>return <expr><call><name>ZSTD_row_getSSEMask</name><argument_list>(<argument><expr><name>rowEntries</name> <operator>/</operator> <literal type="number">16</literal></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>headGrouped</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* SW or NEON-LE */</comment>

<cpp:if># <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ZSTD_ARCH_ARM_NEON</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <comment type="block">/* This NEON path only works for little endian - otherwise use SWAR below */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>MEM_isLittleEndian</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>ZSTD_row_getNEONMask</name><argument_list>(<argument><expr><name>rowEntries</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>headGrouped</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ZSTD_ARCH_ARM_NEON */</comment>
    <comment type="block">/* SWAR */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>chunkSize</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>shiftAmount</name> <init>= <expr><operator>(</operator><operator>(</operator><name>chunkSize</name> <operator>*</operator> <literal type="number">8</literal><operator>)</operator> <operator>-</operator> <name>chunkSize</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>xFF</name> <init>= <expr><operator>~</operator><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>x01</name> <init>= <expr><name>xFF</name> <operator>/</operator> <literal type="number">0xFF</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>x80</name> <init>= <expr><name>x01</name> <operator>&lt;&lt;</operator> <literal type="number">7</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>splatChar</name> <init>= <expr><name>tag</name> <operator>*</operator> <name>x01</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ZSTD_VecMask</name></type> <name>matches</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>rowEntries</name> <operator>-</operator> <name>chunkSize</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <literal type="number">4</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <literal type="number">8</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>MEM_isLittleEndian</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content> <comment type="block">/* runtime check so have two loops */</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>extractMagic</name> <init>= <expr><operator>(</operator><name>xFF</name> <operator>/</operator> <literal type="number">0x7F</literal><operator>)</operator> <operator>&gt;&gt;</operator> <name>chunkSize</name></expr></init></decl>;</decl_stmt>
            <do>do <block>{<block_content>
                <decl_stmt><decl><type><name>size_t</name></type> <name>chunk</name> <init>= <expr><call><name>MEM_readST</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>chunk</name> <operator>^=</operator> <name>splatChar</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>chunk</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>chunk</name> <operator>|</operator> <name>x80</name><operator>)</operator> <operator>-</operator> <name>x01</name><operator>)</operator> <operator>|</operator> <name>chunk</name><operator>)</operator> <operator>&amp;</operator> <name>x80</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>matches</name> <operator>&lt;&lt;=</operator> <name>chunkSize</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>matches</name> <operator>|=</operator> <operator>(</operator><name>chunk</name> <operator>*</operator> <name>extractMagic</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>shiftAmount</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name> <operator>-=</operator> <name>chunkSize</name></expr>;</expr_stmt>
            </block_content>}</block> while <condition>(<expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>;</do>
        </block_content>}</block></if> <else>else <block>{<block_content> <comment type="block">/* big endian: reverse bits during extraction */</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>msb</name> <init>= <expr><name>xFF</name> <operator>^</operator> <operator>(</operator><name>xFF</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>extractMagic</name> <init>= <expr><operator>(</operator><name>msb</name> <operator>/</operator> <literal type="number">0x1FF</literal><operator>)</operator> <operator>|</operator> <name>msb</name></expr></init></decl>;</decl_stmt>
            <do>do <block>{<block_content>
                <decl_stmt><decl><type><name>size_t</name></type> <name>chunk</name> <init>= <expr><call><name>MEM_readST</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>chunk</name> <operator>^=</operator> <name>splatChar</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>chunk</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>chunk</name> <operator>|</operator> <name>x80</name><operator>)</operator> <operator>-</operator> <name>x01</name><operator>)</operator> <operator>|</operator> <name>chunk</name><operator>)</operator> <operator>&amp;</operator> <name>x80</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>matches</name> <operator>&lt;&lt;=</operator> <name>chunkSize</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>matches</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>chunk</name> <operator>&gt;&gt;</operator> <literal type="number">7</literal><operator>)</operator> <operator>*</operator> <name>extractMagic</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>shiftAmount</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name> <operator>-=</operator> <name>chunkSize</name></expr>;</expr_stmt>
            </block_content>}</block> while <condition>(<expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>;</do>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>matches</name> <operator>=</operator> <operator>~</operator><name>matches</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>rowEntries</name> <operator>==</operator> <literal type="number">16</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><call><name>ZSTD_rotateRight_U16</name><argument_list>(<argument><expr><operator>(</operator><name>U16</name><operator>)</operator><name>matches</name></expr></argument>, <argument><expr><name>headGrouped</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>rowEntries</name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><call><name>ZSTD_rotateRight_U32</name><argument_list>(<argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>matches</name></expr></argument>, <argument><expr><name>headGrouped</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <return>return <expr><call><name>ZSTD_rotateRight_U64</name><argument_list>(<argument><expr><operator>(</operator><name>U64</name><operator>)</operator><name>matches</name></expr></argument>, <argument><expr><name>headGrouped</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/* The high-level approach of the SIMD row based match finder is as follows:
 * - Figure out where to insert the new entry:
 *      - Generate a hash from a byte along with an additional 1-byte "short hash". The additional byte is our "tag"
 *      - The hashTable is effectively split into groups or "rows" of 16 or 32 entries of U32, and the hash determines
 *        which row to insert into.
 *      - Determine the correct position within the row to insert the entry into. Each row of 16 or 32 can
 *        be considered as a circular buffer with a "head" index that resides in the tagTable.
 *      - Also insert the "tag" into the equivalent row and position in the tagTable.
 *          - Note: The tagTable has 17 or 33 1-byte entries per row, due to 16 or 32 tags, and 1 "head" entry.
 *                  The 17 or 33 entry rows are spaced out to occur every 32 or 64 bytes, respectively,
 *                  for alignment/performance reasons, leaving some bytes unused.
 * - Use SIMD to efficiently compare the tags in the tagTable to the 1-byte "short hash" and
 *   generate a bitfield that we can cycle through to check the collisions in the hash table.
 * - Pick the longest match.
 */</comment>
<function><type><name>FORCE_INLINE_TEMPLATE</name>
<name>size_t</name></type> <name>ZSTD_RowFindBestMatch</name><parameter_list>(
                        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ip</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iLimit</name></decl></parameter>,
                        <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>offsetPtr</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name>mls</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ZSTD_dictMode_e</name></type> <name>dictMode</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name>rowLog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>hashTable</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>hashTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U16</name><modifier>*</modifier> <specifier>const</specifier></type> <name>tagTable</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>tagTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>hashCache</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>hashCache</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>hashLog</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>rowHashLog</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_compressionParameters</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cParams</name> <init>= <expr><operator>&amp;</operator><name><name>ms</name><operator>-&gt;</operator><name>cParams</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>base</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictBase</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictBase</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dictLimit</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictLimit</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>prefixStart</name> <init>= <expr><name>base</name> <operator>+</operator> <name>dictLimit</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictEnd</name> <init>= <expr><name>dictBase</name> <operator>+</operator> <name>dictLimit</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>curr</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>maxDistance</name> <init>= <expr><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name><name>cParams</name><operator>-&gt;</operator><name>windowLog</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>lowestValid</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>lowLimit</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>withinMaxDistance</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>curr</name> <operator>-</operator> <name>lowestValid</name> <operator>&gt;</operator> <name>maxDistance</name><operator>)</operator></expr> ?</condition><then> <expr><name>curr</name> <operator>-</operator> <name>maxDistance</name></expr> </then><else>: <expr><name>lowestValid</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>isDictionary</name> <init>= <expr><operator>(</operator><name><name>ms</name><operator>-&gt;</operator><name>loadedDictEnd</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>lowLimit</name> <init>= <expr><ternary><condition><expr><name>isDictionary</name></expr> ?</condition><then> <expr><name>lowestValid</name></expr> </then><else>: <expr><name>withinMaxDistance</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>rowEntries</name> <init>= <expr><operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>rowLog</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>rowMask</name> <init>= <expr><name>rowEntries</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>cappedSearchLog</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name><name>cParams</name><operator>-&gt;</operator><name>searchLog</name></name></expr></argument>, <argument><expr><name>rowLog</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* nb of searches is capped at nb entries per row */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>groupWidth</name> <init>= <expr><call><name>ZSTD_row_matchMaskGroupWidth</name><argument_list>(<argument><expr><name>rowEntries</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>nbAttempts</name> <init>= <expr><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>cappedSearchLog</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>ml</name><init>=<expr><literal type="number">4</literal><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* DMS/DDS variables that may be referenced laster */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_matchState_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dms</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>dictMatchState</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Initialize the following variables to satisfy static analyzer */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>ddsIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>ddsExtraAttempts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* cctx hash tables are limited in searches, but allow extra searches into DDS */</comment>
    <decl_stmt><decl><type><name>U32</name></type> <name>dmsTag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier></type> <name>dmsRow</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>dmsTagRow</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_dedicatedDictSearch</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>ddsHashLog</name> <init>= <expr><name><name>dms</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>hashLog</name></name> <operator>-</operator> <name>ZSTD_LAZY_DDSS_BUCKET_LOG</name></expr></init></decl>;</decl_stmt>
        <block>{<block_content>   <comment type="block">/* Prefetch DDS hashtable entry */</comment>
            <expr_stmt><expr><name>ddsIdx</name> <operator>=</operator> <call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>ddsHashLog</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <name>ZSTD_LAZY_DDSS_BUCKET_LOG</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PREFETCH_L1</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dms</name><operator>-&gt;</operator><name>hashTable</name><index>[<expr><name>ddsIdx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><name>ddsExtraAttempts</name> <operator>=</operator> <ternary><condition><expr><name><name>cParams</name><operator>-&gt;</operator><name>searchLog</name></name> <operator>&gt;</operator> <name>rowLog</name></expr> ?</condition><then> <expr><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name><name>cParams</name><operator>-&gt;</operator><name>searchLog</name></name> <operator>-</operator> <name>rowLog</name><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_dictMatchState</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Prefetch DMS rows */</comment>
        <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dmsHashTable</name> <init>= <expr><name><name>dms</name><operator>-&gt;</operator><name>hashTable</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U16</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dmsTagTable</name> <init>= <expr><name><name>dms</name><operator>-&gt;</operator><name>tagTable</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>dmsHash</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name><name>dms</name><operator>-&gt;</operator><name>rowHashLog</name></name> <operator>+</operator> <name>ZSTD_ROW_HASH_TAG_BITS</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>dmsRelRow</name> <init>= <expr><operator>(</operator><name>dmsHash</name> <operator>&gt;&gt;</operator> <name>ZSTD_ROW_HASH_TAG_BITS</name><operator>)</operator> <operator>&lt;&lt;</operator> <name>rowLog</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>dmsTag</name> <operator>=</operator> <name>dmsHash</name> <operator>&amp;</operator> <name>ZSTD_ROW_HASH_TAG_MASK</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dmsTagRow</name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><operator>(</operator><name>dmsTagTable</name> <operator>+</operator> <name>dmsRelRow</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>dmsRow</name> <operator>=</operator> <name>dmsHashTable</name> <operator>+</operator> <name>dmsRelRow</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_row_prefetch</name><argument_list>(<argument><expr><name>dmsHashTable</name></expr></argument>, <argument><expr><name>dmsTagTable</name></expr></argument>, <argument><expr><name>dmsRelRow</name></expr></argument>, <argument><expr><name>rowLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Update the hashTable and tagTable up to (but not including) ip */</comment>
    <expr_stmt><expr><call><name>ZSTD_row_update_internal</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>, <argument><expr><name>rowLog</name></expr></argument>, <argument><expr><name>rowMask</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> <comment type="block">/* useCache */</comment>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>   <comment type="block">/* Get the hash for ip, compute the appropriate row */</comment>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>hash</name> <init>= <expr><call><name>ZSTD_row_nextCachedHash</name><argument_list>(<argument><expr><name>hashCache</name></expr></argument>, <argument><expr><name>hashTable</name></expr></argument>, <argument><expr><name>tagTable</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>curr</name></expr></argument>, <argument><expr><name>hashLog</name></expr></argument>, <argument><expr><name>rowLog</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>relRow</name> <init>= <expr><operator>(</operator><name>hash</name> <operator>&gt;&gt;</operator> <name>ZSTD_ROW_HASH_TAG_BITS</name><operator>)</operator> <operator>&lt;&lt;</operator> <name>rowLog</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>tag</name> <init>= <expr><name>hash</name> <operator>&amp;</operator> <name>ZSTD_ROW_HASH_TAG_MASK</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>row</name> <init>= <expr><name>hashTable</name> <operator>+</operator> <name>relRow</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>tagRow</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><operator>(</operator><name>tagTable</name> <operator>+</operator> <name>relRow</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>headGrouped</name> <init>= <expr><operator>(</operator><operator>*</operator><name>tagRow</name> <operator>&amp;</operator> <name>rowMask</name><operator>)</operator> <operator>*</operator> <name>groupWidth</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name></type> <name><name>matchBuffer</name><index>[<expr><name>ZSTD_ROW_HASH_MAX_ENTRIES</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>numMatches</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>currMatch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ZSTD_VecMask</name></type> <name>matches</name> <init>= <expr><call><name>ZSTD_row_getMatchMask</name><argument_list>(<argument><expr><name>tagRow</name></expr></argument>, <argument><expr><operator>(</operator><name>BYTE</name><operator>)</operator><name>tag</name></expr></argument>, <argument><expr><name>headGrouped</name></expr></argument>, <argument><expr><name>rowEntries</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Cycle through the matches and prefetch */</comment>
        <for>for <control>(<init>;</init> <condition><expr><operator>(</operator><name>matches</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>nbAttempts</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</condition> <incr><expr><operator>--</operator><name>nbAttempts</name></expr><operator>,</operator> <expr><name>matches</name> <operator>&amp;=</operator> <operator>(</operator><name>matches</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>matchPos</name> <init>= <expr><operator>(</operator><operator>(</operator><name>headGrouped</name> <operator>+</operator> <call><name>ZSTD_VecMask_next</name><argument_list>(<argument><expr><name>matches</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>/</operator> <name>groupWidth</name><operator>)</operator> <operator>&amp;</operator> <name>rowMask</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>matchIndex</name> <init>= <expr><name><name>row</name><index>[<expr><name>matchPos</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>numMatches</name> <operator>&lt;</operator> <name>rowEntries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>matchIndex</name> <operator>&lt;</operator> <name>lowLimit</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>dictMode</name> <operator>!=</operator> <name>ZSTD_extDict</name><operator>)</operator> <operator>||</operator> <name>matchIndex</name> <operator>&gt;=</operator> <name>dictLimit</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>PREFETCH_L1</name><argument_list>(<argument><expr><name>base</name> <operator>+</operator> <name>matchIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>PREFETCH_L1</name><argument_list>(<argument><expr><name>dictBase</name> <operator>+</operator> <name>matchIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name><name>matchBuffer</name><index>[<expr><name>numMatches</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>matchIndex</name></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="block">/* Speed opt: insert current byte into hashtable too. This allows us to avoid one iteration of the loop
           in ZSTD_row_update_internal() at the next search. */</comment>
        <block>{<block_content>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>pos</name> <init>= <expr><call><name>ZSTD_row_nextIndex</name><argument_list>(<argument><expr><name>tagRow</name></expr></argument>, <argument><expr><name>rowMask</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>tagRow</name><index>[<expr><name>pos</name> <operator>+</operator> <name>ZSTD_ROW_HASH_TAG_OFFSET</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><name>tag</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>row</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>=</operator> <name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block>

        <comment type="block">/* Return the longest match */</comment>
        <for>for <control>(<init>;</init> <condition><expr><name>currMatch</name> <operator>&lt;</operator> <name>numMatches</name></expr>;</condition> <incr><expr><operator>++</operator><name>currMatch</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>matchIndex</name> <init>= <expr><name><name>matchBuffer</name><index>[<expr><name>currMatch</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name></type> <name>currentMl</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>matchIndex</name> <operator>&lt;</operator> <name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>matchIndex</name> <operator>&gt;=</operator> <name>lowLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>dictMode</name> <operator>!=</operator> <name>ZSTD_extDict</name><operator>)</operator> <operator>||</operator> <name>matchIndex</name> <operator>&gt;=</operator> <name>dictLimit</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>match</name> <init>= <expr><name>base</name> <operator>+</operator> <name>matchIndex</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>matchIndex</name> <operator>&gt;=</operator> <name>dictLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* ensures this is true if dictMode != ZSTD_extDict */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>match</name><index>[<expr><name>ml</name></expr>]</index></name> <operator>==</operator> <name><name>ip</name><index>[<expr><name>ml</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>   <comment type="block">/* potentially better */</comment>
                    <expr_stmt><expr><name>currentMl</name> <operator>=</operator> <call><name>ZSTD_count</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>match</name> <init>= <expr><name>dictBase</name> <operator>+</operator> <name>matchIndex</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>match</name><operator>+</operator><literal type="number">4</literal> <operator>&lt;=</operator> <name>dictEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>MEM_read32</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>   <comment type="block">/* assumption : matchIndex &lt;= dictLimit-4 (by table construction) */</comment>
                    <expr_stmt><expr><name>currentMl</name> <operator>=</operator> <call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>match</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>, <argument><expr><name>dictEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/* Save best solution */</comment>
            <if_stmt><if>if <condition>(<expr><name>currentMl</name> <operator>&gt;</operator> <name>ml</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>ml</name> <operator>=</operator> <name>currentMl</name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>offsetPtr</name> <operator>=</operator> <call><name>OFFSET_TO_OFFBASE</name><argument_list>(<argument><expr><name>curr</name> <operator>-</operator> <name>matchIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>ip</name><operator>+</operator><name>currentMl</name> <operator>==</operator> <name>iLimit</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt> <comment type="block">/* best possible, avoids read overflow on next attempt */</comment>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nbAttempts</name> <operator>&lt;=</operator> <operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>ZSTD_SEARCHLOG_MAX</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Check we haven't underflowed. */</comment>
    <if_stmt><if>if <condition>(<expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_dedicatedDictSearch</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>ml</name> <operator>=</operator> <call><name>ZSTD_dedicatedDictSearch_lazy_search</name><argument_list>(<argument><expr><name>offsetPtr</name></expr></argument>, <argument><expr><name>ml</name></expr></argument>, <argument><expr><name>nbAttempts</name> <operator>+</operator> <name>ddsExtraAttempts</name></expr></argument>, <argument><expr><name>dms</name></expr></argument>,
                                                  <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>, <argument><expr><name>curr</name></expr></argument>, <argument><expr><name>dictLimit</name></expr></argument>, <argument><expr><name>ddsIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_dictMatchState</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* TODO: Measure and potentially add prefetching to DMS */</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dmsLowestIndex</name>       <init>= <expr><name><name>dms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictLimit</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dmsBase</name>      <init>= <expr><name><name>dms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dmsEnd</name>       <init>= <expr><name><name>dms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>nextSrc</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dmsSize</name>              <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>dmsEnd</name> <operator>-</operator> <name>dmsBase</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dmsIndexDelta</name>        <init>= <expr><name>dictLimit</name> <operator>-</operator> <name>dmsSize</name></expr></init></decl>;</decl_stmt>

        <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>headGrouped</name> <init>= <expr><operator>(</operator><operator>*</operator><name>dmsTagRow</name> <operator>&amp;</operator> <name>rowMask</name><operator>)</operator> <operator>*</operator> <name>groupWidth</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name></type> <name><name>matchBuffer</name><index>[<expr><name>ZSTD_ROW_HASH_MAX_ENTRIES</name></expr>]</index></name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name></type> <name>numMatches</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name></type> <name>currMatch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ZSTD_VecMask</name></type> <name>matches</name> <init>= <expr><call><name>ZSTD_row_getMatchMask</name><argument_list>(<argument><expr><name>dmsTagRow</name></expr></argument>, <argument><expr><operator>(</operator><name>BYTE</name><operator>)</operator><name>dmsTag</name></expr></argument>, <argument><expr><name>headGrouped</name></expr></argument>, <argument><expr><name>rowEntries</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init>;</init> <condition><expr><operator>(</operator><name>matches</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>nbAttempts</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</condition> <incr><expr><operator>--</operator><name>nbAttempts</name></expr><operator>,</operator> <expr><name>matches</name> <operator>&amp;=</operator> <operator>(</operator><name>matches</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></incr>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>matchPos</name> <init>= <expr><operator>(</operator><operator>(</operator><name>headGrouped</name> <operator>+</operator> <call><name>ZSTD_VecMask_next</name><argument_list>(<argument><expr><name>matches</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>/</operator> <name>groupWidth</name><operator>)</operator> <operator>&amp;</operator> <name>rowMask</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>matchIndex</name> <init>= <expr><name><name>dmsRow</name><index>[<expr><name>matchPos</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>matchIndex</name> <operator>&lt;</operator> <name>dmsLowestIndex</name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>PREFETCH_L1</name><argument_list>(<argument><expr><name>dmsBase</name> <operator>+</operator> <name>matchIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>matchBuffer</name><index>[<expr><name>numMatches</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>matchIndex</name></expr>;</expr_stmt>
            </block_content>}</block></for>

            <comment type="block">/* Return the longest match */</comment>
            <for>for <control>(<init>;</init> <condition><expr><name>currMatch</name> <operator>&lt;</operator> <name>numMatches</name></expr>;</condition> <incr><expr><operator>++</operator><name>currMatch</name></expr></incr>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>matchIndex</name> <init>= <expr><name><name>matchBuffer</name><index>[<expr><name>currMatch</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>size_t</name></type> <name>currentMl</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>matchIndex</name> <operator>&gt;=</operator> <name>dmsLowestIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>matchIndex</name> <operator>&lt;</operator> <name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <block>{<block_content>   <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>match</name> <init>= <expr><name>dmsBase</name> <operator>+</operator> <name>matchIndex</name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>match</name><operator>+</operator><literal type="number">4</literal> <operator>&lt;=</operator> <name>dmsEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>MEM_read32</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>currentMl</name> <operator>=</operator> <call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>match</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>, <argument><expr><name>dmsEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block>

                <if_stmt><if>if <condition>(<expr><name>currentMl</name> <operator>&gt;</operator> <name>ml</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>ml</name> <operator>=</operator> <name>currentMl</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>curr</name> <operator>&gt;</operator> <name>matchIndex</name> <operator>+</operator> <name>dmsIndexDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><operator>*</operator><name>offsetPtr</name> <operator>=</operator> <call><name>OFFSET_TO_OFFBASE</name><argument_list>(<argument><expr><name>curr</name> <operator>-</operator> <operator>(</operator><name>matchIndex</name> <operator>+</operator> <name>dmsIndexDelta</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>ip</name><operator>+</operator><name>currentMl</name> <operator>==</operator> <name>iLimit</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>ml</name></expr>;</return>
</block_content>}</block></function>


<typedef>typedef <function_decl><type><name>size_t</name></type> (<modifier>*</modifier><name>searchMax_f</name>)<parameter_list>(
                    <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>,
                    <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>iLimit</name></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>offsetPtr</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<comment type="block" format="doxygen">/**
 * This struct contains the functions necessary for lazy to search.
 * Currently, that is only searchMax. However, it is still valuable to have the
 * VTable because this makes it easier to add more functions to the VTable later.
 *
 * TODO: The start of the search function involves loading and calculating a
 * bunch of constants from the ZSTD_matchState_t. These computations could be
 * done in an initialization function, and saved somewhere in the match state.
 * Then we could pass a pointer to the saved state instead of the match state,
 * and avoid duplicate computations.
 *
 * TODO: Move the match re-winding into searchMax. This improves compression
 * ratio, and unlocks further simplifications with the next TODO.
 *
 * TODO: Try moving the repcode search into searchMax. After the re-winding
 * and repcode search are in searchMax, there is no more logic in the match
 * finder loop that requires knowledge about the dictMode. So we should be
 * able to avoid force inlining it, and we can join the extDict loop with
 * the single segment loop. It should go in searchMax instead of its own
 * function to avoid having multiple virtual function calls per search.
 */</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>searchMax_f</name></type> <name>searchMax</name></decl>;</decl_stmt>
}</block></struct></type> <name>ZSTD_LazyVTable</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GEN_ZSTD_BT_VTABLE</name><parameter_list>(<parameter><type><name>dictMode</name></type></parameter>, <parameter><type><name>mls</name></type></parameter>)</parameter_list></cpp:macro>                                             \
    <cpp:value>static size_t ZSTD_BtFindBestMatch_##dictMode##_##mls(                            \
            ZSTD_matchState_t* ms,                                                    \
            const BYTE* ip, const BYTE* const iLimit,                                 \
            size_t* offBasePtr)                                                       \
    {                                                                                 \
        assert(MAX(4, MIN(6, ms-&gt;cParams.minMatch)) == mls);                          \
        return ZSTD_BtFindBestMatch(ms, ip, iLimit, offBasePtr, mls, ZSTD_##dictMode);\
    }                                                                                 \
    static const ZSTD_LazyVTable ZSTD_BtVTable_##dictMode##_##mls = {                 \
        ZSTD_BtFindBestMatch_##dictMode##_##mls                                       \
    };</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GEN_ZSTD_HC_VTABLE</name><parameter_list>(<parameter><type><name>dictMode</name></type></parameter>, <parameter><type><name>mls</name></type></parameter>)</parameter_list></cpp:macro>                                             \
    <cpp:value>static size_t ZSTD_HcFindBestMatch_##dictMode##_##mls(                            \
            ZSTD_matchState_t* ms,                                                    \
            const BYTE* ip, const BYTE* const iLimit,                                 \
            size_t* offsetPtr)                                                        \
    {                                                                                 \
        assert(MAX(4, MIN(6, ms-&gt;cParams.minMatch)) == mls);                          \
        return ZSTD_HcFindBestMatch(ms, ip, iLimit, offsetPtr, mls, ZSTD_##dictMode); \
    }                                                                                 \
    static const ZSTD_LazyVTable ZSTD_HcVTable_##dictMode##_##mls = {                 \
        ZSTD_HcFindBestMatch_##dictMode##_##mls                                       \
    };</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GEN_ZSTD_ROW_VTABLE</name><parameter_list>(<parameter><type><name>dictMode</name></type></parameter>, <parameter><type><name>mls</name></type></parameter>, <parameter><type><name>rowLog</name></type></parameter>)</parameter_list></cpp:macro>                                             \
    <cpp:value>static size_t ZSTD_RowFindBestMatch_##dictMode##_##mls##_##rowLog(                         \
            ZSTD_matchState_t* ms,                                                             \
            const BYTE* ip, const BYTE* const iLimit,                                          \
            size_t* offsetPtr)                                                                 \
    {                                                                                          \
        assert(MAX(4, MIN(6, ms-&gt;cParams.minMatch)) == mls);                                   \
        assert(MAX(4, MIN(6, ms-&gt;cParams.searchLog)) == rowLog);                               \
        return ZSTD_RowFindBestMatch(ms, ip, iLimit, offsetPtr, mls, ZSTD_##dictMode, rowLog); \
    }                                                                                          \
    static const ZSTD_LazyVTable ZSTD_RowVTable_##dictMode##_##mls##_##rowLog = {              \
        ZSTD_RowFindBestMatch_##dictMode##_##mls##_##rowLog                                    \
    };</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZSTD_FOR_EACH_ROWLOG</name><parameter_list>(<parameter><type><name>X</name></type></parameter>, <parameter><type><name>dictMode</name></type></parameter>, <parameter><type><name>mls</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>X(dictMode, mls, 4)                        \
    X(dictMode, mls, 5)                        \
    X(dictMode, mls, 6)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZSTD_FOR_EACH_MLS_ROWLOG</name><parameter_list>(<parameter><type><name>X</name></type></parameter>, <parameter><type><name>dictMode</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>ZSTD_FOR_EACH_ROWLOG(X, dictMode, 4)      \
    ZSTD_FOR_EACH_ROWLOG(X, dictMode, 5)      \
    ZSTD_FOR_EACH_ROWLOG(X, dictMode, 6)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZSTD_FOR_EACH_MLS</name><parameter_list>(<parameter><type><name>X</name></type></parameter>, <parameter><type><name>dictMode</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>X(dictMode, 4)                     \
    X(dictMode, 5)                     \
    X(dictMode, 6)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZSTD_FOR_EACH_DICT_MODE</name><parameter_list>(<parameter><type><name>X</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>X(__VA_ARGS__, noDict)              \
    X(__VA_ARGS__, extDict)             \
    X(__VA_ARGS__, dictMatchState)      \
    X(__VA_ARGS__, dedicatedDictSearch)</cpp:value></cpp:define>

<comment type="block">/* Generate Row VTables for each combination of (dictMode, mls, rowLog) */</comment>
<macro><name>ZSTD_FOR_EACH_DICT_MODE</name><argument_list>(<argument>ZSTD_FOR_EACH_MLS_ROWLOG</argument>, <argument>GEN_ZSTD_ROW_VTABLE</argument>)</argument_list></macro>
<comment type="block">/* Generate Binary Tree VTables for each combination of (dictMode, mls) */</comment>
<macro><name>ZSTD_FOR_EACH_DICT_MODE</name><argument_list>(<argument>ZSTD_FOR_EACH_MLS</argument>, <argument>GEN_ZSTD_BT_VTABLE</argument>)</argument_list></macro>
<comment type="block">/* Generate Hash Chain VTables for each combination of (dictMode, mls) */</comment>
<macro><name>ZSTD_FOR_EACH_DICT_MODE</name><argument_list>(<argument>ZSTD_FOR_EACH_MLS</argument>, <argument>GEN_ZSTD_HC_VTABLE</argument>)</argument_list></macro>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GEN_ZSTD_BT_VTABLE_ARRAY</name><parameter_list>(<parameter><type><name>dictMode</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>{                                      \
        &amp;ZSTD_BtVTable_##dictMode##_4,     \
        &amp;ZSTD_BtVTable_##dictMode##_5,     \
        &amp;ZSTD_BtVTable_##dictMode##_6      \
    }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GEN_ZSTD_HC_VTABLE_ARRAY</name><parameter_list>(<parameter><type><name>dictMode</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>{                                      \
        &amp;ZSTD_HcVTable_##dictMode##_4,     \
        &amp;ZSTD_HcVTable_##dictMode##_5,     \
        &amp;ZSTD_HcVTable_##dictMode##_6      \
    }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GEN_ZSTD_ROW_VTABLE_ARRAY_</name><parameter_list>(<parameter><type><name>dictMode</name></type></parameter>, <parameter><type><name>mls</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>{                                             \
        &amp;ZSTD_RowVTable_##dictMode##_##mls##_4,   \
        &amp;ZSTD_RowVTable_##dictMode##_##mls##_5,   \
        &amp;ZSTD_RowVTable_##dictMode##_##mls##_6    \
    }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GEN_ZSTD_ROW_VTABLE_ARRAY</name><parameter_list>(<parameter><type><name>dictMode</name></type></parameter>)</parameter_list></cpp:macro>      \
    <cpp:value>{                                            \
        GEN_ZSTD_ROW_VTABLE_ARRAY_(dictMode, 4), \
        GEN_ZSTD_ROW_VTABLE_ARRAY_(dictMode, 5), \
        GEN_ZSTD_ROW_VTABLE_ARRAY_(dictMode, 6)  \
    }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GEN_ZSTD_VTABLE_ARRAY</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>{                            \
        X(noDict),               \
        X(extDict),              \
        X(dictMatchState),       \
        X(dedicatedDictSearch)   \
    }</cpp:value></cpp:define>

<comment type="block">/* *******************************
*  Common parser - lazy strategy
*********************************/</comment>
<typedef>typedef <type><enum>enum <block>{ <decl><name>search_hashChain</name><init>=<expr><literal type="number">0</literal></expr></init></decl>, <decl><name>search_binaryTree</name><init>=<expr><literal type="number">1</literal></expr></init></decl>, <decl><name>search_rowHash</name><init>=<expr><literal type="number">2</literal></expr></init></decl> }</block></enum></type> <name>searchMethod_e</name>;</typedef>

<comment type="block" format="doxygen">/**
 * This table is indexed first by the four ZSTD_dictMode_e values, and then
 * by the two searchMethod_e values. NULLs are placed for configurations
 * that should never occur (extDict modes go to the other implementation
 * below and there is no DDSS for binary tree search yet).
 */</comment>

<function><type><specifier>static</specifier> <name>ZSTD_LazyVTable</name> <specifier>const</specifier><modifier>*</modifier></type>
<name>ZSTD_selectLazyVTable</name><parameter_list>(<parameter><decl><type><name>ZSTD_matchState_t</name> <specifier>const</specifier><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>searchMethod_e</name></type> <name>searchMethod</name></decl></parameter>, <parameter><decl><type><name>ZSTD_dictMode_e</name></type> <name>dictMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Fill the Hc/Bt VTable arrays with the right functions for the (dictMode, mls) combination. */</comment>
    <decl_stmt><decl><type><name>ZSTD_LazyVTable</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name><name>hcVTables</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><call><name>GEN_ZSTD_VTABLE_ARRAY</name><argument_list>(<argument><expr><name>GEN_ZSTD_HC_VTABLE_ARRAY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_LazyVTable</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name><name>btVTables</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><call><name>GEN_ZSTD_VTABLE_ARRAY</name><argument_list>(<argument><expr><name>GEN_ZSTD_BT_VTABLE_ARRAY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Fill the Row VTable array with the right functions for the (dictMode, mls, rowLog) combination. */</comment>
    <decl_stmt><decl><type><name>ZSTD_LazyVTable</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name><name>rowVTables</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">3</literal></expr>]</index><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><call><name>GEN_ZSTD_VTABLE_ARRAY</name><argument_list>(<argument><expr><name>GEN_ZSTD_ROW_VTABLE_ARRAY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>mls</name> <init>= <expr><call><name>MAX</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><call><name>MIN</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name><name>ms</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>minMatch</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>rowLog</name> <init>= <expr><call><name>MAX</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><call><name>MIN</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name><name>ms</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>searchLog</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><name>searchMethod</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>search_hashChain</name></expr>:</case>
            <return>return <expr><name><name>hcVTables</name><index>[<expr><name>dictMode</name></expr>]</index><index>[<expr><name>mls</name> <operator>-</operator> <literal type="number">4</literal></expr>]</index></name></expr>;</return>
        <case>case <expr><name>search_binaryTree</name></expr>:</case>
            <return>return <expr><name><name>btVTables</name><index>[<expr><name>dictMode</name></expr>]</index><index>[<expr><name>mls</name> <operator>-</operator> <literal type="number">4</literal></expr>]</index></name></expr>;</return>
        <case>case <expr><name>search_rowHash</name></expr>:</case>
            <return>return <expr><name><name>rowVTables</name><index>[<expr><name>dictMode</name></expr>]</index><index>[<expr><name>mls</name> <operator>-</operator> <literal type="number">4</literal></expr>]</index><index>[<expr><name>rowLog</name> <operator>-</operator> <literal type="number">4</literal></expr>]</index></name></expr>;</return>
        <default>default:</default>
            <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>size_t</name></type>
<name>ZSTD_compressBlock_lazy_generic</name><parameter_list>(
                        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>,
                        <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>searchMethod_e</name></type> <name>searchMethod</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name>depth</name></decl></parameter>,
                        <parameter><decl><type><name>ZSTD_dictMode_e</name> <specifier>const</specifier></type> <name>dictMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>istart</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><name>istart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>anchor</name> <init>= <expr><name>istart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name> <init>= <expr><name>istart</name> <operator>+</operator> <name>srcSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ilimit</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>searchMethod</name> <operator>==</operator> <name>search_rowHash</name><operator>)</operator></expr> ?</condition><then> <expr><name>iend</name> <operator>-</operator> <literal type="number">8</literal> <operator>-</operator> <name>ZSTD_ROW_HASH_CACHE_SIZE</name></expr> </then><else>: <expr><name>iend</name> <operator>-</operator> <literal type="number">8</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>base</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>prefixLowestIndex</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictLimit</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>prefixLowest</name> <init>= <expr><name>base</name> <operator>+</operator> <name>prefixLowestIndex</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>searchMax_f</name> <specifier>const</specifier></type> <name>searchMax</name> <init>= <expr><call><name>ZSTD_selectLazyVTable</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>searchMethod</name></expr></argument>, <argument><expr><name>dictMode</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>searchMax</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>offset_1</name> <init>= <expr><name><name>rep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>, <decl><type ref="prev"/><name>offset_2</name> <init>= <expr><name><name>rep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>offsetSaved1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>offsetSaved2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>isDMS</name> <init>= <expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_dictMatchState</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>isDDS</name> <init>= <expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_dedicatedDictSearch</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>isDxS</name> <init>= <expr><name>isDMS</name> <operator>||</operator> <name>isDDS</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_matchState_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dms</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>dictMatchState</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dictLowestIndex</name>      <init>= <expr><ternary><condition><expr><name>isDxS</name></expr> ?</condition><then> <expr><name><name>dms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictLimit</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictBase</name>     <init>= <expr><ternary><condition><expr><name>isDxS</name></expr> ?</condition><then> <expr><name><name>dms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictLowest</name>   <init>= <expr><ternary><condition><expr><name>isDxS</name></expr> ?</condition><then> <expr><name>dictBase</name> <operator>+</operator> <name>dictLowestIndex</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictEnd</name>      <init>= <expr><ternary><condition><expr><name>isDxS</name></expr> ?</condition><then> <expr><name><name>dms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>nextSrc</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dictIndexDelta</name>       <init>= <expr><ternary><condition><expr><name>isDxS</name></expr> ?</condition><then>
                                     <expr><name>prefixLowestIndex</name> <operator>-</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>dictEnd</name> <operator>-</operator> <name>dictBase</name><operator>)</operator></expr> </then><else>:
                                     <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dictAndPrefixLength</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>prefixLowest</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>dictEnd</name> <operator>-</operator> <name>dictLowest</name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>searchMax</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressBlock_lazy_generic (dictMode=%u) (searchFunc=%u)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>dictMode</name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>searchMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ip</name> <operator>+=</operator> <operator>(</operator><name>dictAndPrefixLength</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_noDict</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>curr</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>windowLow</name> <init>= <expr><call><name>ZSTD_getLowestPrefixIndex</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>curr</name></expr></argument>, <argument><expr><name><name>ms</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>windowLog</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>maxRep</name> <init>= <expr><name>curr</name> <operator>-</operator> <name>windowLow</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>offset_2</name> <operator>&gt;</operator> <name>maxRep</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>offsetSaved2</name> <operator>=</operator> <name>offset_2</name></expr><operator>,</operator> <expr><name>offset_2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>offset_1</name> <operator>&gt;</operator> <name>maxRep</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>offsetSaved1</name> <operator>=</operator> <name>offset_1</name></expr><operator>,</operator> <expr><name>offset_1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>isDxS</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* dictMatchState repCode checks don't currently handle repCode == 0
         * disabling. */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>offset_1</name> <operator>&lt;=</operator> <name>dictAndPrefixLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>offset_2</name> <operator>&lt;=</operator> <name>dictAndPrefixLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>searchMethod</name> <operator>==</operator> <name>search_rowHash</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>rowLog</name> <init>= <expr><call><name>MAX</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><call><name>MIN</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name><name>ms</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>searchLog</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ZSTD_row_fillHashCache</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>rowLog</name></expr></argument>,
                            <argument><expr><call><name>MIN</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>minMatch</name></name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument> <comment type="block">/* mls caps out at 6 */</comment>)</argument_list></call></expr></argument>,
                            <argument><expr><name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name></expr></argument>, <argument><expr><name>ilimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Match Loop */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__x86_64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="block">/* I've measured random a 5% speed loss on levels 5 &amp; 6 (greedy) when the
     * code alignment is perturbed. To fix the instability align the loop on 32-bytes.
     */</comment>
    <asm>__asm__(".p2align 5");</asm>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <while>while <condition>(<expr><name>ip</name> <operator>&lt;</operator> <name>ilimit</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>matchLength</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>offBase</name> <init>= <expr><name>REPCODE1_TO_OFFBASE</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>start</name><init>=<expr><name>ip</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"search baseline (depth 0)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* check repCode */</comment>
        <if_stmt><if>if <condition>(<expr><name>isDxS</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>repIndex</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>base</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>offset_1</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>repMatch</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>dictMode</name> <operator>==</operator> <name>ZSTD_dictMatchState</name> <operator>||</operator> <name>dictMode</name> <operator>==</operator> <name>ZSTD_dedicatedDictSearch</name><operator>)</operator>
                                <operator>&amp;&amp;</operator> <name>repIndex</name> <operator>&lt;</operator> <name>prefixLowestIndex</name><operator>)</operator></expr> ?</condition><then>
                                   <expr><name>dictBase</name> <operator>+</operator> <operator>(</operator><name>repIndex</name> <operator>-</operator> <name>dictIndexDelta</name><operator>)</operator></expr> </then><else>:
                                   <expr><name>base</name> <operator>+</operator> <name>repIndex</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>prefixLowestIndex</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name>repIndex</name><operator>)</operator> <operator>&gt;=</operator> <literal type="number">3</literal> <comment type="block">/* intentional underflow */</comment><operator>)</operator>
                <operator>&amp;&amp;</operator> <operator>(</operator><call><name>MEM_read32</name><argument_list>(<argument><expr><name>repMatch</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition> <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>repMatchEnd</name> <init>= <expr><ternary><condition><expr><name>repIndex</name> <operator>&lt;</operator> <name>prefixLowestIndex</name></expr> ?</condition><then> <expr><name>dictEnd</name></expr> </then><else>: <expr><name>iend</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>matchLength</name> <operator>=</operator> <call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>repMatch</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>repMatchEnd</name></expr></argument>, <argument><expr><name>prefixLowest</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>depth</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>_storeSequence</name>;</goto></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>( <expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_noDict</name>
          <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>offset_1</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">1</literal><operator>-</operator><name>offset_1</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>matchLength</name> <operator>=</operator> <call><name>ZSTD_count</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>ip</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><literal type="number">4</literal><operator>-</operator><name>offset_1</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>depth</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>_storeSequence</name>;</goto></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* first search (depth 0) */</comment>
        <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name></type> <name>offbaseFound</name> <init>= <expr><literal type="number">999999999</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>ml2</name> <init>= <expr><call><name>searchMax</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offbaseFound</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>ml2</name> <operator>&gt;</operator> <name>matchLength</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>matchLength</name> <operator>=</operator> <name>ml2</name></expr><operator>,</operator> <expr><name>start</name> <operator>=</operator> <name>ip</name></expr><operator>,</operator> <expr><name>offBase</name> <operator>=</operator> <name>offbaseFound</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block>

        <if_stmt><if>if <condition>(<expr><name>matchLength</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>ip</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>ip</name><operator>-</operator><name>anchor</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>kSearchStrength</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>   <comment type="block">/* jump faster over incompressible sections */</comment>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* let's try to find a better solution */</comment>
        <if_stmt><if>if <condition>(<expr><name>depth</name><operator>&gt;=</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <while>while <condition>(<expr><name>ip</name><operator>&lt;</operator><name>ilimit</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"search depth 1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ip</name> <operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>( <expr><operator>(</operator><name>dictMode</name> <operator>==</operator> <name>ZSTD_noDict</name><operator>)</operator>
              <operator>&amp;&amp;</operator> <operator>(</operator><name>offBase</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>offset_1</name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip</name> <operator>-</operator> <name>offset_1</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>mlRep</name> <init>= <expr><call><name>ZSTD_count</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>ip</name><operator>+</operator><literal type="number">4</literal><operator>-</operator><name>offset_1</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>gain2</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>mlRep</name> <operator>*</operator> <literal type="number">3</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>gain1</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>matchLength</name><operator>*</operator><literal type="number">3</literal> <operator>-</operator> <call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>offBase</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>mlRep</name> <operator>&gt;=</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>gain2</name> <operator>&gt;</operator> <name>gain1</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>matchLength</name> <operator>=</operator> <name>mlRep</name></expr><operator>,</operator> <expr><name>offBase</name> <operator>=</operator> <name>REPCODE1_TO_OFFBASE</name></expr><operator>,</operator> <expr><name>start</name> <operator>=</operator> <name>ip</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>isDxS</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>repIndex</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>base</name><operator>)</operator> <operator>-</operator> <name>offset_1</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>repMatch</name> <init>= <expr><ternary><condition><expr><name>repIndex</name> <operator>&lt;</operator> <name>prefixLowestIndex</name></expr> ?</condition><then>
                               <expr><name>dictBase</name> <operator>+</operator> <operator>(</operator><name>repIndex</name> <operator>-</operator> <name>dictIndexDelta</name><operator>)</operator></expr> </then><else>:
                               <expr><name>base</name> <operator>+</operator> <name>repIndex</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>prefixLowestIndex</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name>repIndex</name><operator>)</operator> <operator>&gt;=</operator> <literal type="number">3</literal> <comment type="block">/* intentional underflow */</comment><operator>)</operator>
                    <operator>&amp;&amp;</operator> <operator>(</operator><call><name>MEM_read32</name><argument_list>(<argument><expr><name>repMatch</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition> <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>repMatchEnd</name> <init>= <expr><ternary><condition><expr><name>repIndex</name> <operator>&lt;</operator> <name>prefixLowestIndex</name></expr> ?</condition><then> <expr><name>dictEnd</name></expr> </then><else>: <expr><name>iend</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>mlRep</name> <init>= <expr><call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>repMatch</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>repMatchEnd</name></expr></argument>, <argument><expr><name>prefixLowest</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>gain2</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>mlRep</name> <operator>*</operator> <literal type="number">3</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>gain1</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>matchLength</name><operator>*</operator><literal type="number">3</literal> <operator>-</operator> <call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>offBase</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>mlRep</name> <operator>&gt;=</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>gain2</name> <operator>&gt;</operator> <name>gain1</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>matchLength</name> <operator>=</operator> <name>mlRep</name></expr><operator>,</operator> <expr><name>offBase</name> <operator>=</operator> <name>REPCODE1_TO_OFFBASE</name></expr><operator>,</operator> <expr><name>start</name> <operator>=</operator> <name>ip</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name></type> <name>ofbCandidate</name><init>=<expr><literal type="number">999999999</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>ml2</name> <init>= <expr><call><name>searchMax</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ofbCandidate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>gain2</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>ml2</name><operator>*</operator><literal type="number">4</literal> <operator>-</operator> <call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>ofbCandidate</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>   <comment type="block">/* raw approx */</comment>
                <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>gain1</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>matchLength</name><operator>*</operator><literal type="number">4</literal> <operator>-</operator> <call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>offBase</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ml2</name> <operator>&gt;=</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>gain2</name> <operator>&gt;</operator> <name>gain1</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>matchLength</name> <operator>=</operator> <name>ml2</name></expr><operator>,</operator> <expr><name>offBase</name> <operator>=</operator> <name>ofbCandidate</name></expr><operator>,</operator> <expr><name>start</name> <operator>=</operator> <name>ip</name></expr>;</expr_stmt>
                    <continue>continue;</continue>   <comment type="block">/* search a better one */</comment>
            </block_content>}</block></if></if_stmt>   </block_content>}</block>

            <comment type="block">/* let's find an even better one */</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>depth</name><operator>==</operator><literal type="number">2</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>ip</name><operator>&lt;</operator><name>ilimit</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"search depth 2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>ip</name> <operator>++</operator></expr>;</expr_stmt>
                <if_stmt><if>if <condition>( <expr><operator>(</operator><name>dictMode</name> <operator>==</operator> <name>ZSTD_noDict</name><operator>)</operator>
                  <operator>&amp;&amp;</operator> <operator>(</operator><name>offBase</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>offset_1</name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip</name> <operator>-</operator> <name>offset_1</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>mlRep</name> <init>= <expr><call><name>ZSTD_count</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>ip</name><operator>+</operator><literal type="number">4</literal><operator>-</operator><name>offset_1</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>gain2</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>mlRep</name> <operator>*</operator> <literal type="number">4</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>gain1</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>matchLength</name><operator>*</operator><literal type="number">4</literal> <operator>-</operator> <call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>offBase</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>mlRep</name> <operator>&gt;=</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>gain2</name> <operator>&gt;</operator> <name>gain1</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>matchLength</name> <operator>=</operator> <name>mlRep</name></expr><operator>,</operator> <expr><name>offBase</name> <operator>=</operator> <name>REPCODE1_TO_OFFBASE</name></expr><operator>,</operator> <expr><name>start</name> <operator>=</operator> <name>ip</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>isDxS</name></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>repIndex</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>base</name><operator>)</operator> <operator>-</operator> <name>offset_1</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>repMatch</name> <init>= <expr><ternary><condition><expr><name>repIndex</name> <operator>&lt;</operator> <name>prefixLowestIndex</name></expr> ?</condition><then>
                                   <expr><name>dictBase</name> <operator>+</operator> <operator>(</operator><name>repIndex</name> <operator>-</operator> <name>dictIndexDelta</name><operator>)</operator></expr> </then><else>:
                                   <expr><name>base</name> <operator>+</operator> <name>repIndex</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>prefixLowestIndex</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name>repIndex</name><operator>)</operator> <operator>&gt;=</operator> <literal type="number">3</literal> <comment type="block">/* intentional underflow */</comment><operator>)</operator>
                        <operator>&amp;&amp;</operator> <operator>(</operator><call><name>MEM_read32</name><argument_list>(<argument><expr><name>repMatch</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition> <block>{<block_content>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>repMatchEnd</name> <init>= <expr><ternary><condition><expr><name>repIndex</name> <operator>&lt;</operator> <name>prefixLowestIndex</name></expr> ?</condition><then> <expr><name>dictEnd</name></expr> </then><else>: <expr><name>iend</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>mlRep</name> <init>= <expr><call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>repMatch</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>repMatchEnd</name></expr></argument>, <argument><expr><name>prefixLowest</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>gain2</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>mlRep</name> <operator>*</operator> <literal type="number">4</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>gain1</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>matchLength</name><operator>*</operator><literal type="number">4</literal> <operator>-</operator> <call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>offBase</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
                        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>mlRep</name> <operator>&gt;=</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>gain2</name> <operator>&gt;</operator> <name>gain1</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>matchLength</name> <operator>=</operator> <name>mlRep</name></expr><operator>,</operator> <expr><name>offBase</name> <operator>=</operator> <name>REPCODE1_TO_OFFBASE</name></expr><operator>,</operator> <expr><name>start</name> <operator>=</operator> <name>ip</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name></type> <name>ofbCandidate</name><init>=<expr><literal type="number">999999999</literal></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>ml2</name> <init>= <expr><call><name>searchMax</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ofbCandidate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>gain2</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>ml2</name><operator>*</operator><literal type="number">4</literal> <operator>-</operator> <call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>ofbCandidate</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>   <comment type="block">/* raw approx */</comment>
                    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>gain1</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>matchLength</name><operator>*</operator><literal type="number">4</literal> <operator>-</operator> <call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>offBase</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">7</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ml2</name> <operator>&gt;=</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>gain2</name> <operator>&gt;</operator> <name>gain1</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>matchLength</name> <operator>=</operator> <name>ml2</name></expr><operator>,</operator> <expr><name>offBase</name> <operator>=</operator> <name>ofbCandidate</name></expr><operator>,</operator> <expr><name>start</name> <operator>=</operator> <name>ip</name></expr>;</expr_stmt>
                        <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>   </block_content>}</block>   </block_content>}</block></if></if_stmt>
            <break>break;</break>  <comment type="block">/* nothing found : store previous solution */</comment>
        </block_content>}</block></while></block_content></block></if></if_stmt>

        <comment type="block">/* NOTE:
         * Pay attention that `start[-value]` can lead to strange undefined behavior
         * notably if `value` is unsigned, resulting in a large positive `-value`.
         */</comment>
        <comment type="block">/* catch up */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>OFFBASE_IS_OFFSET</name><argument_list>(<argument><expr><name>offBase</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_noDict</name></expr>)</condition> <block>{<block_content>
                <while>while <condition>( <expr><operator>(</operator><operator>(</operator><name>start</name> <operator>&gt;</operator> <name>anchor</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>start</name> <operator>-</operator> <call><name>OFFBASE_TO_OFFSET</name><argument_list>(<argument><expr><name>offBase</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>prefixLowest</name><operator>)</operator><operator>)</operator>
                     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>start</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <operator>(</operator><name>start</name><operator>-</operator><call><name>OFFBASE_TO_OFFSET</name><argument_list>(<argument><expr><name>offBase</name></expr></argument>)</argument_list></call><operator>)</operator><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index><operator>)</operator></expr> )</condition>  <comment type="block">/* only search for offset within prefix */</comment>
                    <block>{<block_content> <expr_stmt><expr><name>start</name><operator>--</operator></expr>;</expr_stmt> <expr_stmt><expr><name>matchLength</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>isDxS</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>matchIndex</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>start</name><operator>-</operator><name>base</name><operator>)</operator> <operator>-</operator> <call><name>OFFBASE_TO_OFFSET</name><argument_list>(<argument><expr><name>offBase</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>match</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>matchIndex</name> <operator>&lt;</operator> <name>prefixLowestIndex</name><operator>)</operator></expr> ?</condition><then> <expr><name>dictBase</name> <operator>+</operator> <name>matchIndex</name> <operator>-</operator> <name>dictIndexDelta</name></expr> </then><else>: <expr><name>base</name> <operator>+</operator> <name>matchIndex</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>mStart</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>matchIndex</name> <operator>&lt;</operator> <name>prefixLowestIndex</name><operator>)</operator></expr> ?</condition><then> <expr><name>dictLowest</name></expr> </then><else>: <expr><name>prefixLowest</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                <while>while <condition>(<expr><operator>(</operator><name>start</name><operator>&gt;</operator><name>anchor</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>match</name><operator>&gt;</operator><name>mStart</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>start</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>match</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>start</name><operator>--</operator></expr>;</expr_stmt> <expr_stmt><expr><name>match</name><operator>--</operator></expr>;</expr_stmt> <expr_stmt><expr><name>matchLength</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>  <comment type="block">/* catch up */</comment>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>offset_2</name> <operator>=</operator> <name>offset_1</name></expr>;</expr_stmt> <expr_stmt><expr><name>offset_1</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><call><name>OFFBASE_TO_OFFSET</name><argument_list>(<argument><expr><name>offBase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* store sequence */</comment>
<label><name>_storeSequence</name>:</label>
        <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>litLength</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>start</name> <operator>-</operator> <name>anchor</name><operator>)</operator></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ZSTD_storeSeq</name><argument_list>(<argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>litLength</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>offBase</name></expr></argument>, <argument><expr><name>matchLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>anchor</name> <operator>=</operator> <name>ip</name> <operator>=</operator> <name>start</name> <operator>+</operator> <name>matchLength</name></expr>;</expr_stmt>
        </block_content>}</block>

        <comment type="block">/* check immediate repcode */</comment>
        <if_stmt><if>if <condition>(<expr><name>isDxS</name></expr>)</condition> <block>{<block_content>
            <while>while <condition>(<expr><name>ip</name> <operator>&lt;=</operator> <name>ilimit</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>current2</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>repIndex</name> <init>= <expr><name>current2</name> <operator>-</operator> <name>offset_2</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>repMatch</name> <init>= <expr><ternary><condition><expr><name>repIndex</name> <operator>&lt;</operator> <name>prefixLowestIndex</name></expr> ?</condition><then>
                        <expr><name>dictBase</name> <operator>-</operator> <name>dictIndexDelta</name> <operator>+</operator> <name>repIndex</name></expr> </then><else>:
                        <expr><name>base</name> <operator>+</operator> <name>repIndex</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>( <expr><operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>prefixLowestIndex</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>-</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>repIndex</name><operator>)</operator> <operator>&gt;=</operator> <literal type="number">3</literal> <comment type="block">/* intentional overflow */</comment><operator>)</operator>
                   <operator>&amp;&amp;</operator> <operator>(</operator><call><name>MEM_read32</name><argument_list>(<argument><expr><name>repMatch</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition> <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>repEnd2</name> <init>= <expr><ternary><condition><expr><name>repIndex</name> <operator>&lt;</operator> <name>prefixLowestIndex</name></expr> ?</condition><then> <expr><name>dictEnd</name></expr> </then><else>: <expr><name>iend</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>matchLength</name> <operator>=</operator> <call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>repMatch</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>repEnd2</name></expr></argument>, <argument><expr><name>prefixLowest</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>offBase</name> <operator>=</operator> <name>offset_2</name></expr>;</expr_stmt> <expr_stmt><expr><name>offset_2</name> <operator>=</operator> <name>offset_1</name></expr>;</expr_stmt> <expr_stmt><expr><name>offset_1</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>offBase</name></expr>;</expr_stmt>   <comment type="block">/* swap offset_2 &lt;=&gt; offset_1 */</comment>
                    <expr_stmt><expr><call><name>ZSTD_storeSeq</name><argument_list>(<argument><expr><name>seqStore</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>REPCODE1_TO_OFFBASE</name></expr></argument>, <argument><expr><name>matchLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>matchLength</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>anchor</name> <operator>=</operator> <name>ip</name></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_noDict</name></expr>)</condition> <block>{<block_content>
            <while>while <condition>( <expr><operator>(</operator><operator>(</operator><name>ip</name> <operator>&lt;=</operator> <name>ilimit</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>offset_2</name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator><operator>)</operator>
                 <operator>&amp;&amp;</operator> <operator>(</operator><call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip</name> <operator>-</operator> <name>offset_2</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition> <block>{<block_content>
                <comment type="block">/* store sequence */</comment>
                <expr_stmt><expr><name>matchLength</name> <operator>=</operator> <call><name>ZSTD_count</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>ip</name><operator>+</operator><literal type="number">4</literal><operator>-</operator><name>offset_2</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>offBase</name> <operator>=</operator> <name>offset_2</name></expr>;</expr_stmt> <expr_stmt><expr><name>offset_2</name> <operator>=</operator> <name>offset_1</name></expr>;</expr_stmt> <expr_stmt><expr><name>offset_1</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>offBase</name></expr>;</expr_stmt> <comment type="block">/* swap repcodes */</comment>
                <expr_stmt><expr><call><name>ZSTD_storeSeq</name><argument_list>(<argument><expr><name>seqStore</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>REPCODE1_TO_OFFBASE</name></expr></argument>, <argument><expr><name>matchLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>matchLength</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>anchor</name> <operator>=</operator> <name>ip</name></expr>;</expr_stmt>
                <continue>continue;</continue>   <comment type="block">/* faster when present ... (?) */</comment>
    </block_content>}</block></while>   </block_content>}</block></if></if_stmt>   </block_content>}</block></while>

    <comment type="block">/* If offset_1 started invalid (offsetSaved1 != 0) and became valid (offset_1 != 0),
     * rotate saved offsets. See comment in ZSTD_compressBlock_fast_noDict for more context. */</comment>
    <expr_stmt><expr><name>offsetSaved2</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>(</operator><name>offsetSaved1</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>offset_1</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><name>offsetSaved1</name></expr> </then><else>: <expr><name>offsetSaved2</name></expr></else></ternary></expr>;</expr_stmt>

    <comment type="block">/* save reps for next block */</comment>
    <expr_stmt><expr><name><name>rep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>offset_1</name></expr> ?</condition><then> <expr><name>offset_1</name></expr> </then><else>: <expr><name>offsetSaved1</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>offset_2</name></expr> ?</condition><then> <expr><name>offset_2</name></expr> </then><else>: <expr><name>offsetSaved2</name></expr></else></ternary></expr>;</expr_stmt>

    <comment type="block">/* Return the last literals size */</comment>
    <return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>iend</name> <operator>-</operator> <name>anchor</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_btlazy2</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBlock_lazy_generic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>search_binaryTree</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>ZSTD_noDict</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_lazy2</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBlock_lazy_generic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>search_hashChain</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>ZSTD_noDict</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_lazy</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBlock_lazy_generic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>search_hashChain</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ZSTD_noDict</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_greedy</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBlock_lazy_generic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>search_hashChain</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ZSTD_noDict</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_btlazy2_dictMatchState</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBlock_lazy_generic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>search_binaryTree</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>ZSTD_dictMatchState</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_lazy2_dictMatchState</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBlock_lazy_generic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>search_hashChain</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>ZSTD_dictMatchState</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_lazy_dictMatchState</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBlock_lazy_generic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>search_hashChain</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ZSTD_dictMatchState</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_greedy_dictMatchState</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBlock_lazy_generic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>search_hashChain</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ZSTD_dictMatchState</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_lazy2_dedicatedDictSearch</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBlock_lazy_generic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>search_hashChain</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>ZSTD_dedicatedDictSearch</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_lazy_dedicatedDictSearch</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBlock_lazy_generic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>search_hashChain</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ZSTD_dedicatedDictSearch</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_greedy_dedicatedDictSearch</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBlock_lazy_generic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>search_hashChain</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ZSTD_dedicatedDictSearch</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Row-based matchfinder */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_lazy2_row</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBlock_lazy_generic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>search_rowHash</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>ZSTD_noDict</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_lazy_row</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBlock_lazy_generic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>search_rowHash</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ZSTD_noDict</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_greedy_row</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBlock_lazy_generic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>search_rowHash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ZSTD_noDict</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_lazy2_dictMatchState_row</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBlock_lazy_generic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>search_rowHash</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>ZSTD_dictMatchState</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_lazy_dictMatchState_row</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBlock_lazy_generic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>search_rowHash</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ZSTD_dictMatchState</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_greedy_dictMatchState_row</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBlock_lazy_generic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>search_rowHash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ZSTD_dictMatchState</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_lazy2_dedicatedDictSearch_row</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBlock_lazy_generic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>search_rowHash</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>ZSTD_dedicatedDictSearch</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_lazy_dedicatedDictSearch_row</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBlock_lazy_generic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>search_rowHash</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ZSTD_dedicatedDictSearch</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_greedy_dedicatedDictSearch_row</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBlock_lazy_generic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>search_rowHash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ZSTD_dedicatedDictSearch</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>FORCE_INLINE_TEMPLATE</name>
<name>size_t</name></type> <name>ZSTD_compressBlock_lazy_extDict_generic</name><parameter_list>(
                        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>,
                        <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>searchMethod_e</name></type> <name>searchMethod</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name>depth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>istart</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><name>istart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>anchor</name> <init>= <expr><name>istart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name> <init>= <expr><name>istart</name> <operator>+</operator> <name>srcSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ilimit</name> <init>= <expr><ternary><condition><expr><name>searchMethod</name> <operator>==</operator> <name>search_rowHash</name></expr> ?</condition><then> <expr><name>iend</name> <operator>-</operator> <literal type="number">8</literal> <operator>-</operator> <name>ZSTD_ROW_HASH_CACHE_SIZE</name></expr> </then><else>: <expr><name>iend</name> <operator>-</operator> <literal type="number">8</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>base</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dictLimit</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictLimit</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>prefixStart</name> <init>= <expr><name>base</name> <operator>+</operator> <name>dictLimit</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictBase</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictBase</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictEnd</name>  <init>= <expr><name>dictBase</name> <operator>+</operator> <name>dictLimit</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictStart</name>  <init>= <expr><name>dictBase</name> <operator>+</operator> <name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>lowLimit</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>windowLog</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>windowLog</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>rowLog</name> <init>= <expr><ternary><condition><expr><name><name>ms</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>searchLog</name></name> <operator>&lt;</operator> <literal type="number">5</literal></expr> ?</condition><then> <expr><literal type="number">4</literal></expr> </then><else>: <expr><literal type="number">5</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>searchMax_f</name> <specifier>const</specifier></type> <name>searchMax</name> <init>= <expr><call><name>ZSTD_selectLazyVTable</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>searchMethod</name></expr></argument>, <argument><expr><name>ZSTD_extDict</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>searchMax</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>offset_1</name> <init>= <expr><name><name>rep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>, <decl><type ref="prev"/><name>offset_2</name> <init>= <expr><name><name>rep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressBlock_lazy_extDict_generic (searchFunc=%u)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>searchMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* init */</comment>
    <expr_stmt><expr><name>ip</name> <operator>+=</operator> <operator>(</operator><name>ip</name> <operator>==</operator> <name>prefixStart</name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>searchMethod</name> <operator>==</operator> <name>search_rowHash</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>ZSTD_row_fillHashCache</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>rowLog</name></expr></argument>,
                               <argument><expr><call><name>MIN</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>minMatch</name></name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument> <comment type="block">/* mls caps out at 6 */</comment>)</argument_list></call></expr></argument>,
                               <argument><expr><name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name></expr></argument>, <argument><expr><name>ilimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Match Loop */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__x86_64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="block">/* I've measured random a 5% speed loss on levels 5 &amp; 6 (greedy) when the
     * code alignment is perturbed. To fix the instability align the loop on 32-bytes.
     */</comment>
    <asm>__asm__(".p2align 5");</asm>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <while>while <condition>(<expr><name>ip</name> <operator>&lt;</operator> <name>ilimit</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>matchLength</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>offBase</name> <init>= <expr><name>REPCODE1_TO_OFFBASE</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>start</name><init>=<expr><name>ip</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name></type> <name>curr</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>

        <comment type="block">/* check repCode */</comment>
        <block>{<block_content>   <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>windowLow</name> <init>= <expr><call><name>ZSTD_getLowestMatchIndex</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>curr</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>windowLog</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>repIndex</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>curr</name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name>offset_1</name><operator>)</operator></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>repBase</name> <init>= <expr><ternary><condition><expr><name>repIndex</name> <operator>&lt;</operator> <name>dictLimit</name></expr> ?</condition><then> <expr><name>dictBase</name></expr> </then><else>: <expr><name>base</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>repMatch</name> <init>= <expr><name>repBase</name> <operator>+</operator> <name>repIndex</name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>( <expr><operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>dictLimit</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name>repIndex</name><operator>)</operator> <operator>&gt;=</operator> <literal type="number">3</literal><operator>)</operator> <comment type="block">/* intentional overflow */</comment>
               <operator>&amp;</operator> <operator>(</operator><name>offset_1</name> <operator>&lt;=</operator> <name>curr</name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name>windowLow</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <comment type="block">/* note: we are searching at curr+1 */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>repMatch</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <comment type="block">/* repcode detected we should take it */</comment>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>repEnd</name> <init>= <expr><ternary><condition><expr><name>repIndex</name> <operator>&lt;</operator> <name>dictLimit</name></expr> ?</condition><then> <expr><name>dictEnd</name></expr> </then><else>: <expr><name>iend</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>matchLength</name> <operator>=</operator> <call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>repMatch</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>repEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>depth</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>_storeSequence</name>;</goto></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>   </block_content>}</block>

        <comment type="block">/* first search (depth 0) */</comment>
        <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name></type> <name>ofbCandidate</name> <init>= <expr><literal type="number">999999999</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>ml2</name> <init>= <expr><call><name>searchMax</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ofbCandidate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>ml2</name> <operator>&gt;</operator> <name>matchLength</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>matchLength</name> <operator>=</operator> <name>ml2</name></expr><operator>,</operator> <expr><name>start</name> <operator>=</operator> <name>ip</name></expr><operator>,</operator> <expr><name>offBase</name> <operator>=</operator> <name>ofbCandidate</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block>

        <if_stmt><if>if <condition>(<expr><name>matchLength</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>ip</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>ip</name><operator>-</operator><name>anchor</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>kSearchStrength</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>   <comment type="block">/* jump faster over incompressible sections */</comment>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* let's try to find a better solution */</comment>
        <if_stmt><if>if <condition>(<expr><name>depth</name><operator>&gt;=</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <while>while <condition>(<expr><name>ip</name><operator>&lt;</operator><name>ilimit</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>ip</name> <operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>curr</name><operator>++</operator></expr>;</expr_stmt>
            <comment type="block">/* check repCode */</comment>
            <if_stmt><if>if <condition>(<expr><name>offBase</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>windowLow</name> <init>= <expr><call><name>ZSTD_getLowestMatchIndex</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>curr</name></expr></argument>, <argument><expr><name>windowLog</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>repIndex</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>curr</name> <operator>-</operator> <name>offset_1</name><operator>)</operator></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>repBase</name> <init>= <expr><ternary><condition><expr><name>repIndex</name> <operator>&lt;</operator> <name>dictLimit</name></expr> ?</condition><then> <expr><name>dictBase</name></expr> </then><else>: <expr><name>base</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>repMatch</name> <init>= <expr><name>repBase</name> <operator>+</operator> <name>repIndex</name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>( <expr><operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>dictLimit</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name>repIndex</name><operator>)</operator> <operator>&gt;=</operator> <literal type="number">3</literal><operator>)</operator> <comment type="block">/* intentional overflow : do not test positions overlapping 2 memory segments  */</comment>
                   <operator>&amp;</operator> <operator>(</operator><name>offset_1</name> <operator>&lt;=</operator> <name>curr</name> <operator>-</operator> <name>windowLow</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <comment type="block">/* equivalent to `curr &gt; repIndex &gt;= windowLow` */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>repMatch</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <comment type="block">/* repcode detected */</comment>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>repEnd</name> <init>= <expr><ternary><condition><expr><name>repIndex</name> <operator>&lt;</operator> <name>dictLimit</name></expr> ?</condition><then> <expr><name>dictEnd</name></expr> </then><else>: <expr><name>iend</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>repLength</name> <init>= <expr><call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>repMatch</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>repEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>gain2</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>repLength</name> <operator>*</operator> <literal type="number">3</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>gain1</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>matchLength</name><operator>*</operator><literal type="number">3</literal> <operator>-</operator> <call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>offBase</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>repLength</name> <operator>&gt;=</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>gain2</name> <operator>&gt;</operator> <name>gain1</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>matchLength</name> <operator>=</operator> <name>repLength</name></expr><operator>,</operator> <expr><name>offBase</name> <operator>=</operator> <name>REPCODE1_TO_OFFBASE</name></expr><operator>,</operator> <expr><name>start</name> <operator>=</operator> <name>ip</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>   </block_content>}</block></if></if_stmt>

            <comment type="block">/* search match, depth 1 */</comment>
            <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name></type> <name>ofbCandidate</name> <init>= <expr><literal type="number">999999999</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>ml2</name> <init>= <expr><call><name>searchMax</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ofbCandidate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>gain2</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>ml2</name><operator>*</operator><literal type="number">4</literal> <operator>-</operator> <call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>ofbCandidate</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>   <comment type="block">/* raw approx */</comment>
                <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>gain1</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>matchLength</name><operator>*</operator><literal type="number">4</literal> <operator>-</operator> <call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>offBase</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ml2</name> <operator>&gt;=</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>gain2</name> <operator>&gt;</operator> <name>gain1</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>matchLength</name> <operator>=</operator> <name>ml2</name></expr><operator>,</operator> <expr><name>offBase</name> <operator>=</operator> <name>ofbCandidate</name></expr><operator>,</operator> <expr><name>start</name> <operator>=</operator> <name>ip</name></expr>;</expr_stmt>
                    <continue>continue;</continue>   <comment type="block">/* search a better one */</comment>
            </block_content>}</block></if></if_stmt>   </block_content>}</block>

            <comment type="block">/* let's find an even better one */</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>depth</name><operator>==</operator><literal type="number">2</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>ip</name><operator>&lt;</operator><name>ilimit</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>ip</name> <operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>curr</name><operator>++</operator></expr>;</expr_stmt>
                <comment type="block">/* check repCode */</comment>
                <if_stmt><if>if <condition>(<expr><name>offBase</name></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>windowLow</name> <init>= <expr><call><name>ZSTD_getLowestMatchIndex</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>curr</name></expr></argument>, <argument><expr><name>windowLog</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>repIndex</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>curr</name> <operator>-</operator> <name>offset_1</name><operator>)</operator></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>repBase</name> <init>= <expr><ternary><condition><expr><name>repIndex</name> <operator>&lt;</operator> <name>dictLimit</name></expr> ?</condition><then> <expr><name>dictBase</name></expr> </then><else>: <expr><name>base</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>repMatch</name> <init>= <expr><name>repBase</name> <operator>+</operator> <name>repIndex</name></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>( <expr><operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>dictLimit</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name>repIndex</name><operator>)</operator> <operator>&gt;=</operator> <literal type="number">3</literal><operator>)</operator> <comment type="block">/* intentional overflow : do not test positions overlapping 2 memory segments  */</comment>
                       <operator>&amp;</operator> <operator>(</operator><name>offset_1</name> <operator>&lt;=</operator> <name>curr</name> <operator>-</operator> <name>windowLow</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <comment type="block">/* equivalent to `curr &gt; repIndex &gt;= windowLow` */</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>repMatch</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <comment type="block">/* repcode detected */</comment>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>repEnd</name> <init>= <expr><ternary><condition><expr><name>repIndex</name> <operator>&lt;</operator> <name>dictLimit</name></expr> ?</condition><then> <expr><name>dictEnd</name></expr> </then><else>: <expr><name>iend</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>repLength</name> <init>= <expr><call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>repMatch</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>repEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>gain2</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>repLength</name> <operator>*</operator> <literal type="number">4</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>gain1</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>matchLength</name><operator>*</operator><literal type="number">4</literal> <operator>-</operator> <call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>offBase</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
                        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>repLength</name> <operator>&gt;=</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>gain2</name> <operator>&gt;</operator> <name>gain1</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>matchLength</name> <operator>=</operator> <name>repLength</name></expr><operator>,</operator> <expr><name>offBase</name> <operator>=</operator> <name>REPCODE1_TO_OFFBASE</name></expr><operator>,</operator> <expr><name>start</name> <operator>=</operator> <name>ip</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>   </block_content>}</block></if></if_stmt>

                <comment type="block">/* search match, depth 2 */</comment>
                <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name></type> <name>ofbCandidate</name> <init>= <expr><literal type="number">999999999</literal></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>ml2</name> <init>= <expr><call><name>searchMax</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ofbCandidate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>gain2</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>ml2</name><operator>*</operator><literal type="number">4</literal> <operator>-</operator> <call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>ofbCandidate</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>   <comment type="block">/* raw approx */</comment>
                    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>gain1</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>matchLength</name><operator>*</operator><literal type="number">4</literal> <operator>-</operator> <call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>offBase</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">7</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ml2</name> <operator>&gt;=</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>gain2</name> <operator>&gt;</operator> <name>gain1</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>matchLength</name> <operator>=</operator> <name>ml2</name></expr><operator>,</operator> <expr><name>offBase</name> <operator>=</operator> <name>ofbCandidate</name></expr><operator>,</operator> <expr><name>start</name> <operator>=</operator> <name>ip</name></expr>;</expr_stmt>
                        <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>   </block_content>}</block>   </block_content>}</block></if></if_stmt>
            <break>break;</break>  <comment type="block">/* nothing found : store previous solution */</comment>
        </block_content>}</block></while></block_content></block></if></if_stmt>

        <comment type="block">/* catch up */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>OFFBASE_IS_OFFSET</name><argument_list>(<argument><expr><name>offBase</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>matchIndex</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>start</name><operator>-</operator><name>base</name><operator>)</operator> <operator>-</operator> <call><name>OFFBASE_TO_OFFSET</name><argument_list>(<argument><expr><name>offBase</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>match</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>matchIndex</name> <operator>&lt;</operator> <name>dictLimit</name><operator>)</operator></expr> ?</condition><then> <expr><name>dictBase</name> <operator>+</operator> <name>matchIndex</name></expr> </then><else>: <expr><name>base</name> <operator>+</operator> <name>matchIndex</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>mStart</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>matchIndex</name> <operator>&lt;</operator> <name>dictLimit</name><operator>)</operator></expr> ?</condition><then> <expr><name>dictStart</name></expr> </then><else>: <expr><name>prefixStart</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><operator>(</operator><name>start</name><operator>&gt;</operator><name>anchor</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>match</name><operator>&gt;</operator><name>mStart</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>start</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>match</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>start</name><operator>--</operator></expr>;</expr_stmt> <expr_stmt><expr><name>match</name><operator>--</operator></expr>;</expr_stmt> <expr_stmt><expr><name>matchLength</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>  <comment type="block">/* catch up */</comment>
            <expr_stmt><expr><name>offset_2</name> <operator>=</operator> <name>offset_1</name></expr>;</expr_stmt> <expr_stmt><expr><name>offset_1</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><call><name>OFFBASE_TO_OFFSET</name><argument_list>(<argument><expr><name>offBase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* store sequence */</comment>
<label><name>_storeSequence</name>:</label>
        <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>litLength</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>start</name> <operator>-</operator> <name>anchor</name><operator>)</operator></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ZSTD_storeSeq</name><argument_list>(<argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>litLength</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>offBase</name></expr></argument>, <argument><expr><name>matchLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>anchor</name> <operator>=</operator> <name>ip</name> <operator>=</operator> <name>start</name> <operator>+</operator> <name>matchLength</name></expr>;</expr_stmt>
        </block_content>}</block>

        <comment type="block">/* check immediate repcode */</comment>
        <while>while <condition>(<expr><name>ip</name> <operator>&lt;=</operator> <name>ilimit</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>repCurrent</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>windowLow</name> <init>= <expr><call><name>ZSTD_getLowestMatchIndex</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>repCurrent</name></expr></argument>, <argument><expr><name>windowLog</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>repIndex</name> <init>= <expr><name>repCurrent</name> <operator>-</operator> <name>offset_2</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>repBase</name> <init>= <expr><ternary><condition><expr><name>repIndex</name> <operator>&lt;</operator> <name>dictLimit</name></expr> ?</condition><then> <expr><name>dictBase</name></expr> </then><else>: <expr><name>base</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>repMatch</name> <init>= <expr><name>repBase</name> <operator>+</operator> <name>repIndex</name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>( <expr><operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>dictLimit</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name>repIndex</name><operator>)</operator> <operator>&gt;=</operator> <literal type="number">3</literal><operator>)</operator> <comment type="block">/* intentional overflow : do not test positions overlapping 2 memory segments  */</comment>
               <operator>&amp;</operator> <operator>(</operator><name>offset_2</name> <operator>&lt;=</operator> <name>repCurrent</name> <operator>-</operator> <name>windowLow</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <comment type="block">/* equivalent to `curr &gt; repIndex &gt;= windowLow` */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>repMatch</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <comment type="block">/* repcode detected we should take it */</comment>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>repEnd</name> <init>= <expr><ternary><condition><expr><name>repIndex</name> <operator>&lt;</operator> <name>dictLimit</name></expr> ?</condition><then> <expr><name>dictEnd</name></expr> </then><else>: <expr><name>iend</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>matchLength</name> <operator>=</operator> <call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>repMatch</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>repEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>offBase</name> <operator>=</operator> <name>offset_2</name></expr>;</expr_stmt> <expr_stmt><expr><name>offset_2</name> <operator>=</operator> <name>offset_1</name></expr>;</expr_stmt> <expr_stmt><expr><name>offset_1</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>offBase</name></expr>;</expr_stmt>   <comment type="block">/* swap offset history */</comment>
                <expr_stmt><expr><call><name>ZSTD_storeSeq</name><argument_list>(<argument><expr><name>seqStore</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>REPCODE1_TO_OFFBASE</name></expr></argument>, <argument><expr><name>matchLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>matchLength</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>anchor</name> <operator>=</operator> <name>ip</name></expr>;</expr_stmt>
                <continue>continue;</continue>   <comment type="block">/* faster when present ... (?) */</comment>
            </block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>
            <break>break;</break>
    </block_content>}</block></while>   </block_content>}</block></while>

    <comment type="block">/* Save reps for next block */</comment>
    <expr_stmt><expr><name><name>rep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>offset_1</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>offset_2</name></expr>;</expr_stmt>

    <comment type="block">/* Return the last literals size */</comment>
    <return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>iend</name> <operator>-</operator> <name>anchor</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_greedy_extDict</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBlock_lazy_extDict_generic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>search_hashChain</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_lazy_extDict</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>

<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBlock_lazy_extDict_generic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>search_hashChain</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_lazy2_extDict</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>

<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBlock_lazy_extDict_generic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>search_hashChain</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_btlazy2_extDict</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>

<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBlock_lazy_extDict_generic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>search_binaryTree</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_greedy_extDict_row</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBlock_lazy_extDict_generic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>search_rowHash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_lazy_extDict_row</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>

<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBlock_lazy_extDict_generic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>search_rowHash</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_lazy2_extDict_row</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>

<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBlock_lazy_extDict_generic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>search_rowHash</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
