<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/zstd/zstd_subset/compress/zstdmt_compress.c"><comment type="block">/*
 * Copyright (c) Yann Collet, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
 */</comment>


<comment type="block">/* ======   Compiler specifics   ====== */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#  <cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name> <name>:</name> <name>4204</name><name>)</name></cpp:pragma>   <comment type="block">/* disable: C4204: non-constant aggregate initializer */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* ======   Constants   ====== */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZSTDMT_OVERLAPLOG_DEFAULT</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>


<comment type="block">/* ======   Dependencies   ====== */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/zstd_deps.h"</cpp:file></cpp:include>   <comment type="block">/* ZSTD_memcpy, ZSTD_memset, INT_MAX, UINT_MAX */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/mem.h"</cpp:file></cpp:include>         <comment type="block">/* MEM_STATIC */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/pool.h"</cpp:file></cpp:include>        <comment type="block">/* threadpool */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/threading.h"</cpp:file></cpp:include>   <comment type="block">/* mutex */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_compress_internal.h"</cpp:file></cpp:include>  <comment type="block">/* MIN, ERROR, ZSTD_*, ZSTD_highbit32 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_ldm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstdmt_compress.h"</cpp:file></cpp:include>

<comment type="block">/* Guards code to support resizing the SeqPool.
 * We will want to resize the SeqPool to save memory in the future.
 * Until then, comment the code out since it is unused.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZSTD_RESIZE_SEQPOOL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<comment type="block">/* ======   Debug   ====== */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUGLEVEL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>DEBUGLEVEL</name><operator>&gt;=</operator><literal type="number">2</literal><operator>)</operator> \
    <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> \
    <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/times.h&gt;</cpp:file></cpp:include>

<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_PRINTHEX</name><parameter_list>(<parameter><type><name>l</name></type></parameter>,<parameter><type><name>p</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{            \
    unsigned debug_u;                        \
    for (debug_u=0; debug_u&lt;(n); debug_u++)  \
        RAWLOG(l, "%02X ", ((const unsigned char*)(p))[debug_u]); \
    RAWLOG(l, " \n");                        \
}</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>long</name> <name>long</name></type> <name>GetCurrentClockTimeMicroseconds</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
   <decl_stmt><decl><type><specifier>static</specifier> <name>clock_t</name></type> <name>_ticksPerSecond</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
   <if_stmt><if>if <condition>(<expr><name>_ticksPerSecond</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>_ticksPerSecond</name> <operator>=</operator> <call><name>sysconf</name><argument_list>(<argument><expr><name>_SC_CLK_TCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

   <block>{<block_content>   <decl_stmt><decl><type><name><name>struct</name> <name>tms</name></name></type> <name>junk</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>clock_t</name></type> <name>newTicks</name> <init>= <expr><operator>(</operator><name>clock_t</name><operator>)</operator> <call><name>times</name><argument_list>(<argument><expr><operator>&amp;</operator><name>junk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
       <return>return <expr><operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator><name>newTicks</name><operator>)</operator><operator>*</operator><operator>(</operator><literal type="number">1000000</literal><operator>)</operator><operator>)</operator><operator>/</operator><name>_ticksPerSecond</name><operator>)</operator></expr>;</return>
</block_content>}</block>  </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUTEX_WAIT_TIME_DLEVEL</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZSTD_PTHREAD_MUTEX_LOCK</name><parameter_list>(<parameter><type><name>mutex</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{          \
    if (DEBUGLEVEL &gt;= MUTEX_WAIT_TIME_DLEVEL) {   \
        unsigned long long const beforeTime = GetCurrentClockTimeMicroseconds(); \
        ZSTD_pthread_mutex_lock(mutex);           \
        {   unsigned long long const afterTime = GetCurrentClockTimeMicroseconds(); \
            unsigned long long const elapsedTime = (afterTime-beforeTime); \
            if (elapsedTime &gt; 1000) {  <comment type="block">/* or whatever threshold you like; I'm using 1 millisecond here */</comment> \
                DEBUGLOG(MUTEX_WAIT_TIME_DLEVEL, "Thread took %llu microseconds to acquire mutex %s \n", \
                   elapsedTime, #mutex);          \
        }   }                                     \
    } else {                                      \
        ZSTD_pthread_mutex_lock(mutex);           \
    }                                             \
}</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>ZSTD_PTHREAD_MUTEX_LOCK</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ZSTD_pthread_mutex_lock(m)</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_PRINTHEX</name><parameter_list>(<parameter><type><name>l</name></type></parameter>,<parameter><type><name>p</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{}</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* =====   Buffer Pool   ===== */</comment>
<comment type="block">/* a single Buffer Pool can be invoked from multiple threads in parallel */</comment>

<typedef>typedef <type><struct>struct <name>buffer_s</name> <block>{
    <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>capacity</name></decl>;</decl_stmt>
}</block></struct></type> <name>buffer_t</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>buffer_t</name></type> <name>g_nullBuffer</name> <init>= <expr><block>{ <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <name>ZSTDMT_bufferPool_s</name> <block>{
    <decl_stmt><decl><type><name>ZSTD_pthread_mutex_t</name></type> <name>poolMutex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>bufferSize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>totalBuffers</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>nbBuffers</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_customMem</name></type> <name>cMem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>buffer_t</name></type> <name><name>bTable</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>   <comment type="block">/* variable size */</comment>
}</block></struct></type> <name>ZSTDMT_bufferPool</name>;</typedef>

<function><type><specifier>static</specifier> <name>ZSTDMT_bufferPool</name><modifier>*</modifier></type> <name>ZSTDMT_createBufferPool</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>maxNbBuffers</name></decl></parameter>, <parameter><decl><type><name>ZSTD_customMem</name></type> <name>cMem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTDMT_bufferPool</name><modifier>*</modifier> <specifier>const</specifier></type> <name>bufPool</name> <init>= <expr><operator>(</operator><name>ZSTDMT_bufferPool</name><operator>*</operator><operator>)</operator><call><name>ZSTD_customCalloc</name><argument_list>(
        <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZSTDMT_bufferPool</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <operator>(</operator><name>maxNbBuffers</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buffer_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cMem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>bufPool</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ZSTD_pthread_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufPool</name><operator>-&gt;</operator><name>poolMutex</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>ZSTD_customFree</name><argument_list>(<argument><expr><name>bufPool</name></expr></argument>, <argument><expr><name>cMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>bufPool</name><operator>-&gt;</operator><name>bufferSize</name></name> <operator>=</operator> <literal type="number">64</literal> <name>KB</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bufPool</name><operator>-&gt;</operator><name>totalBuffers</name></name> <operator>=</operator> <name>maxNbBuffers</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bufPool</name><operator>-&gt;</operator><name>nbBuffers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bufPool</name><operator>-&gt;</operator><name>cMem</name></name> <operator>=</operator> <name>cMem</name></expr>;</expr_stmt>
    <return>return <expr><name>bufPool</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTDMT_freeBufferPool</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_bufferPool</name><modifier>*</modifier></type> <name>bufPool</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>u</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_freeBufferPool (address:%08X)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>size_t</name><operator>)</operator><name>bufPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>bufPool</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>   <comment type="block">/* compatibility with free on NULL */</comment>
    <for>for <control>(<init><expr><name>u</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>u</name><operator>&lt;</operator><name><name>bufPool</name><operator>-&gt;</operator><name>totalBuffers</name></name></expr>;</condition> <incr><expr><name>u</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"free buffer %2u (address:%08X)"</literal></expr></argument>, <argument><expr><name>u</name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>size_t</name><operator>)</operator><name><name>bufPool</name><operator>-&gt;</operator><name>bTable</name><index>[<expr><name>u</name></expr>]</index></name><operator>.</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_customFree</name><argument_list>(<argument><expr><name><name>bufPool</name><operator>-&gt;</operator><name>bTable</name><index>[<expr><name>u</name></expr>]</index></name><operator>.</operator><name>start</name></expr></argument>, <argument><expr><name><name>bufPool</name><operator>-&gt;</operator><name>cMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>ZSTD_pthread_mutex_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufPool</name><operator>-&gt;</operator><name>poolMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_customFree</name><argument_list>(<argument><expr><name>bufPool</name></expr></argument>, <argument><expr><name><name>bufPool</name><operator>-&gt;</operator><name>cMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* only works at initialization, not during compression */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTDMT_sizeof_bufferPool</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_bufferPool</name><modifier>*</modifier></type> <name>bufPool</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>poolSize</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>bufPool</name></expr></argument>)</argument_list></sizeof>
                          <operator>+</operator> <operator>(</operator><name><name>bufPool</name><operator>-&gt;</operator><name>totalBuffers</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buffer_t</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>u</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>totalBufferSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ZSTD_pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufPool</name><operator>-&gt;</operator><name>poolMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>u</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>u</name><operator>&lt;</operator><name><name>bufPool</name><operator>-&gt;</operator><name>totalBuffers</name></name></expr>;</condition> <incr><expr><name>u</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name>totalBufferSize</name> <operator>+=</operator> <name><name>bufPool</name><operator>-&gt;</operator><name>bTable</name><index>[<expr><name>u</name></expr>]</index></name><operator>.</operator><name>capacity</name></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>ZSTD_pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufPool</name><operator>-&gt;</operator><name>poolMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>poolSize</name> <operator>+</operator> <name>totalBufferSize</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ZSTDMT_setBufferSize() :
 * all future buffers provided by this buffer pool will have _at least_ this size
 * note : it's better for all buffers to have same size,
 * as they become freely interchangeable, reducing malloc/free usages and memory fragmentation */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTDMT_setBufferSize</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_bufferPool</name><modifier>*</modifier> <specifier>const</specifier></type> <name>bufPool</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>bSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>ZSTD_pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufPool</name><operator>-&gt;</operator><name>poolMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_setBufferSize: bSize = %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>bSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bufPool</name><operator>-&gt;</operator><name>bufferSize</name></name> <operator>=</operator> <name>bSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufPool</name><operator>-&gt;</operator><name>poolMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>ZSTDMT_bufferPool</name><modifier>*</modifier></type> <name>ZSTDMT_expandBufferPool</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_bufferPool</name><modifier>*</modifier></type> <name>srcBufPool</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>maxNbBuffers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>srcBufPool</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>srcBufPool</name><operator>-&gt;</operator><name>totalBuffers</name></name> <operator>&gt;=</operator> <name>maxNbBuffers</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* good enough */</comment>
        <return>return <expr><name>srcBufPool</name></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* need a larger buffer pool */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>ZSTD_customMem</name> <specifier>const</specifier></type> <name>cMem</name> <init>= <expr><name><name>srcBufPool</name><operator>-&gt;</operator><name>cMem</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>bSize</name> <init>= <expr><name><name>srcBufPool</name><operator>-&gt;</operator><name>bufferSize</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* forward parameters */</comment>
        <decl_stmt><decl><type><name>ZSTDMT_bufferPool</name><modifier>*</modifier></type> <name>newBufPool</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ZSTDMT_freeBufferPool</name><argument_list>(<argument><expr><name>srcBufPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>newBufPool</name> <operator>=</operator> <call><name>ZSTDMT_createBufferPool</name><argument_list>(<argument><expr><name>maxNbBuffers</name></expr></argument>, <argument><expr><name>cMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>newBufPool</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>newBufPool</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>ZSTDMT_setBufferSize</name><argument_list>(<argument><expr><name>newBufPool</name></expr></argument>, <argument><expr><name>bSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>newBufPool</name></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** ZSTDMT_getBuffer() :
 *  assumption : bufPool must be valid
 * @return : a buffer, with start pointer and size
 *  note: allocation may fail, in this case, start==NULL and size==0 */</comment>
<function><type><specifier>static</specifier> <name>buffer_t</name></type> <name>ZSTDMT_getBuffer</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_bufferPool</name><modifier>*</modifier></type> <name>bufPool</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>bSize</name> <init>= <expr><name><name>bufPool</name><operator>-&gt;</operator><name>bufferSize</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_getBuffer: bSize = %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>bufPool</name><operator>-&gt;</operator><name>bufferSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufPool</name><operator>-&gt;</operator><name>poolMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>bufPool</name><operator>-&gt;</operator><name>nbBuffers</name></name></expr>)</condition> <block>{<block_content>   <comment type="block">/* try to use an existing buffer */</comment>
        <decl_stmt><decl><type><name>buffer_t</name> <specifier>const</specifier></type> <name>buf</name> <init>= <expr><name><name>bufPool</name><operator>-&gt;</operator><name>bTable</name><index>[<expr><operator>--</operator><operator>(</operator><name><name>bufPool</name><operator>-&gt;</operator><name>nbBuffers</name></name><operator>)</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>availBufferSize</name> <init>= <expr><name><name>buf</name><operator>.</operator><name>capacity</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>bufPool</name><operator>-&gt;</operator><name>bTable</name><index>[<expr><name><name>bufPool</name><operator>-&gt;</operator><name>nbBuffers</name></name></expr>]</index></name> <operator>=</operator> <name>g_nullBuffer</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>availBufferSize</name> <operator>&gt;=</operator> <name>bSize</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>availBufferSize</name><operator>&gt;&gt;</operator><literal type="number">3</literal><operator>)</operator> <operator>&lt;=</operator> <name>bSize</name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <comment type="block">/* large enough, but not too much */</comment>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_getBuffer: provide buffer %u of size %u"</literal></expr></argument>,
                        <argument><expr><name><name>bufPool</name><operator>-&gt;</operator><name>nbBuffers</name></name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>buf</name><operator>.</operator><name>capacity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ZSTD_pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufPool</name><operator>-&gt;</operator><name>poolMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>buf</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* size conditions not respected : scratch this buffer, create new one */</comment>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_getBuffer: existing buffer does not meet size conditions =&gt; freeing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_customFree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name><name>bufPool</name><operator>-&gt;</operator><name>cMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>ZSTD_pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufPool</name><operator>-&gt;</operator><name>poolMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* create new buffer */</comment>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_getBuffer: create a new buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>buffer_t</name></type> <name>buffer</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>void</name><modifier>*</modifier> <specifier>const</specifier></type> <name>start</name> <init>= <expr><call><name>ZSTD_customMalloc</name><argument_list>(<argument><expr><name>bSize</name></expr></argument>, <argument><expr><name><name>bufPool</name><operator>-&gt;</operator><name>cMem</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>start</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>   <comment type="block">/* note : start can be NULL if malloc fails ! */</comment>
        <expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>capacity</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>start</name><operator>==</operator><name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>bSize</name></expr></else></ternary></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>start</name><operator>==</operator><name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_getBuffer: buffer allocation failure !!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_getBuffer: created buffer of size %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>bSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><name>buffer</name></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ZSTD_RESIZE_SEQPOOL</name></expr></cpp:if>
<comment type="block" format="doxygen">/** ZSTDMT_resizeBuffer() :
 * assumption : bufPool must be valid
 * @return : a buffer that is at least the buffer pool buffer size.
 *           If a reallocation happens, the data in the input buffer is copied.
 */</comment>
<function><type><specifier>static</specifier> <name>buffer_t</name></type> <name>ZSTDMT_resizeBuffer</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_bufferPool</name><modifier>*</modifier></type> <name>bufPool</name></decl></parameter>, <parameter><decl><type><name>buffer_t</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>bSize</name> <init>= <expr><name><name>bufPool</name><operator>-&gt;</operator><name>bufferSize</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>buffer</name><operator>.</operator><name>capacity</name></name> <operator>&lt;</operator> <name>bSize</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>void</name><modifier>*</modifier> <specifier>const</specifier></type> <name>start</name> <init>= <expr><call><name>ZSTD_customMalloc</name><argument_list>(<argument><expr><name>bSize</name></expr></argument>, <argument><expr><name><name>bufPool</name><operator>-&gt;</operator><name>cMem</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>buffer_t</name></type> <name>newBuffer</name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>newBuffer</name><operator>.</operator><name>start</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newBuffer</name><operator>.</operator><name>capacity</name></name> <operator>=</operator> <ternary><condition><expr><name>start</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>bSize</name></expr></else></ternary></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>start</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>newBuffer</name><operator>.</operator><name>capacity</name></name> <operator>&gt;=</operator> <name><name>buffer</name><operator>.</operator><name>capacity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name><name>newBuffer</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name><name>buffer</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name><name>buffer</name><operator>.</operator><name>capacity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_resizeBuffer: created buffer of size %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>bSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>newBuffer</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_resizeBuffer: buffer allocation failure !!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>buffer</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* store buffer for later re-use, up to pool capacity */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTDMT_releaseBuffer</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_bufferPool</name><modifier>*</modifier></type> <name>bufPool</name></decl></parameter>, <parameter><decl><type><name>buffer_t</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_releaseBuffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>.</operator><name>start</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>   <comment type="block">/* compatible with release on NULL */</comment>
    <expr_stmt><expr><call><name>ZSTD_pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufPool</name><operator>-&gt;</operator><name>poolMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>bufPool</name><operator>-&gt;</operator><name>nbBuffers</name></name> <operator>&lt;</operator> <name><name>bufPool</name><operator>-&gt;</operator><name>totalBuffers</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>bufPool</name><operator>-&gt;</operator><name>bTable</name><index>[<expr><name><name>bufPool</name><operator>-&gt;</operator><name>nbBuffers</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>  <comment type="block">/* stored for later use */</comment>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_releaseBuffer: stored buffer of size %u in slot %u"</literal></expr></argument>,
                    <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>buf</name><operator>.</operator><name>capacity</name></name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name><name>bufPool</name><operator>-&gt;</operator><name>nbBuffers</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufPool</name><operator>-&gt;</operator><name>poolMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>ZSTD_pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufPool</name><operator>-&gt;</operator><name>poolMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Reached bufferPool capacity (should not happen) */</comment>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_releaseBuffer: pool capacity reached =&gt; freeing "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_customFree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name><name>bufPool</name><operator>-&gt;</operator><name>cMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* We need 2 output buffers per worker since each dstBuff must be flushed after it is released.
 * The 3 additional buffers are as follows:
 *   1 buffer for input loading
 *   1 buffer for "next input" when submitting current one
 *   1 buffer stuck in queue */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUF_POOL_MAX_NB_BUFFERS</name><parameter_list>(<parameter><type><name>nbWorkers</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(2*(nbWorkers) + 3)</cpp:value></cpp:define>

<comment type="block">/* After a worker releases its rawSeqStore, it is immediately ready for reuse.
 * So we only need one seq buffer per worker. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEQ_POOL_MAX_NB_BUFFERS</name><parameter_list>(<parameter><type><name>nbWorkers</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(nbWorkers)</cpp:value></cpp:define>

<comment type="block">/* =====   Seq Pool Wrapper   ====== */</comment>

<typedef>typedef <type><name>ZSTDMT_bufferPool</name></type> <name>ZSTDMT_seqPool</name>;</typedef>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTDMT_sizeof_seqPool</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_seqPool</name><modifier>*</modifier></type> <name>seqPool</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTDMT_sizeof_bufferPool</name><argument_list>(<argument><expr><name>seqPool</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rawSeqStore_t</name></type> <name>bufferToSeq</name><parameter_list>(<parameter><decl><type><name>buffer_t</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>rawSeqStore_t</name></type> <name>seq</name> <init>= <expr><name>kNullRawSeqStore</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>seq</name><operator>.</operator><name>seq</name></name> <operator>=</operator> <operator>(</operator><name>rawSeq</name><operator>*</operator><operator>)</operator><name><name>buffer</name><operator>.</operator><name>start</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>seq</name><operator>.</operator><name>capacity</name></name> <operator>=</operator> <name><name>buffer</name><operator>.</operator><name>capacity</name></name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>rawSeq</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <return>return <expr><name>seq</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>buffer_t</name></type> <name>seqToBuffer</name><parameter_list>(<parameter><decl><type><name>rawSeqStore_t</name></type> <name>seq</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>buffer_t</name></type> <name>buffer</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>start</name></name> <operator>=</operator> <name><name>seq</name><operator>.</operator><name>seq</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>capacity</name></name> <operator>=</operator> <name><name>seq</name><operator>.</operator><name>capacity</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>rawSeq</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <return>return <expr><name>buffer</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rawSeqStore_t</name></type> <name>ZSTDMT_getSeq</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_seqPool</name><modifier>*</modifier></type> <name>seqPool</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>seqPool</name><operator>-&gt;</operator><name>bufferSize</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>kNullRawSeqStore</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name>bufferToSeq</name><argument_list>(<argument><expr><call><name>ZSTDMT_getBuffer</name><argument_list>(<argument><expr><name>seqPool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ZSTD_RESIZE_SEQPOOL</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>rawSeqStore_t</name></type> <name>ZSTDMT_resizeSeq</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_seqPool</name><modifier>*</modifier></type> <name>seqPool</name></decl></parameter>, <parameter><decl><type><name>rawSeqStore_t</name></type> <name>seq</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><call><name>bufferToSeq</name><argument_list>(<argument><expr><call><name>ZSTDMT_resizeBuffer</name><argument_list>(<argument><expr><name>seqPool</name></expr></argument>, <argument><expr><call><name>seqToBuffer</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTDMT_releaseSeq</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_seqPool</name><modifier>*</modifier></type> <name>seqPool</name></decl></parameter>, <parameter><decl><type><name>rawSeqStore_t</name></type> <name>seq</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>ZSTDMT_releaseBuffer</name><argument_list>(<argument><expr><name>seqPool</name></expr></argument>, <argument><expr><call><name>seqToBuffer</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTDMT_setNbSeq</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_seqPool</name><modifier>*</modifier> <specifier>const</specifier></type> <name>seqPool</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>nbSeq</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>ZSTDMT_setBufferSize</name><argument_list>(<argument><expr><name>seqPool</name></expr></argument>, <argument><expr><name>nbSeq</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>rawSeq</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ZSTDMT_seqPool</name><modifier>*</modifier></type> <name>ZSTDMT_createSeqPool</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>nbWorkers</name></decl></parameter>, <parameter><decl><type><name>ZSTD_customMem</name></type> <name>cMem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTDMT_seqPool</name><modifier>*</modifier> <specifier>const</specifier></type> <name>seqPool</name> <init>= <expr><call><name>ZSTDMT_createBufferPool</name><argument_list>(<argument><expr><call><name>SEQ_POOL_MAX_NB_BUFFERS</name><argument_list>(<argument><expr><name>nbWorkers</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cMem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>seqPool</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>ZSTDMT_setNbSeq</name><argument_list>(<argument><expr><name>seqPool</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>seqPool</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTDMT_freeSeqPool</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_seqPool</name><modifier>*</modifier></type> <name>seqPool</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>ZSTDMT_freeBufferPool</name><argument_list>(<argument><expr><name>seqPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ZSTDMT_seqPool</name><modifier>*</modifier></type> <name>ZSTDMT_expandSeqPool</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_seqPool</name><modifier>*</modifier></type> <name>pool</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>nbWorkers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTDMT_expandBufferPool</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>SEQ_POOL_MAX_NB_BUFFERS</name><argument_list>(<argument><expr><name>nbWorkers</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* =====   CCtx Pool   ===== */</comment>
<comment type="block">/* a single CCtx Pool can be invoked from multiple threads in parallel */</comment>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>ZSTD_pthread_mutex_t</name></type> <name>poolMutex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>totalCCtx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>availCCtx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_customMem</name></type> <name>cMem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name><name>cctx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>   <comment type="block">/* variable size */</comment>
}</block></struct></type> <name>ZSTDMT_CCtxPool</name>;</typedef>

<comment type="block">/* note : all CCtx borrowed from the pool should be released back to the pool _before_ freeing the pool */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTDMT_freeCCtxPool</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_CCtxPool</name><modifier>*</modifier></type> <name>pool</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>cid</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>cid</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>cid</name><operator>&lt;</operator><name><name>pool</name><operator>-&gt;</operator><name>totalCCtx</name></name></expr>;</condition> <incr><expr><name>cid</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ZSTD_freeCCtx</name><argument_list>(<argument><expr><name><name>pool</name><operator>-&gt;</operator><name>cctx</name><index>[<expr><name>cid</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>  <comment type="block">/* note : compatible with free on NULL */</comment>
    <expr_stmt><expr><call><name>ZSTD_pthread_mutex_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pool</name><operator>-&gt;</operator><name>poolMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_customFree</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>pool</name><operator>-&gt;</operator><name>cMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ZSTDMT_createCCtxPool() :
 * implies nbWorkers &gt;= 1 , checked by caller ZSTDMT_createCCtx() */</comment>
<function><type><specifier>static</specifier> <name>ZSTDMT_CCtxPool</name><modifier>*</modifier></type> <name>ZSTDMT_createCCtxPool</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nbWorkers</name></decl></parameter>,
                                              <parameter><decl><type><name>ZSTD_customMem</name></type> <name>cMem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTDMT_CCtxPool</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cctxPool</name> <init>= <expr><operator>(</operator><name>ZSTDMT_CCtxPool</name><operator>*</operator><operator>)</operator> <call><name>ZSTD_customCalloc</name><argument_list>(
        <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZSTDMT_CCtxPool</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <operator>(</operator><name>nbWorkers</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_CCtx</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cMem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nbWorkers</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>cctxPool</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ZSTD_pthread_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctxPool</name><operator>-&gt;</operator><name>poolMutex</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>ZSTD_customFree</name><argument_list>(<argument><expr><name>cctxPool</name></expr></argument>, <argument><expr><name>cMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>cctxPool</name><operator>-&gt;</operator><name>cMem</name></name> <operator>=</operator> <name>cMem</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctxPool</name><operator>-&gt;</operator><name>totalCCtx</name></name> <operator>=</operator> <name>nbWorkers</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctxPool</name><operator>-&gt;</operator><name>availCCtx</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>   <comment type="block">/* at least one cctx for single-thread mode */</comment>
    <expr_stmt><expr><name><name>cctxPool</name><operator>-&gt;</operator><name>cctx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>ZSTD_createCCtx_advanced</name><argument_list>(<argument><expr><name>cMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cctxPool</name><operator>-&gt;</operator><name>cctx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>ZSTDMT_freeCCtxPool</name><argument_list>(<argument><expr><name>cctxPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>NULL</name></expr>;</return> </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"cctxPool created, with %u workers"</literal></expr></argument>, <argument><expr><name>nbWorkers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>cctxPool</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ZSTDMT_CCtxPool</name><modifier>*</modifier></type> <name>ZSTDMT_expandCCtxPool</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_CCtxPool</name><modifier>*</modifier></type> <name>srcPool</name></decl></parameter>,
                                              <parameter><decl><type><name>int</name></type> <name>nbWorkers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>srcPool</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>nbWorkers</name> <operator>&lt;=</operator> <name><name>srcPool</name><operator>-&gt;</operator><name>totalCCtx</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>srcPool</name></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* good enough */</comment>
    <comment type="block">/* need a larger cctx pool */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>ZSTD_customMem</name> <specifier>const</specifier></type> <name>cMem</name> <init>= <expr><name><name>srcPool</name><operator>-&gt;</operator><name>cMem</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ZSTDMT_freeCCtxPool</name><argument_list>(<argument><expr><name>srcPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>ZSTDMT_createCCtxPool</name><argument_list>(<argument><expr><name>nbWorkers</name></expr></argument>, <argument><expr><name>cMem</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/* only works during initialization phase, not during compression */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTDMT_sizeof_CCtxPool</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_CCtxPool</name><modifier>*</modifier></type> <name>cctxPool</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>ZSTD_pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctxPool</name><operator>-&gt;</operator><name>poolMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>nbWorkers</name> <init>= <expr><name><name>cctxPool</name><operator>-&gt;</operator><name>totalCCtx</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>poolSize</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>cctxPool</name></expr></argument>)</argument_list></sizeof>
                                <operator>+</operator> <operator>(</operator><name>nbWorkers</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_CCtx</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name></type> <name>u</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>totalCCtxSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>u</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>u</name><operator>&lt;</operator><name>nbWorkers</name></expr>;</condition> <incr><expr><name>u</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><name>totalCCtxSize</name> <operator>+=</operator> <call><name>ZSTD_sizeof_CCtx</name><argument_list>(<argument><expr><name><name>cctxPool</name><operator>-&gt;</operator><name>cctx</name><index>[<expr><name>u</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>ZSTD_pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctxPool</name><operator>-&gt;</operator><name>poolMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nbWorkers</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>poolSize</name> <operator>+</operator> <name>totalCCtxSize</name></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>ZSTDMT_getCCtx</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_CCtxPool</name><modifier>*</modifier></type> <name>cctxPool</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_getCCtx"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctxPool</name><operator>-&gt;</operator><name>poolMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cctxPool</name><operator>-&gt;</operator><name>availCCtx</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>cctxPool</name><operator>-&gt;</operator><name>availCCtx</name></name><operator>--</operator></expr>;</expr_stmt>
        <block>{<block_content>   <decl_stmt><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cctx</name> <init>= <expr><name><name>cctxPool</name><operator>-&gt;</operator><name>cctx</name><index>[<expr><name><name>cctxPool</name><operator>-&gt;</operator><name>availCCtx</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ZSTD_pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctxPool</name><operator>-&gt;</operator><name>poolMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>cctx</name></expr>;</return>
    </block_content>}</block>   </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>ZSTD_pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctxPool</name><operator>-&gt;</operator><name>poolMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"create one more CCtx"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>ZSTD_createCCtx_advanced</name><argument_list>(<argument><expr><name><name>cctxPool</name><operator>-&gt;</operator><name>cMem</name></name></expr></argument>)</argument_list></call></expr>;</return>   <comment type="block">/* note : can be NULL, when creation fails ! */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTDMT_releaseCCtx</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_CCtxPool</name><modifier>*</modifier></type> <name>pool</name></decl></parameter>, <parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>cctx</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>   <comment type="block">/* compatibility with release on NULL */</comment>
    <expr_stmt><expr><call><name>ZSTD_pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pool</name><operator>-&gt;</operator><name>poolMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pool</name><operator>-&gt;</operator><name>availCCtx</name></name> <operator>&lt;</operator> <name><name>pool</name><operator>-&gt;</operator><name>totalCCtx</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>cctx</name><index>[<expr><name><name>pool</name><operator>-&gt;</operator><name>availCCtx</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>cctx</name></expr>;</expr_stmt></block_content></block></if>
    <else>else <block>{<block_content>
        <comment type="block">/* pool overflow : should not happen, since totalCCtx==nbWorkers */</comment>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"CCtx pool overflow : free cctx"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_freeCCtx</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>ZSTD_pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pool</name><operator>-&gt;</operator><name>poolMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ====   Serial State   ==== */</comment>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>
}</block></struct></type> <name>range_t</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
    <comment type="block">/* All variables in the struct are protected by mutex. */</comment>
    <decl_stmt><decl><type><name>ZSTD_pthread_mutex_t</name></type> <name>mutex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_pthread_cond_t</name></type> <name>cond</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_CCtx_params</name></type> <name>params</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ldmState_t</name></type> <name>ldmState</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XXH64_state_t</name></type> <name>xxhState</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>nextJobID</name></decl>;</decl_stmt>
    <comment type="block">/* Protects ldmWindow.
     * Must be acquired after the main mutex when acquiring both.
     */</comment>
    <decl_stmt><decl><type><name>ZSTD_pthread_mutex_t</name></type> <name>ldmWindowMutex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_pthread_cond_t</name></type> <name>ldmWindowCond</name></decl>;</decl_stmt>  <comment type="block">/* Signaled when ldmWindow is updated */</comment>
    <decl_stmt><decl><type><name>ZSTD_window_t</name></type> <name>ldmWindow</name></decl>;</decl_stmt>  <comment type="block">/* A thread-safe copy of ldmState.window */</comment>
}</block></struct></type> <name>serialState_t</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>ZSTDMT_serialState_reset</name><parameter_list>(<parameter><decl><type><name>serialState_t</name><modifier>*</modifier></type> <name>serialState</name></decl></parameter>,
                         <parameter><decl><type><name>ZSTDMT_seqPool</name><modifier>*</modifier></type> <name>seqPool</name></decl></parameter>,
                         <parameter><decl><type><name>ZSTD_CCtx_params</name></type> <name>params</name></decl></parameter>,
                         <parameter><decl><type><name>size_t</name></type> <name>jobSize</name></decl></parameter>,
                         <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>dictSize</name></decl></parameter>,
                         <parameter><decl><type><name>ZSTD_dictContentType_e</name></type> <name>dictContentType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Adjust parameters */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>.</operator><name>ldmParams</name><operator>.</operator><name>enableLdm</name></name> <operator>==</operator> <name>ZSTD_ps_enable</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"LDM window size = %u KB"</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name><name>params</name><operator>.</operator><name>cParams</name><operator>.</operator><name>windowLog</name></name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_ldm_adjustParameters</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>params</name><operator>.</operator><name>ldmParams</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>params</name><operator>.</operator><name>cParams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>params</name><operator>.</operator><name>ldmParams</name><operator>.</operator><name>hashLog</name></name> <operator>&gt;=</operator> <name><name>params</name><operator>.</operator><name>ldmParams</name><operator>.</operator><name>bucketSizeLog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>params</name><operator>.</operator><name>ldmParams</name><operator>.</operator><name>hashRateLog</name></name> <operator>&lt;</operator> <literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>params</name><operator>.</operator><name>ldmParams</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>params</name><operator>.</operator><name>ldmParams</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>serialState</name><operator>-&gt;</operator><name>nextJobID</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>.</operator><name>fParams</name><operator>.</operator><name>checksumFlag</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>XXH64_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>serialState</name><operator>-&gt;</operator><name>xxhState</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>.</operator><name>ldmParams</name><operator>.</operator><name>enableLdm</name></name> <operator>==</operator> <name>ZSTD_ps_enable</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>ZSTD_customMem</name></type> <name>cMem</name> <init>= <expr><name><name>params</name><operator>.</operator><name>customMem</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>hashLog</name> <init>= <expr><name><name>params</name><operator>.</operator><name>ldmParams</name><operator>.</operator><name>hashLog</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>hashSize</name> <init>= <expr><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>hashLog</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ldmEntry_t</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>bucketLog</name> <init>=
            <expr><name><name>params</name><operator>.</operator><name>ldmParams</name><operator>.</operator><name>hashLog</name></name> <operator>-</operator> <name><name>params</name><operator>.</operator><name>ldmParams</name><operator>.</operator><name>bucketSizeLog</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>prevBucketLog</name> <init>=
            <expr><name><name>serialState</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>ldmParams</name><operator>.</operator><name>hashLog</name></name> <operator>-</operator>
            <name><name>serialState</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>ldmParams</name><operator>.</operator><name>bucketSizeLog</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>numBuckets</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>bucketLog</name></expr></init></decl>;</decl_stmt>
        <comment type="block">/* Size the seq pool tables */</comment>
        <expr_stmt><expr><call><name>ZSTDMT_setNbSeq</name><argument_list>(<argument><expr><name>seqPool</name></expr></argument>, <argument><expr><call><name>ZSTD_ldm_getMaxNbSeq</name><argument_list>(<argument><expr><name><name>params</name><operator>.</operator><name>ldmParams</name></name></expr></argument>, <argument><expr><name>jobSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Reset the window */</comment>
        <expr_stmt><expr><call><name>ZSTD_window_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>serialState</name><operator>-&gt;</operator><name>ldmState</name><operator>.</operator><name>window</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Resize tables and output space if necessary. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>serialState</name><operator>-&gt;</operator><name>ldmState</name><operator>.</operator><name>hashTable</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>serialState</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>ldmParams</name><operator>.</operator><name>hashLog</name></name> <operator>&lt;</operator> <name>hashLog</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>ZSTD_customFree</name><argument_list>(<argument><expr><name><name>serialState</name><operator>-&gt;</operator><name>ldmState</name><operator>.</operator><name>hashTable</name></name></expr></argument>, <argument><expr><name>cMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>serialState</name><operator>-&gt;</operator><name>ldmState</name><operator>.</operator><name>hashTable</name></name> <operator>=</operator> <operator>(</operator><name>ldmEntry_t</name><operator>*</operator><operator>)</operator><call><name>ZSTD_customMalloc</name><argument_list>(<argument><expr><name>hashSize</name></expr></argument>, <argument><expr><name>cMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>serialState</name><operator>-&gt;</operator><name>ldmState</name><operator>.</operator><name>bucketOffsets</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>prevBucketLog</name> <operator>&lt;</operator> <name>bucketLog</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>ZSTD_customFree</name><argument_list>(<argument><expr><name><name>serialState</name><operator>-&gt;</operator><name>ldmState</name><operator>.</operator><name>bucketOffsets</name></name></expr></argument>, <argument><expr><name>cMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>serialState</name><operator>-&gt;</operator><name>ldmState</name><operator>.</operator><name>bucketOffsets</name></name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><call><name>ZSTD_customMalloc</name><argument_list>(<argument><expr><name>numBuckets</name></expr></argument>, <argument><expr><name>cMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>serialState</name><operator>-&gt;</operator><name>ldmState</name><operator>.</operator><name>hashTable</name></name> <operator>||</operator> <operator>!</operator><name><name>serialState</name><operator>-&gt;</operator><name>ldmState</name><operator>.</operator><name>bucketOffsets</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <comment type="block">/* Zero the tables */</comment>
        <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><name><name>serialState</name><operator>-&gt;</operator><name>ldmState</name><operator>.</operator><name>hashTable</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>hashSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><name><name>serialState</name><operator>-&gt;</operator><name>ldmState</name><operator>.</operator><name>bucketOffsets</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>numBuckets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Update window state and fill hash table with dict */</comment>
        <expr_stmt><expr><name><name>serialState</name><operator>-&gt;</operator><name>ldmState</name><operator>.</operator><name>loadedDictEnd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>dictSize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>dictContentType</name> <operator>==</operator> <name>ZSTD_dct_rawContent</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>dictEnd</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>dict</name> <operator>+</operator> <name>dictSize</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>ZSTD_window_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>serialState</name><operator>-&gt;</operator><name>ldmState</name><operator>.</operator><name>window</name></name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>, <comment type="block">/* forceNonContiguous */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ZSTD_ldm_fillHashTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>serialState</name><operator>-&gt;</operator><name>ldmState</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>dict</name></expr></argument>, <argument><expr><name>dictEnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>params</name><operator>.</operator><name>ldmParams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>serialState</name><operator>-&gt;</operator><name>ldmState</name><operator>.</operator><name>loadedDictEnd</name></name> <operator>=</operator> <ternary><condition><expr><name><name>params</name><operator>.</operator><name>forceWindow</name></name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>dictEnd</name> <operator>-</operator> <name><name>serialState</name><operator>-&gt;</operator><name>ldmState</name><operator>.</operator><name>window</name><operator>.</operator><name>base</name></name><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <comment type="block">/* don't even load anything */</comment>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Initialize serialState's copy of ldmWindow. */</comment>
        <expr_stmt><expr><name><name>serialState</name><operator>-&gt;</operator><name>ldmWindow</name></name> <operator>=</operator> <name><name>serialState</name><operator>-&gt;</operator><name>ldmState</name><operator>.</operator><name>window</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>serialState</name><operator>-&gt;</operator><name>params</name></name> <operator>=</operator> <name>params</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>serialState</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>jobSize</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>jobSize</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ZSTDMT_serialState_init</name><parameter_list>(<parameter><decl><type><name>serialState_t</name><modifier>*</modifier></type> <name>serialState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>initError</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><name>serialState</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>serialState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>initError</name> <operator>|=</operator> <call><name>ZSTD_pthread_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>serialState</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>initError</name> <operator>|=</operator> <call><name>ZSTD_pthread_cond_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>serialState</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>initError</name> <operator>|=</operator> <call><name>ZSTD_pthread_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>serialState</name><operator>-&gt;</operator><name>ldmWindowMutex</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>initError</name> <operator>|=</operator> <call><name>ZSTD_pthread_cond_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>serialState</name><operator>-&gt;</operator><name>ldmWindowCond</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>initError</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTDMT_serialState_free</name><parameter_list>(<parameter><decl><type><name>serialState_t</name><modifier>*</modifier></type> <name>serialState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_customMem</name></type> <name>cMem</name> <init>= <expr><name><name>serialState</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>customMem</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ZSTD_pthread_mutex_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>serialState</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_pthread_cond_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>serialState</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_pthread_mutex_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>serialState</name><operator>-&gt;</operator><name>ldmWindowMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_pthread_cond_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>serialState</name><operator>-&gt;</operator><name>ldmWindowCond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_customFree</name><argument_list>(<argument><expr><name><name>serialState</name><operator>-&gt;</operator><name>ldmState</name><operator>.</operator><name>hashTable</name></name></expr></argument>, <argument><expr><name>cMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_customFree</name><argument_list>(<argument><expr><name><name>serialState</name><operator>-&gt;</operator><name>ldmState</name><operator>.</operator><name>bucketOffsets</name></name></expr></argument>, <argument><expr><name>cMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTDMT_serialState_update</name><parameter_list>(<parameter><decl><type><name>serialState_t</name><modifier>*</modifier></type> <name>serialState</name></decl></parameter>,
                                      <parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>jobCCtx</name></decl></parameter>, <parameter><decl><type><name>rawSeqStore_t</name></type> <name>seqStore</name></decl></parameter>,
                                      <parameter><decl><type><name>range_t</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>jobID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Wait for our turn */</comment>
    <expr_stmt><expr><call><name>ZSTD_PTHREAD_MUTEX_LOCK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>serialState</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name><name>serialState</name><operator>-&gt;</operator><name>nextJobID</name></name> <operator>&lt;</operator> <name>jobID</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"wait for serialState-&gt;cond"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_pthread_cond_wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>serialState</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>serialState</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <comment type="block">/* A future job may error and skip our job */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>serialState</name><operator>-&gt;</operator><name>nextJobID</name></name> <operator>==</operator> <name>jobID</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* It is now our turn, do any processing necessary */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>serialState</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>ldmParams</name><operator>.</operator><name>enableLdm</name></name> <operator>==</operator> <name>ZSTD_ps_enable</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>size_t</name></type> <name>error</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>seqStore</name><operator>.</operator><name>seq</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>seqStore</name><operator>.</operator><name>pos</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                   <name><name>seqStore</name><operator>.</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>seqStore</name><operator>.</operator><name>capacity</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>src</name><operator>.</operator><name>size</name></name> <operator>&lt;=</operator> <name><name>serialState</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>jobSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ZSTD_window_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>serialState</name><operator>-&gt;</operator><name>ldmState</name><operator>.</operator><name>window</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>.</operator><name>size</name></name></expr></argument>, <comment type="block">/* forceNonContiguous */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>ZSTD_ldm_generateSequences</name><argument_list>(
                <argument><expr><operator>&amp;</operator><name><name>serialState</name><operator>-&gt;</operator><name>ldmState</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seqStore</name></expr></argument>,
                <argument><expr><operator>&amp;</operator><name><name>serialState</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>ldmParams</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* We provide a large enough buffer to never fail. */</comment>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>error</name></expr>;</expr_stmt>
            <comment type="block">/* Update ldmWindow to match the ldmState.window and signal the main
             * thread if it is waiting for a buffer.
             */</comment>
            <expr_stmt><expr><call><name>ZSTD_PTHREAD_MUTEX_LOCK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>serialState</name><operator>-&gt;</operator><name>ldmWindowMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>serialState</name><operator>-&gt;</operator><name>ldmWindow</name></name> <operator>=</operator> <name><name>serialState</name><operator>-&gt;</operator><name>ldmState</name><operator>.</operator><name>window</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ZSTD_pthread_cond_signal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>serialState</name><operator>-&gt;</operator><name>ldmWindowCond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ZSTD_pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>serialState</name><operator>-&gt;</operator><name>ldmWindowMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>serialState</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>fParams</name><operator>.</operator><name>checksumFlag</name></name> <operator>&amp;&amp;</operator> <name><name>src</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>XXH64_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>serialState</name><operator>-&gt;</operator><name>xxhState</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Now it is the next jobs turn */</comment>
    <expr_stmt><expr><name><name>serialState</name><operator>-&gt;</operator><name>nextJobID</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_pthread_cond_broadcast</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>serialState</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>serialState</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>seqStore</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>err</name> <init>= <expr><call><name>ZSTD_referenceExternalSequences</name><argument_list>(
            <argument><expr><name>jobCCtx</name></expr></argument>, <argument><expr><name><name>seqStore</name><operator>.</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>seqStore</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>serialState</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>ldmParams</name><operator>.</operator><name>enableLdm</name></name> <operator>==</operator> <name>ZSTD_ps_enable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>err</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTDMT_serialState_ensureFinished</name><parameter_list>(<parameter><decl><type><name>serialState_t</name><modifier>*</modifier></type> <name>serialState</name></decl></parameter>,
                                              <parameter><decl><type><name>unsigned</name></type> <name>jobID</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>ZSTD_PTHREAD_MUTEX_LOCK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>serialState</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>serialState</name><operator>-&gt;</operator><name>nextJobID</name></name> <operator>&lt;=</operator> <name>jobID</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>cSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Skipping past job %u because of error"</literal></expr></argument>, <argument><expr><name>jobID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>serialState</name><operator>-&gt;</operator><name>nextJobID</name></name> <operator>=</operator> <name>jobID</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_pthread_cond_broadcast</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>serialState</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ZSTD_PTHREAD_MUTEX_LOCK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>serialState</name><operator>-&gt;</operator><name>ldmWindowMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_window_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>serialState</name><operator>-&gt;</operator><name>ldmWindow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_pthread_cond_signal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>serialState</name><operator>-&gt;</operator><name>ldmWindowCond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>serialState</name><operator>-&gt;</operator><name>ldmWindowMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>ZSTD_pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>serialState</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>


<comment type="block">/* ------------------------------------------ */</comment>
<comment type="block">/* =====          Worker thread         ===== */</comment>
<comment type="block">/* ------------------------------------------ */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>range_t</name></type> <name>kNullRange</name> <init>= <expr><block>{ <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>size_t</name></type>   <name>consumed</name></decl>;</decl_stmt>                   <comment type="block">/* SHARED - set0 by mtctx, then modified by worker AND read by mtctx */</comment>
    <decl_stmt><decl><type><name>size_t</name></type>   <name>cSize</name></decl>;</decl_stmt>                      <comment type="block">/* SHARED - set0 by mtctx, then modified by worker AND read by mtctx, then set0 by mtctx */</comment>
    <decl_stmt><decl><type><name>ZSTD_pthread_mutex_t</name></type> <name>job_mutex</name></decl>;</decl_stmt>      <comment type="block">/* Thread-safe - used by mtctx and worker */</comment>
    <decl_stmt><decl><type><name>ZSTD_pthread_cond_t</name></type> <name>job_cond</name></decl>;</decl_stmt>        <comment type="block">/* Thread-safe - used by mtctx and worker */</comment>
    <decl_stmt><decl><type><name>ZSTDMT_CCtxPool</name><modifier>*</modifier></type> <name>cctxPool</name></decl>;</decl_stmt>           <comment type="block">/* Thread-safe - used by mtctx and (all) workers */</comment>
    <decl_stmt><decl><type><name>ZSTDMT_bufferPool</name><modifier>*</modifier></type> <name>bufPool</name></decl>;</decl_stmt>          <comment type="block">/* Thread-safe - used by mtctx and (all) workers */</comment>
    <decl_stmt><decl><type><name>ZSTDMT_seqPool</name><modifier>*</modifier></type> <name>seqPool</name></decl>;</decl_stmt>             <comment type="block">/* Thread-safe - used by mtctx and (all) workers */</comment>
    <decl_stmt><decl><type><name>serialState_t</name><modifier>*</modifier></type> <name>serial</name></decl>;</decl_stmt>               <comment type="block">/* Thread-safe - used by mtctx and (all) workers */</comment>
    <decl_stmt><decl><type><name>buffer_t</name></type> <name>dstBuff</name></decl>;</decl_stmt>                    <comment type="block">/* set by worker (or mtctx), then read by worker &amp; mtctx, then modified by mtctx =&gt; no barrier */</comment>
    <decl_stmt><decl><type><name>range_t</name></type> <name>prefix</name></decl>;</decl_stmt>                      <comment type="block">/* set by mtctx, then read by worker &amp; mtctx =&gt; no barrier */</comment>
    <decl_stmt><decl><type><name>range_t</name></type> <name>src</name></decl>;</decl_stmt>                         <comment type="block">/* set by mtctx, then read by worker &amp; mtctx =&gt; no barrier */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>jobID</name></decl>;</decl_stmt>                      <comment type="block">/* set by mtctx, then read by worker =&gt; no barrier */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>firstJob</name></decl>;</decl_stmt>                   <comment type="block">/* set by mtctx, then read by worker =&gt; no barrier */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>lastJob</name></decl>;</decl_stmt>                    <comment type="block">/* set by mtctx, then read by worker =&gt; no barrier */</comment>
    <decl_stmt><decl><type><name>ZSTD_CCtx_params</name></type> <name>params</name></decl>;</decl_stmt>             <comment type="block">/* set by mtctx, then read by worker =&gt; no barrier */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_CDict</name><modifier>*</modifier></type> <name>cdict</name></decl>;</decl_stmt>             <comment type="block">/* set by mtctx, then read by worker =&gt; no barrier */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>fullFrameSize</name></decl>;</decl_stmt>    <comment type="block">/* set by mtctx, then read by worker =&gt; no barrier */</comment>
    <decl_stmt><decl><type><name>size_t</name></type>   <name>dstFlushed</name></decl>;</decl_stmt>                 <comment type="block">/* used only by mtctx */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>frameChecksumNeeded</name></decl>;</decl_stmt>        <comment type="block">/* used only by mtctx */</comment>
}</block></struct></type> <name>ZSTDMT_jobDescription</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JOB_ERROR</name><parameter_list>(<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{                          \
    ZSTD_PTHREAD_MUTEX_LOCK(&amp;job-&gt;job_mutex);   \
    job-&gt;cSize = e;                             \
    ZSTD_pthread_mutex_unlock(&amp;job-&gt;job_mutex); \
    goto _endJob;                               \
}</cpp:value></cpp:define>

<comment type="block">/* ZSTDMT_compressionJob() is a POOL_function type */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTDMT_compressionJob</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>jobDescription</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTDMT_jobDescription</name><modifier>*</modifier> <specifier>const</specifier></type> <name>job</name> <init>= <expr><operator>(</operator><name>ZSTDMT_jobDescription</name><operator>*</operator><operator>)</operator><name>jobDescription</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_CCtx_params</name></type> <name>jobParams</name> <init>= <expr><name><name>job</name><operator>-&gt;</operator><name>params</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* do not modify job-&gt;params ! copy it, modify the copy */</comment>
    <decl_stmt><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cctx</name> <init>= <expr><call><name>ZSTDMT_getCCtx</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>cctxPool</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>rawSeqStore_t</name></type> <name>rawSeqStore</name> <init>= <expr><call><name>ZSTDMT_getSeq</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>seqPool</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>buffer_t</name></type> <name>dstBuff</name> <init>= <expr><name><name>job</name><operator>-&gt;</operator><name>dstBuff</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>lastCBlockSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* resources */</comment>
    <if_stmt><if>if <condition>(<expr><name>cctx</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>JOB_ERROR</name><argument_list>(<argument><expr><call><name>ERROR</name><argument_list>(<argument><expr><name>memory_allocation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>dstBuff</name><operator>.</operator><name>start</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>   <comment type="block">/* streaming job : doesn't provide a dstBuffer */</comment>
        <expr_stmt><expr><name>dstBuff</name> <operator>=</operator> <call><name>ZSTDMT_getBuffer</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>bufPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>dstBuff</name><operator>.</operator><name>start</name></name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>JOB_ERROR</name><argument_list>(<argument><expr><call><name>ERROR</name><argument_list>(<argument><expr><name>memory_allocation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>dstBuff</name></name> <operator>=</operator> <name>dstBuff</name></expr>;</expr_stmt>   <comment type="block">/* this value can be read in ZSTDMT_flush, when it copies the whole job */</comment>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>jobParams</name><operator>.</operator><name>ldmParams</name><operator>.</operator><name>enableLdm</name></name> <operator>==</operator> <name>ZSTD_ps_enable</name> <operator>&amp;&amp;</operator> <name><name>rawSeqStore</name><operator>.</operator><name>seq</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>JOB_ERROR</name><argument_list>(<argument><expr><call><name>ERROR</name><argument_list>(<argument><expr><name>memory_allocation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Don't compute the checksum for chunks, since we compute it externally,
     * but write it in the header.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>job</name><operator>-&gt;</operator><name>jobID</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>jobParams</name><operator>.</operator><name>fParams</name><operator>.</operator><name>checksumFlag</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* Don't run LDM for the chunks, since we handle it externally */</comment>
    <expr_stmt><expr><name><name>jobParams</name><operator>.</operator><name>ldmParams</name><operator>.</operator><name>enableLdm</name></name> <operator>=</operator> <name>ZSTD_ps_disable</name></expr>;</expr_stmt>
    <comment type="block">/* Correct nbWorkers to 0. */</comment>
    <expr_stmt><expr><name><name>jobParams</name><operator>.</operator><name>nbWorkers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


    <comment type="block">/* init */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>job</name><operator>-&gt;</operator><name>cdict</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>initError</name> <init>= <expr><call><name>ZSTD_compressBegin_advanced_internal</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ZSTD_dct_auto</name></expr></argument>, <argument><expr><name>ZSTD_dtlm_fast</name></expr></argument>, <argument><expr><name><name>job</name><operator>-&gt;</operator><name>cdict</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jobParams</name></expr></argument>, <argument><expr><name><name>job</name><operator>-&gt;</operator><name>fullFrameSize</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>firstJob</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* only allowed for first job */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>initError</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>JOB_ERROR</name><argument_list>(<argument><expr><name>initError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* srcStart points at reloaded section */</comment>
        <decl_stmt><decl><type><name>U64</name> <specifier>const</specifier></type> <name>pledgedSrcSize</name> <init>= <expr><ternary><condition><expr><name><name>job</name><operator>-&gt;</operator><name>firstJob</name></name></expr> ?</condition><then> <expr><name><name>job</name><operator>-&gt;</operator><name>fullFrameSize</name></name></expr> </then><else>: <expr><name><name>job</name><operator>-&gt;</operator><name>src</name><operator>.</operator><name>size</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>forceWindowError</name> <init>= <expr><call><name>ZSTD_CCtxParams_setParameter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jobParams</name></expr></argument>, <argument><expr><name>ZSTD_c_forceMaxWindow</name></expr></argument>, <argument><expr><operator>!</operator><name><name>job</name><operator>-&gt;</operator><name>firstJob</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>forceWindowError</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>JOB_ERROR</name><argument_list>(<argument><expr><name>forceWindowError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>job</name><operator>-&gt;</operator><name>firstJob</name></name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>err</name> <init>= <expr><call><name>ZSTD_CCtxParams_setParameter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jobParams</name></expr></argument>, <argument><expr><name>ZSTD_c_deterministicRefPrefix</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>JOB_ERROR</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>initError</name> <init>= <expr><call><name>ZSTD_compressBegin_advanced_internal</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>,
                                        <argument><expr><name><name>job</name><operator>-&gt;</operator><name>prefix</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name><name>job</name><operator>-&gt;</operator><name>prefix</name><operator>.</operator><name>size</name></name></expr></argument>, <argument><expr><name>ZSTD_dct_rawContent</name></expr></argument>, <comment type="block">/* load dictionary in "content-only" mode (no header analysis) */</comment>
                                        <argument><expr><name>ZSTD_dtlm_fast</name></expr></argument>,
                                        <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/*cdict*/</comment>
                                        <argument><expr><operator>&amp;</operator><name>jobParams</name></expr></argument>, <argument><expr><name>pledgedSrcSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>initError</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>JOB_ERROR</name><argument_list>(<argument><expr><name>initError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>   </block_content>}</block></else></if_stmt>

    <comment type="block">/* Perform serial step as early as possible, but after CCtx initialization */</comment>
    <expr_stmt><expr><call><name>ZSTDMT_serialState_update</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>serial</name></name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>rawSeqStore</name></expr></argument>, <argument><expr><name><name>job</name><operator>-&gt;</operator><name>src</name></name></expr></argument>, <argument><expr><name><name>job</name><operator>-&gt;</operator><name>jobID</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>job</name><operator>-&gt;</operator><name>firstJob</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* flush and overwrite frame header when it's not first job */</comment>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>hSize</name> <init>= <expr><call><name>ZSTD_compressContinue</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name><name>dstBuff</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name><name>dstBuff</name><operator>.</operator><name>capacity</name></name></expr></argument>, <argument><expr><name><name>job</name><operator>-&gt;</operator><name>src</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>hSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>JOB_ERROR</name><argument_list>(<argument><expr><name>hSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_compressionJob: flush and overwrite %u bytes of frame header (not first job)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>hSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_invalidateRepCodes</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* compress */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>chunkSize</name> <init>= <expr><literal type="number">4</literal><operator>*</operator><name>ZSTD_BLOCKSIZE_MAX</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>nbChunks</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>job</name><operator>-&gt;</operator><name>src</name><operator>.</operator><name>size</name></name> <operator>+</operator> <operator>(</operator><name>chunkSize</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <name>chunkSize</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator> <name><name>job</name><operator>-&gt;</operator><name>src</name><operator>.</operator><name>start</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ostart</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name><name>dstBuff</name><operator>.</operator><name>start</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><name>ostart</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>oend</name> <init>= <expr><name>op</name> <operator>+</operator> <name><name>dstBuff</name><operator>.</operator><name>capacity</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>chunkNb</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>src</name><operator>.</operator><name>size</name></name> <operator>&lt;</operator> <operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><name>INT_MAX</name><operator>)</operator> <operator>*</operator> <name>chunkSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>   <comment type="block">/* check overflow */</comment>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_compressionJob: compress %u bytes in %i blocks"</literal></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>job</name><operator>-&gt;</operator><name>src</name><operator>.</operator><name>size</name></name></expr></argument>, <argument><expr><name>nbChunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>cSize</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>chunkNb</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>chunkNb</name> <operator>&lt;</operator> <name>nbChunks</name></expr>;</condition> <incr><expr><name>chunkNb</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>cSize</name> <init>= <expr><call><name>ZSTD_compressContinue</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name><operator>-</operator><name>op</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>chunkSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>JOB_ERROR</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>chunkSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>cSize</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name> <operator>&lt;</operator> <name>oend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* stats */</comment>
            <expr_stmt><expr><call><name>ZSTD_PTHREAD_MUTEX_LOCK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>job</name><operator>-&gt;</operator><name>job_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>cSize</name></name> <operator>+=</operator> <name>cSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>consumed</name></name> <operator>=</operator> <name>chunkSize</name> <operator>*</operator> <name>chunkNb</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_compressionJob: compress new block : cSize==%u bytes (total: %u)"</literal></expr></argument>,
                        <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>cSize</name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>job</name><operator>-&gt;</operator><name>cSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ZSTD_pthread_cond_signal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>job</name><operator>-&gt;</operator><name>job_cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* warns some more data is ready to be flushed */</comment>
            <expr_stmt><expr><call><name>ZSTD_pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>job</name><operator>-&gt;</operator><name>job_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <comment type="block">/* last block */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>chunkSize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>chunkSize</name> <operator>&amp;</operator> <operator>(</operator><name>chunkSize</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* chunkSize must be power of 2 for mask==(chunkSize-1) to work */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>nbChunks</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>|</operator> <name><name>job</name><operator>-&gt;</operator><name>lastJob</name></name></expr> <comment type="block">/*must output a "last block" flag*/</comment> )</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>lastBlockSize1</name> <init>= <expr><name><name>job</name><operator>-&gt;</operator><name>src</name><operator>.</operator><name>size</name></name> <operator>&amp;</operator> <operator>(</operator><name>chunkSize</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>lastBlockSize</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>lastBlockSize1</name><operator>==</operator><literal type="number">0</literal><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name><name>job</name><operator>-&gt;</operator><name>src</name><operator>.</operator><name>size</name></name><operator>&gt;=</operator><name>chunkSize</name><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><name>chunkSize</name></expr> </then><else>: <expr><name>lastBlockSize1</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>cSize</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>job</name><operator>-&gt;</operator><name>lastJob</name></name><operator>)</operator></expr> ?</condition><then>
                 <expr><call><name>ZSTD_compressEnd</name>     <argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name><operator>-</operator><name>op</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>lastBlockSize</name></expr></argument>)</argument_list></call></expr> </then><else>:
                 <expr><call><name>ZSTD_compressContinue</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name><operator>-</operator><name>op</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>lastBlockSize</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>JOB_ERROR</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>lastCBlockSize</name> <operator>=</operator> <name>cSize</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>   </block_content>}</block>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>job</name><operator>-&gt;</operator><name>firstJob</name></name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Double check that we don't have an ext-dict, because then our
         * repcode invalidation doesn't work.
         */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ZSTD_window_hasExtDict</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name><operator>.</operator><name>window</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>ZSTD_CCtx_trace</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>_endJob</name>:</label>
    <expr_stmt><expr><call><name>ZSTDMT_serialState_ensureFinished</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>serial</name></name></expr></argument>, <argument><expr><name><name>job</name><operator>-&gt;</operator><name>jobID</name></name></expr></argument>, <argument><expr><name><name>job</name><operator>-&gt;</operator><name>cSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>job</name><operator>-&gt;</operator><name>prefix</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Finished with prefix: %zx"</literal></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>job</name><operator>-&gt;</operator><name>prefix</name><operator>.</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Finished with source: %zx"</literal></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>job</name><operator>-&gt;</operator><name>src</name><operator>.</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* release resources */</comment>
    <expr_stmt><expr><call><name>ZSTDMT_releaseSeq</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>seqPool</name></name></expr></argument>, <argument><expr><name>rawSeqStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTDMT_releaseCCtx</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>cctxPool</name></name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* report */</comment>
    <expr_stmt><expr><call><name>ZSTD_PTHREAD_MUTEX_LOCK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>job</name><operator>-&gt;</operator><name>job_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>cSize</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lastCBlockSize</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>cSize</name></name> <operator>+=</operator> <name>lastCBlockSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>consumed</name></name> <operator>=</operator> <name><name>job</name><operator>-&gt;</operator><name>src</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>  <comment type="block">/* when job-&gt;consumed == job-&gt;src.size , compression job is presumed completed */</comment>
    <expr_stmt><expr><call><name>ZSTD_pthread_cond_signal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>job</name><operator>-&gt;</operator><name>job_cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>job</name><operator>-&gt;</operator><name>job_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ------------------------------------------ */</comment>
<comment type="block">/* =====   Multi-threaded compression   ===== */</comment>
<comment type="block">/* ------------------------------------------ */</comment>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>range_t</name></type> <name>prefix</name></decl>;</decl_stmt>         <comment type="block">/* read-only non-owned prefix buffer */</comment>
    <decl_stmt><decl><type><name>buffer_t</name></type> <name>buffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>filled</name></decl>;</decl_stmt>
}</block></struct></type> <name>inBuff_t</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
  <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>buffer</name></decl>;</decl_stmt>     <comment type="block">/* The round input buffer. All jobs get references
                     * to pieces of the buffer. ZSTDMT_tryGetInputRange()
                     * handles handing out job input buffers, and makes
                     * sure it doesn't overlap with any pieces still in use.
                     */</comment>
  <decl_stmt><decl><type><name>size_t</name></type> <name>capacity</name></decl>;</decl_stmt>  <comment type="block">/* The capacity of buffer. */</comment>
  <decl_stmt><decl><type><name>size_t</name></type> <name>pos</name></decl>;</decl_stmt>       <comment type="block">/* The position of the current inBuff in the round
                     * buffer. Updated past the end if the inBuff once
                     * the inBuff is sent to the worker thread.
                     * pos &lt;= capacity.
                     */</comment>
}</block></struct></type> <name>roundBuff_t</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>roundBuff_t</name></type> <name>kNullRoundBuff</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RSYNC_LENGTH</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>
<comment type="block">/* Don't create chunks smaller than the zstd block size.
 * This stops us from regressing compression ratio too much,
 * and ensures our output fits in ZSTD_compressBound().
 *
 * If this is shrunk &lt; ZSTD_BLOCKSIZELOG_MIN then
 * ZSTD_COMPRESSBOUND() will need to be updated.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RSYNC_MIN_BLOCK_LOG</name></cpp:macro> <cpp:value>ZSTD_BLOCKSIZELOG_MAX</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RSYNC_MIN_BLOCK_SIZE</name></cpp:macro> <cpp:value>(1&lt;&lt;RSYNC_MIN_BLOCK_LOG)</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{
  <decl_stmt><decl><type><name>U64</name></type> <name>hash</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>U64</name></type> <name>hitMask</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>U64</name></type> <name>primePower</name></decl>;</decl_stmt>
}</block></struct></type> <name>rsyncState_t</name>;</typedef>

<struct>struct <name>ZSTDMT_CCtx_s</name> <block>{
    <decl_stmt><decl><type><name>POOL_ctx</name><modifier>*</modifier></type> <name>factory</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTDMT_jobDescription</name><modifier>*</modifier></type> <name>jobs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTDMT_bufferPool</name><modifier>*</modifier></type> <name>bufPool</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTDMT_CCtxPool</name><modifier>*</modifier></type> <name>cctxPool</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTDMT_seqPool</name><modifier>*</modifier></type> <name>seqPool</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_CCtx_params</name></type> <name>params</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>targetSectionSize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>targetPrefixSize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>jobReady</name></decl>;</decl_stmt>        <comment type="block">/* 1 =&gt; one job is already prepared, but pool has shortage of workers. Don't create a new job. */</comment>
    <decl_stmt><decl><type><name>inBuff_t</name></type> <name>inBuff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>roundBuff_t</name></type> <name>roundBuff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>serialState_t</name></type> <name>serial</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>rsyncState_t</name></type> <name>rsync</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>jobIDMask</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>doneJobID</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>nextJobID</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>frameEnded</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>allJobsCompleted</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>frameContentSize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>consumed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>produced</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_customMem</name></type> <name>cMem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_CDict</name><modifier>*</modifier></type> <name>cdictLocal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_CDict</name><modifier>*</modifier></type> <name>cdict</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>providedFactory</name><range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTDMT_freeJobsTable</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_jobDescription</name><modifier>*</modifier></type> <name>jobTable</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>nbJobs</name></decl></parameter>, <parameter><decl><type><name>ZSTD_customMem</name></type> <name>cMem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name></type> <name>jobNb</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>jobTable</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <for>for <control>(<init><expr><name>jobNb</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>jobNb</name><operator>&lt;</operator><name>nbJobs</name></expr>;</condition> <incr><expr><name>jobNb</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>ZSTD_pthread_mutex_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>jobTable</name><index>[<expr><name>jobNb</name></expr>]</index></name><operator>.</operator><name>job_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_pthread_cond_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>jobTable</name><index>[<expr><name>jobNb</name></expr>]</index></name><operator>.</operator><name>job_cond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>ZSTD_customFree</name><argument_list>(<argument><expr><name>jobTable</name></expr></argument>, <argument><expr><name>cMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ZSTDMT_allocJobsTable()
 * allocate and init a job table.
 * update *nbJobsPtr to next power of 2 value, as size of table */</comment>
<function><type><specifier>static</specifier> <name>ZSTDMT_jobDescription</name><modifier>*</modifier></type> <name>ZSTDMT_createJobsTable</name><parameter_list>(<parameter><decl><type><name>U32</name><modifier>*</modifier></type> <name>nbJobsPtr</name></decl></parameter>, <parameter><decl><type><name>ZSTD_customMem</name></type> <name>cMem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>nbJobsLog2</name> <init>= <expr><call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><operator>*</operator><name>nbJobsPtr</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>nbJobs</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>nbJobsLog2</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>jobNb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTDMT_jobDescription</name><modifier>*</modifier> <specifier>const</specifier></type> <name>jobTable</name> <init>= <expr><operator>(</operator><name>ZSTDMT_jobDescription</name><operator>*</operator><operator>)</operator>
                <call><name>ZSTD_customCalloc</name><argument_list>(<argument><expr><name>nbJobs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ZSTDMT_jobDescription</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cMem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>initError</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>jobTable</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>nbJobsPtr</name> <operator>=</operator> <name>nbJobs</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>jobNb</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>jobNb</name><operator>&lt;</operator><name>nbJobs</name></expr>;</condition> <incr><expr><name>jobNb</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name>initError</name> <operator>|=</operator> <call><name>ZSTD_pthread_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>jobTable</name><index>[<expr><name>jobNb</name></expr>]</index></name><operator>.</operator><name>job_mutex</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>initError</name> <operator>|=</operator> <call><name>ZSTD_pthread_cond_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>jobTable</name><index>[<expr><name>jobNb</name></expr>]</index></name><operator>.</operator><name>job_cond</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>initError</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>ZSTDMT_freeJobsTable</name><argument_list>(<argument><expr><name>jobTable</name></expr></argument>, <argument><expr><name>nbJobs</name></expr></argument>, <argument><expr><name>cMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>jobTable</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTDMT_expandJobsTable</name> <parameter_list>(<parameter><decl><type><name>ZSTDMT_CCtx</name><modifier>*</modifier></type> <name>mtctx</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>nbWorkers</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>U32</name></type> <name>nbJobs</name> <init>= <expr><name>nbWorkers</name> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>nbJobs</name> <operator>&gt;</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>jobIDMask</name></name><operator>+</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* need more job capacity */</comment>
        <expr_stmt><expr><call><name>ZSTDMT_freeJobsTable</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name></name></expr></argument>, <argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobIDMask</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>cMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobIDMask</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name></name> <operator>=</operator> <call><name>ZSTDMT_createJobsTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nbJobs</name></expr></argument>, <argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>cMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name></name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>memory_allocation</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>nbJobs</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>nbJobs</name> <operator>&amp;</operator> <operator>(</operator><name>nbJobs</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* ensure nbJobs is a power of 2 */</comment>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobIDMask</name></name> <operator>=</operator> <name>nbJobs</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ZSTDMT_CCtxParam_setNbWorkers():
 * Internal use only */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTDMT_CCtxParam_setNbWorkers</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>params</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>nbWorkers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_CCtxParams_setParameter</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>ZSTD_c_nbWorkers</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>nbWorkers</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>MEM_STATIC</name> <name>ZSTDMT_CCtx</name><modifier>*</modifier></type> <name>ZSTDMT_createCCtx_advanced_internal</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>nbWorkers</name></decl></parameter>, <parameter><decl><type><name>ZSTD_customMem</name></type> <name>cMem</name></decl></parameter>, <parameter><decl><type><name>ZSTD_threadPool</name><modifier>*</modifier></type> <name>pool</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTDMT_CCtx</name><modifier>*</modifier></type> <name>mtctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>nbJobs</name> <init>= <expr><name>nbWorkers</name> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>initError</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_createCCtx_advanced (nbWorkers = %u)"</literal></expr></argument>, <argument><expr><name>nbWorkers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>nbWorkers</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>nbWorkers</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>nbWorkers</name></expr></argument> , <argument><expr><name>ZSTDMT_NBWORKERS_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cMem</name><operator>.</operator><name>customAlloc</name></name><operator>!=</operator><name>NULL</name><operator>)</operator> <operator>^</operator> <operator>(</operator><name><name>cMem</name><operator>.</operator><name>customFree</name></name><operator>!=</operator><name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <comment type="block">/* invalid custom allocator */</comment>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>mtctx</name> <operator>=</operator> <operator>(</operator><name>ZSTDMT_CCtx</name><operator>*</operator><operator>)</operator> <call><name>ZSTD_customCalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZSTDMT_CCtx</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>mtctx</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>ZSTDMT_CCtxParam_setNbWorkers</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mtctx</name><operator>-&gt;</operator><name>params</name></name></expr></argument>, <argument><expr><name>nbWorkers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>cMem</name></name> <operator>=</operator> <name>cMem</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>allJobsCompleted</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>pool</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>factory</name></name> <operator>=</operator> <name>pool</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>providedFactory</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else <block>{<block_content>
      <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>factory</name></name> <operator>=</operator> <call><name>POOL_create_advanced</name><argument_list>(<argument><expr><name>nbWorkers</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>cMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>providedFactory</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name></name> <operator>=</operator> <call><name>ZSTDMT_createJobsTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nbJobs</name></expr></argument>, <argument><expr><name>cMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nbJobs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>nbJobs</name> <operator>&amp;</operator> <operator>(</operator><name>nbJobs</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* ensure nbJobs is a power of 2 */</comment>
    <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobIDMask</name></name> <operator>=</operator> <name>nbJobs</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>bufPool</name></name> <operator>=</operator> <call><name>ZSTDMT_createBufferPool</name><argument_list>(<argument><expr><call><name>BUF_POOL_MAX_NB_BUFFERS</name><argument_list>(<argument><expr><name>nbWorkers</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>cctxPool</name></name> <operator>=</operator> <call><name>ZSTDMT_createCCtxPool</name><argument_list>(<argument><expr><name>nbWorkers</name></expr></argument>, <argument><expr><name>cMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>seqPool</name></name> <operator>=</operator> <call><name>ZSTDMT_createSeqPool</name><argument_list>(<argument><expr><name>nbWorkers</name></expr></argument>, <argument><expr><name>cMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>initError</name> <operator>=</operator> <call><name>ZSTDMT_serialState_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mtctx</name><operator>-&gt;</operator><name>serial</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>roundBuff</name></name> <operator>=</operator> <name>kNullRoundBuff</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mtctx</name><operator>-&gt;</operator><name>factory</name></name> <operator>|</operator> <operator>!</operator><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name></name> <operator>|</operator> <operator>!</operator><name><name>mtctx</name><operator>-&gt;</operator><name>bufPool</name></name> <operator>|</operator> <operator>!</operator><name><name>mtctx</name><operator>-&gt;</operator><name>cctxPool</name></name> <operator>|</operator> <operator>!</operator><name><name>mtctx</name><operator>-&gt;</operator><name>seqPool</name></name> <operator>|</operator> <name>initError</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>ZSTDMT_freeCCtx</name><argument_list>(<argument><expr><name>mtctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"mt_cctx created, for %u threads"</literal></expr></argument>, <argument><expr><name>nbWorkers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>mtctx</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ZSTDMT_CCtx</name><modifier>*</modifier></type> <name>ZSTDMT_createCCtx_advanced</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>nbWorkers</name></decl></parameter>, <parameter><decl><type><name>ZSTD_customMem</name></type> <name>cMem</name></decl></parameter>, <parameter><decl><type><name>ZSTD_threadPool</name><modifier>*</modifier></type> <name>pool</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ZSTD_MULTITHREAD</name></cpp:ifdef>
    <return>return <expr><call><name>ZSTDMT_createCCtx_advanced_internal</name><argument_list>(<argument><expr><name>nbWorkers</name></expr></argument>, <argument><expr><name>cMem</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>nbWorkers</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>cMem</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pool</name></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<comment type="block">/* ZSTDMT_releaseAllJobResources() :
 * note : ensure all workers are killed first ! */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTDMT_releaseAllJobResources</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_CCtx</name><modifier>*</modifier></type> <name>mtctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>jobID</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_releaseAllJobResources"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>jobID</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>jobID</name> <operator>&lt;=</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>jobIDMask</name></name></expr>;</condition> <incr><expr><name>jobID</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <comment type="block">/* Copy the mutex/cond out */</comment>
        <decl_stmt><decl><type><name>ZSTD_pthread_mutex_t</name> <specifier>const</specifier></type> <name>mutex</name> <init>= <expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name><operator>.</operator><name>job_mutex</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ZSTD_pthread_cond_t</name> <specifier>const</specifier></type> <name>cond</name> <init>= <expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name><operator>.</operator><name>job_cond</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"job%02u: release dst address %08X"</literal></expr></argument>, <argument><expr><name>jobID</name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>size_t</name><operator>)</operator><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name><operator>.</operator><name><name>dstBuff</name><operator>.</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTDMT_releaseBuffer</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>bufPool</name></name></expr></argument>, <argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name><operator>.</operator><name>dstBuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Clear the job description, but keep the mutex/cond */</comment>
        <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name><operator>.</operator><name>job_mutex</name> <operator>=</operator> <name>mutex</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name><operator>.</operator><name>job_cond</name> <operator>=</operator> <name>cond</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>buffer</name></name> <operator>=</operator> <name>g_nullBuffer</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>filled</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>allJobsCompleted</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTDMT_waitForAllJobsCompleted</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_CCtx</name><modifier>*</modifier></type> <name>mtctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_waitForAllJobsCompleted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name><name>mtctx</name><operator>-&gt;</operator><name>doneJobID</name></name> <operator>&lt;</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>nextJobID</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>jobID</name> <init>= <expr><name><name>mtctx</name><operator>-&gt;</operator><name>doneJobID</name></name> <operator>&amp;</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>jobIDMask</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ZSTD_PTHREAD_MUTEX_LOCK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name><operator>.</operator><name>job_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name><operator>.</operator><name>consumed</name> <operator>&lt;</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name><operator>.</operator><name><name>src</name><operator>.</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"waiting for jobCompleted signal from job %u"</literal></expr></argument>, <argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>doneJobID</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* we want to block when waiting for data to flush */</comment>
            <expr_stmt><expr><call><name>ZSTD_pthread_cond_wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name><operator>.</operator><name>job_cond</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name><operator>.</operator><name>job_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>ZSTD_pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name><operator>.</operator><name>job_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>doneJobID</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTDMT_freeCCtx</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_CCtx</name><modifier>*</modifier></type> <name>mtctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>mtctx</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* compatible with free on NULL */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mtctx</name><operator>-&gt;</operator><name>providedFactory</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>POOL_free</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>factory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>   <comment type="block">/* stop and free worker threads */</comment>
    <expr_stmt><expr><call><name>ZSTDMT_releaseAllJobResources</name><argument_list>(<argument><expr><name>mtctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* release job resources into pools first */</comment>
    <expr_stmt><expr><call><name>ZSTDMT_freeJobsTable</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name></name></expr></argument>, <argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobIDMask</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>cMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTDMT_freeBufferPool</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>bufPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTDMT_freeCCtxPool</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>cctxPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTDMT_freeSeqPool</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>seqPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTDMT_serialState_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mtctx</name><operator>-&gt;</operator><name>serial</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_freeCDict</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>cdictLocal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>mtctx</name><operator>-&gt;</operator><name>roundBuff</name><operator>.</operator><name>buffer</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ZSTD_customFree</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>roundBuff</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>cMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>ZSTD_customFree</name><argument_list>(<argument><expr><name>mtctx</name></expr></argument>, <argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>cMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTDMT_sizeof_CCtx</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_CCtx</name><modifier>*</modifier></type> <name>mtctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>mtctx</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* supports sizeof NULL */</comment>
    <return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>mtctx</name></expr></argument>)</argument_list></sizeof>
            <operator>+</operator> <call><name>POOL_sizeof</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>factory</name></name></expr></argument>)</argument_list></call>
            <operator>+</operator> <call><name>ZSTDMT_sizeof_bufferPool</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>bufPool</name></name></expr></argument>)</argument_list></call>
            <operator>+</operator> <operator>(</operator><name><name>mtctx</name><operator>-&gt;</operator><name>jobIDMask</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ZSTDMT_jobDescription</name></expr></argument>)</argument_list></sizeof>
            <operator>+</operator> <call><name>ZSTDMT_sizeof_CCtxPool</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>cctxPool</name></name></expr></argument>)</argument_list></call>
            <operator>+</operator> <call><name>ZSTDMT_sizeof_seqPool</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>seqPool</name></name></expr></argument>)</argument_list></call>
            <operator>+</operator> <call><name>ZSTD_sizeof_CDict</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>cdictLocal</name></name></expr></argument>)</argument_list></call>
            <operator>+</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>roundBuff</name><operator>.</operator><name>capacity</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ZSTDMT_resize() :
 * @return : error code if fails, 0 on success */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTDMT_resize</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_CCtx</name><modifier>*</modifier></type> <name>mtctx</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>nbWorkers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>POOL_resize</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>factory</name></name></expr></argument>, <argument><expr><name>nbWorkers</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>memory_allocation</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTDMT_expandJobsTable</name><argument_list>(<argument><expr><name>mtctx</name></expr></argument>, <argument><expr><name>nbWorkers</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>bufPool</name></name> <operator>=</operator> <call><name>ZSTDMT_expandBufferPool</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>bufPool</name></name></expr></argument>, <argument><expr><call><name>BUF_POOL_MAX_NB_BUFFERS</name><argument_list>(<argument><expr><name>nbWorkers</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>mtctx</name><operator>-&gt;</operator><name>bufPool</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>memory_allocation</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>cctxPool</name></name> <operator>=</operator> <call><name>ZSTDMT_expandCCtxPool</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>cctxPool</name></name></expr></argument>, <argument><expr><name>nbWorkers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>mtctx</name><operator>-&gt;</operator><name>cctxPool</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>memory_allocation</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>seqPool</name></name> <operator>=</operator> <call><name>ZSTDMT_expandSeqPool</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>seqPool</name></name></expr></argument>, <argument><expr><name>nbWorkers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>mtctx</name><operator>-&gt;</operator><name>seqPool</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>memory_allocation</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>ZSTDMT_CCtxParam_setNbWorkers</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mtctx</name><operator>-&gt;</operator><name>params</name></name></expr></argument>, <argument><expr><name>nbWorkers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*! ZSTDMT_updateCParams_whileCompressing() :
 *  Updates a selected set of compression parameters, remaining compatible with currently active frame.
 *  New parameters will be applied to next compression job. */</comment>
<function><type><name>void</name></type> <name>ZSTDMT_updateCParams_whileCompressing</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_CCtx</name><modifier>*</modifier></type> <name>mtctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>cctxParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>saved_wlog</name> <init>= <expr><name><name>mtctx</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>cParams</name><operator>.</operator><name>windowLog</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Do not modify windowLog while compressing */</comment>
    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>compressionLevel</name> <init>= <expr><name><name>cctxParams</name><operator>-&gt;</operator><name>compressionLevel</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_updateCParams_whileCompressing (level:%i)"</literal></expr></argument>,
                <argument><expr><name>compressionLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>compressionLevel</name></name> <operator>=</operator> <name>compressionLevel</name></expr>;</expr_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>ZSTD_compressionParameters</name></type> <name>cParams</name> <init>= <expr><call><name>ZSTD_getCParamsFromCCtxParams</name><argument_list>(<argument><expr><name>cctxParams</name></expr></argument>, <argument><expr><name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ZSTD_cpm_noAttachDict</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>cParams</name><operator>.</operator><name>windowLog</name></name> <operator>=</operator> <name>saved_wlog</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>cParams</name></name> <operator>=</operator> <name>cParams</name></expr>;</expr_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/* ZSTDMT_getFrameProgression():
 * tells how much data has been consumed (input) and produced (output) for current frame.
 * able to count progression inside worker threads.
 * Note : mutex will be acquired during statistics collection inside workers. */</comment>
<function><type><name>ZSTD_frameProgression</name></type> <name>ZSTDMT_getFrameProgression</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_CCtx</name><modifier>*</modifier></type> <name>mtctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_frameProgression</name></type> <name>fps</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_getFrameProgression"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fps</name><operator>.</operator><name>ingested</name></name> <operator>=</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>consumed</name></name> <operator>+</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>filled</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fps</name><operator>.</operator><name>consumed</name></name> <operator>=</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>consumed</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fps</name><operator>.</operator><name>produced</name></name> <operator>=</operator> <name><name>fps</name><operator>.</operator><name>flushed</name></name> <operator>=</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>produced</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fps</name><operator>.</operator><name>currentJobID</name></name> <operator>=</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>nextJobID</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fps</name><operator>.</operator><name>nbActiveWorkers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>unsigned</name></type> <name>jobNb</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name></type> <name>lastJobNb</name> <init>= <expr><name><name>mtctx</name><operator>-&gt;</operator><name>nextJobID</name></name> <operator>+</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>jobReady</name></name></expr></init></decl>;</decl_stmt> <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobReady</name></name> <operator>&lt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <macro><name>DEBUGLOG</name><argument_list>(<argument><literal type="number">6</literal></argument>, <argument><literal type="string">"ZSTDMT_getFrameProgression: jobs: from %u to &lt;%u (jobReady:%u)"</literal></argument>,
                    <argument>mtctx-&gt;doneJobID</argument>, <argument>lastJobNb</argument>, <argument>mtctx-&gt;jobReady</argument>)</argument_list></macro>
        <for>for <control>(<init><expr><name>jobNb</name> <operator>=</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>doneJobID</name></name></expr> ;</init> <condition><expr><name>jobNb</name> <operator>&lt;</operator> <name>lastJobNb</name></expr> ;</condition> <incr><expr><name>jobNb</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>wJobID</name> <init>= <expr><name>jobNb</name> <operator>&amp;</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>jobIDMask</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ZSTDMT_jobDescription</name><modifier>*</modifier></type> <name>jobPtr</name> <init>= <expr><operator>&amp;</operator><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ZSTD_pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>jobPtr</name><operator>-&gt;</operator><name>job_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>cResult</name> <init>= <expr><name><name>jobPtr</name><operator>-&gt;</operator><name>cSize</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>produced</name> <init>= <expr><ternary><condition><expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>cResult</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>cResult</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>flushed</name> <init>= <expr><ternary><condition><expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>cResult</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>jobPtr</name><operator>-&gt;</operator><name>dstFlushed</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>flushed</name> <operator>&lt;=</operator> <name>produced</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>fps</name><operator>.</operator><name>ingested</name></name> <operator>+=</operator> <name><name>jobPtr</name><operator>-&gt;</operator><name>src</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>fps</name><operator>.</operator><name>consumed</name></name> <operator>+=</operator> <name><name>jobPtr</name><operator>-&gt;</operator><name>consumed</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>fps</name><operator>.</operator><name>produced</name></name> <operator>+=</operator> <name>produced</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>fps</name><operator>.</operator><name>flushed</name></name>  <operator>+=</operator> <name>flushed</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>fps</name><operator>.</operator><name>nbActiveWorkers</name></name> <operator>+=</operator> <operator>(</operator><name><name>jobPtr</name><operator>-&gt;</operator><name>consumed</name></name> <operator>&lt;</operator> <name><name>jobPtr</name><operator>-&gt;</operator><name>src</name><operator>.</operator><name>size</name></name><operator>)</operator></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>ZSTD_pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>job_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block>
    <return>return <expr><name>fps</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>size_t</name></type> <name>ZSTDMT_toFlushNow</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_CCtx</name><modifier>*</modifier></type> <name>mtctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>toFlush</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>jobID</name> <init>= <expr><name><name>mtctx</name><operator>-&gt;</operator><name>doneJobID</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>jobID</name> <operator>&lt;=</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>nextJobID</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>jobID</name> <operator>==</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>nextJobID</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* no active job =&gt; nothing to flush */</comment>

    <comment type="block">/* look into oldest non-fully-flushed job */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>wJobID</name> <init>= <expr><name>jobID</name> <operator>&amp;</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>jobIDMask</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ZSTDMT_jobDescription</name><modifier>*</modifier> <specifier>const</specifier></type> <name>jobPtr</name> <init>= <expr><operator>&amp;</operator><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ZSTD_pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>jobPtr</name><operator>-&gt;</operator><name>job_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>cResult</name> <init>= <expr><name><name>jobPtr</name><operator>-&gt;</operator><name>cSize</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>produced</name> <init>= <expr><ternary><condition><expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>cResult</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>cResult</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>flushed</name> <init>= <expr><ternary><condition><expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>cResult</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>jobPtr</name><operator>-&gt;</operator><name>dstFlushed</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>flushed</name> <operator>&lt;=</operator> <name>produced</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>jobPtr</name><operator>-&gt;</operator><name>consumed</name></name> <operator>&lt;=</operator> <name><name>jobPtr</name><operator>-&gt;</operator><name>src</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>toFlush</name> <operator>=</operator> <name>produced</name> <operator>-</operator> <name>flushed</name></expr>;</expr_stmt>
            <comment type="block">/* if toFlush==0, nothing is available to flush.
             * However, jobID is expected to still be active:
             * if jobID was already completed and fully flushed,
             * ZSTDMT_flushProduced() should have already moved onto next job.
             * Therefore, some input has not yet been consumed. */</comment>
            <if_stmt><if>if <condition>(<expr><name>toFlush</name><operator>==</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>jobPtr</name><operator>-&gt;</operator><name>consumed</name></name> <operator>&lt;</operator> <name><name>jobPtr</name><operator>-&gt;</operator><name>src</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>ZSTD_pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>job_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><name>toFlush</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ------------------------------------------ */</comment>
<comment type="block">/* =====   Multi-threaded compression   ===== */</comment>
<comment type="block">/* ------------------------------------------ */</comment>

<function><type><specifier>static</specifier> <name>unsigned</name></type> <name>ZSTDMT_computeTargetJobLog</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>jobLog</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>ldmParams</name><operator>.</operator><name>enableLdm</name></name> <operator>==</operator> <name>ZSTD_ps_enable</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* In Long Range Mode, the windowLog is typically oversized.
         * In which case, it's preferable to determine the jobSize
         * based on cycleLog instead. */</comment>
        <expr_stmt><expr><name>jobLog</name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><literal type="number">21</literal></expr></argument>, <argument><expr><call><name>ZSTD_cycleLog</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>chainLog</name></name></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>strategy</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>jobLog</name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><literal type="number">20</literal></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>windowLog</name></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><call><name>MIN</name><argument_list>(<argument><expr><name>jobLog</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>ZSTDMT_JOBLOG_MAX</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ZSTDMT_overlapLog_default</name><parameter_list>(<parameter><decl><type><name>ZSTD_strategy</name></type> <name>strat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch<condition>(<expr><name>strat</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>ZSTD_btultra2</name></expr>:</case>
            <return>return <expr><literal type="number">9</literal></expr>;</return>
        <case>case <expr><name>ZSTD_btultra</name></expr>:</case>
        <case>case <expr><name>ZSTD_btopt</name></expr>:</case>
            <return>return <expr><literal type="number">8</literal></expr>;</return>
        <case>case <expr><name>ZSTD_btlazy2</name></expr>:</case>
        <case>case <expr><name>ZSTD_lazy2</name></expr>:</case>
            <return>return <expr><literal type="number">7</literal></expr>;</return>
        <case>case <expr><name>ZSTD_lazy</name></expr>:</case>
        <case>case <expr><name>ZSTD_greedy</name></expr>:</case>
        <case>case <expr><name>ZSTD_dfast</name></expr>:</case>
        <case>case <expr><name>ZSTD_fast</name></expr>:</case>
        <default>default:</default><empty_stmt>;</empty_stmt>
    </block_content>}</block></switch>
    <return>return <expr><literal type="number">6</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ZSTDMT_overlapLog</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>ovlog</name></decl></parameter>, <parameter><decl><type><name>ZSTD_strategy</name></type> <name>strat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>ovlog</name> <operator>&amp;&amp;</operator> <name>ovlog</name> <operator>&lt;=</operator> <literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ovlog</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ZSTDMT_overlapLog_default</name><argument_list>(<argument><expr><name>strat</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name>ovlog</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTDMT_computeOverlapSize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>overlapRLog</name> <init>= <expr><literal type="number">9</literal> <operator>-</operator> <call><name>ZSTDMT_overlapLog</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>overlapLog</name></name></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ovLog</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>overlapRLog</name> <operator>&gt;=</operator> <literal type="number">8</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>windowLog</name></name> <operator>-</operator> <name>overlapRLog</name><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>overlapRLog</name> <operator>&amp;&amp;</operator> <name>overlapRLog</name> <operator>&lt;=</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>ldmParams</name><operator>.</operator><name>enableLdm</name></name> <operator>==</operator> <name>ZSTD_ps_enable</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* In Long Range Mode, the windowLog is typically oversized.
         * In which case, it's preferable to determine the jobSize
         * based on chainLog instead.
         * Then, ovLog becomes a fraction of the jobSize, rather than windowSize */</comment>
        <expr_stmt><expr><name>ovLog</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>windowLog</name></name></expr></argument>, <argument><expr><call><name>ZSTDMT_computeTargetJobLog</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call>
                <operator>-</operator> <name>overlapRLog</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>ovLog</name> <operator>&amp;&amp;</operator> <name>ovLog</name> <operator>&lt;=</operator> <name>ZSTD_WINDOWLOG_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"overlapLog : %i"</literal></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>overlapLog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"overlap size : %i"</literal></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>ovLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><ternary><condition><expr><operator>(</operator><name>ovLog</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>ovLog</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ====================================== */</comment>
<comment type="block">/* =======      Streaming API     ======= */</comment>
<comment type="block">/* ====================================== */</comment>

<function><type><name>size_t</name></type> <name>ZSTDMT_initCStream_internal</name><parameter_list>(
        <parameter><decl><type><name>ZSTDMT_CCtx</name><modifier>*</modifier></type> <name>mtctx</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>, <parameter><decl><type><name>ZSTD_dictContentType_e</name></type> <name>dictContentType</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CDict</name><modifier>*</modifier></type> <name>cdict</name></decl></parameter>, <parameter><decl><type><name>ZSTD_CCtx_params</name></type> <name>params</name></decl></parameter>,
        <parameter><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>pledgedSrcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_initCStream_internal (pledgedSrcSize=%u, nbWorkers=%u, cctxPool=%u)"</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>pledgedSrcSize</name></expr></argument>, <argument><expr><name><name>params</name><operator>.</operator><name>nbWorkers</name></name></expr></argument>, <argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>cctxPool</name><operator>-&gt;</operator><name>totalCCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* params supposed partially fully validated at this point */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ZSTD_isError</name><argument_list>(<argument><expr><call><name>ZSTD_checkCParams</name><argument_list>(<argument><expr><name><name>params</name><operator>.</operator><name>cParams</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><operator>(</operator><name>dict</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>cdict</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* either dict or cdict, not both */</comment>

    <comment type="block">/* init */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>.</operator><name>nbWorkers</name></name> <operator>!=</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>nbWorkers</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTDMT_resize</name><argument_list>(<argument><expr><name>mtctx</name></expr></argument>, <argument><expr><name><name>params</name><operator>.</operator><name>nbWorkers</name></name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>.</operator><name>jobSize</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>params</name><operator>.</operator><name>jobSize</name></name> <operator>&lt;</operator> <name>ZSTDMT_JOBSIZE_MIN</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>params</name><operator>.</operator><name>jobSize</name></name> <operator>=</operator> <name>ZSTDMT_JOBSIZE_MIN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>.</operator><name>jobSize</name></name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>ZSTDMT_JOBSIZE_MAX</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>params</name><operator>.</operator><name>jobSize</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>ZSTDMT_JOBSIZE_MAX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_initCStream_internal: %u workers"</literal></expr></argument>, <argument><expr><name><name>params</name><operator>.</operator><name>nbWorkers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>mtctx</name><operator>-&gt;</operator><name>allJobsCompleted</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>   <comment type="block">/* previous compression not correctly finished */</comment>
        <expr_stmt><expr><call><name>ZSTDMT_waitForAllJobsCompleted</name><argument_list>(<argument><expr><name>mtctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTDMT_releaseAllJobResources</name><argument_list>(<argument><expr><name>mtctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>allJobsCompleted</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>params</name></name> <operator>=</operator> <name>params</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>frameContentSize</name></name> <operator>=</operator> <name>pledgedSrcSize</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>dict</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>ZSTD_freeCDict</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>cdictLocal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>cdictLocal</name></name> <operator>=</operator> <call><name>ZSTD_createCDict_advanced</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>,
                                                    <argument><expr><name>ZSTD_dlm_byCopy</name></expr></argument>, <argument><expr><name>dictContentType</name></expr></argument>, <comment type="block">/* note : a loadPrefix becomes an internal CDict */</comment>
                                                    <argument><expr><name><name>params</name><operator>.</operator><name>cParams</name></name></expr></argument>, <argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>cMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>cdict</name></name> <operator>=</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>cdictLocal</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>mtctx</name><operator>-&gt;</operator><name>cdictLocal</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>memory_allocation</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>ZSTD_freeCDict</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>cdictLocal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>cdictLocal</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>cdict</name></name> <operator>=</operator> <name>cdict</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>targetPrefixSize</name></name> <operator>=</operator> <call><name>ZSTDMT_computeOverlapSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"overlapLog=%i =&gt; %u KB"</literal></expr></argument>, <argument><expr><name><name>params</name><operator>.</operator><name>overlapLog</name></name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name><name>mtctx</name><operator>-&gt;</operator><name>targetPrefixSize</name></name><operator>&gt;&gt;</operator><literal type="number">10</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>targetSectionSize</name></name> <operator>=</operator> <name><name>params</name><operator>.</operator><name>jobSize</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>mtctx</name><operator>-&gt;</operator><name>targetSectionSize</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>targetSectionSize</name></name> <operator>=</operator> <literal type="number">1ULL</literal> <operator>&lt;&lt;</operator> <call><name>ZSTDMT_computeTargetJobLog</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>targetSectionSize</name></name> <operator>&lt;=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>ZSTDMT_JOBSIZE_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>.</operator><name>rsyncable</name></name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Aim for the targetsectionSize as the average job size. */</comment>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>jobSizeKB</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name><name>mtctx</name><operator>-&gt;</operator><name>targetSectionSize</name></name> <operator>&gt;&gt;</operator> <literal type="number">10</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>rsyncBits</name> <init>= <expr><operator>(</operator><call><name>assert</name><argument_list>(<argument><expr><name>jobSizeKB</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call>, <call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><name>jobSizeKB</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">10</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
        <comment type="block">/* We refuse to create jobs &lt; RSYNC_MIN_BLOCK_SIZE bytes, so make sure our
         * expected job size is at least 4x larger. */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rsyncBits</name> <operator>&gt;=</operator> <name>RSYNC_MIN_BLOCK_LOG</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"rsyncLog = %u"</literal></expr></argument>, <argument><expr><name>rsyncBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>rsync</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>rsync</name><operator>.</operator><name>hitMask</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1ULL</literal> <operator>&lt;&lt;</operator> <name>rsyncBits</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>rsync</name><operator>.</operator><name>primePower</name></name> <operator>=</operator> <call><name>ZSTD_rollingHash_primePower</name><argument_list>(<argument><expr><name>RSYNC_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>mtctx</name><operator>-&gt;</operator><name>targetSectionSize</name></name> <operator>&lt;</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>targetPrefixSize</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>targetSectionSize</name></name> <operator>=</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>targetPrefixSize</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* job size must be &gt;= overlap size */</comment>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"Job Size : %u KB (note : set to %u)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name><name>mtctx</name><operator>-&gt;</operator><name>targetSectionSize</name></name><operator>&gt;&gt;</operator><literal type="number">10</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>params</name><operator>.</operator><name>jobSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"inBuff Size : %u KB"</literal></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name><name>mtctx</name><operator>-&gt;</operator><name>targetSectionSize</name></name><operator>&gt;&gt;</operator><literal type="number">10</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTDMT_setBufferSize</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>bufPool</name></name></expr></argument>, <argument><expr><call><name>ZSTD_compressBound</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>targetSectionSize</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <comment type="block">/* If ldm is enabled we need windowSize space. */</comment>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>windowSize</name> <init>= <expr><ternary><condition><expr><name><name>mtctx</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>ldmParams</name><operator>.</operator><name>enableLdm</name></name> <operator>==</operator> <name>ZSTD_ps_enable</name></expr> ?</condition><then> <expr><operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>cParams</name><operator>.</operator><name>windowLog</name></name><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <comment type="block">/* Two buffers of slack, plus extra space for the overlap
         * This is the minimum slack that LDM works with. One extra because
         * flush might waste up to targetSectionSize-1 bytes. Another extra
         * for the overlap (if &gt; 0), then one to fill which doesn't overlap
         * with the LDM window.
         */</comment>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>nbSlackBuffers</name> <init>= <expr><literal type="number">2</literal> <operator>+</operator> <operator>(</operator><name><name>mtctx</name><operator>-&gt;</operator><name>targetPrefixSize</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>slackSize</name> <init>= <expr><name><name>mtctx</name><operator>-&gt;</operator><name>targetSectionSize</name></name> <operator>*</operator> <name>nbSlackBuffers</name></expr></init></decl>;</decl_stmt>
        <comment type="block">/* Compute the total size, and always have enough slack */</comment>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>nbWorkers</name> <init>= <expr><call><name>MAX</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>nbWorkers</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>sectionsSize</name> <init>= <expr><name><name>mtctx</name><operator>-&gt;</operator><name>targetSectionSize</name></name> <operator>*</operator> <name>nbWorkers</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>capacity</name> <init>= <expr><call><name>MAX</name><argument_list>(<argument><expr><name>windowSize</name></expr></argument>, <argument><expr><name>sectionsSize</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>slackSize</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>mtctx</name><operator>-&gt;</operator><name>roundBuff</name><operator>.</operator><name>capacity</name></name> <operator>&lt;</operator> <name>capacity</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>mtctx</name><operator>-&gt;</operator><name>roundBuff</name><operator>.</operator><name>buffer</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ZSTD_customFree</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>roundBuff</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>cMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>roundBuff</name><operator>.</operator><name>buffer</name></name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><call><name>ZSTD_customMalloc</name><argument_list>(<argument><expr><name>capacity</name></expr></argument>, <argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>cMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>mtctx</name><operator>-&gt;</operator><name>roundBuff</name><operator>.</operator><name>buffer</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>roundBuff</name><operator>.</operator><name>capacity</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>memory_allocation</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>roundBuff</name><operator>.</operator><name>capacity</name></name> <operator>=</operator> <name>capacity</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"roundBuff capacity : %u KB"</literal></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name><name>mtctx</name><operator>-&gt;</operator><name>roundBuff</name><operator>.</operator><name>capacity</name></name><operator>&gt;&gt;</operator><literal type="number">10</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>roundBuff</name><operator>.</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>buffer</name></name> <operator>=</operator> <name>g_nullBuffer</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>filled</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>prefix</name></name> <operator>=</operator> <name>kNullRange</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>doneJobID</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>nextJobID</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>frameEnded</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>allJobsCompleted</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>consumed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>produced</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ZSTDMT_serialState_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mtctx</name><operator>-&gt;</operator><name>serial</name></name></expr></argument>, <argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>seqPool</name></name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>targetSectionSize</name></name></expr></argument>,
                                 <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>, <argument><expr><name>dictContentType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>memory_allocation</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ZSTDMT_writeLastEmptyBlock()
 * Write a single empty block with an end-of-frame to finish a frame.
 * Job must be created from streaming variant.
 * This function is always successful if expected conditions are fulfilled.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTDMT_writeLastEmptyBlock</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_jobDescription</name><modifier>*</modifier></type> <name>job</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>lastJob</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>src</name><operator>.</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* last job is empty -&gt; will be simplified into a last empty block */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>firstJob</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* cannot be first job, as it also needs to create frame header */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>dstBuff</name><operator>.</operator><name>start</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* invoked from streaming variant only (otherwise, dstBuff might be user's output) */</comment>
    <expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>dstBuff</name></name> <operator>=</operator> <call><name>ZSTDMT_getBuffer</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>bufPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>job</name><operator>-&gt;</operator><name>dstBuff</name><operator>.</operator><name>start</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>cSize</name></name> <operator>=</operator> <call><name>ERROR</name><argument_list>(<argument><expr><name>memory_allocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>dstBuff</name><operator>.</operator><name>capacity</name></name> <operator>&gt;=</operator> <name>ZSTD_blockHeaderSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* no buffer should ever be that small */</comment>
    <expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>src</name></name> <operator>=</operator> <name>kNullRange</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>cSize</name></name> <operator>=</operator> <call><name>ZSTD_writeLastEmptyBlock</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>dstBuff</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name><name>job</name><operator>-&gt;</operator><name>dstBuff</name><operator>.</operator><name>capacity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>cSize</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>consumed</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTDMT_createCompressionJob</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_CCtx</name><modifier>*</modifier></type> <name>mtctx</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>ZSTD_EndDirective</name></type> <name>endOp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>jobID</name> <init>= <expr><name><name>mtctx</name><operator>-&gt;</operator><name>nextJobID</name></name> <operator>&amp;</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>jobIDMask</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>endFrame</name> <init>= <expr><operator>(</operator><name>endOp</name> <operator>==</operator> <name>ZSTD_e_end</name><operator>)</operator></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>mtctx</name><operator>-&gt;</operator><name>nextJobID</name></name> <operator>&gt;</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>doneJobID</name></name> <operator>+</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>jobIDMask</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_createCompressionJob: will not create new job : table is full"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>mtctx</name><operator>-&gt;</operator><name>nextJobID</name></name> <operator>&amp;</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>jobIDMask</name></name><operator>)</operator> <operator>==</operator> <operator>(</operator><name><name>mtctx</name><operator>-&gt;</operator><name>doneJobID</name></name> <operator>&amp;</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>jobIDMask</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mtctx</name><operator>-&gt;</operator><name>jobReady</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name> <init>= <expr><operator>(</operator><name>BYTE</name> <specifier>const</specifier><operator>*</operator><operator>)</operator><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>buffer</name><operator>.</operator><name>start</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_createCompressionJob: preparing job %u to compress %u bytes with %u preload "</literal></expr></argument>,
                    <argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>nextJobID</name></name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>srcSize</name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>prefix</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name><operator>.</operator><name><name>src</name><operator>.</operator><name>start</name></name> <operator>=</operator> <name>src</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name><operator>.</operator><name><name>src</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>srcSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>filled</name></name> <operator>&gt;=</operator> <name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name><operator>.</operator><name>prefix</name> <operator>=</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>prefix</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name><operator>.</operator><name>consumed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name><operator>.</operator><name>cSize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name><operator>.</operator><name>params</name> <operator>=</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>params</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name><operator>.</operator><name>cdict</name> <operator>=</operator> <ternary><condition><expr><name><name>mtctx</name><operator>-&gt;</operator><name>nextJobID</name></name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>mtctx</name><operator>-&gt;</operator><name>cdict</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name><operator>.</operator><name>fullFrameSize</name> <operator>=</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>frameContentSize</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name><operator>.</operator><name>dstBuff</name> <operator>=</operator> <name>g_nullBuffer</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name><operator>.</operator><name>cctxPool</name> <operator>=</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>cctxPool</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name><operator>.</operator><name>bufPool</name> <operator>=</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>bufPool</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name><operator>.</operator><name>seqPool</name> <operator>=</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>seqPool</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name><operator>.</operator><name>serial</name> <operator>=</operator> <operator>&amp;</operator><name><name>mtctx</name><operator>-&gt;</operator><name>serial</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name><operator>.</operator><name>jobID</name> <operator>=</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>nextJobID</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name><operator>.</operator><name>firstJob</name> <operator>=</operator> <operator>(</operator><name><name>mtctx</name><operator>-&gt;</operator><name>nextJobID</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name><operator>.</operator><name>lastJob</name> <operator>=</operator> <name>endFrame</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name><operator>.</operator><name>frameChecksumNeeded</name> <operator>=</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>fParams</name><operator>.</operator><name>checksumFlag</name></name> <operator>&amp;&amp;</operator> <name>endFrame</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mtctx</name><operator>-&gt;</operator><name>nextJobID</name></name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name><operator>.</operator><name>dstFlushed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <comment type="block">/* Update the round buffer pos and clear the input buffer to be reset */</comment>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>roundBuff</name><operator>.</operator><name>pos</name></name> <operator>+=</operator> <name>srcSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>buffer</name></name> <operator>=</operator> <name>g_nullBuffer</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>filled</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <comment type="block">/* Set the prefix */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>endFrame</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>newPrefixSize</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>targetPrefixSize</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>prefix</name><operator>.</operator><name>start</name></name> <operator>=</operator> <name>src</name> <operator>+</operator> <name>srcSize</name> <operator>-</operator> <name>newPrefixSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>prefix</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>newPrefixSize</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>   <comment type="block">/* endFrame==1 =&gt; no need for another input buffer */</comment>
            <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>prefix</name></name> <operator>=</operator> <name>kNullRange</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>frameEnded</name></name> <operator>=</operator> <name>endFrame</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>mtctx</name><operator>-&gt;</operator><name>nextJobID</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <comment type="block">/* single job exception : checksum is already calculated directly within worker thread */</comment>
                <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>fParams</name><operator>.</operator><name>checksumFlag</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>   </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>( <expr><operator>(</operator><name>srcSize</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator>
          <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mtctx</name><operator>-&gt;</operator><name>nextJobID</name></name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator></expr><comment type="block">/*single job must also write frame header*/</comment> )</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_createCompressionJob: creating a last empty block to end frame"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>endOp</name> <operator>==</operator> <name>ZSTD_e_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* only possible case : need to end the frame with an empty last block */</comment>
            <expr_stmt><expr><call><name>ZSTDMT_writeLastEmptyBlock</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name></name> <operator>+</operator> <name>jobID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>nextJobID</name></name><operator>++</operator></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_createCompressionJob: posting job %u : %u bytes  (end:%u, jobNb == %u (mod:%u))"</literal></expr></argument>,
                <argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>nextJobID</name></name></expr></argument>,
                <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name><operator>.</operator><name><name>src</name><operator>.</operator><name>size</name></name></expr></argument>,
                <argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name><operator>.</operator><name>lastJob</name></expr></argument>,
                <argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>nextJobID</name></name></expr></argument>,
                <argument><expr><name>jobID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>POOL_tryAdd</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>factory</name></name></expr></argument>, <argument><expr><name>ZSTDMT_compressionJob</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>jobID</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>nextJobID</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobReady</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_createCompressionJob: no worker available for job %u"</literal></expr></argument>, <argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>nextJobID</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobReady</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*! ZSTDMT_flushProduced() :
 *  flush whatever data has been produced but not yet flushed in current job.
 *  move to next job if current one is fully flushed.
 * `output` : `pos` will be updated with amount of data flushed .
 * `blockToFlush` : if &gt;0, the function will block and wait if there is no data available to flush .
 * @return : amount of data remaining within internal buffer, 0 if no more, 1 if unknown but &gt; 0, or an error code */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTDMT_flushProduced</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_CCtx</name><modifier>*</modifier></type> <name>mtctx</name></decl></parameter>, <parameter><decl><type><name>ZSTD_outBuffer</name><modifier>*</modifier></type> <name>output</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>blockToFlush</name></decl></parameter>, <parameter><decl><type><name>ZSTD_EndDirective</name></type> <name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>wJobID</name> <init>= <expr><name><name>mtctx</name><operator>-&gt;</operator><name>doneJobID</name></name> <operator>&amp;</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>jobIDMask</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_flushProduced (blocking:%u , job %u &lt;= %u)"</literal></expr></argument>,
                <argument><expr><name>blockToFlush</name></expr></argument>, <argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>doneJobID</name></name></expr></argument>, <argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>nextJobID</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>output</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;=</operator> <name><name>output</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ZSTD_PTHREAD_MUTEX_LOCK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>job_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(  <expr><name>blockToFlush</name>
      <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mtctx</name><operator>-&gt;</operator><name>doneJobID</name></name> <operator>&lt;</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>nextJobID</name></name><operator>)</operator></expr> )</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>dstFlushed</name> <operator>&lt;=</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>cSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>dstFlushed</name> <operator>==</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>cSize</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* nothing to flush */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>consumed</name> <operator>==</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name><name>src</name><operator>.</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"job %u is completely consumed (%u == %u) =&gt; don't wait for cond, there will be none"</literal></expr></argument>,
                            <argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>doneJobID</name></name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>consumed</name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name><name>src</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"waiting for something to flush from job %u (currently flushed: %u bytes)"</literal></expr></argument>,
                        <argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>doneJobID</name></name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>dstFlushed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ZSTD_pthread_cond_wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>job_cond</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>job_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* block when nothing to flush but some to come */</comment>
    </block_content>}</block></while>   </block_content>}</block></if></if_stmt>

    <comment type="block">/* try to flush something */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name></type> <name>cSize</name> <init>= <expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>cSize</name></expr></init></decl>;</decl_stmt>                  <comment type="block">/* shared */</comment>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>srcConsumed</name> <init>= <expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>consumed</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* shared */</comment>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>srcSize</name> <init>= <expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name><name>src</name><operator>.</operator><name>size</name></name></expr></init></decl>;</decl_stmt>       <comment type="block">/* read-only, could be done after mutex lock, but no-declaration-after-statement */</comment>
        <expr_stmt><expr><call><name>ZSTD_pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>job_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_flushProduced: job %u : compression error detected : %s"</literal></expr></argument>,
                        <argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>doneJobID</name></name></expr></argument>, <argument><expr><call><name>ZSTD_getErrorName</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ZSTDMT_waitForAllJobsCompleted</name><argument_list>(<argument><expr><name>mtctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ZSTDMT_releaseAllJobResources</name><argument_list>(<argument><expr><name>mtctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>cSize</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* add frame checksum if necessary (can only happen once) */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>srcConsumed</name> <operator>&lt;=</operator> <name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>( <expr><operator>(</operator><name>srcConsumed</name> <operator>==</operator> <name>srcSize</name><operator>)</operator>   <comment type="block">/* job completed -&gt; worker no longer active */</comment>
          <operator>&amp;&amp;</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>frameChecksumNeeded</name></expr> )</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>checksum</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><call><name>XXH64_digest</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mtctx</name><operator>-&gt;</operator><name>serial</name><operator>.</operator><name>xxhState</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_flushProduced: writing checksum : %08X \n"</literal></expr></argument>, <argument><expr><name>checksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MEM_writeLE32</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name><name>dstBuff</name><operator>.</operator><name>start</name></name> <operator>+</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>cSize</name></expr></argument>, <argument><expr><name>checksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>cSize</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>cSize</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>  <comment type="block">/* can write this shared value, as worker is no longer active */</comment>
            <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>frameChecksumNeeded</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>cSize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>   <comment type="block">/* compression is ongoing or completed */</comment>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>toFlush</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name>cSize</name> <operator>-</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>dstFlushed</name></expr></argument>, <argument><expr><name><name>output</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name><name>output</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_flushProduced: Flushing %u bytes from job %u (completion:%u/%u, generated:%u)"</literal></expr></argument>,
                        <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>toFlush</name></expr></argument>, <argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>doneJobID</name></name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>srcConsumed</name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>srcSize</name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>cSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>doneJobID</name></name> <operator>&lt;</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>nextJobID</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>cSize</name> <operator>&gt;=</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>dstFlushed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name><name>dstBuff</name><operator>.</operator><name>start</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>toFlush</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>output</name><operator>-&gt;</operator><name>dst</name></name> <operator>+</operator> <name><name>output</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>,
                    <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name><name>dstBuff</name><operator>.</operator><name>start</name></name> <operator>+</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>dstFlushed</name></expr></argument>,
                    <argument><expr><name>toFlush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>output</name><operator>-&gt;</operator><name>pos</name></name> <operator>+=</operator> <name>toFlush</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>dstFlushed</name> <operator>+=</operator> <name>toFlush</name></expr>;</expr_stmt>  <comment type="block">/* can write : this value is only used by mtctx */</comment>

            <if_stmt><if>if <condition>( <expr><operator>(</operator><name>srcConsumed</name> <operator>==</operator> <name>srcSize</name><operator>)</operator>    <comment type="block">/* job is completed */</comment>
              <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>dstFlushed</name> <operator>==</operator> <name>cSize</name><operator>)</operator></expr> )</condition> <block>{<block_content>   <comment type="block">/* output buffer fully flushed =&gt; free this job position */</comment>
                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Job %u completed (%u bytes), moving to next one"</literal></expr></argument>,
                        <argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>doneJobID</name></name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>dstFlushed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ZSTDMT_releaseBuffer</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>bufPool</name></name></expr></argument>, <argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>dstBuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"dstBuffer released"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>dstBuff</name> <operator>=</operator> <name>g_nullBuffer</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>cSize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>   <comment type="block">/* ensure this job slot is considered "not started" in future check */</comment>
                <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>consumed</name></name> <operator>+=</operator> <name>srcSize</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>produced</name></name> <operator>+=</operator> <name>cSize</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>doneJobID</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>   </block_content>}</block></if></if_stmt>

        <comment type="block">/* return value : how many bytes left in buffer ; fake it to 1 when unknown but &gt;0 */</comment>
        <if_stmt><if>if <condition>(<expr><name>cSize</name> <operator>&gt;</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>dstFlushed</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name>cSize</name> <operator>-</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>dstFlushed</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>srcSize</name> <operator>&gt;</operator> <name>srcConsumed</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* current job not completely compressed */</comment>
    </block_content>}</block>
    <if_stmt><if>if <condition>(<expr><name><name>mtctx</name><operator>-&gt;</operator><name>doneJobID</name></name> <operator>&lt;</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>nextJobID</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* some more jobs ongoing */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobReady</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>      <comment type="block">/* one job is ready to push, just not yet in the list */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>filled</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* input is not empty, and still needs to be converted into a job */</comment>
    <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>allJobsCompleted</name></name> <operator>=</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>frameEnded</name></name></expr>;</expr_stmt>   <comment type="block">/* all jobs are entirely flushed =&gt; if this one is last one, frame is completed */</comment>
    <if_stmt><if>if <condition>(<expr><name>end</name> <operator>==</operator> <name>ZSTD_e_end</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>!</operator><name><name>mtctx</name><operator>-&gt;</operator><name>frameEnded</name></name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* for ZSTD_e_end, question becomes : is frame completed ? instead of : are internal buffers fully flushed ? */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* internal buffers fully flushed */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Returns the range of data used by the earliest job that is not yet complete.
 * If the data of the first job is broken up into two segments, we cover both
 * sections.
 */</comment>
<function><type><specifier>static</specifier> <name>range_t</name></type> <name>ZSTDMT_getInputDataInUse</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_CCtx</name><modifier>*</modifier></type> <name>mtctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>firstJobID</name> <init>= <expr><name><name>mtctx</name><operator>-&gt;</operator><name>doneJobID</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>lastJobID</name> <init>= <expr><name><name>mtctx</name><operator>-&gt;</operator><name>nextJobID</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>jobID</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>jobID</name> <operator>=</operator> <name>firstJobID</name></expr>;</init> <condition><expr><name>jobID</name> <operator>&lt;</operator> <name>lastJobID</name></expr>;</condition> <incr><expr><operator>++</operator><name>jobID</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>wJobID</name> <init>= <expr><name>jobID</name> <operator>&amp;</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>jobIDMask</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>consumed</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>ZSTD_PTHREAD_MUTEX_LOCK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>job_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>consumed</name> <operator>=</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>consumed</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>job_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>consumed</name> <operator>&lt;</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name><name>src</name><operator>.</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>range_t</name></type> <name>range</name> <init>= <expr><name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>prefix</name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>range</name><operator>.</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <comment type="block">/* Empty prefix */</comment>
                <expr_stmt><expr><name>range</name> <operator>=</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name>src</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* Job source in multiple segments not supported yet */</comment>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>range</name><operator>.</operator><name>start</name></name> <operator>&lt;=</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>jobs</name><index>[<expr><name>wJobID</name></expr>]</index></name><operator>.</operator><name><name>src</name><operator>.</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>range</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>kNullRange</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Returns non-zero iff buffer and range overlap.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ZSTDMT_isOverlapped</name><parameter_list>(<parameter><decl><type><name>buffer_t</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>range_t</name></type> <name>range</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>bufferStart</name> <init>= <expr><operator>(</operator><name>BYTE</name> <specifier>const</specifier><operator>*</operator><operator>)</operator><name><name>buffer</name><operator>.</operator><name>start</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>rangeStart</name> <init>= <expr><operator>(</operator><name>BYTE</name> <specifier>const</specifier><operator>*</operator><operator>)</operator><name><name>range</name><operator>.</operator><name>start</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>rangeStart</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>bufferStart</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <block>{<block_content>
        <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>bufferEnd</name> <init>= <expr><name>bufferStart</name> <operator>+</operator> <name><name>buffer</name><operator>.</operator><name>capacity</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>rangeEnd</name> <init>= <expr><name>rangeStart</name> <operator>+</operator> <name><name>range</name><operator>.</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Empty ranges cannot overlap */</comment>
        <if_stmt><if>if <condition>(<expr><name>bufferStart</name> <operator>==</operator> <name>bufferEnd</name> <operator>||</operator> <name>rangeStart</name> <operator>==</operator> <name>rangeEnd</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

        <return>return <expr><name>bufferStart</name> <operator>&lt;</operator> <name>rangeEnd</name> <operator>&amp;&amp;</operator> <name>rangeStart</name> <operator>&lt;</operator> <name>bufferEnd</name></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ZSTDMT_doesOverlapWindow</name><parameter_list>(<parameter><decl><type><name>buffer_t</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>ZSTD_window_t</name></type> <name>window</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>range_t</name></type> <name>extDict</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>range_t</name></type> <name>prefix</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_doesOverlapWindow"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>extDict</name><operator>.</operator><name>start</name></name> <operator>=</operator> <name><name>window</name><operator>.</operator><name>dictBase</name></name> <operator>+</operator> <name><name>window</name><operator>.</operator><name>lowLimit</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>extDict</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name><name>window</name><operator>.</operator><name>dictLimit</name></name> <operator>-</operator> <name><name>window</name><operator>.</operator><name>lowLimit</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>prefix</name><operator>.</operator><name>start</name></name> <operator>=</operator> <name><name>window</name><operator>.</operator><name>base</name></name> <operator>+</operator> <name><name>window</name><operator>.</operator><name>dictLimit</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>prefix</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name><name>window</name><operator>.</operator><name>nextSrc</name></name> <operator>-</operator> <operator>(</operator><name><name>window</name><operator>.</operator><name>base</name></name> <operator>+</operator> <name><name>window</name><operator>.</operator><name>dictLimit</name></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"extDict [0x%zx, 0x%zx)"</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>extDict</name><operator>.</operator><name>start</name></name></expr></argument>,
                <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>extDict</name><operator>.</operator><name>start</name></name> <operator>+</operator> <name><name>extDict</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"prefix  [0x%zx, 0x%zx)"</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>prefix</name><operator>.</operator><name>start</name></name></expr></argument>,
                <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>prefix</name><operator>.</operator><name>start</name></name> <operator>+</operator> <name><name>prefix</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>ZSTDMT_isOverlapped</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>extDict</name></expr></argument>)</argument_list></call>
        <operator>||</operator> <call><name>ZSTDMT_isOverlapped</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTDMT_waitForLdmComplete</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_CCtx</name><modifier>*</modifier></type> <name>mtctx</name></decl></parameter>, <parameter><decl><type><name>buffer_t</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>mtctx</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>ldmParams</name><operator>.</operator><name>enableLdm</name></name> <operator>==</operator> <name>ZSTD_ps_enable</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>ZSTD_pthread_mutex_t</name><modifier>*</modifier></type> <name>mutex</name> <init>= <expr><operator>&amp;</operator><name><name>mtctx</name><operator>-&gt;</operator><name>serial</name><operator>.</operator><name>ldmWindowMutex</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_waitForLdmComplete"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"source  [0x%zx, 0x%zx)"</literal></expr></argument>,
                    <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>buffer</name><operator>.</operator><name>start</name></name></expr></argument>,
                    <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>buffer</name><operator>.</operator><name>start</name></name> <operator>+</operator> <name><name>buffer</name><operator>.</operator><name>capacity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_PTHREAD_MUTEX_LOCK</name><argument_list>(<argument><expr><name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><call><name>ZSTDMT_doesOverlapWindow</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>serial</name><operator>.</operator><name>ldmWindow</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Waiting for LDM to finish..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ZSTD_pthread_cond_wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mtctx</name><operator>-&gt;</operator><name>serial</name><operator>.</operator><name>ldmWindowCond</name></name></expr></argument>, <argument><expr><name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"Done waiting for LDM to finish"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_pthread_mutex_unlock</name><argument_list>(<argument><expr><name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Attempts to set the inBuff to the next section to fill.
 * If any part of the new section is still in use we give up.
 * Returns non-zero if the buffer is filled.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ZSTDMT_tryGetInputRange</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_CCtx</name><modifier>*</modifier></type> <name>mtctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>range_t</name> <specifier>const</specifier></type> <name>inUse</name> <init>= <expr><call><name>ZSTDMT_getInputDataInUse</name><argument_list>(<argument><expr><name>mtctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>spaceLeft</name> <init>= <expr><name><name>mtctx</name><operator>-&gt;</operator><name>roundBuff</name><operator>.</operator><name>capacity</name></name> <operator>-</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>roundBuff</name><operator>.</operator><name>pos</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>target</name> <init>= <expr><name><name>mtctx</name><operator>-&gt;</operator><name>targetSectionSize</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>buffer_t</name></type> <name>buffer</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_tryGetInputRange"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>buffer</name><operator>.</operator><name>start</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>roundBuff</name><operator>.</operator><name>capacity</name></name> <operator>&gt;=</operator> <name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>spaceLeft</name> <operator>&lt;</operator> <name>target</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* ZSTD_invalidateRepCodes() doesn't work for extDict variants.
         * Simply copy the prefix to the beginning in that case.
         */</comment>
        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>start</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name><name>mtctx</name><operator>-&gt;</operator><name>roundBuff</name><operator>.</operator><name>buffer</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>prefixSize</name> <init>= <expr><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>prefix</name><operator>.</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>start</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>capacity</name></name> <operator>=</operator> <name>prefixSize</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ZSTDMT_isOverlapped</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>inUse</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Waiting for buffer..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>ZSTDMT_waitForLdmComplete</name><argument_list>(<argument><expr><name>mtctx</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_memmove</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>prefix</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name>prefixSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>prefix</name><operator>.</operator><name>start</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>roundBuff</name><operator>.</operator><name>pos</name></name> <operator>=</operator> <name>prefixSize</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>start</name></name> <operator>=</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>roundBuff</name><operator>.</operator><name>buffer</name></name> <operator>+</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>roundBuff</name><operator>.</operator><name>pos</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>capacity</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>ZSTDMT_isOverlapped</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>inUse</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Waiting for buffer..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ZSTDMT_isOverlapped</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ZSTDMT_waitForLdmComplete</name><argument_list>(<argument><expr><name>mtctx</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Using prefix range [%zx, %zx)"</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>prefix</name><operator>.</operator><name>start</name></name></expr></argument>,
                <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>prefix</name><operator>.</operator><name>start</name></name> <operator>+</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>prefix</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Using source range [%zx, %zx)"</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>buffer</name><operator>.</operator><name>start</name></name></expr></argument>,
                <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>buffer</name><operator>.</operator><name>start</name></name> <operator>+</operator> <name><name>buffer</name><operator>.</operator><name>capacity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


    <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>buffer</name></name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>filled</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>roundBuff</name><operator>.</operator><name>pos</name></name> <operator>+</operator> <name><name>buffer</name><operator>.</operator><name>capacity</name></name> <operator>&lt;=</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>roundBuff</name><operator>.</operator><name>capacity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <block>{
  <decl_stmt><decl><type><name>size_t</name></type> <name>toLoad</name></decl>;</decl_stmt>  <comment type="block">/* The number of bytes to load from the input. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>flush</name></decl>;</decl_stmt>      <comment type="block">/* Boolean declaring if we must flush because we found a synchronization point. */</comment>
}</block></struct></type> <name>syncPoint_t</name>;</typedef>

<comment type="block" format="doxygen">/**
 * Searches through the input for a synchronization point. If one is found, we
 * will instruct the caller to flush, and return the number of bytes to load.
 * Otherwise, we will load as many bytes as possible and instruct the caller
 * to continue as normal.
 */</comment>
<function><type><specifier>static</specifier> <name>syncPoint_t</name></type>
<name>findSynchronizationPoint</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_CCtx</name> <specifier>const</specifier><modifier>*</modifier></type> <name>mtctx</name></decl></parameter>, <parameter><decl><type><name>ZSTD_inBuffer</name> <specifier>const</specifier></type> <name>input</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>istart</name> <init>= <expr><operator>(</operator><name>BYTE</name> <specifier>const</specifier><operator>*</operator><operator>)</operator><name><name>input</name><operator>.</operator><name>src</name></name> <operator>+</operator> <name><name>input</name><operator>.</operator><name>pos</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U64</name> <specifier>const</specifier></type> <name>primePower</name> <init>= <expr><name><name>mtctx</name><operator>-&gt;</operator><name>rsync</name><operator>.</operator><name>primePower</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U64</name> <specifier>const</specifier></type> <name>hitMask</name> <init>= <expr><name><name>mtctx</name><operator>-&gt;</operator><name>rsync</name><operator>.</operator><name>hitMask</name></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>syncPoint_t</name></type> <name>syncPoint</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U64</name></type> <name>hash</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>prev</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>pos</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>syncPoint</name><operator>.</operator><name>toLoad</name></name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name><name>input</name><operator>.</operator><name>size</name></name> <operator>-</operator> <name><name>input</name><operator>.</operator><name>pos</name></name></expr></argument>, <argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>targetSectionSize</name></name> <operator>-</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>filled</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>syncPoint</name><operator>.</operator><name>flush</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mtctx</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>rsyncable</name></name></expr>)</condition><block type="pseudo"><block_content>
        <comment type="block">/* Rsync is disabled. */</comment>
        <return>return <expr><name>syncPoint</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>filled</name></name> <operator>+</operator> <name><name>input</name><operator>.</operator><name>size</name></name> <operator>-</operator> <name><name>input</name><operator>.</operator><name>pos</name></name> <operator>&lt;</operator> <name>RSYNC_MIN_BLOCK_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
        <comment type="block">/* We don't emit synchronization points if it would produce too small blocks.
         * We don't have enough input to find a synchronization point, so don't look.
         */</comment>
        <return>return <expr><name>syncPoint</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>filled</name></name> <operator>+</operator> <name><name>syncPoint</name><operator>.</operator><name>toLoad</name></name> <operator>&lt;</operator> <name>RSYNC_LENGTH</name></expr>)</condition><block type="pseudo"><block_content>
        <comment type="block">/* Not enough to compute the hash.
         * We will miss any synchronization points in this RSYNC_LENGTH byte
         * window. However, since it depends only in the internal buffers, if the
         * state is already synchronized, we will remain synchronized.
         * Additionally, the probability that we miss a synchronization point is
         * low: RSYNC_LENGTH / targetSectionSize.
         */</comment>
        <return>return <expr><name>syncPoint</name></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Initialize the loop variables. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>filled</name></name> <operator>&lt;</operator> <name>RSYNC_MIN_BLOCK_SIZE</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* We don't need to scan the first RSYNC_MIN_BLOCK_SIZE positions
         * because they can't possibly be a sync point. So we can start
         * part way through the input buffer.
         */</comment>
        <expr_stmt><expr><name>pos</name> <operator>=</operator> <name>RSYNC_MIN_BLOCK_SIZE</name> <operator>-</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>filled</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <name>RSYNC_LENGTH</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>prev</name> <operator>=</operator> <name>istart</name> <operator>+</operator> <name>pos</name> <operator>-</operator> <name>RSYNC_LENGTH</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>ZSTD_rollingHash_compute</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><name>RSYNC_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>filled</name></name> <operator>&gt;=</operator> <name>RSYNC_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>prev</name> <operator>=</operator> <operator>(</operator><name>BYTE</name> <specifier>const</specifier><operator>*</operator><operator>)</operator><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>buffer</name><operator>.</operator><name>start</name></name> <operator>+</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>filled</name></name> <operator>-</operator> <name>RSYNC_LENGTH</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>ZSTD_rollingHash_compute</name><argument_list>(<argument><expr><name>prev</name> <operator>+</operator> <name>pos</name></expr></argument>, <argument><expr><operator>(</operator><name>RSYNC_LENGTH</name> <operator>-</operator> <name>pos</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>ZSTD_rollingHash_append</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>istart</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* We have enough bytes buffered to initialize the hash,
         * and have processed enough bytes to find a sync point.
         * Start scanning at the beginning of the input.
         */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>filled</name></name> <operator>&gt;=</operator> <name>RSYNC_MIN_BLOCK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>RSYNC_MIN_BLOCK_SIZE</name> <operator>&gt;=</operator> <name>RSYNC_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>prev</name> <operator>=</operator> <operator>(</operator><name>BYTE</name> <specifier>const</specifier><operator>*</operator><operator>)</operator><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>buffer</name><operator>.</operator><name>start</name></name> <operator>+</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>filled</name></name> <operator>-</operator> <name>RSYNC_LENGTH</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>ZSTD_rollingHash_compute</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><name>RSYNC_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>hash</name> <operator>&amp;</operator> <name>hitMask</name><operator>)</operator> <operator>==</operator> <name>hitMask</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* We're already at a sync point so don't load any more until
             * we're able to flush this sync point.
             * This likely happened because the job table was full so we
             * couldn't add our job.
             */</comment>
            <expr_stmt><expr><name><name>syncPoint</name><operator>.</operator><name>toLoad</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>syncPoint</name><operator>.</operator><name>flush</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <return>return <expr><name>syncPoint</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <comment type="block">/* Starting with the hash of the previous RSYNC_LENGTH bytes, roll
     * through the input. If we hit a synchronization point, then cut the
     * job off, and tell the compressor to flush the job. Otherwise, load
     * all the bytes and continue as normal.
     * If we go too long without a synchronization point (targetSectionSize)
     * then a block will be emitted anyways, but this is okay, since if we
     * are already synchronized we will remain synchronized.
     */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pos</name> <operator>&lt;</operator> <name>RSYNC_LENGTH</name> <operator>||</operator> <call><name>ZSTD_rollingHash_compute</name><argument_list>(<argument><expr><name>istart</name> <operator>+</operator> <name>pos</name> <operator>-</operator> <name>RSYNC_LENGTH</name></expr></argument>, <argument><expr><name>RSYNC_LENGTH</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <name><name>syncPoint</name><operator>.</operator><name>toLoad</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>pos</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier></type> <name>toRemove</name> <init>= <expr><ternary><condition><expr><name>pos</name> <operator>&lt;</operator> <name>RSYNC_LENGTH</name></expr> ?</condition><then> <expr><name><name>prev</name><index>[<expr><name>pos</name></expr>]</index></name></expr> </then><else>: <expr><name><name>istart</name><index>[<expr><name>pos</name> <operator>-</operator> <name>RSYNC_LENGTH</name></expr>]</index></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <comment type="block">/* This assert is very expensive, and Debian compiles with asserts enabled.
         * So disable it for now. We can get similar coverage by checking it at the
         * beginning &amp; end of the loop.
         * assert(pos &lt; RSYNC_LENGTH || ZSTD_rollingHash_compute(istart + pos - RSYNC_LENGTH, RSYNC_LENGTH) == hash);
         */</comment>
        <expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>ZSTD_rollingHash_rotate</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>toRemove</name></expr></argument>, <argument><expr><name><name>istart</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>, <argument><expr><name>primePower</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>filled</name></name> <operator>+</operator> <name>pos</name> <operator>&gt;=</operator> <name>RSYNC_MIN_BLOCK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>hash</name> <operator>&amp;</operator> <name>hitMask</name><operator>)</operator> <operator>==</operator> <name>hitMask</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>syncPoint</name><operator>.</operator><name>toLoad</name></name> <operator>=</operator> <name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>syncPoint</name><operator>.</operator><name>flush</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>++</operator><name>pos</name></expr>;</expr_stmt> <comment type="block">/* for assert */</comment>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pos</name> <operator>&lt;</operator> <name>RSYNC_LENGTH</name> <operator>||</operator> <call><name>ZSTD_rollingHash_compute</name><argument_list>(<argument><expr><name>istart</name> <operator>+</operator> <name>pos</name> <operator>-</operator> <name>RSYNC_LENGTH</name></expr></argument>, <argument><expr><name>RSYNC_LENGTH</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>syncPoint</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTDMT_nextInputSizeHint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ZSTDMT_CCtx</name><modifier>*</modifier></type> <name>mtctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>hintInSize</name> <init>= <expr><name><name>mtctx</name><operator>-&gt;</operator><name>targetSectionSize</name></name> <operator>-</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>filled</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>hintInSize</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>hintInSize</name> <operator>=</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>targetSectionSize</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>hintInSize</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** ZSTDMT_compressStream_generic() :
 *  internal use only - exposed to be invoked from zstd_compress.c
 *  assumption : output and input are valid (pos &lt;= size)
 * @return : minimum amount of data remaining to flush, 0 if none */</comment>
<function><type><name>size_t</name></type> <name>ZSTDMT_compressStream_generic</name><parameter_list>(<parameter><decl><type><name>ZSTDMT_CCtx</name><modifier>*</modifier></type> <name>mtctx</name></decl></parameter>,
                                     <parameter><decl><type><name>ZSTD_outBuffer</name><modifier>*</modifier></type> <name>output</name></decl></parameter>,
                                     <parameter><decl><type><name>ZSTD_inBuffer</name><modifier>*</modifier></type> <name>input</name></decl></parameter>,
                                     <parameter><decl><type><name>ZSTD_EndDirective</name></type> <name>endOp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>forwardInputProgress</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_compressStream_generic (endOp=%u, srcSize=%u)"</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>endOp</name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name><name>input</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name><name>input</name><operator>-&gt;</operator><name>pos</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>output</name><operator>-&gt;</operator><name>pos</name></name> <operator>&lt;=</operator> <name><name>output</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>input</name><operator>-&gt;</operator><name>pos</name></name>  <operator>&lt;=</operator> <name><name>input</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>mtctx</name><operator>-&gt;</operator><name>frameEnded</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>endOp</name><operator>==</operator><name>ZSTD_e_continue</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <comment type="block">/* current frame being ended. Only flush/end are allowed */</comment>
        <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>stage_wrong</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* fill input buffer */</comment>
    <if_stmt><if>if <condition>( <expr><operator>(</operator><operator>!</operator><name><name>mtctx</name><operator>-&gt;</operator><name>jobReady</name></name><operator>)</operator>
      <operator>&amp;&amp;</operator> <operator>(</operator><name><name>input</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;</operator> <name><name>input</name><operator>-&gt;</operator><name>pos</name></name><operator>)</operator></expr> )</condition> <block>{<block_content>   <comment type="block">/* support NULL input */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>buffer</name><operator>.</operator><name>start</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>filled</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Can't fill an empty buffer */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ZSTDMT_tryGetInputRange</name><argument_list>(<argument><expr><name>mtctx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <comment type="block">/* It is only possible for this operation to fail if there are
                 * still compression jobs ongoing.
                 */</comment>
                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_tryGetInputRange failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>doneJobID</name></name> <operator>!=</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>nextJobID</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_tryGetInputRange completed successfully : mtctx-&gt;inBuff.buffer.start = %p"</literal></expr></argument>, <argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>buffer</name><operator>.</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>buffer</name><operator>.</operator><name>start</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>syncPoint_t</name> <specifier>const</specifier></type> <name>syncPoint</name> <init>= <expr><call><name>findSynchronizationPoint</name><argument_list>(<argument><expr><name>mtctx</name></expr></argument>, <argument><expr><operator>*</operator><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>syncPoint</name><operator>.</operator><name>flush</name></name> <operator>&amp;&amp;</operator> <name>endOp</name> <operator>==</operator> <name>ZSTD_e_continue</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>endOp</name> <operator>=</operator> <name>ZSTD_e_flush</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>buffer</name><operator>.</operator><name>capacity</name></name> <operator>&gt;=</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>targetSectionSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_compressStream_generic: adding %u bytes on top of %u to buffer of size %u"</literal></expr></argument>,
                        <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>syncPoint</name><operator>.</operator><name>toLoad</name></name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>filled</name></name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>mtctx</name><operator>-&gt;</operator><name>targetSectionSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>buffer</name><operator>.</operator><name>start</name></name> <operator>+</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>filled</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name><name>input</name><operator>-&gt;</operator><name>src</name></name> <operator>+</operator> <name><name>input</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>, <argument><expr><name><name>syncPoint</name><operator>.</operator><name>toLoad</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>input</name><operator>-&gt;</operator><name>pos</name></name> <operator>+=</operator> <name><name>syncPoint</name><operator>.</operator><name>toLoad</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>filled</name></name> <operator>+=</operator> <name><name>syncPoint</name><operator>.</operator><name>toLoad</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>forwardInputProgress</name> <operator>=</operator> <name><name>syncPoint</name><operator>.</operator><name>toLoad</name></name><operator>&gt;</operator><literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>input</name><operator>-&gt;</operator><name>pos</name></name> <operator>&lt;</operator> <name><name>input</name><operator>-&gt;</operator><name>size</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>endOp</name> <operator>==</operator> <name>ZSTD_e_end</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Can't end yet because the input is not fully consumed.
            * We are in one of these cases:
            * - mtctx-&gt;inBuff is NULL &amp; empty: we couldn't get an input buffer so don't create a new job.
            * - We filled the input buffer: flush this job but don't end the frame.
            * - We hit a synchronization point: flush this job but don't end the frame.
            */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>filled</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>filled</name></name> <operator>==</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>targetSectionSize</name></name> <operator>||</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>rsyncable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>endOp</name> <operator>=</operator> <name>ZSTD_e_flush</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>( <expr><operator>(</operator><name><name>mtctx</name><operator>-&gt;</operator><name>jobReady</name></name><operator>)</operator>
      <operator>||</operator> <operator>(</operator><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>filled</name></name> <operator>&gt;=</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>targetSectionSize</name></name><operator>)</operator>  <comment type="block">/* filled enough : let's compress */</comment>
      <operator>||</operator> <operator>(</operator><operator>(</operator><name>endOp</name> <operator>!=</operator> <name>ZSTD_e_continue</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>filled</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator>  <comment type="block">/* something to flush : let's go */</comment>
      <operator>||</operator> <operator>(</operator><operator>(</operator><name>endOp</name> <operator>==</operator> <name>ZSTD_e_end</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name><name>mtctx</name><operator>-&gt;</operator><name>frameEnded</name></name><operator>)</operator><operator>)</operator></expr> )</condition> <block>{<block_content>   <comment type="block">/* must finish the frame with a zero-size block */</comment>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>jobSize</name> <init>= <expr><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>filled</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>mtctx</name><operator>-&gt;</operator><name>inBuff</name><operator>.</operator><name>filled</name></name> <operator>&lt;=</operator> <name><name>mtctx</name><operator>-&gt;</operator><name>targetSectionSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTDMT_createCompressionJob</name><argument_list>(<argument><expr><name>mtctx</name></expr></argument>, <argument><expr><name>jobSize</name></expr></argument>, <argument><expr><name>endOp</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* check for potential compressed data ready to be flushed */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>remainingToFlush</name> <init>= <expr><call><name>ZSTDMT_flushProduced</name><argument_list>(<argument><expr><name>mtctx</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><operator>!</operator><name>forwardInputProgress</name></expr></argument>, <argument><expr><name>endOp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* block if there was no forward input progress */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>input</name><operator>-&gt;</operator><name>pos</name></name> <operator>&lt;</operator> <name><name>input</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>MAX</name><argument_list>(<argument><expr><name>remainingToFlush</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* input not consumed : do not end flush yet */</comment>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"end of ZSTDMT_compressStream_generic: remainingToFlush = %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>remainingToFlush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>remainingToFlush</name></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>
</unit>
