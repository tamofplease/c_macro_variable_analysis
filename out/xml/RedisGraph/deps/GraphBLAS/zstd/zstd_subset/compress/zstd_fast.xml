<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/zstd/zstd_subset/compress/zstd_fast.c"><comment type="block">/*
 * Copyright (c) Yann Collet, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_compress_internal.h"</cpp:file></cpp:include>  <comment type="block">/* ZSTD_hashPtr, ZSTD_count, ZSTD_storeSeq */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_fast.h"</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_fillHashTableForCDict</name><parameter_list>(<parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier> <specifier>const</specifier></type> <name>end</name></decl></parameter>,
                        <parameter><decl><type><name>ZSTD_dictTableLoadMethod_e</name></type> <name>dtlm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_compressionParameters</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cParams</name> <init>= <expr><operator>&amp;</operator><name><name>ms</name><operator>-&gt;</operator><name>cParams</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>hashTable</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>hashTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>  <specifier>const</specifier></type> <name>hBits</name> <init>= <expr><name><name>cParams</name><operator>-&gt;</operator><name>hashLog</name></name> <operator>+</operator> <name>ZSTD_SHORT_CACHE_TAG_BITS</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>  <specifier>const</specifier></type> <name>mls</name> <init>= <expr><name><name>cParams</name><operator>-&gt;</operator><name>minMatch</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>base</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><name>base</name> <operator>+</operator> <name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>end</name><operator>)</operator> <operator>-</operator> <name>HASH_READ_SIZE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>fastHashFillStep</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Currently, we always use ZSTD_dtlm_full for filling CDict tables.
     * Feel free to remove this assert if there's a good reason! */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dtlm</name> <operator>==</operator> <name>ZSTD_dtlm_full</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Always insert every fastHashFillStep position into the hash table.
     * Insert the other positions if their hash entry is empty.
     */</comment>
    <for>for <control>( <init>;</init> <condition><expr><name>ip</name> <operator>+</operator> <name>fastHashFillStep</name> <operator>&lt;</operator> <name>iend</name> <operator>+</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>ip</name> <operator>+=</operator> <name>fastHashFillStep</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>curr</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>hashAndTag</name> <init>= <expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>hBits</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ZSTD_writeTaggedIndex</name><argument_list>(<argument><expr><name>hashTable</name></expr></argument>, <argument><expr><name>hashAndTag</name></expr></argument>, <argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   </block_content>}</block>

        <if_stmt><if>if <condition>(<expr><name>dtlm</name> <operator>==</operator> <name>ZSTD_dtlm_fast</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <comment type="block">/* Only load extra positions for ZSTD_dtlm_full */</comment>
        <block>{<block_content>   <decl_stmt><decl><type><name>U32</name></type> <name>p</name></decl>;</decl_stmt>
            <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>fastHashFillStep</name></expr>;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>hashAndTag</name> <init>= <expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name> <operator>+</operator> <name>p</name></expr></argument>, <argument><expr><name>hBits</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>hashTable</name><index>[<expr><name>hashAndTag</name> <operator>&gt;&gt;</operator> <name>ZSTD_SHORT_CACHE_TAG_BITS</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* not yet filled */</comment>
                    <expr_stmt><expr><call><name>ZSTD_writeTaggedIndex</name><argument_list>(<argument><expr><name>hashTable</name></expr></argument>, <argument><expr><name>hashAndTag</name></expr></argument>, <argument><expr><name>curr</name> <operator>+</operator> <name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>   </block_content>}</block></for>   </block_content>}</block>   </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_fillHashTableForCCtx</name><parameter_list>(<parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier> <specifier>const</specifier></type> <name>end</name></decl></parameter>,
                        <parameter><decl><type><name>ZSTD_dictTableLoadMethod_e</name></type> <name>dtlm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_compressionParameters</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cParams</name> <init>= <expr><operator>&amp;</operator><name><name>ms</name><operator>-&gt;</operator><name>cParams</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>hashTable</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>hashTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>  <specifier>const</specifier></type> <name>hBits</name> <init>= <expr><name><name>cParams</name><operator>-&gt;</operator><name>hashLog</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>  <specifier>const</specifier></type> <name>mls</name> <init>= <expr><name><name>cParams</name><operator>-&gt;</operator><name>minMatch</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>base</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><name>base</name> <operator>+</operator> <name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>end</name><operator>)</operator> <operator>-</operator> <name>HASH_READ_SIZE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>fastHashFillStep</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Currently, we always use ZSTD_dtlm_fast for filling CCtx tables.
     * Feel free to remove this assert if there's a good reason! */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dtlm</name> <operator>==</operator> <name>ZSTD_dtlm_fast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Always insert every fastHashFillStep position into the hash table.
     * Insert the other positions if their hash entry is empty.
     */</comment>
    <for>for <control>( <init>;</init> <condition><expr><name>ip</name> <operator>+</operator> <name>fastHashFillStep</name> <operator>&lt;</operator> <name>iend</name> <operator>+</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>ip</name> <operator>+=</operator> <name>fastHashFillStep</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>curr</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>hash0</name> <init>= <expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>hBits</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>hashTable</name><index>[<expr><name>hash0</name></expr>]</index></name> <operator>=</operator> <name>curr</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>dtlm</name> <operator>==</operator> <name>ZSTD_dtlm_fast</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <comment type="block">/* Only load extra positions for ZSTD_dtlm_full */</comment>
        <block>{<block_content>   <decl_stmt><decl><type><name>U32</name></type> <name>p</name></decl>;</decl_stmt>
            <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>fastHashFillStep</name></expr>;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>hash</name> <init>= <expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name> <operator>+</operator> <name>p</name></expr></argument>, <argument><expr><name>hBits</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>hashTable</name><index>[<expr><name>hash</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* not yet filled */</comment>
                    <expr_stmt><expr><name><name>hashTable</name><index>[<expr><name>hash</name></expr>]</index></name> <operator>=</operator> <name>curr</name> <operator>+</operator> <name>p</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>   </block_content>}</block></for>   </block_content>}</block>   </block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>ZSTD_fillHashTable</name><parameter_list>(<parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier> <specifier>const</specifier></type> <name>end</name></decl></parameter>,
                        <parameter><decl><type><name>ZSTD_dictTableLoadMethod_e</name></type> <name>dtlm</name></decl></parameter>,
                        <parameter><decl><type><name>ZSTD_tableFillPurpose_e</name></type> <name>tfp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>tfp</name> <operator>==</operator> <name>ZSTD_tfp_forCDict</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>ZSTD_fillHashTableForCDict</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>dtlm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>ZSTD_fillHashTableForCCtx</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>dtlm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
 * If you squint hard enough (and ignore repcodes), the search operation at any
 * given position is broken into 4 stages:
 *
 * 1. Hash   (map position to hash value via input read)
 * 2. Lookup (map hash val to index via hashtable read)
 * 3. Load   (map index to value at that position via input read)
 * 4. Compare
 *
 * Each of these steps involves a memory read at an address which is computed
 * from the previous step. This means these steps must be sequenced and their
 * latencies are cumulative.
 *
 * Rather than do 1-&gt;2-&gt;3-&gt;4 sequentially for a single position before moving
 * onto the next, this implementation interleaves these operations across the
 * next few positions:
 *
 * R = Repcode Read &amp; Compare
 * H = Hash
 * T = Table Lookup
 * M = Match Read &amp; Compare
 *
 * Pos | Time --&gt;
 * ----+-------------------
 * N   | ... M
 * N+1 | ...   TM
 * N+2 |    R H   T M
 * N+3 |         H    TM
 * N+4 |           R H   T M
 * N+5 |                H   ...
 * N+6 |                  R ...
 *
 * This is very much analogous to the pipelining of execution in a CPU. And just
 * like a CPU, we have to dump the pipeline when we find a match (i.e., take a
 * branch).
 *
 * When this happens, we throw away our current state, and do the following prep
 * to re-enter the loop:
 *
 * Pos | Time --&gt;
 * ----+-------------------
 * N   | H T
 * N+1 |  H
 *
 * This is also the work we do at the beginning to enter the loop initially.
 */</comment>
<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>size_t</name></type>
<name>ZSTD_compressBlock_fast_noDict_generic</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
        <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>mls</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>hasStep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_compressionParameters</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cParams</name> <init>= <expr><operator>&amp;</operator><name><name>ms</name><operator>-&gt;</operator><name>cParams</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>hashTable</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>hashTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>hlog</name> <init>= <expr><name><name>cParams</name><operator>-&gt;</operator><name>hashLog</name></name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* support stepSize of 0 */</comment>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>stepSize</name> <init>= <expr><ternary><condition><expr><name>hasStep</name></expr> ?</condition><then> <expr><operator>(</operator><name><name>cParams</name><operator>-&gt;</operator><name>targetLength</name></name> <operator>+</operator> <operator>!</operator><operator>(</operator><name><name>cParams</name><operator>-&gt;</operator><name>targetLength</name></name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>base</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>istart</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type>   <name>endIndex</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>istart</name> <operator>-</operator> <name>base</name><operator>)</operator> <operator>+</operator> <name>srcSize</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type>   <name>prefixStartIndex</name> <init>= <expr><call><name>ZSTD_getLowestPrefixIndex</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>endIndex</name></expr></argument>, <argument><expr><name><name>cParams</name><operator>-&gt;</operator><name>windowLog</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>prefixStart</name> <init>= <expr><name>base</name> <operator>+</operator> <name>prefixStartIndex</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name> <init>= <expr><name>istart</name> <operator>+</operator> <name>srcSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ilimit</name> <init>= <expr><name>iend</name> <operator>-</operator> <name>HASH_READ_SIZE</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>anchor</name> <init>= <expr><name>istart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip0</name> <init>= <expr><name>istart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip3</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>current0</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>U32</name></type> <name>rep_offset1</name> <init>= <expr><name><name>rep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>rep_offset2</name> <init>= <expr><name><name>rep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>offsetSaved1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>offsetSaved2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>size_t</name></type> <name>hash0</name></decl>;</decl_stmt> <comment type="block">/* hash for ip0 */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>hash1</name></decl>;</decl_stmt> <comment type="block">/* hash for ip1 */</comment>
    <decl_stmt><decl><type><name>U32</name></type> <name>idx</name></decl>;</decl_stmt> <comment type="block">/* match idx for ip0 */</comment>
    <decl_stmt><decl><type><name>U32</name></type> <name>mval</name></decl>;</decl_stmt> <comment type="block">/* src value at match idx */</comment>

    <decl_stmt><decl><type><name>U32</name></type> <name>offcode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>match0</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>mLength</name></decl>;</decl_stmt>

    <comment type="block">/* ip0 and ip1 are always adjacent. The targetLength skipping and
     * uncompressibility acceleration is applied to every other position,
     * matching the behavior of #1562. step therefore represents the gap
     * between pairs of positions, from ip0 to ip2 or ip1 to ip3. */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>step</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>nextStep</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>kStepIncr</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>kSearchStrength</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressBlock_fast_generic"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ip0</name> <operator>+=</operator> <operator>(</operator><name>ip0</name> <operator>==</operator> <name>prefixStart</name><operator>)</operator></expr>;</expr_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>curr</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip0</name> <operator>-</operator> <name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>windowLow</name> <init>= <expr><call><name>ZSTD_getLowestPrefixIndex</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>curr</name></expr></argument>, <argument><expr><name><name>cParams</name><operator>-&gt;</operator><name>windowLog</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>maxRep</name> <init>= <expr><name>curr</name> <operator>-</operator> <name>windowLow</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>rep_offset2</name> <operator>&gt;</operator> <name>maxRep</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>offsetSaved2</name> <operator>=</operator> <name>rep_offset2</name></expr><operator>,</operator> <expr><name>rep_offset2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>rep_offset1</name> <operator>&gt;</operator> <name>maxRep</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>offsetSaved1</name> <operator>=</operator> <name>rep_offset1</name></expr><operator>,</operator> <expr><name>rep_offset1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/* start each op */</comment>
<label><name>_start</name>:</label> <comment type="block">/* Requires: ip0 */</comment>

    <expr_stmt><expr><name>step</name> <operator>=</operator> <name>stepSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nextStep</name> <operator>=</operator> <name>ip0</name> <operator>+</operator> <name>kStepIncr</name></expr>;</expr_stmt>

    <comment type="block">/* calculate positions, ip0 - anchor == 0, so we skip step calc */</comment>
    <expr_stmt><expr><name>ip1</name> <operator>=</operator> <name>ip0</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>ip2</name> <operator>=</operator> <name>ip0</name> <operator>+</operator> <name>step</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ip3</name> <operator>=</operator> <name>ip2</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>ip3</name> <operator>&gt;=</operator> <name>ilimit</name></expr>)</condition> <block>{<block_content>
        <goto>goto <name>_cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>hash0</name> <operator>=</operator> <call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip0</name></expr></argument>, <argument><expr><name>hlog</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hash1</name> <operator>=</operator> <call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip1</name></expr></argument>, <argument><expr><name>hlog</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>idx</name> <operator>=</operator> <name><name>hashTable</name><index>[<expr><name>hash0</name></expr>]</index></name></expr>;</expr_stmt>

    <do>do <block>{<block_content>
        <comment type="block">/* load repcode match for ip[2]*/</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>rval</name> <init>= <expr><call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip2</name> <operator>-</operator> <name>rep_offset1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* write back hash table entry */</comment>
        <expr_stmt><expr><name>current0</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip0</name> <operator>-</operator> <name>base</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hashTable</name><index>[<expr><name>hash0</name></expr>]</index></name> <operator>=</operator> <name>current0</name></expr>;</expr_stmt>

        <comment type="block">/* check repcode at ip[2] */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip2</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rval</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>rep_offset1</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>ip0</name> <operator>=</operator> <name>ip2</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>match0</name> <operator>=</operator> <name>ip0</name> <operator>-</operator> <name>rep_offset1</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>mLength</name> <operator>=</operator> <name><name>ip0</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>match0</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ip0</name> <operator>-=</operator> <name>mLength</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>match0</name> <operator>-=</operator> <name>mLength</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>offcode</name> <operator>=</operator> <name>REPCODE1_TO_OFFBASE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>mLength</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

            <comment type="block">/* First write next hash table entry; we've already calculated it.
             * This write is known to be safe because the ip1 is before the
             * repcode (ip2). */</comment>
            <expr_stmt><expr><name><name>hashTable</name><index>[<expr><name>hash1</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip1</name> <operator>-</operator> <name>base</name><operator>)</operator></expr>;</expr_stmt>

            <goto>goto <name>_match</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* load match for ip[0] */</comment>
        <if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&gt;=</operator> <name>prefixStartIndex</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>mval</name> <operator>=</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>base</name> <operator>+</operator> <name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>mval</name> <operator>=</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip0</name></expr></argument>)</argument_list></call> <operator>^</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* guaranteed to not match. */</comment>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* check match at ip[0] */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip0</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>mval</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* found a match! */</comment>

            <comment type="block">/* First write next hash table entry; we've already calculated it.
             * This write is known to be safe because the ip1 == ip0 + 1, so
             * we know we will resume searching after ip1 */</comment>
            <expr_stmt><expr><name><name>hashTable</name><index>[<expr><name>hash1</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip1</name> <operator>-</operator> <name>base</name><operator>)</operator></expr>;</expr_stmt>

            <goto>goto <name>_offset</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* lookup ip[1] */</comment>
        <expr_stmt><expr><name>idx</name> <operator>=</operator> <name><name>hashTable</name><index>[<expr><name>hash1</name></expr>]</index></name></expr>;</expr_stmt>

        <comment type="block">/* hash ip[2] */</comment>
        <expr_stmt><expr><name>hash0</name> <operator>=</operator> <name>hash1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>hash1</name> <operator>=</operator> <call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip2</name></expr></argument>, <argument><expr><name>hlog</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* advance to next positions */</comment>
        <expr_stmt><expr><name>ip0</name> <operator>=</operator> <name>ip1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ip1</name> <operator>=</operator> <name>ip2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ip2</name> <operator>=</operator> <name>ip3</name></expr>;</expr_stmt>

        <comment type="block">/* write back hash table entry */</comment>
        <expr_stmt><expr><name>current0</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip0</name> <operator>-</operator> <name>base</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hashTable</name><index>[<expr><name>hash0</name></expr>]</index></name> <operator>=</operator> <name>current0</name></expr>;</expr_stmt>

        <comment type="block">/* load match for ip[0] */</comment>
        <if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&gt;=</operator> <name>prefixStartIndex</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>mval</name> <operator>=</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>base</name> <operator>+</operator> <name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>mval</name> <operator>=</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip0</name></expr></argument>)</argument_list></call> <operator>^</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* guaranteed to not match. */</comment>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* check match at ip[0] */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip0</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>mval</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* found a match! */</comment>

            <comment type="block">/* first write next hash table entry; we've already calculated it */</comment>
            <if_stmt><if>if <condition>(<expr><name>step</name> <operator>&lt;=</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
                <comment type="block">/* We need to avoid writing an index into the hash table &gt;= the
                 * position at which we will pick up our searching after we've
                 * taken this match.
                 *
                 * The minimum possible match has length 4, so the earliest ip0
                 * can be after we take this match will be the current ip0 + 4.
                 * ip1 is ip0 + step - 1. If ip1 is &gt;= ip0 + 4, we can't safely
                 * write this position.
                 */</comment>
                <expr_stmt><expr><name><name>hashTable</name><index>[<expr><name>hash1</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip1</name> <operator>-</operator> <name>base</name><operator>)</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <goto>goto <name>_offset</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* lookup ip[1] */</comment>
        <expr_stmt><expr><name>idx</name> <operator>=</operator> <name><name>hashTable</name><index>[<expr><name>hash1</name></expr>]</index></name></expr>;</expr_stmt>

        <comment type="block">/* hash ip[2] */</comment>
        <expr_stmt><expr><name>hash0</name> <operator>=</operator> <name>hash1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>hash1</name> <operator>=</operator> <call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip2</name></expr></argument>, <argument><expr><name>hlog</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* advance to next positions */</comment>
        <expr_stmt><expr><name>ip0</name> <operator>=</operator> <name>ip1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ip1</name> <operator>=</operator> <name>ip2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ip2</name> <operator>=</operator> <name>ip0</name> <operator>+</operator> <name>step</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ip3</name> <operator>=</operator> <name>ip1</name> <operator>+</operator> <name>step</name></expr>;</expr_stmt>

        <comment type="block">/* calculate step */</comment>
        <if_stmt><if>if <condition>(<expr><name>ip2</name> <operator>&gt;=</operator> <name>nextStep</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>step</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PREFETCH_L1</name><argument_list>(<argument><expr><name>ip1</name> <operator>+</operator> <literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PREFETCH_L1</name><argument_list>(<argument><expr><name>ip1</name> <operator>+</operator> <literal type="number">128</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>nextStep</name> <operator>+=</operator> <name>kStepIncr</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block> while <condition>(<expr><name>ip3</name> <operator>&lt;</operator> <name>ilimit</name></expr>)</condition>;</do>

<label><name>_cleanup</name>:</label>
    <comment type="block">/* Note that there are probably still a couple positions we could search.
     * However, it seems to be a meaningful performance hit to try to search
     * them. So let's not. */</comment>

    <comment type="block">/* When the repcodes are outside of the prefix, we set them to zero before the loop.
     * When the offsets are still zero, we need to restore them after the block to have a correct
     * repcode history. If only one offset was invalid, it is easy. The tricky case is when both
     * offsets were invalid. We need to figure out which offset to refill with.
     *     - If both offsets are zero they are in the same order.
     *     - If both offsets are non-zero, we won't restore the offsets from `offsetSaved[12]`.
     *     - If only one is zero, we need to decide which offset to restore.
     *         - If rep_offset1 is non-zero, then rep_offset2 must be offsetSaved1.
     *         - It is impossible for rep_offset2 to be non-zero.
     *
     * So if rep_offset1 started invalid (offsetSaved1 != 0) and became valid (rep_offset1 != 0), then
     * set rep[0] = rep_offset1 and rep[1] = offsetSaved1.
     */</comment>
    <expr_stmt><expr><name>offsetSaved2</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>(</operator><name>offsetSaved1</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>rep_offset1</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><name>offsetSaved1</name></expr> </then><else>: <expr><name>offsetSaved2</name></expr></else></ternary></expr>;</expr_stmt>

    <comment type="block">/* save reps for next block */</comment>
    <expr_stmt><expr><name><name>rep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>rep_offset1</name></expr> ?</condition><then> <expr><name>rep_offset1</name></expr> </then><else>: <expr><name>offsetSaved1</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>rep_offset2</name></expr> ?</condition><then> <expr><name>rep_offset2</name></expr> </then><else>: <expr><name>offsetSaved2</name></expr></else></ternary></expr>;</expr_stmt>

    <comment type="block">/* Return the last literals size */</comment>
    <return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>iend</name> <operator>-</operator> <name>anchor</name><operator>)</operator></expr>;</return>

<label><name>_offset</name>:</label> <comment type="block">/* Requires: ip0, idx */</comment>

    <comment type="block">/* Compute the offset code. */</comment>
    <expr_stmt><expr><name>match0</name> <operator>=</operator> <name>base</name> <operator>+</operator> <name>idx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rep_offset2</name> <operator>=</operator> <name>rep_offset1</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rep_offset1</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip0</name><operator>-</operator><name>match0</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>offcode</name> <operator>=</operator> <call><name>OFFSET_TO_OFFBASE</name><argument_list>(<argument><expr><name>rep_offset1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mLength</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

    <comment type="block">/* Count the backwards match length. */</comment>
    <while>while <condition>(<expr><operator>(</operator><operator>(</operator><name>ip0</name><operator>&gt;</operator><name>anchor</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>match0</name><operator>&gt;</operator><name>prefixStart</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ip0</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>match0</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>ip0</name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>match0</name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>mLength</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

<label><name>_match</name>:</label> <comment type="block">/* Requires: ip0, match0, offcode */</comment>

    <comment type="block">/* Count the forward length. */</comment>
    <expr_stmt><expr><name>mLength</name> <operator>+=</operator> <call><name>ZSTD_count</name><argument_list>(<argument><expr><name>ip0</name> <operator>+</operator> <name>mLength</name></expr></argument>, <argument><expr><name>match0</name> <operator>+</operator> <name>mLength</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ZSTD_storeSeq</name><argument_list>(<argument><expr><name>seqStore</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>ip0</name> <operator>-</operator> <name>anchor</name><operator>)</operator></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>offcode</name></expr></argument>, <argument><expr><name>mLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ip0</name> <operator>+=</operator> <name>mLength</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>anchor</name> <operator>=</operator> <name>ip0</name></expr>;</expr_stmt>

    <comment type="block">/* Fill table and check for immediate repcode. */</comment>
    <if_stmt><if>if <condition>(<expr><name>ip0</name> <operator>&lt;=</operator> <name>ilimit</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Fill Table */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>base</name><operator>+</operator><name>current0</name><operator>+</operator><literal type="number">2</literal> <operator>&gt;</operator> <name>istart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* check base overflow */</comment>
        <expr_stmt><expr><name><name>hashTable</name><index>[<expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>base</name><operator>+</operator><name>current0</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>hlog</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>current0</name><operator>+</operator><literal type="number">2</literal></expr>;</expr_stmt>  <comment type="block">/* here because current+2 could be &gt; iend-8 */</comment>
        <expr_stmt><expr><name><name>hashTable</name><index>[<expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip0</name><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>hlog</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip0</name><operator>-</operator><literal type="number">2</literal><operator>-</operator><name>base</name><operator>)</operator></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>rep_offset2</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> <comment type="block">/* rep_offset2==0 means rep_offset2 is invalidated */</comment>
            <while>while <condition>( <expr><operator>(</operator><name>ip0</name> <operator>&lt;=</operator> <name>ilimit</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip0</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip0</name> <operator>-</operator> <name>rep_offset2</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition> <block>{<block_content>
                <comment type="block">/* store sequence */</comment>
                <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>rLength</name> <init>= <expr><call><name>ZSTD_count</name><argument_list>(<argument><expr><name>ip0</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>ip0</name><operator>+</operator><literal type="number">4</literal><operator>-</operator><name>rep_offset2</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>
                <block>{<block_content> <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>tmpOff</name> <init>= <expr><name>rep_offset2</name></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name>rep_offset2</name> <operator>=</operator> <name>rep_offset1</name></expr>;</expr_stmt> <expr_stmt><expr><name>rep_offset1</name> <operator>=</operator> <name>tmpOff</name></expr>;</expr_stmt> </block_content>}</block> <comment type="block">/* swap rep_offset2 &lt;=&gt; rep_offset1 */</comment>
                <expr_stmt><expr><name><name>hashTable</name><index>[<expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip0</name></expr></argument>, <argument><expr><name>hlog</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip0</name><operator>-</operator><name>base</name><operator>)</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>ip0</name> <operator>+=</operator> <name>rLength</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ZSTD_storeSeq</name><argument_list>(<argument><expr><name>seqStore</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/*litLen*/</comment>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>REPCODE1_TO_OFFBASE</name></expr></argument>, <argument><expr><name>rLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>anchor</name> <operator>=</operator> <name>ip0</name></expr>;</expr_stmt>
                <continue>continue;</continue>   <comment type="block">/* faster when present (confirmed on gcc-8) ... (?) */</comment>
    </block_content>}</block></while>   </block_content>}</block></if></if_stmt>   </block_content>}</block></if></if_stmt>

    <goto>goto <name>_start</name>;</goto>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZSTD_GEN_FAST_FN</name><parameter_list>(<parameter><type><name>dictMode</name></type></parameter>, <parameter><type><name>mls</name></type></parameter>, <parameter><type><name>step</name></type></parameter>)</parameter_list></cpp:macro>                                                            \
    <cpp:value>static size_t ZSTD_compressBlock_fast_##dictMode##_##mls##_##step(                                      \
            ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],                    \
            void const* src, size_t srcSize)                                                       \
    {                                                                                              \
        return ZSTD_compressBlock_fast_##dictMode##_generic(ms, seqStore, rep, src, srcSize, mls, step); \
    }</cpp:value></cpp:define>

<macro><name>ZSTD_GEN_FAST_FN</name><argument_list>(<argument>noDict</argument>, <argument><literal type="number">4</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>
<macro><name>ZSTD_GEN_FAST_FN</name><argument_list>(<argument>noDict</argument>, <argument><literal type="number">5</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>
<macro><name>ZSTD_GEN_FAST_FN</name><argument_list>(<argument>noDict</argument>, <argument><literal type="number">6</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>
<macro><name>ZSTD_GEN_FAST_FN</name><argument_list>(<argument>noDict</argument>, <argument><literal type="number">7</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>

<macro><name>ZSTD_GEN_FAST_FN</name><argument_list>(<argument>noDict</argument>, <argument><literal type="number">4</literal></argument>, <argument><literal type="number">0</literal></argument>)</argument_list></macro>
<macro><name>ZSTD_GEN_FAST_FN</name><argument_list>(<argument>noDict</argument>, <argument><literal type="number">5</literal></argument>, <argument><literal type="number">0</literal></argument>)</argument_list></macro>
<macro><name>ZSTD_GEN_FAST_FN</name><argument_list>(<argument>noDict</argument>, <argument><literal type="number">6</literal></argument>, <argument><literal type="number">0</literal></argument>)</argument_list></macro>
<macro><name>ZSTD_GEN_FAST_FN</name><argument_list>(<argument>noDict</argument>, <argument><literal type="number">7</literal></argument>, <argument><literal type="number">0</literal></argument>)</argument_list></macro>

<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_fast</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>mls</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>minMatch</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>dictMatchState</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ms</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>targetLength</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <switch>switch<condition>(<expr><name>mls</name></expr>)</condition>
        <block>{<block_content>
        <default>default:</default> <comment type="block">/* includes case 3 */</comment>
        <case>case <expr><literal type="number">4</literal></expr> :</case>
            <return>return <expr><call><name>ZSTD_compressBlock_fast_noDict_4_1</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><literal type="number">5</literal></expr> :</case>
            <return>return <expr><call><name>ZSTD_compressBlock_fast_noDict_5_1</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><literal type="number">6</literal></expr> :</case>
            <return>return <expr><call><name>ZSTD_compressBlock_fast_noDict_6_1</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><literal type="number">7</literal></expr> :</case>
            <return>return <expr><call><name>ZSTD_compressBlock_fast_noDict_7_1</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></switch>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <switch>switch<condition>(<expr><name>mls</name></expr>)</condition>
        <block>{<block_content>
        <default>default:</default> <comment type="block">/* includes case 3 */</comment>
        <case>case <expr><literal type="number">4</literal></expr> :</case>
            <return>return <expr><call><name>ZSTD_compressBlock_fast_noDict_4_0</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><literal type="number">5</literal></expr> :</case>
            <return>return <expr><call><name>ZSTD_compressBlock_fast_noDict_5_0</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><literal type="number">6</literal></expr> :</case>
            <return>return <expr><call><name>ZSTD_compressBlock_fast_noDict_6_0</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><literal type="number">7</literal></expr> :</case>
            <return>return <expr><call><name>ZSTD_compressBlock_fast_noDict_7_0</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></switch>

    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>FORCE_INLINE_TEMPLATE</name>
<name>size_t</name></type> <name>ZSTD_compressBlock_fast_dictMatchState_generic</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>mls</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>hasStep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_compressionParameters</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cParams</name> <init>= <expr><operator>&amp;</operator><name><name>ms</name><operator>-&gt;</operator><name>cParams</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>hashTable</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>hashTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>hlog</name> <init>= <expr><name><name>cParams</name><operator>-&gt;</operator><name>hashLog</name></name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* support stepSize of 0 */</comment>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>stepSize</name> <init>= <expr><name><name>cParams</name><operator>-&gt;</operator><name>targetLength</name></name> <operator>+</operator> <operator>!</operator><operator>(</operator><name><name>cParams</name><operator>-&gt;</operator><name>targetLength</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>base</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>istart</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip0</name> <init>= <expr><name>istart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip1</name> <init>= <expr><name>ip0</name> <operator>+</operator> <name>stepSize</name></expr></init></decl>;</decl_stmt> <comment type="block">/* we assert below that stepSize &gt;= 1 */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>anchor</name> <init>= <expr><name>istart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type>   <name>prefixStartIndex</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictLimit</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>prefixStart</name> <init>= <expr><name>base</name> <operator>+</operator> <name>prefixStartIndex</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name> <init>= <expr><name>istart</name> <operator>+</operator> <name>srcSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ilimit</name> <init>= <expr><name>iend</name> <operator>-</operator> <name>HASH_READ_SIZE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>offset_1</name><init>=<expr><name><name>rep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>, <decl><type ref="prev"/><name>offset_2</name><init>=<expr><name><name>rep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_matchState_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dms</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>dictMatchState</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_compressionParameters</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictCParams</name> <init>= <expr><operator>&amp;</operator><name><name>dms</name><operator>-&gt;</operator><name>cParams</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictHashTable</name> <init>= <expr><name><name>dms</name><operator>-&gt;</operator><name>hashTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dictStartIndex</name>       <init>= <expr><name><name>dms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictLimit</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictBase</name>     <init>= <expr><name><name>dms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictStart</name>    <init>= <expr><name>dictBase</name> <operator>+</operator> <name>dictStartIndex</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictEnd</name>      <init>= <expr><name><name>dms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>nextSrc</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dictIndexDelta</name>       <init>= <expr><name>prefixStartIndex</name> <operator>-</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>dictEnd</name> <operator>-</operator> <name>dictBase</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dictAndPrefixLength</name>  <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>istart</name> <operator>-</operator> <name>prefixStart</name> <operator>+</operator> <name>dictEnd</name> <operator>-</operator> <name>dictStart</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dictHBits</name>            <init>= <expr><name><name>dictCParams</name><operator>-&gt;</operator><name>hashLog</name></name> <operator>+</operator> <name>ZSTD_SHORT_CACHE_TAG_BITS</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* if a dictionary is still attached, it necessarily means that
     * it is within window size. So we just check it. */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>maxDistance</name> <init>= <expr><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name><name>cParams</name><operator>-&gt;</operator><name>windowLog</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>endIndex</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>istart</name> <operator>-</operator> <name>base</name><operator>)</operator> <operator>+</operator> <name>srcSize</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>endIndex</name> <operator>-</operator> <name>prefixStartIndex</name> <operator>&lt;=</operator> <name>maxDistance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>maxDistance</name></expr>;</expr_stmt> <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>endIndex</name></expr>;</expr_stmt>   <comment type="block">/* these variables are not used when assert() is disabled */</comment>

    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>hasStep</name></expr>;</expr_stmt> <comment type="block">/* not currently specialized on whether it's accelerated */</comment>

    <comment type="block">/* ensure there will be no underflow
     * when translating a dict index into a local index */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>prefixStartIndex</name> <operator>&gt;=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>dictEnd</name> <operator>-</operator> <name>dictBase</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>ms</name><operator>-&gt;</operator><name>prefetchCDictTables</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>hashTableBytes</name> <init>= <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name><name>dictCParams</name><operator>-&gt;</operator><name>hashLog</name></name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>U32</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
        <macro><name>PREFETCH_AREA</name><argument_list>(<argument>dictHashTable</argument>, <argument>hashTableBytes</argument>)</argument_list></macro>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* init */</comment>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressBlock_fast_dictMatchState_generic"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ip0</name> <operator>+=</operator> <operator>(</operator><name>dictAndPrefixLength</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
    <comment type="block">/* dictMatchState repCode checks don't currently handle repCode == 0
     * disabling. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>offset_1</name> <operator>&lt;=</operator> <name>dictAndPrefixLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>offset_2</name> <operator>&lt;=</operator> <name>dictAndPrefixLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Outer search loop */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>stepSize</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>ip1</name> <operator>&lt;=</operator> <name>ilimit</name></expr>)</condition> <block>{<block_content>   <comment type="block">/* repcode check at (ip0 + 1) is safe because ip0 &lt; ip1 */</comment>
        <decl_stmt><decl><type><name>size_t</name></type> <name>mLength</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>hash0</name> <init>= <expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip0</name></expr></argument>, <argument><expr><name>hlog</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>dictHashAndTag0</name> <init>= <expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip0</name></expr></argument>, <argument><expr><name>dictHBits</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name></type> <name>dictMatchIndexAndTag</name> <init>= <expr><name><name>dictHashTable</name><index>[<expr><name>dictHashAndTag0</name> <operator>&gt;&gt;</operator> <name>ZSTD_SHORT_CACHE_TAG_BITS</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>dictTagsMatch</name> <init>= <expr><call><name>ZSTD_comparePackedTags</name><argument_list>(<argument><expr><name>dictMatchIndexAndTag</name></expr></argument>, <argument><expr><name>dictHashAndTag0</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>U32</name></type> <name>matchIndex</name> <init>= <expr><name><name>hashTable</name><index>[<expr><name>hash0</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name></type> <name>curr</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip0</name> <operator>-</operator> <name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>step</name> <init>= <expr><name>stepSize</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>kStepIncr</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>kSearchStrength</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>nextStep</name> <init>= <expr><name>ip0</name> <operator>+</operator> <name>kStepIncr</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Inner search loop */</comment>
        <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>match</name> <init>= <expr><name>base</name> <operator>+</operator> <name>matchIndex</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>repIndex</name> <init>= <expr><name>curr</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>offset_1</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>repMatch</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>repIndex</name> <operator>&lt;</operator> <name>prefixStartIndex</name><operator>)</operator></expr> ?</condition><then>
                                   <expr><name>dictBase</name> <operator>+</operator> <operator>(</operator><name>repIndex</name> <operator>-</operator> <name>dictIndexDelta</name><operator>)</operator></expr> </then><else>:
                                   <expr><name>base</name> <operator>+</operator> <name>repIndex</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>hash1</name> <init>= <expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip1</name></expr></argument>, <argument><expr><name>hlog</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>dictHashAndTag1</name> <init>= <expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip1</name></expr></argument>, <argument><expr><name>dictHBits</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>hashTable</name><index>[<expr><name>hash0</name></expr>]</index></name> <operator>=</operator> <name>curr</name></expr>;</expr_stmt>   <comment type="block">/* update hash table */</comment>

            <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>prefixStartIndex</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name>repIndex</name><operator>)</operator> <operator>&gt;=</operator>
                 <literal type="number">3</literal><operator>)</operator> <comment type="block">/* intentional underflow : ensure repIndex isn't overlapping dict + prefix */</comment>
                <operator>&amp;&amp;</operator> <operator>(</operator><call><name>MEM_read32</name><argument_list>(<argument><expr><name>repMatch</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip0</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>repMatchEnd</name> <init>= <expr><ternary><condition><expr><name>repIndex</name> <operator>&lt;</operator> <name>prefixStartIndex</name></expr> ?</condition><then> <expr><name>dictEnd</name></expr> </then><else>: <expr><name>iend</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>mLength</name> <operator>=</operator> <call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip0</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>repMatch</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>repMatchEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>ip0</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ZSTD_storeSeq</name><argument_list>(<argument><expr><name>seqStore</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator><name>ip0</name> <operator>-</operator> <name>anchor</name><operator>)</operator></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>REPCODE1_TO_OFFBASE</name></expr></argument>, <argument><expr><name>mLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>dictTagsMatch</name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* Found a possible dict match */</comment>
                <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dictMatchIndex</name> <init>= <expr><name>dictMatchIndexAndTag</name> <operator>&gt;&gt;</operator> <name>ZSTD_SHORT_CACHE_TAG_BITS</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>dictMatch</name> <init>= <expr><name>dictBase</name> <operator>+</operator> <name>dictMatchIndex</name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>dictMatchIndex</name> <operator>&gt;</operator> <name>dictStartIndex</name> <operator>&amp;&amp;</operator>
                    <call><name>MEM_read32</name><argument_list>(<argument><expr><name>dictMatch</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip0</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <comment type="block">/* To replicate extDict parse behavior, we only use dict matches when the normal matchIndex is invalid */</comment>
                    <if_stmt><if>if <condition>(<expr><name>matchIndex</name> <operator>&lt;=</operator> <name>prefixStartIndex</name></expr>)</condition> <block>{<block_content>
                        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>offset</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator> <operator>(</operator><name>curr</name> <operator>-</operator> <name>dictMatchIndex</name> <operator>-</operator> <name>dictIndexDelta</name><operator>)</operator></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><name>mLength</name> <operator>=</operator> <call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip0</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>dictMatch</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>dictEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
                        <while>while <condition>(<expr><operator>(</operator><operator>(</operator><name>ip0</name> <operator>&gt;</operator> <name>anchor</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>dictMatch</name> <operator>&gt;</operator> <name>dictStart</name><operator>)</operator><operator>)</operator>
                            <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ip0</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>dictMatch</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content>
                            <expr_stmt><expr><name>ip0</name><operator>--</operator></expr>;</expr_stmt>
                            <expr_stmt><expr><name>dictMatch</name><operator>--</operator></expr>;</expr_stmt>
                            <expr_stmt><expr><name>mLength</name><operator>++</operator></expr>;</expr_stmt>
                        </block_content>}</block></while> <comment type="block">/* catch up */</comment>
                        <expr_stmt><expr><name>offset_2</name> <operator>=</operator> <name>offset_1</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>offset_1</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>ZSTD_storeSeq</name><argument_list>(<argument><expr><name>seqStore</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator><name>ip0</name> <operator>-</operator> <name>anchor</name><operator>)</operator></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><call><name>OFFSET_TO_OFFBASE</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>matchIndex</name> <operator>&gt;</operator> <name>prefixStartIndex</name> <operator>&amp;&amp;</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip0</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <comment type="block">/* found a regular match */</comment>
                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>offset</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator> <operator>(</operator><name>ip0</name> <operator>-</operator> <name>match</name><operator>)</operator></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>mLength</name> <operator>=</operator> <call><name>ZSTD_count</name><argument_list>(<argument><expr><name>ip0</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>match</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>iend</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
                <while>while <condition>(<expr><operator>(</operator><operator>(</operator><name>ip0</name> <operator>&gt;</operator> <name>anchor</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>match</name> <operator>&gt;</operator> <name>prefixStart</name><operator>)</operator><operator>)</operator>
                       <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ip0</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>match</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>ip0</name><operator>--</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name>match</name><operator>--</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name>mLength</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></while> <comment type="block">/* catch up */</comment>
                <expr_stmt><expr><name>offset_2</name> <operator>=</operator> <name>offset_1</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>offset_1</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ZSTD_storeSeq</name><argument_list>(<argument><expr><name>seqStore</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator><name>ip0</name> <operator>-</operator> <name>anchor</name><operator>)</operator></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><call><name>OFFSET_TO_OFFBASE</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Prepare for next iteration */</comment>
            <expr_stmt><expr><name>dictMatchIndexAndTag</name> <operator>=</operator> <name><name>dictHashTable</name><index>[<expr><name>dictHashAndTag1</name> <operator>&gt;&gt;</operator> <name>ZSTD_SHORT_CACHE_TAG_BITS</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>dictTagsMatch</name> <operator>=</operator> <call><name>ZSTD_comparePackedTags</name><argument_list>(<argument><expr><name>dictMatchIndexAndTag</name></expr></argument>, <argument><expr><name>dictHashAndTag1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>matchIndex</name> <operator>=</operator> <name><name>hashTable</name><index>[<expr><name>hash1</name></expr>]</index></name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>ip1</name> <operator>&gt;=</operator> <name>nextStep</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>step</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>nextStep</name> <operator>+=</operator> <name>kStepIncr</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>ip0</name> <operator>=</operator> <name>ip1</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ip1</name> <operator>=</operator> <name>ip1</name> <operator>+</operator> <name>step</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>ip1</name> <operator>&gt;</operator> <name>ilimit</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>_cleanup</name>;</goto></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>curr</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip0</name> <operator>-</operator> <name>base</name><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>hash0</name> <operator>=</operator> <name>hash1</name></expr>;</expr_stmt>
        </block_content>}</block></while>   <comment type="block">/* end inner search loop */</comment>

        <comment type="block">/* match found */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>mLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ip0</name> <operator>+=</operator> <name>mLength</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>anchor</name> <operator>=</operator> <name>ip0</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>ip0</name> <operator>&lt;=</operator> <name>ilimit</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Fill Table */</comment>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>base</name><operator>+</operator><name>curr</name><operator>+</operator><literal type="number">2</literal> <operator>&gt;</operator> <name>istart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* check base overflow */</comment>
            <expr_stmt><expr><name><name>hashTable</name><index>[<expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>base</name><operator>+</operator><name>curr</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>hlog</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>curr</name><operator>+</operator><literal type="number">2</literal></expr>;</expr_stmt>  <comment type="block">/* here because curr+2 could be &gt; iend-8 */</comment>
            <expr_stmt><expr><name><name>hashTable</name><index>[<expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip0</name><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>hlog</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip0</name><operator>-</operator><literal type="number">2</literal><operator>-</operator><name>base</name><operator>)</operator></expr>;</expr_stmt>

            <comment type="block">/* check immediate repcode */</comment>
            <while>while <condition>(<expr><name>ip0</name> <operator>&lt;=</operator> <name>ilimit</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>current2</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip0</name><operator>-</operator><name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>repIndex2</name> <init>= <expr><name>current2</name> <operator>-</operator> <name>offset_2</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>repMatch2</name> <init>= <expr><ternary><condition><expr><name>repIndex2</name> <operator>&lt;</operator> <name>prefixStartIndex</name></expr> ?</condition><then>
                        <expr><name>dictBase</name> <operator>-</operator> <name>dictIndexDelta</name> <operator>+</operator> <name>repIndex2</name></expr> </then><else>:
                        <expr><name>base</name> <operator>+</operator> <name>repIndex2</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>( <expr><operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>prefixStartIndex</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>-</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>repIndex2</name><operator>)</operator> <operator>&gt;=</operator> <literal type="number">3</literal> <comment type="block">/* intentional overflow */</comment><operator>)</operator>
                   <operator>&amp;&amp;</operator> <operator>(</operator><call><name>MEM_read32</name><argument_list>(<argument><expr><name>repMatch2</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip0</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>repEnd2</name> <init>= <expr><ternary><condition><expr><name>repIndex2</name> <operator>&lt;</operator> <name>prefixStartIndex</name></expr> ?</condition><then> <expr><name>dictEnd</name></expr> </then><else>: <expr><name>iend</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>repLength2</name> <init>= <expr><call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip0</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>repMatch2</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>repEnd2</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>U32</name></type> <name>tmpOffset</name> <init>= <expr><name>offset_2</name></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name>offset_2</name> <operator>=</operator> <name>offset_1</name></expr>;</expr_stmt> <expr_stmt><expr><name>offset_1</name> <operator>=</operator> <name>tmpOffset</name></expr>;</expr_stmt>   <comment type="block">/* swap offset_2 &lt;=&gt; offset_1 */</comment>
                    <expr_stmt><expr><call><name>ZSTD_storeSeq</name><argument_list>(<argument><expr><name>seqStore</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>REPCODE1_TO_OFFBASE</name></expr></argument>, <argument><expr><name>repLength2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>hashTable</name><index>[<expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip0</name></expr></argument>, <argument><expr><name>hlog</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>current2</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>ip0</name> <operator>+=</operator> <name>repLength2</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>anchor</name> <operator>=</operator> <name>ip0</name></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Prepare for next iteration */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ip0</name> <operator>==</operator> <name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ip1</name> <operator>=</operator> <name>ip0</name> <operator>+</operator> <name>stepSize</name></expr>;</expr_stmt>
    </block_content>}</block></while>

<label><name>_cleanup</name>:</label>
    <comment type="block">/* save reps for next block */</comment>
    <expr_stmt><expr><name><name>rep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>offset_1</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>offset_2</name></expr>;</expr_stmt>

    <comment type="block">/* Return the last literals size */</comment>
    <return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>iend</name> <operator>-</operator> <name>anchor</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<macro><name>ZSTD_GEN_FAST_FN</name><argument_list>(<argument>dictMatchState</argument>, <argument><literal type="number">4</literal></argument>, <argument><literal type="number">0</literal></argument>)</argument_list></macro>
<macro><name>ZSTD_GEN_FAST_FN</name><argument_list>(<argument>dictMatchState</argument>, <argument><literal type="number">5</literal></argument>, <argument><literal type="number">0</literal></argument>)</argument_list></macro>
<macro><name>ZSTD_GEN_FAST_FN</name><argument_list>(<argument>dictMatchState</argument>, <argument><literal type="number">6</literal></argument>, <argument><literal type="number">0</literal></argument>)</argument_list></macro>
<macro><name>ZSTD_GEN_FAST_FN</name><argument_list>(<argument>dictMatchState</argument>, <argument><literal type="number">7</literal></argument>, <argument><literal type="number">0</literal></argument>)</argument_list></macro>

<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_fast_dictMatchState</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>mls</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>minMatch</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>dictMatchState</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch<condition>(<expr><name>mls</name></expr>)</condition>
    <block>{<block_content>
    <default>default:</default> <comment type="block">/* includes case 3 */</comment>
    <case>case <expr><literal type="number">4</literal></expr> :</case>
        <return>return <expr><call><name>ZSTD_compressBlock_fast_dictMatchState_4_0</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><literal type="number">5</literal></expr> :</case>
        <return>return <expr><call><name>ZSTD_compressBlock_fast_dictMatchState_5_0</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><literal type="number">6</literal></expr> :</case>
        <return>return <expr><call><name>ZSTD_compressBlock_fast_dictMatchState_6_0</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><literal type="number">7</literal></expr> :</case>
        <return>return <expr><call><name>ZSTD_compressBlock_fast_dictMatchState_7_0</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_compressBlock_fast_extDict_generic</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>mls</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>hasStep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_compressionParameters</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cParams</name> <init>= <expr><operator>&amp;</operator><name><name>ms</name><operator>-&gt;</operator><name>cParams</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>hashTable</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>hashTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>hlog</name> <init>= <expr><name><name>cParams</name><operator>-&gt;</operator><name>hashLog</name></name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* support stepSize of 0 */</comment>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>stepSize</name> <init>= <expr><name><name>cParams</name><operator>-&gt;</operator><name>targetLength</name></name> <operator>+</operator> <operator>!</operator><operator>(</operator><name><name>cParams</name><operator>-&gt;</operator><name>targetLength</name></name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>base</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictBase</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictBase</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>istart</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>anchor</name> <init>= <expr><name>istart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type>   <name>endIndex</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>istart</name> <operator>-</operator> <name>base</name><operator>)</operator> <operator>+</operator> <name>srcSize</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type>   <name>lowLimit</name> <init>= <expr><call><name>ZSTD_getLowestMatchIndex</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>endIndex</name></expr></argument>, <argument><expr><name><name>cParams</name><operator>-&gt;</operator><name>windowLog</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type>   <name>dictStartIndex</name> <init>= <expr><name>lowLimit</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictStart</name> <init>= <expr><name>dictBase</name> <operator>+</operator> <name>dictStartIndex</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type>   <name>dictLimit</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictLimit</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type>   <name>prefixStartIndex</name> <init>= <expr><ternary><condition><expr><name>dictLimit</name> <operator>&lt;</operator> <name>lowLimit</name></expr> ?</condition><then> <expr><name>lowLimit</name></expr> </then><else>: <expr><name>dictLimit</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>prefixStart</name> <init>= <expr><name>base</name> <operator>+</operator> <name>prefixStartIndex</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictEnd</name> <init>= <expr><name>dictBase</name> <operator>+</operator> <name>prefixStartIndex</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name> <init>= <expr><name>istart</name> <operator>+</operator> <name>srcSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ilimit</name> <init>= <expr><name>iend</name> <operator>-</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>offset_1</name><init>=<expr><name><name>rep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>, <decl><type ref="prev"/><name>offset_2</name><init>=<expr><name><name>rep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>offsetSaved1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>offsetSaved2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip0</name> <init>= <expr><name>istart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip3</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>current0</name></decl>;</decl_stmt>


    <decl_stmt><decl><type><name>size_t</name></type> <name>hash0</name></decl>;</decl_stmt> <comment type="block">/* hash for ip0 */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>hash1</name></decl>;</decl_stmt> <comment type="block">/* hash for ip1 */</comment>
    <decl_stmt><decl><type><name>U32</name></type> <name>idx</name></decl>;</decl_stmt> <comment type="block">/* match idx for ip0 */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>idxBase</name></decl>;</decl_stmt> <comment type="block">/* base pointer for idx */</comment>

    <decl_stmt><decl><type><name>U32</name></type> <name>offcode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>match0</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>mLength</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>matchEnd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* initialize to avoid warning, assert != 0 later */</comment>

    <decl_stmt><decl><type><name>size_t</name></type> <name>step</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>nextStep</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>kStepIncr</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>kSearchStrength</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>hasStep</name></expr>;</expr_stmt> <comment type="block">/* not currently specialized on whether it's accelerated */</comment>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressBlock_fast_extDict_generic (offset_1=%u)"</literal></expr></argument>, <argument><expr><name>offset_1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* switch to "regular" variant if extDict is invalidated due to maxDistance */</comment>
    <if_stmt><if>if <condition>(<expr><name>prefixStartIndex</name> <operator>==</operator> <name>dictStartIndex</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>ZSTD_compressBlock_fast</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>curr</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip0</name> <operator>-</operator> <name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>maxRep</name> <init>= <expr><name>curr</name> <operator>-</operator> <name>dictStartIndex</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>offset_2</name> <operator>&gt;=</operator> <name>maxRep</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>offsetSaved2</name> <operator>=</operator> <name>offset_2</name></expr><operator>,</operator> <expr><name>offset_2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>offset_1</name> <operator>&gt;=</operator> <name>maxRep</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>offsetSaved1</name> <operator>=</operator> <name>offset_1</name></expr><operator>,</operator> <expr><name>offset_1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/* start each op */</comment>
<label><name>_start</name>:</label> <comment type="block">/* Requires: ip0 */</comment>

    <expr_stmt><expr><name>step</name> <operator>=</operator> <name>stepSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nextStep</name> <operator>=</operator> <name>ip0</name> <operator>+</operator> <name>kStepIncr</name></expr>;</expr_stmt>

    <comment type="block">/* calculate positions, ip0 - anchor == 0, so we skip step calc */</comment>
    <expr_stmt><expr><name>ip1</name> <operator>=</operator> <name>ip0</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>ip2</name> <operator>=</operator> <name>ip0</name> <operator>+</operator> <name>step</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ip3</name> <operator>=</operator> <name>ip2</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>ip3</name> <operator>&gt;=</operator> <name>ilimit</name></expr>)</condition> <block>{<block_content>
        <goto>goto <name>_cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>hash0</name> <operator>=</operator> <call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip0</name></expr></argument>, <argument><expr><name>hlog</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hash1</name> <operator>=</operator> <call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip1</name></expr></argument>, <argument><expr><name>hlog</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>idx</name> <operator>=</operator> <name><name>hashTable</name><index>[<expr><name>hash0</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>idxBase</name> <operator>=</operator> <ternary><condition><expr><name>idx</name> <operator>&lt;</operator> <name>prefixStartIndex</name></expr> ?</condition><then> <expr><name>dictBase</name></expr> </then><else>: <expr><name>base</name></expr></else></ternary></expr>;</expr_stmt>

    <do>do <block>{<block_content>
        <block>{<block_content>   <comment type="block">/* load repcode match for ip[2] */</comment>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>current2</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip2</name> <operator>-</operator> <name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>repIndex</name> <init>= <expr><name>current2</name> <operator>-</operator> <name>offset_1</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>repBase</name> <init>= <expr><ternary><condition><expr><name>repIndex</name> <operator>&lt;</operator> <name>prefixStartIndex</name></expr> ?</condition><then> <expr><name>dictBase</name></expr> </then><else>: <expr><name>base</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name></type> <name>rval</name></decl>;</decl_stmt>
            <if_stmt><if>if <condition>( <expr><operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>prefixStartIndex</name> <operator>-</operator> <name>repIndex</name><operator>)</operator> <operator>&gt;=</operator> <literal type="number">4</literal><operator>)</operator> <comment type="block">/* intentional underflow */</comment>
                 <operator>&amp;</operator> <operator>(</operator><name>offset_1</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> )</condition> <block>{<block_content>
                <expr_stmt><expr><name>rval</name> <operator>=</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>repBase</name> <operator>+</operator> <name>repIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>rval</name> <operator>=</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip2</name></expr></argument>)</argument_list></call> <operator>^</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* guaranteed to not match. */</comment>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/* write back hash table entry */</comment>
            <expr_stmt><expr><name>current0</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip0</name> <operator>-</operator> <name>base</name><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hashTable</name><index>[<expr><name>hash0</name></expr>]</index></name> <operator>=</operator> <name>current0</name></expr>;</expr_stmt>

            <comment type="block">/* check repcode at ip[2] */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip2</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rval</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>ip0</name> <operator>=</operator> <name>ip2</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>match0</name> <operator>=</operator> <name>repBase</name> <operator>+</operator> <name>repIndex</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>matchEnd</name> <operator>=</operator> <ternary><condition><expr><name>repIndex</name> <operator>&lt;</operator> <name>prefixStartIndex</name></expr> ?</condition><then> <expr><name>dictEnd</name></expr> </then><else>: <expr><name>iend</name></expr></else></ternary></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>match0</name> <operator>!=</operator> <name>prefixStart</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>match0</name> <operator>!=</operator> <name>dictStart</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>mLength</name> <operator>=</operator> <name><name>ip0</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>match0</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>ip0</name> <operator>-=</operator> <name>mLength</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>match0</name> <operator>-=</operator> <name>mLength</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>offcode</name> <operator>=</operator> <name>REPCODE1_TO_OFFBASE</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>mLength</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
                <goto>goto <name>_match</name>;</goto>
        </block_content>}</block></if></if_stmt>   </block_content>}</block>

        <block>{<block_content>   <comment type="block">/* load match for ip[0] */</comment>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>mval</name> <init>= <expr><ternary><condition><expr><name>idx</name> <operator>&gt;=</operator> <name>dictStartIndex</name></expr> ?</condition><then>
                    <expr><call><name>MEM_read32</name><argument_list>(<argument><expr><name>idxBase</name> <operator>+</operator> <name>idx</name></expr></argument>)</argument_list></call></expr> </then><else>:
                    <expr><call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip0</name></expr></argument>)</argument_list></call> <operator>^</operator> <literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt> <comment type="block">/* guaranteed not to match */</comment>

            <comment type="block">/* check match at ip[0] */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip0</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>mval</name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* found a match! */</comment>
                <goto>goto <name>_offset</name>;</goto>
        </block_content>}</block></if></if_stmt>   </block_content>}</block>

        <comment type="block">/* lookup ip[1] */</comment>
        <expr_stmt><expr><name>idx</name> <operator>=</operator> <name><name>hashTable</name><index>[<expr><name>hash1</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>idxBase</name> <operator>=</operator> <ternary><condition><expr><name>idx</name> <operator>&lt;</operator> <name>prefixStartIndex</name></expr> ?</condition><then> <expr><name>dictBase</name></expr> </then><else>: <expr><name>base</name></expr></else></ternary></expr>;</expr_stmt>

        <comment type="block">/* hash ip[2] */</comment>
        <expr_stmt><expr><name>hash0</name> <operator>=</operator> <name>hash1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>hash1</name> <operator>=</operator> <call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip2</name></expr></argument>, <argument><expr><name>hlog</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* advance to next positions */</comment>
        <expr_stmt><expr><name>ip0</name> <operator>=</operator> <name>ip1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ip1</name> <operator>=</operator> <name>ip2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ip2</name> <operator>=</operator> <name>ip3</name></expr>;</expr_stmt>

        <comment type="block">/* write back hash table entry */</comment>
        <expr_stmt><expr><name>current0</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip0</name> <operator>-</operator> <name>base</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hashTable</name><index>[<expr><name>hash0</name></expr>]</index></name> <operator>=</operator> <name>current0</name></expr>;</expr_stmt>

        <block>{<block_content>   <comment type="block">/* load match for ip[0] */</comment>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>mval</name> <init>= <expr><ternary><condition><expr><name>idx</name> <operator>&gt;=</operator> <name>dictStartIndex</name></expr> ?</condition><then>
                    <expr><call><name>MEM_read32</name><argument_list>(<argument><expr><name>idxBase</name> <operator>+</operator> <name>idx</name></expr></argument>)</argument_list></call></expr> </then><else>:
                    <expr><call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip0</name></expr></argument>)</argument_list></call> <operator>^</operator> <literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt> <comment type="block">/* guaranteed not to match */</comment>

            <comment type="block">/* check match at ip[0] */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip0</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>mval</name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* found a match! */</comment>
                <goto>goto <name>_offset</name>;</goto>
        </block_content>}</block></if></if_stmt>   </block_content>}</block>

        <comment type="block">/* lookup ip[1] */</comment>
        <expr_stmt><expr><name>idx</name> <operator>=</operator> <name><name>hashTable</name><index>[<expr><name>hash1</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>idxBase</name> <operator>=</operator> <ternary><condition><expr><name>idx</name> <operator>&lt;</operator> <name>prefixStartIndex</name></expr> ?</condition><then> <expr><name>dictBase</name></expr> </then><else>: <expr><name>base</name></expr></else></ternary></expr>;</expr_stmt>

        <comment type="block">/* hash ip[2] */</comment>
        <expr_stmt><expr><name>hash0</name> <operator>=</operator> <name>hash1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>hash1</name> <operator>=</operator> <call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip2</name></expr></argument>, <argument><expr><name>hlog</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* advance to next positions */</comment>
        <expr_stmt><expr><name>ip0</name> <operator>=</operator> <name>ip1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ip1</name> <operator>=</operator> <name>ip2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ip2</name> <operator>=</operator> <name>ip0</name> <operator>+</operator> <name>step</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ip3</name> <operator>=</operator> <name>ip1</name> <operator>+</operator> <name>step</name></expr>;</expr_stmt>

        <comment type="block">/* calculate step */</comment>
        <if_stmt><if>if <condition>(<expr><name>ip2</name> <operator>&gt;=</operator> <name>nextStep</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>step</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PREFETCH_L1</name><argument_list>(<argument><expr><name>ip1</name> <operator>+</operator> <literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PREFETCH_L1</name><argument_list>(<argument><expr><name>ip1</name> <operator>+</operator> <literal type="number">128</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>nextStep</name> <operator>+=</operator> <name>kStepIncr</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block> while <condition>(<expr><name>ip3</name> <operator>&lt;</operator> <name>ilimit</name></expr>)</condition>;</do>

<label><name>_cleanup</name>:</label>
    <comment type="block">/* Note that there are probably still a couple positions we could search.
     * However, it seems to be a meaningful performance hit to try to search
     * them. So let's not. */</comment>

    <comment type="block">/* If offset_1 started invalid (offsetSaved1 != 0) and became valid (offset_1 != 0),
     * rotate saved offsets. See comment in ZSTD_compressBlock_fast_noDict for more context. */</comment>
    <expr_stmt><expr><name>offsetSaved2</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>(</operator><name>offsetSaved1</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>offset_1</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><name>offsetSaved1</name></expr> </then><else>: <expr><name>offsetSaved2</name></expr></else></ternary></expr>;</expr_stmt>

    <comment type="block">/* save reps for next block */</comment>
    <expr_stmt><expr><name><name>rep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>offset_1</name></expr> ?</condition><then> <expr><name>offset_1</name></expr> </then><else>: <expr><name>offsetSaved1</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>offset_2</name></expr> ?</condition><then> <expr><name>offset_2</name></expr> </then><else>: <expr><name>offsetSaved2</name></expr></else></ternary></expr>;</expr_stmt>

    <comment type="block">/* Return the last literals size */</comment>
    <return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>iend</name> <operator>-</operator> <name>anchor</name><operator>)</operator></expr>;</return>

<label><name>_offset</name>:</label> <comment type="block">/* Requires: ip0, idx, idxBase */</comment>

    <comment type="block">/* Compute the offset code. */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>offset</name> <init>= <expr><name>current0</name> <operator>-</operator> <name>idx</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>lowMatchPtr</name> <init>= <expr><ternary><condition><expr><name>idx</name> <operator>&lt;</operator> <name>prefixStartIndex</name></expr> ?</condition><then> <expr><name>dictStart</name></expr> </then><else>: <expr><name>prefixStart</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>matchEnd</name> <operator>=</operator> <ternary><condition><expr><name>idx</name> <operator>&lt;</operator> <name>prefixStartIndex</name></expr> ?</condition><then> <expr><name>dictEnd</name></expr> </then><else>: <expr><name>iend</name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name>match0</name> <operator>=</operator> <name>idxBase</name> <operator>+</operator> <name>idx</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>offset_2</name> <operator>=</operator> <name>offset_1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>offset_1</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>offcode</name> <operator>=</operator> <call><name>OFFSET_TO_OFFBASE</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mLength</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

        <comment type="block">/* Count the backwards match length. */</comment>
        <while>while <condition>(<expr><operator>(</operator><operator>(</operator><name>ip0</name><operator>&gt;</operator><name>anchor</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>match0</name><operator>&gt;</operator><name>lowMatchPtr</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ip0</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>match0</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>ip0</name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>match0</name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>mLength</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>   </block_content>}</block>

<label><name>_match</name>:</label> <comment type="block">/* Requires: ip0, match0, offcode, matchEnd */</comment>

    <comment type="block">/* Count the forward length. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>matchEnd</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mLength</name> <operator>+=</operator> <call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip0</name> <operator>+</operator> <name>mLength</name></expr></argument>, <argument><expr><name>match0</name> <operator>+</operator> <name>mLength</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>matchEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ZSTD_storeSeq</name><argument_list>(<argument><expr><name>seqStore</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>ip0</name> <operator>-</operator> <name>anchor</name><operator>)</operator></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>offcode</name></expr></argument>, <argument><expr><name>mLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ip0</name> <operator>+=</operator> <name>mLength</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>anchor</name> <operator>=</operator> <name>ip0</name></expr>;</expr_stmt>

    <comment type="block">/* write next hash table entry */</comment>
    <if_stmt><if>if <condition>(<expr><name>ip1</name> <operator>&lt;</operator> <name>ip0</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>hashTable</name><index>[<expr><name>hash1</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip1</name> <operator>-</operator> <name>base</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Fill table and check for immediate repcode. */</comment>
    <if_stmt><if>if <condition>(<expr><name>ip0</name> <operator>&lt;=</operator> <name>ilimit</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Fill Table */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>base</name><operator>+</operator><name>current0</name><operator>+</operator><literal type="number">2</literal> <operator>&gt;</operator> <name>istart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* check base overflow */</comment>
        <expr_stmt><expr><name><name>hashTable</name><index>[<expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>base</name><operator>+</operator><name>current0</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>hlog</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>current0</name><operator>+</operator><literal type="number">2</literal></expr>;</expr_stmt>  <comment type="block">/* here because current+2 could be &gt; iend-8 */</comment>
        <expr_stmt><expr><name><name>hashTable</name><index>[<expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip0</name><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>hlog</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip0</name><operator>-</operator><literal type="number">2</literal><operator>-</operator><name>base</name><operator>)</operator></expr>;</expr_stmt>

        <while>while <condition>(<expr><name>ip0</name> <operator>&lt;=</operator> <name>ilimit</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>repIndex2</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip0</name><operator>-</operator><name>base</name><operator>)</operator> <operator>-</operator> <name>offset_2</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>repMatch2</name> <init>= <expr><ternary><condition><expr><name>repIndex2</name> <operator>&lt;</operator> <name>prefixStartIndex</name></expr> ?</condition><then> <expr><name>dictBase</name> <operator>+</operator> <name>repIndex2</name></expr> </then><else>: <expr><name>base</name> <operator>+</operator> <name>repIndex2</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>( <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>prefixStartIndex</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name>repIndex2</name><operator>)</operator> <operator>&gt;=</operator> <literal type="number">3</literal><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>offset_2</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator>  <comment type="block">/* intentional underflow */</comment>
                 <operator>&amp;&amp;</operator> <operator>(</operator><call><name>MEM_read32</name><argument_list>(<argument><expr><name>repMatch2</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip0</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition> <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>repEnd2</name> <init>= <expr><ternary><condition><expr><name>repIndex2</name> <operator>&lt;</operator> <name>prefixStartIndex</name></expr> ?</condition><then> <expr><name>dictEnd</name></expr> </then><else>: <expr><name>iend</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>repLength2</name> <init>= <expr><call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip0</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>repMatch2</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>repEnd2</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>
                <block>{<block_content> <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>tmpOffset</name> <init>= <expr><name>offset_2</name></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name>offset_2</name> <operator>=</operator> <name>offset_1</name></expr>;</expr_stmt> <expr_stmt><expr><name>offset_1</name> <operator>=</operator> <name>tmpOffset</name></expr>;</expr_stmt> </block_content>}</block>  <comment type="block">/* swap offset_2 &lt;=&gt; offset_1 */</comment>
                <expr_stmt><expr><call><name>ZSTD_storeSeq</name><argument_list>(<argument><expr><name>seqStore</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/*litlen*/</comment>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>REPCODE1_TO_OFFBASE</name></expr></argument>, <argument><expr><name>repLength2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>hashTable</name><index>[<expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip0</name></expr></argument>, <argument><expr><name>hlog</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip0</name><operator>-</operator><name>base</name><operator>)</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>ip0</name> <operator>+=</operator> <name>repLength2</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>anchor</name> <operator>=</operator> <name>ip0</name></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
    </block_content>}</block></while>   </block_content>}</block></if></if_stmt>

    <goto>goto <name>_start</name>;</goto>
</block_content>}</block></function>

<macro><name>ZSTD_GEN_FAST_FN</name><argument_list>(<argument>extDict</argument>, <argument><literal type="number">4</literal></argument>, <argument><literal type="number">0</literal></argument>)</argument_list></macro>
<macro><name>ZSTD_GEN_FAST_FN</name><argument_list>(<argument>extDict</argument>, <argument><literal type="number">5</literal></argument>, <argument><literal type="number">0</literal></argument>)</argument_list></macro>
<macro><name>ZSTD_GEN_FAST_FN</name><argument_list>(<argument>extDict</argument>, <argument><literal type="number">6</literal></argument>, <argument><literal type="number">0</literal></argument>)</argument_list></macro>
<macro><name>ZSTD_GEN_FAST_FN</name><argument_list>(<argument>extDict</argument>, <argument><literal type="number">7</literal></argument>, <argument><literal type="number">0</literal></argument>)</argument_list></macro>

<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_fast_extDict</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>mls</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>minMatch</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>dictMatchState</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch<condition>(<expr><name>mls</name></expr>)</condition>
    <block>{<block_content>
    <default>default:</default> <comment type="block">/* includes case 3 */</comment>
    <case>case <expr><literal type="number">4</literal></expr> :</case>
        <return>return <expr><call><name>ZSTD_compressBlock_fast_extDict_4_0</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><literal type="number">5</literal></expr> :</case>
        <return>return <expr><call><name>ZSTD_compressBlock_fast_extDict_5_0</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><literal type="number">6</literal></expr> :</case>
        <return>return <expr><call><name>ZSTD_compressBlock_fast_extDict_6_0</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><literal type="number">7</literal></expr> :</case>
        <return>return <expr><call><name>ZSTD_compressBlock_fast_extDict_7_0</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>
</unit>
