<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/zstd/zstd_subset/compress/zstd_opt.c"><comment type="block">/*
 * Copyright (c) Przemyslaw Skibinski, Yann Collet, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_compress_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_opt.h"</cpp:file></cpp:include>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZSTD_LITFREQ_ADD</name></cpp:macro>    <cpp:value>2</cpp:value></cpp:define>   <comment type="block">/* scaling factor for litFreq, so that frequencies adapt faster to new stats */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZSTD_MAX_PRICE</name></cpp:macro>     <cpp:value>(1&lt;&lt;30)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZSTD_PREDEF_THRESHOLD</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>   <comment type="block">/* if srcSize &lt; ZSTD_PREDEF_THRESHOLD, symbols' cost is assumed static, directly determined by pre-defined distributions */</comment>


<comment type="block">/*-*************************************
*  Price functions for optimal parser
***************************************/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>    <comment type="block">/* approximation at bit level (for tests) */</comment>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>BITCOST_ACCURACY</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>BITCOST_MULTIPLIER</name></cpp:macro> <cpp:value>(1 &lt;&lt; BITCOST_ACCURACY)</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>WEIGHT</name><parameter_list>(<parameter><type><name>stat</name></type></parameter>, <parameter><type><name>opt</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void)opt, ZSTD_bitWeight(stat))</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:elif>  <comment type="block">/* fractional bit accuracy (for tests) */</comment>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>BITCOST_ACCURACY</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>BITCOST_MULTIPLIER</name></cpp:macro> <cpp:value>(1 &lt;&lt; BITCOST_ACCURACY)</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>WEIGHT</name><parameter_list>(<parameter><type><name>stat</name></type></parameter>,<parameter><type><name>opt</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void)opt, ZSTD_fracWeight(stat))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>    <comment type="block">/* opt==approx, ultra==accurate */</comment>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>BITCOST_ACCURACY</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>BITCOST_MULTIPLIER</name></cpp:macro> <cpp:value>(1 &lt;&lt; BITCOST_ACCURACY)</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>WEIGHT</name><parameter_list>(<parameter><type><name>stat</name></type></parameter>,<parameter><type><name>opt</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(opt ? ZSTD_fracWeight(stat) : ZSTD_bitWeight(stat))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>MEM_STATIC</name> <name>U32</name></type> <name>ZSTD_bitWeight</name><parameter_list>(<parameter><decl><type><name>U32</name></type> <name>stat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><name>stat</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>*</operator> <name>BITCOST_MULTIPLIER</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>MEM_STATIC</name> <name>U32</name></type> <name>ZSTD_fracWeight</name><parameter_list>(<parameter><decl><type><name>U32</name></type> <name>rawStat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>stat</name> <init>= <expr><name>rawStat</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>hb</name> <init>= <expr><call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><name>stat</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>BWeight</name> <init>= <expr><name>hb</name> <operator>*</operator> <name>BITCOST_MULTIPLIER</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>FWeight</name> <init>= <expr><operator>(</operator><name>stat</name> <operator>&lt;&lt;</operator> <name>BITCOST_ACCURACY</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>hb</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>weight</name> <init>= <expr><name>BWeight</name> <operator>+</operator> <name>FWeight</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>hb</name> <operator>+</operator> <name>BITCOST_ACCURACY</name> <operator>&lt;</operator> <literal type="number">31</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>weight</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>DEBUGLEVEL</name><operator>&gt;=</operator><literal type="number">2</literal><operator>)</operator></expr></cpp:if>
<comment type="block">/* debugging function,
 * @return price in bytes as fractional value
 * for debug messages only */</comment>
<function><type><name>MEM_STATIC</name> <name>double</name></type> <name>ZSTD_fCost</name><parameter_list>(<parameter><decl><type><name>U32</name></type> <name>price</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><name>double</name><operator>)</operator><name>price</name> <operator>/</operator> <operator>(</operator><name>BITCOST_MULTIPLIER</name><operator>*</operator><literal type="number">8</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ZSTD_compressedLiterals</name><parameter_list>(<parameter><decl><type><name>optState_t</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>optPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name><name>optPtr</name><operator>-&gt;</operator><name>literalCompressionMode</name></name> <operator>!=</operator> <name>ZSTD_ps_disable</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_setBasePrices</name><parameter_list>(<parameter><decl><type><name>optState_t</name><modifier>*</modifier></type> <name>optPtr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>optLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>ZSTD_compressedLiterals</name><argument_list>(<argument><expr><name>optPtr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>litSumBasePrice</name></name> <operator>=</operator> <call><name>WEIGHT</name><argument_list>(<argument><expr><name><name>optPtr</name><operator>-&gt;</operator><name>litSum</name></name></expr></argument>, <argument><expr><name>optLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>litLengthSumBasePrice</name></name> <operator>=</operator> <call><name>WEIGHT</name><argument_list>(<argument><expr><name><name>optPtr</name><operator>-&gt;</operator><name>litLengthSum</name></name></expr></argument>, <argument><expr><name>optLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>matchLengthSumBasePrice</name></name> <operator>=</operator> <call><name>WEIGHT</name><argument_list>(<argument><expr><name><name>optPtr</name><operator>-&gt;</operator><name>matchLengthSum</name></name></expr></argument>, <argument><expr><name>optLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>offCodeSumBasePrice</name></name> <operator>=</operator> <call><name>WEIGHT</name><argument_list>(<argument><expr><name><name>optPtr</name><operator>-&gt;</operator><name>offCodeSum</name></name></expr></argument>, <argument><expr><name>optLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>U32</name></type> <name>sum_u32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name><name>table</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nbElts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>total</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name><operator>&lt;</operator><name>nbElts</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name>total</name> <operator>+=</operator> <name><name>table</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>total</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>U32</name></type> <name>ZSTD_downscaleStats</name><parameter_list>(<parameter><decl><type><name>unsigned</name><modifier>*</modifier></type> <name>table</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>lastEltIndex</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>shift</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>sum</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_downscaleStats (nbElts=%u, shift=%u)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>lastEltIndex</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>shift</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>shift</name> <operator>&lt;</operator> <literal type="number">30</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>s</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>s</name><operator>&lt;</operator><name>lastEltIndex</name><operator>+</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>table</name><index>[<expr><name>s</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name><name>table</name><index>[<expr><name>s</name></expr>]</index></name> <operator>&gt;&gt;</operator> <name>shift</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>sum</name> <operator>+=</operator> <name><name>table</name><index>[<expr><name>s</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>sum</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ZSTD_scaleStats() :
 * reduce all elements in table is sum too large
 * return the resulting sum of elements */</comment>
<function><type><specifier>static</specifier> <name>U32</name></type> <name>ZSTD_scaleStats</name><parameter_list>(<parameter><decl><type><name>unsigned</name><modifier>*</modifier></type> <name>table</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>lastEltIndex</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>logTarget</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>prevsum</name> <init>= <expr><call><name>sum_u32</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>lastEltIndex</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>factor</name> <init>= <expr><name>prevsum</name> <operator>&gt;&gt;</operator> <name>logTarget</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_scaleStats (nbElts=%u, target=%u)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>lastEltIndex</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>logTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>logTarget</name> <operator>&lt;</operator> <literal type="number">30</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>factor</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>prevsum</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>ZSTD_downscaleStats</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>lastEltIndex</name></expr></argument>, <argument><expr><call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><name>factor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ZSTD_rescaleFreqs() :
 * if first block (detected by optPtr-&gt;litLengthSum == 0) : init statistics
 *    take hints from dictionary if there is one
 *    and init from zero if there is none,
 *    using src for literals stats, and baseline stats for sequence symbols
 * otherwise downscale existing stats, to be used as seed for next block.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ZSTD_rescaleFreqs</name><parameter_list>(<parameter><decl><type><name>optState_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>optPtr</name></decl></parameter>,
            <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>srcSize</name></decl></parameter>,
                  <parameter><decl><type><name>int</name> <specifier>const</specifier></type> <name>optLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>compressedLiterals</name> <init>= <expr><call><name>ZSTD_compressedLiterals</name><argument_list>(<argument><expr><name>optPtr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_rescaleFreqs (srcSize=%u)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>priceType</name></name> <operator>=</operator> <name>zop_dynamic</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>optPtr</name><operator>-&gt;</operator><name>litLengthSum</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* first block : init */</comment>
        <if_stmt><if>if <condition>(<expr><name>srcSize</name> <operator>&lt;=</operator> <name>ZSTD_PREDEF_THRESHOLD</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* heuristic */</comment>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"(srcSize &lt;= ZSTD_PREDEF_THRESHOLD) =&gt; zop_predef"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>priceType</name></name> <operator>=</operator> <name>zop_predef</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>optPtr</name><operator>-&gt;</operator><name>symbolCosts</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>optPtr</name><operator>-&gt;</operator><name>symbolCosts</name><operator>-&gt;</operator><name>huf</name><operator>.</operator><name>repeatMode</name></name> <operator>==</operator> <name>HUF_repeat_valid</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* huffman table presumed generated by dictionary */</comment>
            <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>priceType</name></name> <operator>=</operator> <name>zop_dynamic</name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>compressedLiterals</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>unsigned</name></type> <name>lit</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>optPtr</name><operator>-&gt;</operator><name>litFreq</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>litSum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <for>for <control>(<init><expr><name>lit</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>lit</name><operator>&lt;=</operator><name>MaxLit</name></expr>;</condition> <incr><expr><name>lit</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>scaleLog</name> <init>= <expr><literal type="number">11</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* scale to 2K */</comment>
                    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>bitCost</name> <init>= <expr><call><name>HUF_getNbBitsFromCTable</name><argument_list>(<argument><expr><name><name>optPtr</name><operator>-&gt;</operator><name>symbolCosts</name><operator>-&gt;</operator><name>huf</name><operator>.</operator><name>CTable</name></name></expr></argument>, <argument><expr><name>lit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>bitCost</name> <operator>&lt;=</operator> <name>scaleLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>litFreq</name><index>[<expr><name>lit</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>bitCost</name></expr> ?</condition><then> <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>scaleLog</name><operator>-</operator><name>bitCost</name><operator>)</operator></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr> <comment type="block">/*minimum to calculate cost*/</comment>;</expr_stmt>
                    <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>litSum</name></name> <operator>+=</operator> <name><name>optPtr</name><operator>-&gt;</operator><name>litFreq</name><index>[<expr><name>lit</name></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></for>   </block_content>}</block></if></if_stmt>

            <block>{<block_content>   <decl_stmt><decl><type><name>unsigned</name></type> <name>ll</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>FSE_CState_t</name></type> <name>llstate</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>FSE_initCState</name><argument_list>(<argument><expr><operator>&amp;</operator><name>llstate</name></expr></argument>, <argument><expr><name><name>optPtr</name><operator>-&gt;</operator><name>symbolCosts</name><operator>-&gt;</operator><name>fse</name><operator>.</operator><name>litlengthCTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>litLengthSum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <for>for <control>(<init><expr><name>ll</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ll</name><operator>&lt;=</operator><name>MaxLL</name></expr>;</condition> <incr><expr><name>ll</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>scaleLog</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* scale to 1K */</comment>
                    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>bitCost</name> <init>= <expr><call><name>FSE_getMaxNbBits</name><argument_list>(<argument><expr><name><name>llstate</name><operator>.</operator><name>symbolTT</name></name></expr></argument>, <argument><expr><name>ll</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>bitCost</name> <operator>&lt;</operator> <name>scaleLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>litLengthFreq</name><index>[<expr><name>ll</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>bitCost</name></expr> ?</condition><then> <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>scaleLog</name><operator>-</operator><name>bitCost</name><operator>)</operator></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr> <comment type="block">/*minimum to calculate cost*/</comment>;</expr_stmt>
                    <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>litLengthSum</name></name> <operator>+=</operator> <name><name>optPtr</name><operator>-&gt;</operator><name>litLengthFreq</name><index>[<expr><name>ll</name></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></for>   </block_content>}</block>

            <block>{<block_content>   <decl_stmt><decl><type><name>unsigned</name></type> <name>ml</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>FSE_CState_t</name></type> <name>mlstate</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>FSE_initCState</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mlstate</name></expr></argument>, <argument><expr><name><name>optPtr</name><operator>-&gt;</operator><name>symbolCosts</name><operator>-&gt;</operator><name>fse</name><operator>.</operator><name>matchlengthCTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>matchLengthSum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <for>for <control>(<init><expr><name>ml</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ml</name><operator>&lt;=</operator><name>MaxML</name></expr>;</condition> <incr><expr><name>ml</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>scaleLog</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>bitCost</name> <init>= <expr><call><name>FSE_getMaxNbBits</name><argument_list>(<argument><expr><name><name>mlstate</name><operator>.</operator><name>symbolTT</name></name></expr></argument>, <argument><expr><name>ml</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>bitCost</name> <operator>&lt;</operator> <name>scaleLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>matchLengthFreq</name><index>[<expr><name>ml</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>bitCost</name></expr> ?</condition><then> <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>scaleLog</name><operator>-</operator><name>bitCost</name><operator>)</operator></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr> <comment type="block">/*minimum to calculate cost*/</comment>;</expr_stmt>
                    <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>matchLengthSum</name></name> <operator>+=</operator> <name><name>optPtr</name><operator>-&gt;</operator><name>matchLengthFreq</name><index>[<expr><name>ml</name></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></for>   </block_content>}</block>

            <block>{<block_content>   <decl_stmt><decl><type><name>unsigned</name></type> <name>of</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>FSE_CState_t</name></type> <name>ofstate</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>FSE_initCState</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ofstate</name></expr></argument>, <argument><expr><name><name>optPtr</name><operator>-&gt;</operator><name>symbolCosts</name><operator>-&gt;</operator><name>fse</name><operator>.</operator><name>offcodeCTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>offCodeSum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <for>for <control>(<init><expr><name>of</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>of</name><operator>&lt;=</operator><name>MaxOff</name></expr>;</condition> <incr><expr><name>of</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>scaleLog</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>bitCost</name> <init>= <expr><call><name>FSE_getMaxNbBits</name><argument_list>(<argument><expr><name><name>ofstate</name><operator>.</operator><name>symbolTT</name></name></expr></argument>, <argument><expr><name>of</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>bitCost</name> <operator>&lt;</operator> <name>scaleLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>offCodeFreq</name><index>[<expr><name>of</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>bitCost</name></expr> ?</condition><then> <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>scaleLog</name><operator>-</operator><name>bitCost</name><operator>)</operator></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr> <comment type="block">/*minimum to calculate cost*/</comment>;</expr_stmt>
                    <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>offCodeSum</name></name> <operator>+=</operator> <name><name>optPtr</name><operator>-&gt;</operator><name>offCodeFreq</name><index>[<expr><name>of</name></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></for>   </block_content>}</block>

        </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* not a dictionary */</comment>

            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>optPtr</name><operator>-&gt;</operator><name>litFreq</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>compressedLiterals</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>unsigned</name></type> <name>lit</name> <init>= <expr><name>MaxLit</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>HIST_count_simple</name><argument_list>(<argument><expr><name><name>optPtr</name><operator>-&gt;</operator><name>litFreq</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lit</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* use raw first block to init statistics */</comment>
                <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>litSum</name></name> <operator>=</operator> <call><name>ZSTD_downscaleStats</name><argument_list>(<argument><expr><name><name>optPtr</name><operator>-&gt;</operator><name>litFreq</name></name></expr></argument>, <argument><expr><name>MaxLit</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <block>{<block_content>   <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name><name>baseLLfreqs</name><index>[<expr><name>MaxLL</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{
                    <expr><literal type="number">4</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,
                    <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,
                    <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,
                    <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,
                    <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>
                }</block></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name><name>optPtr</name><operator>-&gt;</operator><name>litLengthFreq</name></name></expr></argument>, <argument><expr><name>baseLLfreqs</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>baseLLfreqs</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>litLengthSum</name></name> <operator>=</operator> <call><name>sum_u32</name><argument_list>(<argument><expr><name>baseLLfreqs</name></expr></argument>, <argument><expr><name>MaxLL</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>

            <block>{<block_content>   <decl_stmt><decl><type><name>unsigned</name></type> <name>ml</name></decl>;</decl_stmt>
                <for>for <control>(<init><expr><name>ml</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ml</name><operator>&lt;=</operator><name>MaxML</name></expr>;</condition> <incr><expr><name>ml</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>matchLengthFreq</name><index>[<expr><name>ml</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
            </block_content>}</block>
            <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>matchLengthSum</name></name> <operator>=</operator> <name>MaxML</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>

            <block>{<block_content>   <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name><name>baseOFCfreqs</name><index>[<expr><name>MaxOff</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{
                    <expr><literal type="number">6</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>,
                    <expr><literal type="number">4</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,
                    <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,
                    <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>
                }</block></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name><name>optPtr</name><operator>-&gt;</operator><name>offCodeFreq</name></name></expr></argument>, <argument><expr><name>baseOFCfreqs</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>baseOFCfreqs</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>offCodeSum</name></name> <operator>=</operator> <call><name>sum_u32</name><argument_list>(<argument><expr><name>baseOFCfreqs</name></expr></argument>, <argument><expr><name>MaxOff</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>


        </block_content>}</block></else></if_stmt>

    </block_content>}</block></if> <else>else <block>{<block_content>   <comment type="block">/* new block : re-use previous statistics, scaled down */</comment>

        <if_stmt><if>if <condition>(<expr><name>compressedLiterals</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>litSum</name></name> <operator>=</operator> <call><name>ZSTD_scaleStats</name><argument_list>(<argument><expr><name><name>optPtr</name><operator>-&gt;</operator><name>litFreq</name></name></expr></argument>, <argument><expr><name>MaxLit</name></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>litLengthSum</name></name> <operator>=</operator> <call><name>ZSTD_scaleStats</name><argument_list>(<argument><expr><name><name>optPtr</name><operator>-&gt;</operator><name>litLengthFreq</name></name></expr></argument>, <argument><expr><name>MaxLL</name></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>matchLengthSum</name></name> <operator>=</operator> <call><name>ZSTD_scaleStats</name><argument_list>(<argument><expr><name><name>optPtr</name><operator>-&gt;</operator><name>matchLengthFreq</name></name></expr></argument>, <argument><expr><name>MaxML</name></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>offCodeSum</name></name> <operator>=</operator> <call><name>ZSTD_scaleStats</name><argument_list>(<argument><expr><name><name>optPtr</name><operator>-&gt;</operator><name>offCodeFreq</name></name></expr></argument>, <argument><expr><name>MaxOff</name></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>ZSTD_setBasePrices</name><argument_list>(<argument><expr><name>optPtr</name></expr></argument>, <argument><expr><name>optLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ZSTD_rawLiteralsCost() :
 * price of literals (only) in specified segment (which length can be 0).
 * does not include price of literalLength symbol */</comment>
<function><type><specifier>static</specifier> <name>U32</name></type> <name>ZSTD_rawLiteralsCost</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>literals</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>litLength</name></decl></parameter>,
                                <parameter><decl><type><specifier>const</specifier> <name>optState_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>optPtr</name></decl></parameter>,
                                <parameter><decl><type><name>int</name></type> <name>optLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>litLength</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ZSTD_compressedLiterals</name><argument_list>(<argument><expr><name>optPtr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>(</operator><name>litLength</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>*</operator> <name>BITCOST_MULTIPLIER</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Uncompressed - 8 bytes per literal. */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>optPtr</name><operator>-&gt;</operator><name>priceType</name></name> <operator>==</operator> <name>zop_predef</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>(</operator><name>litLength</name><operator>*</operator><literal type="number">6</literal><operator>)</operator> <operator>*</operator> <name>BITCOST_MULTIPLIER</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* 6 bit per literal - no statistic used */</comment>

    <comment type="block">/* dynamic statistics */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>U32</name></type> <name>price</name> <init>= <expr><name><name>optPtr</name><operator>-&gt;</operator><name>litSumBasePrice</name></name> <operator>*</operator> <name>litLength</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>litPriceMax</name> <init>= <expr><name><name>optPtr</name><operator>-&gt;</operator><name>litSumBasePrice</name></name> <operator>-</operator> <name>BITCOST_MULTIPLIER</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name></type> <name>u</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>optPtr</name><operator>-&gt;</operator><name>litSumBasePrice</name></name> <operator>&gt;=</operator> <name>BITCOST_MULTIPLIER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>u</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>u</name> <operator>&lt;</operator> <name>litLength</name></expr>;</condition> <incr><expr><name>u</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>U32</name></type> <name>litPrice</name> <init>= <expr><call><name>WEIGHT</name><argument_list>(<argument><expr><name><name>optPtr</name><operator>-&gt;</operator><name>litFreq</name><index>[<expr><name><name>literals</name><index>[<expr><name>u</name></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><name>optLevel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><name>litPrice</name> <operator>&gt;</operator> <name>litPriceMax</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>litPrice</name> <operator>=</operator> <name>litPriceMax</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>price</name> <operator>-=</operator> <name>litPrice</name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <return>return <expr><name>price</name></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/* ZSTD_litLengthPrice() :
 * cost of literalLength symbol */</comment>
<function><type><specifier>static</specifier> <name>U32</name></type> <name>ZSTD_litLengthPrice</name><parameter_list>(<parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>litLength</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>optState_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>optPtr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>optLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>litLength</name> <operator>&lt;=</operator> <name>ZSTD_BLOCKSIZE_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>optPtr</name><operator>-&gt;</operator><name>priceType</name></name> <operator>==</operator> <name>zop_predef</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>WEIGHT</name><argument_list>(<argument><expr><name>litLength</name></expr></argument>, <argument><expr><name>optLevel</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* We can't compute the litLength price for sizes &gt;= ZSTD_BLOCKSIZE_MAX
     * because it isn't representable in the zstd format. So instead just
     * call it 1 bit more than ZSTD_BLOCKSIZE_MAX - 1. In this case the block
     * would be all literals.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>litLength</name> <operator>==</operator> <name>ZSTD_BLOCKSIZE_MAX</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>BITCOST_MULTIPLIER</name> <operator>+</operator> <call><name>ZSTD_litLengthPrice</name><argument_list>(<argument><expr><name>ZSTD_BLOCKSIZE_MAX</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>optPtr</name></expr></argument>, <argument><expr><name>optLevel</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* dynamic statistics */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>llCode</name> <init>= <expr><call><name>ZSTD_LLcode</name><argument_list>(<argument><expr><name>litLength</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><operator>(</operator><name><name>LL_bits</name><index>[<expr><name>llCode</name></expr>]</index></name> <operator>*</operator> <name>BITCOST_MULTIPLIER</name><operator>)</operator>
             <operator>+</operator> <name><name>optPtr</name><operator>-&gt;</operator><name>litLengthSumBasePrice</name></name>
             <operator>-</operator> <call><name>WEIGHT</name><argument_list>(<argument><expr><name><name>optPtr</name><operator>-&gt;</operator><name>litLengthFreq</name><index>[<expr><name>llCode</name></expr>]</index></name></expr></argument>, <argument><expr><name>optLevel</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/* ZSTD_getMatchPrice() :
 * Provides the cost of the match part (offset + matchLength) of a sequence
 * Must be combined with ZSTD_fullLiteralsCost() to get the full cost of a sequence.
 * @offBase : sumtype, representing an offset or a repcode, and using numeric representation of ZSTD_storeSeq()
 * @optLevel: when &lt;2, favors small offset for decompression speed (improved cache efficiency)
 */</comment>
<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>U32</name></type>
<name>ZSTD_getMatchPrice</name><parameter_list>(<parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>offBase</name></decl></parameter>,
                   <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>matchLength</name></decl></parameter>,
             <parameter><decl><type><specifier>const</specifier> <name>optState_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>optPtr</name></decl></parameter>,
                   <parameter><decl><type><name>int</name> <specifier>const</specifier></type> <name>optLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name></type> <name>price</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>offCode</name> <init>= <expr><call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><name>offBase</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>mlBase</name> <init>= <expr><name>matchLength</name> <operator>-</operator> <name>MINMATCH</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>matchLength</name> <operator>&gt;=</operator> <name>MINMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>optPtr</name><operator>-&gt;</operator><name>priceType</name></name> <operator>==</operator> <name>zop_predef</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* fixed scheme, do not use statistics */</comment>
        <return>return <expr><call><name>WEIGHT</name><argument_list>(<argument><expr><name>mlBase</name></expr></argument>, <argument><expr><name>optLevel</name></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><operator>(</operator><literal type="number">16</literal> <operator>+</operator> <name>offCode</name><operator>)</operator> <operator>*</operator> <name>BITCOST_MULTIPLIER</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* dynamic statistics */</comment>
    <expr_stmt><expr><name>price</name> <operator>=</operator> <operator>(</operator><name>offCode</name> <operator>*</operator> <name>BITCOST_MULTIPLIER</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>optPtr</name><operator>-&gt;</operator><name>offCodeSumBasePrice</name></name> <operator>-</operator> <call><name>WEIGHT</name><argument_list>(<argument><expr><name><name>optPtr</name><operator>-&gt;</operator><name>offCodeFreq</name><index>[<expr><name>offCode</name></expr>]</index></name></expr></argument>, <argument><expr><name>optLevel</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>optLevel</name><operator>&lt;</operator><literal type="number">2</literal><operator>)</operator> <comment type="block">/*static*/</comment> <operator>&amp;&amp;</operator> <name>offCode</name> <operator>&gt;=</operator> <literal type="number">20</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>price</name> <operator>+=</operator> <operator>(</operator><name>offCode</name><operator>-</operator><literal type="number">19</literal><operator>)</operator><operator>*</operator><literal type="number">2</literal> <operator>*</operator> <name>BITCOST_MULTIPLIER</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* handicap for long distance offsets, favor decompression speed */</comment>

    <comment type="block">/* match Length */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>mlCode</name> <init>= <expr><call><name>ZSTD_MLcode</name><argument_list>(<argument><expr><name>mlBase</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>price</name> <operator>+=</operator> <operator>(</operator><name><name>ML_bits</name><index>[<expr><name>mlCode</name></expr>]</index></name> <operator>*</operator> <name>BITCOST_MULTIPLIER</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>optPtr</name><operator>-&gt;</operator><name>matchLengthSumBasePrice</name></name> <operator>-</operator> <call><name>WEIGHT</name><argument_list>(<argument><expr><name><name>optPtr</name><operator>-&gt;</operator><name>matchLengthFreq</name><index>[<expr><name>mlCode</name></expr>]</index></name></expr></argument>, <argument><expr><name>optLevel</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name>price</name> <operator>+=</operator> <name>BITCOST_MULTIPLIER</name> <operator>/</operator> <literal type="number">5</literal></expr>;</expr_stmt>   <comment type="block">/* heuristic : make matches a bit more costly to favor less sequences -&gt; faster decompression speed */</comment>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_getMatchPrice(ml:%u) = %u"</literal></expr></argument>, <argument><expr><name>matchLength</name></expr></argument>, <argument><expr><name>price</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>price</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ZSTD_updateStats() :
 * assumption : literals + litLength &lt;= iend */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_updateStats</name><parameter_list>(<parameter><decl><type><name>optState_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>optPtr</name></decl></parameter>,
                             <parameter><decl><type><name>U32</name></type> <name>litLength</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>literals</name></decl></parameter>,
                             <parameter><decl><type><name>U32</name></type> <name>offBase</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>matchLength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* literals */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ZSTD_compressedLiterals</name><argument_list>(<argument><expr><name>optPtr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name></type> <name>u</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>u</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>u</name> <operator>&lt;</operator> <name>litLength</name></expr>;</condition> <incr><expr><name>u</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>litFreq</name><index>[<expr><name><name>literals</name><index>[<expr><name>u</name></expr>]</index></name></expr>]</index></name> <operator>+=</operator> <name>ZSTD_LITFREQ_ADD</name></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>litSum</name></name> <operator>+=</operator> <name>litLength</name><operator>*</operator><name>ZSTD_LITFREQ_ADD</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* literal Length */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>llCode</name> <init>= <expr><call><name>ZSTD_LLcode</name><argument_list>(<argument><expr><name>litLength</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>litLengthFreq</name><index>[<expr><name>llCode</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>litLengthSum</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* offset code : expected to follow storeSeq() numeric representation */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>offCode</name> <init>= <expr><call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><name>offBase</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>offCode</name> <operator>&lt;=</operator> <name>MaxOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>offCodeFreq</name><index>[<expr><name>offCode</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>offCodeSum</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* match Length */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>mlBase</name> <init>= <expr><name>matchLength</name> <operator>-</operator> <name>MINMATCH</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>mlCode</name> <init>= <expr><call><name>ZSTD_MLcode</name><argument_list>(<argument><expr><name>mlBase</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>matchLengthFreq</name><index>[<expr><name>mlCode</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>optPtr</name><operator>-&gt;</operator><name>matchLengthSum</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>
</block_content>}</block></function>


<comment type="block">/* ZSTD_readMINMATCH() :
 * function safe only for comparisons
 * assumption : memPtr must be at least 4 bytes before end of buffer */</comment>
<function><type><name>MEM_STATIC</name> <name>U32</name></type> <name>ZSTD_readMINMATCH</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>memPtr</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch <condition>(<expr><name>length</name></expr>)</condition>
    <block>{<block_content>
    <default>default :</default>
    <case>case <expr><literal type="number">4</literal></expr> :</case> <return>return <expr><call><name>MEM_read32</name><argument_list>(<argument><expr><name>memPtr</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><literal type="number">3</literal></expr> :</case> <if_stmt><if>if <condition>(<expr><call><name>MEM_isLittleEndian</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><call><name>MEM_read32</name><argument_list>(<argument><expr><name>memPtr</name></expr></argument>)</argument_list></call><operator>&lt;&lt;</operator><literal type="number">8</literal></expr>;</return></block_content></block></if>
             <else>else<block type="pseudo"><block_content>
                <return>return <expr><call><name>MEM_read32</name><argument_list>(<argument><expr><name>memPtr</name></expr></argument>)</argument_list></call><operator>&gt;&gt;</operator><literal type="number">8</literal></expr>;</return></block_content></block></else></if_stmt>
    </block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/* Update hashTable3 up to ip (excluded)
   Assumption : always within prefix (i.e. not within extDict) */</comment>
<function><type><specifier>static</specifier> <name>U32</name></type> <name>ZSTD_insertAndFindFirstIndexHash3</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>,
                                              <parameter><decl><type><name>U32</name><modifier>*</modifier></type> <name>nextToUpdate3</name></decl></parameter>,
                                              <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ip</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>hashTable3</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>hashTable3</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>hashLog3</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>hashLog3</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>base</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>idx</name> <init>= <expr><operator>*</operator><name>nextToUpdate3</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>target</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>hash3</name> <init>= <expr><call><name>ZSTD_hash3Ptr</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>hashLog3</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>hashLog3</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while<condition>(<expr><name>idx</name> <operator>&lt;</operator> <name>target</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>hashTable3</name><index>[<expr><call><name>ZSTD_hash3Ptr</name><argument_list>(<argument><expr><name>base</name><operator>+</operator><name>idx</name></expr></argument>, <argument><expr><name>hashLog3</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><operator>*</operator><name>nextToUpdate3</name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
    <return>return <expr><name><name>hashTable3</name><index>[<expr><name>hash3</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*-*************************************
*  Binary Tree search
***************************************/</comment>
<comment type="block" format="doxygen">/** ZSTD_insertBt1() : add one or multiple positions to tree.
 * @param ip assumed &lt;= iend-8 .
 * @param target The target of ZSTD_updateTree_internal() - we are filling to this position
 * @return : nb of positions added */</comment>
<function><type><specifier>static</specifier> <name>U32</name></type> <name>ZSTD_insertBt1</name><parameter_list>(
                <parameter><decl><type><specifier>const</specifier> <name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ip</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name></decl></parameter>,
                <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>target</name></decl></parameter>,
                <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>mls</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>extDict</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_compressionParameters</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cParams</name> <init>= <expr><operator>&amp;</operator><name><name>ms</name><operator>-&gt;</operator><name>cParams</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier>   <specifier>const</specifier></type> <name>hashTable</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>hashTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>    <specifier>const</specifier></type> <name>hashLog</name> <init>= <expr><name><name>cParams</name><operator>-&gt;</operator><name>hashLog</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>h</name>  <init>= <expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>hashLog</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier>   <specifier>const</specifier></type> <name>bt</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>chainTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>    <specifier>const</specifier></type> <name>btLog</name>  <init>= <expr><name><name>cParams</name><operator>-&gt;</operator><name>chainLog</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>    <specifier>const</specifier></type> <name>btMask</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>btLog</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>matchIndex</name> <init>= <expr><name><name>hashTable</name><index>[<expr><name>h</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>commonLengthSmaller</name><init>=<expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>commonLengthLarger</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>base</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictBase</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictBase</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dictLimit</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictLimit</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictEnd</name> <init>= <expr><name>dictBase</name> <operator>+</operator> <name>dictLimit</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>prefixStart</name> <init>= <expr><name>base</name> <operator>+</operator> <name>dictLimit</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>match</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>curr</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>btLow</name> <init>= <expr><ternary><condition><expr><name>btMask</name> <operator>&gt;=</operator> <name>curr</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>curr</name> <operator>-</operator> <name>btMask</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier></type> <name>smallerPtr</name> <init>= <expr><name>bt</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><operator>(</operator><name>curr</name><operator>&amp;</operator><name>btMask</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier></type> <name>largerPtr</name>  <init>= <expr><name>smallerPtr</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>dummy32</name></decl>;</decl_stmt>   <comment type="block">/* to be nullified at the end */</comment>
    <comment type="block">/* windowLow is based on target because
     * we only need positions that will be in the window at the end of the tree update.
     */</comment>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>windowLow</name> <init>= <expr><call><name>ZSTD_getLowestMatchIndex</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name><name>cParams</name><operator>-&gt;</operator><name>windowLog</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>matchEndIdx</name> <init>= <expr><name>curr</name><operator>+</operator><literal type="number">8</literal><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>bestLength</name> <init>= <expr><literal type="number">8</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>nbCompares</name> <init>= <expr><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name><name>cParams</name><operator>-&gt;</operator><name>searchLog</name></name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ZSTD_C_PREDICT</name></cpp:ifdef>
    <decl_stmt><decl><type><name>U32</name></type> <name>predictedSmall</name> <init>= <expr><operator>*</operator><operator>(</operator><name>bt</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><operator>(</operator><operator>(</operator><name>curr</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>&amp;</operator><name>btMask</name><operator>)</operator> <operator>+</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>predictedLarge</name> <init>= <expr><operator>*</operator><operator>(</operator><name>bt</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><operator>(</operator><operator>(</operator><name>curr</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>&amp;</operator><name>btMask</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>predictedSmall</name> <operator>+=</operator> <operator>(</operator><name>predictedSmall</name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>predictedLarge</name> <operator>+=</operator> <operator>(</operator><name>predictedLarge</name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ZSTD_C_PREDICT */</comment>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_insertBt1 (%u)"</literal></expr></argument>, <argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>curr</name> <operator>&lt;=</operator> <name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ip</name> <operator>&lt;=</operator> <name>iend</name><operator>-</operator><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* required for h calculation */</comment>
    <expr_stmt><expr><name><name>hashTable</name><index>[<expr><name>h</name></expr>]</index></name> <operator>=</operator> <name>curr</name></expr>;</expr_stmt>   <comment type="block">/* Update Hash Table */</comment>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>windowLow</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init>;</init> <condition><expr><name>nbCompares</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>matchIndex</name> <operator>&gt;=</operator> <name>windowLow</name><operator>)</operator></expr>;</condition> <incr><expr><operator>--</operator><name>nbCompares</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>nextPtr</name> <init>= <expr><name>bt</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><operator>(</operator><name>matchIndex</name> <operator>&amp;</operator> <name>btMask</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>matchLength</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name>commonLengthSmaller</name></expr></argument>, <argument><expr><name>commonLengthLarger</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>   <comment type="block">/* guaranteed minimum nb of common bytes */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>matchIndex</name> <operator>&lt;</operator> <name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ZSTD_C_PREDICT</name></cpp:ifdef>   <comment type="block">/* note : can create issues when hlog small &lt;= 11 */</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name><modifier>*</modifier></type> <name>predictPtr</name> <init>= <expr><name>bt</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><operator>(</operator><operator>(</operator><name>matchIndex</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <name>btMask</name><operator>)</operator></expr></init></decl>;</decl_stmt>   <comment type="block">/* written this way, as bt is a roll buffer */</comment>
        <if_stmt><if>if <condition>(<expr><name>matchIndex</name> <operator>==</operator> <name>predictedSmall</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* no need to check length, result known */</comment>
            <expr_stmt><expr><operator>*</operator><name>smallerPtr</name> <operator>=</operator> <name>matchIndex</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>matchIndex</name> <operator>&lt;=</operator> <name>btLow</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>smallerPtr</name><operator>=</operator><operator>&amp;</operator><name>dummy32</name></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>   <comment type="block">/* beyond tree size, stop the search */</comment>
            <expr_stmt><expr><name>smallerPtr</name> <operator>=</operator> <name>nextPtr</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>               <comment type="block">/* new "smaller" =&gt; larger of match */</comment>
            <expr_stmt><expr><name>matchIndex</name> <operator>=</operator> <name><name>nextPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>              <comment type="block">/* new matchIndex larger than previous (closer to current) */</comment>
            <expr_stmt><expr><name>predictedSmall</name> <operator>=</operator> <name><name>predictPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name><name>predictPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>matchIndex</name> <operator>==</operator> <name>predictedLarge</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>largerPtr</name> <operator>=</operator> <name>matchIndex</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>matchIndex</name> <operator>&lt;=</operator> <name>btLow</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>largerPtr</name><operator>=</operator><operator>&amp;</operator><name>dummy32</name></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>   <comment type="block">/* beyond tree size, stop the search */</comment>
            <expr_stmt><expr><name>largerPtr</name> <operator>=</operator> <name>nextPtr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>matchIndex</name> <operator>=</operator> <name><name>nextPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>predictedLarge</name> <operator>=</operator> <name><name>predictPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name><name>predictPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>extDict</name> <operator>||</operator> <operator>(</operator><name>matchIndex</name><operator>+</operator><name>matchLength</name> <operator>&gt;=</operator> <name>dictLimit</name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>matchIndex</name><operator>+</operator><name>matchLength</name> <operator>&gt;=</operator> <name>dictLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* might be wrong if actually extDict */</comment>
            <expr_stmt><expr><name>match</name> <operator>=</operator> <name>base</name> <operator>+</operator> <name>matchIndex</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>matchLength</name> <operator>+=</operator> <call><name>ZSTD_count</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><name>matchLength</name></expr></argument>, <argument><expr><name>match</name><operator>+</operator><name>matchLength</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>match</name> <operator>=</operator> <name>dictBase</name> <operator>+</operator> <name>matchIndex</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>matchLength</name> <operator>+=</operator> <call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><name>matchLength</name></expr></argument>, <argument><expr><name>match</name><operator>+</operator><name>matchLength</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>dictEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>matchIndex</name><operator>+</operator><name>matchLength</name> <operator>&gt;=</operator> <name>dictLimit</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>match</name> <operator>=</operator> <name>base</name> <operator>+</operator> <name>matchIndex</name></expr>;</expr_stmt></block_content></block></if></if_stmt>   <comment type="block">/* to prepare for next usage of match[matchLength] */</comment>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>matchLength</name> <operator>&gt;</operator> <name>bestLength</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>bestLength</name> <operator>=</operator> <name>matchLength</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>matchLength</name> <operator>&gt;</operator> <name>matchEndIdx</name> <operator>-</operator> <name>matchIndex</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>matchEndIdx</name> <operator>=</operator> <name>matchIndex</name> <operator>+</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>matchLength</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>ip</name><operator>+</operator><name>matchLength</name> <operator>==</operator> <name>iend</name></expr>)</condition> <block>{<block_content>   <comment type="block">/* equal : no way to know if inf or sup */</comment>
            <break>break;</break>   <comment type="block">/* drop , to guarantee consistency ; miss a bit of compression, but other solutions can corrupt tree */</comment>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>match</name><index>[<expr><name>matchLength</name></expr>]</index></name> <operator>&lt;</operator> <name><name>ip</name><index>[<expr><name>matchLength</name></expr>]</index></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* necessarily within buffer */</comment>
            <comment type="block">/* match is smaller than current */</comment>
            <expr_stmt><expr><operator>*</operator><name>smallerPtr</name> <operator>=</operator> <name>matchIndex</name></expr>;</expr_stmt>             <comment type="block">/* update smaller idx */</comment>
            <expr_stmt><expr><name>commonLengthSmaller</name> <operator>=</operator> <name>matchLength</name></expr>;</expr_stmt>    <comment type="block">/* all smaller will now have at least this guaranteed common length */</comment>
            <if_stmt><if>if <condition>(<expr><name>matchIndex</name> <operator>&lt;=</operator> <name>btLow</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>smallerPtr</name><operator>=</operator><operator>&amp;</operator><name>dummy32</name></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>   <comment type="block">/* beyond tree size, stop searching */</comment>
            <expr_stmt><expr><name>smallerPtr</name> <operator>=</operator> <name>nextPtr</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>               <comment type="block">/* new "candidate" =&gt; larger than match, which was smaller than target */</comment>
            <expr_stmt><expr><name>matchIndex</name> <operator>=</operator> <name><name>nextPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>              <comment type="block">/* new matchIndex, larger than previous and closer to current */</comment>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* match is larger than current */</comment>
            <expr_stmt><expr><operator>*</operator><name>largerPtr</name> <operator>=</operator> <name>matchIndex</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>commonLengthLarger</name> <operator>=</operator> <name>matchLength</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>matchIndex</name> <operator>&lt;=</operator> <name>btLow</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>largerPtr</name><operator>=</operator><operator>&amp;</operator><name>dummy32</name></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>   <comment type="block">/* beyond tree size, stop searching */</comment>
            <expr_stmt><expr><name>largerPtr</name> <operator>=</operator> <name>nextPtr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>matchIndex</name> <operator>=</operator> <name><name>nextPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>   </block_content>}</block></for>

    <expr_stmt><expr><operator>*</operator><name>smallerPtr</name> <operator>=</operator> <operator>*</operator><name>largerPtr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>U32</name></type> <name>positions</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>bestLength</name> <operator>&gt;</operator> <literal type="number">384</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>positions</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><literal type="number">192</literal></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>bestLength</name> <operator>-</operator> <literal type="number">384</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>   <comment type="block">/* speed optimization */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>matchEndIdx</name> <operator>&gt;</operator> <name>curr</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>MAX</name><argument_list>(<argument><expr><name>positions</name></expr></argument>, <argument><expr><name>matchEndIdx</name> <operator>-</operator> <operator>(</operator><name>curr</name> <operator>+</operator> <literal type="number">8</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>

<function><type><name>FORCE_INLINE_TEMPLATE</name>
<name>void</name></type> <name>ZSTD_updateTree_internal</name><parameter_list>(
                <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ip</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name>mls</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ZSTD_dictMode_e</name></type> <name>dictMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>base</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>target</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>idx</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_updateTree_internal, from %u to %u  (dictMode:%u)"</literal></expr></argument>,
                <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>dictMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while<condition>(<expr><name>idx</name> <operator>&lt;</operator> <name>target</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>forward</name> <init>= <expr><call><name>ZSTD_insertBt1</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>base</name><operator>+</operator><name>idx</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>, <argument><expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_extDict</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>idx</name> <operator>&lt;</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>idx</name> <operator>+</operator> <name>forward</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>idx</name> <operator>+=</operator> <name>forward</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>base</name><operator>)</operator> <operator>&lt;=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>iend</name> <operator>-</operator> <name>base</name><operator>)</operator> <operator>&lt;=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>ZSTD_updateTree</name><parameter_list>(<parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>iend</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>ZSTD_updateTree_internal</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name><name>ms</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>minMatch</name></name></expr></argument>, <argument><expr><name>ZSTD_noDict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>FORCE_INLINE_TEMPLATE</name>
<name>U32</name></type> <name>ZSTD_insertBtAndGetAllMatches</name> <parameter_list>(
                    <parameter><decl><type><name>ZSTD_match_t</name><modifier>*</modifier></type> <name>matches</name></decl></parameter>,   <comment type="block">/* store result (found matches) in this table (presumed large enough) */</comment>
                    <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>,
                    <parameter><decl><type><name>U32</name><modifier>*</modifier></type> <name>nextToUpdate3</name></decl></parameter>,
                    <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ip</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iLimit</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ZSTD_dictMode_e</name></type> <name>dictMode</name></decl></parameter>,
                    <parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
                    <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>ll0</name></decl></parameter>,   <comment type="block">/* tells if associated literal length is 0 or not. This value must be 0 or 1 */</comment>
                    <parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name>lengthToBeat</name></decl></parameter>,
                    <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>mls</name></decl></parameter> <comment type="block">/* template */</comment>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_compressionParameters</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cParams</name> <init>= <expr><operator>&amp;</operator><name><name>ms</name><operator>-&gt;</operator><name>cParams</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>sufficient_len</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name><name>cParams</name><operator>-&gt;</operator><name>targetLength</name></name></expr></argument>, <argument><expr><name>ZSTD_OPT_NUM</name> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>base</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>curr</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>hashLog</name> <init>= <expr><name><name>cParams</name><operator>-&gt;</operator><name>hashLog</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>minMatch</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>mls</name><operator>==</operator><literal type="number">3</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">3</literal></expr> </then><else>: <expr><literal type="number">4</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>hashTable</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>hashTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>h</name>  <init>= <expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>hashLog</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>matchIndex</name>  <init>= <expr><name><name>hashTable</name><index>[<expr><name>h</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>bt</name>   <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>chainTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>btLog</name> <init>= <expr><name><name>cParams</name><operator>-&gt;</operator><name>chainLog</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>btMask</name><init>= <expr><operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>btLog</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>commonLengthSmaller</name><init>=<expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>commonLengthLarger</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictBase</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictBase</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>dictLimit</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictLimit</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictEnd</name> <init>= <expr><name>dictBase</name> <operator>+</operator> <name>dictLimit</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>prefixStart</name> <init>= <expr><name>base</name> <operator>+</operator> <name>dictLimit</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>btLow</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>btMask</name> <operator>&gt;=</operator> <name>curr</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>curr</name> <operator>-</operator> <name>btMask</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>windowLow</name> <init>= <expr><call><name>ZSTD_getLowestMatchIndex</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>curr</name></expr></argument>, <argument><expr><name><name>cParams</name><operator>-&gt;</operator><name>windowLog</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>matchLow</name> <init>= <expr><ternary><condition><expr><name>windowLow</name></expr> ?</condition><then> <expr><name>windowLow</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier></type> <name>smallerPtr</name> <init>= <expr><name>bt</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><operator>(</operator><name>curr</name><operator>&amp;</operator><name>btMask</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier></type> <name>largerPtr</name>  <init>= <expr><name>bt</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><operator>(</operator><name>curr</name><operator>&amp;</operator><name>btMask</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>matchEndIdx</name> <init>= <expr><name>curr</name><operator>+</operator><literal type="number">8</literal><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* farthest referenced position of any match =&gt; detects repetitive patterns */</comment>
    <decl_stmt><decl><type><name>U32</name></type> <name>dummy32</name></decl>;</decl_stmt>   <comment type="block">/* to be nullified at the end */</comment>
    <decl_stmt><decl><type><name>U32</name></type> <name>mnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>nbCompares</name> <init>= <expr><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name><name>cParams</name><operator>-&gt;</operator><name>searchLog</name></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>dms</name>    <init>= <expr><ternary><condition><expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_dictMatchState</name></expr> ?</condition><then> <expr><name><name>ms</name><operator>-&gt;</operator><name>dictMatchState</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_compressionParameters</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dmsCParams</name> <init>=
                                      <expr><ternary><condition><expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_dictMatchState</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>dms</name><operator>-&gt;</operator><name>cParams</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dmsBase</name>       <init>= <expr><ternary><condition><expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_dictMatchState</name></expr> ?</condition><then> <expr><name><name>dms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dmsEnd</name>        <init>= <expr><ternary><condition><expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_dictMatchState</name></expr> ?</condition><then> <expr><name><name>dms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>nextSrc</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>         <specifier>const</specifier></type> <name>dmsHighLimit</name>  <init>= <expr><ternary><condition><expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_dictMatchState</name></expr> ?</condition><then> <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>dmsEnd</name> <operator>-</operator> <name>dmsBase</name><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>         <specifier>const</specifier></type> <name>dmsLowLimit</name>   <init>= <expr><ternary><condition><expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_dictMatchState</name></expr> ?</condition><then> <expr><name><name>dms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>lowLimit</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>         <specifier>const</specifier></type> <name>dmsIndexDelta</name> <init>= <expr><ternary><condition><expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_dictMatchState</name></expr> ?</condition><then> <expr><name>windowLow</name> <operator>-</operator> <name>dmsHighLimit</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>         <specifier>const</specifier></type> <name>dmsHashLog</name>    <init>= <expr><ternary><condition><expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_dictMatchState</name></expr> ?</condition><then> <expr><name><name>dmsCParams</name><operator>-&gt;</operator><name>hashLog</name></name></expr> </then><else>: <expr><name>hashLog</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>         <specifier>const</specifier></type> <name>dmsBtLog</name>      <init>= <expr><ternary><condition><expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_dictMatchState</name></expr> ?</condition><then> <expr><name><name>dmsCParams</name><operator>-&gt;</operator><name>chainLog</name></name> <operator>-</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>btLog</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>         <specifier>const</specifier></type> <name>dmsBtMask</name>     <init>= <expr><ternary><condition><expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_dictMatchState</name></expr> ?</condition><then> <expr><operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>dmsBtLog</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>         <specifier>const</specifier></type> <name>dmsBtLow</name>      <init>= <expr><ternary><condition><expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_dictMatchState</name> <operator>&amp;&amp;</operator> <name>dmsBtMask</name> <operator>&lt;</operator> <name>dmsHighLimit</name> <operator>-</operator> <name>dmsLowLimit</name></expr> ?</condition><then> <expr><name>dmsHighLimit</name> <operator>-</operator> <name>dmsBtMask</name></expr> </then><else>: <expr><name>dmsLowLimit</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>size_t</name></type> <name>bestLength</name> <init>= <expr><name>lengthToBeat</name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_insertBtAndGetAllMatches: current=%u"</literal></expr></argument>, <argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check repCode */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ll0</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* necessarily 1 or 0 */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>lastR</name> <init>= <expr><name>ZSTD_REP_NUM</name> <operator>+</operator> <name>ll0</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name></type> <name>repCode</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>repCode</name> <operator>=</operator> <name>ll0</name></expr>;</init> <condition><expr><name>repCode</name> <operator>&lt;</operator> <name>lastR</name></expr>;</condition> <incr><expr><name>repCode</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>repOffset</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>repCode</name><operator>==</operator><name>ZSTD_REP_NUM</name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name><name>rep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><name><name>rep</name><index>[<expr><name>repCode</name></expr>]</index></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>repIndex</name> <init>= <expr><name>curr</name> <operator>-</operator> <name>repOffset</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name></type> <name>repLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>curr</name> <operator>&gt;=</operator> <name>dictLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>repOffset</name><operator>-</operator><literal type="number">1</literal> <comment type="block">/* intentional overflow, discards 0 and -1 */</comment> <operator>&lt;</operator> <name>curr</name><operator>-</operator><name>dictLimit</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* equivalent to `curr &gt; repIndex &gt;= dictLimit` */</comment>
                <comment type="block">/* We must validate the repcode offset because when we're using a dictionary the
                 * valid offset range shrinks when the dictionary goes out of bounds.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>repIndex</name> <operator>&gt;=</operator> <name>windowLow</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><call><name>ZSTD_readMINMATCH</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>minMatch</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>ZSTD_readMINMATCH</name><argument_list>(<argument><expr><name>ip</name> <operator>-</operator> <name>repOffset</name></expr></argument>, <argument><expr><name>minMatch</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>repLen</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><call><name>ZSTD_count</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><name>minMatch</name></expr></argument>, <argument><expr><name>ip</name><operator>+</operator><name>minMatch</name><operator>-</operator><name>repOffset</name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>minMatch</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* repIndex &lt; dictLimit || repIndex &gt;= curr */</comment>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>repMatch</name> <init>= <expr><ternary><condition><expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_dictMatchState</name></expr> ?</condition><then>
                                             <expr><name>dmsBase</name> <operator>+</operator> <name>repIndex</name> <operator>-</operator> <name>dmsIndexDelta</name></expr> </then><else>:
                                             <expr><name>dictBase</name> <operator>+</operator> <name>repIndex</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>curr</name> <operator>&gt;=</operator> <name>windowLow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>( <expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_extDict</name>
                  <operator>&amp;&amp;</operator> <operator>(</operator> <operator>(</operator><operator>(</operator><name>repOffset</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <comment type="block">/*intentional overflow*/</comment> <operator>&lt;</operator> <name>curr</name> <operator>-</operator> <name>windowLow</name><operator>)</operator>  <comment type="block">/* equivalent to `curr &gt; repIndex &gt;= windowLow` */</comment>
                     <operator>&amp;</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>dictLimit</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name>repIndex</name><operator>)</operator> <operator>&gt;=</operator> <literal type="number">3</literal><operator>)</operator> <operator>)</operator> <comment type="block">/* intentional overflow : do not test positions overlapping 2 memory segments */</comment><operator>)</operator>
                  <operator>&amp;&amp;</operator> <operator>(</operator><call><name>ZSTD_readMINMATCH</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>minMatch</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>ZSTD_readMINMATCH</name><argument_list>(<argument><expr><name>repMatch</name></expr></argument>, <argument><expr><name>minMatch</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition> <block>{<block_content>
                    <expr_stmt><expr><name>repLen</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><name>minMatch</name></expr></argument>, <argument><expr><name>repMatch</name><operator>+</operator><name>minMatch</name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>, <argument><expr><name>dictEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>minMatch</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_dictMatchState</name>
                  <operator>&amp;&amp;</operator> <operator>(</operator> <operator>(</operator><operator>(</operator><name>repOffset</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <comment type="block">/*intentional overflow*/</comment> <operator>&lt;</operator> <name>curr</name> <operator>-</operator> <operator>(</operator><name>dmsLowLimit</name> <operator>+</operator> <name>dmsIndexDelta</name><operator>)</operator><operator>)</operator>  <comment type="block">/* equivalent to `curr &gt; repIndex &gt;= dmsLowLimit` */</comment>
                     <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>dictLimit</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name>repIndex</name><operator>)</operator> <operator>&gt;=</operator> <literal type="number">3</literal><operator>)</operator> <operator>)</operator> <comment type="block">/* intentional overflow : do not test positions overlapping 2 memory segments */</comment>
                  <operator>&amp;&amp;</operator> <operator>(</operator><call><name>ZSTD_readMINMATCH</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>minMatch</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>ZSTD_readMINMATCH</name><argument_list>(<argument><expr><name>repMatch</name></expr></argument>, <argument><expr><name>minMatch</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition> <block>{<block_content>
                    <expr_stmt><expr><name>repLen</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><name>minMatch</name></expr></argument>, <argument><expr><name>repMatch</name><operator>+</operator><name>minMatch</name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>, <argument><expr><name>dmsEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>minMatch</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>   </block_content>}</block></else></if_stmt>
            <comment type="block">/* save longer solution */</comment>
            <if_stmt><if>if <condition>(<expr><name>repLen</name> <operator>&gt;</operator> <name>bestLength</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">"found repCode %u (ll0:%u, offset:%u) of length %u"</literal></expr></argument>,
                            <argument><expr><name>repCode</name></expr></argument>, <argument><expr><name>ll0</name></expr></argument>, <argument><expr><name>repOffset</name></expr></argument>, <argument><expr><name>repLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>bestLength</name> <operator>=</operator> <name>repLen</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>matches</name><index>[<expr><name>mnum</name></expr>]</index></name><operator>.</operator><name>off</name> <operator>=</operator> <call><name>REPCODE_TO_OFFBASE</name><argument_list>(<argument><expr><name>repCode</name> <operator>-</operator> <name>ll0</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* expect value between 1 and 3 */</comment>
                <expr_stmt><expr><name><name>matches</name><index>[<expr><name>mnum</name></expr>]</index></name><operator>.</operator><name>len</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>repLen</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>mnum</name><operator>++</operator></expr>;</expr_stmt>
                <if_stmt><if>if <condition>( <expr><operator>(</operator><name>repLen</name> <operator>&gt;</operator> <name>sufficient_len</name><operator>)</operator>
                   <operator>|</operator> <operator>(</operator><name>ip</name><operator>+</operator><name>repLen</name> <operator>==</operator> <name>iLimit</name><operator>)</operator></expr> )</condition> <block>{<block_content>  <comment type="block">/* best possible */</comment>
                    <return>return <expr><name>mnum</name></expr>;</return>
    </block_content>}</block></if></if_stmt>   </block_content>}</block></if></if_stmt>   </block_content>}</block></for>   </block_content>}</block>

    <comment type="block">/* HC3 match finder */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>mls</name> <operator>==</operator> <literal type="number">3</literal><operator>)</operator> <comment type="block">/*static*/</comment> <operator>&amp;&amp;</operator> <operator>(</operator><name>bestLength</name> <operator>&lt;</operator> <name>mls</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>matchIndex3</name> <init>= <expr><call><name>ZSTD_insertAndFindFirstIndexHash3</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>nextToUpdate3</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>matchIndex3</name> <operator>&gt;=</operator> <name>matchLow</name><operator>)</operator>
          <operator>&amp;</operator> <operator>(</operator><name>curr</name> <operator>-</operator> <name>matchIndex3</name> <operator>&lt;</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">18</literal><operator>)</operator><operator>)</operator></expr> <comment type="block">/*heuristic : longer distance likely too expensive*/</comment> )</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>size_t</name></type> <name>mlen</name></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>dictMode</name> <operator>==</operator> <name>ZSTD_noDict</name><operator>)</operator> <comment type="block">/*static*/</comment> <operator>||</operator> <operator>(</operator><name>dictMode</name> <operator>==</operator> <name>ZSTD_dictMatchState</name><operator>)</operator> <comment type="block">/*static*/</comment> <operator>||</operator> <operator>(</operator><name>matchIndex3</name> <operator>&gt;=</operator> <name>dictLimit</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>match</name> <init>= <expr><name>base</name> <operator>+</operator> <name>matchIndex3</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>mlen</name> <operator>=</operator> <call><name>ZSTD_count</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>match</name> <init>= <expr><name>dictBase</name> <operator>+</operator> <name>matchIndex3</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>mlen</name> <operator>=</operator> <call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>, <argument><expr><name>dictEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/* save best solution */</comment>
            <if_stmt><if>if <condition>(<expr><name>mlen</name> <operator>&gt;=</operator> <name>mls</name></expr> <comment type="block">/* == 3 &gt; bestLength */</comment>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">"found small match with hlog3, of length %u"</literal></expr></argument>,
                            <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>mlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>bestLength</name> <operator>=</operator> <name>mlen</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>curr</name> <operator>&gt;</operator> <name>matchIndex3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>mnum</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* no prior solution */</comment>
                <expr_stmt><expr><name><name>matches</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>off</name> <operator>=</operator> <call><name>OFFSET_TO_OFFBASE</name><argument_list>(<argument><expr><name>curr</name> <operator>-</operator> <name>matchIndex3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>matches</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>len</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>mlen</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>mnum</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <if_stmt><if>if <condition>( <expr><operator>(</operator><name>mlen</name> <operator>&gt;</operator> <name>sufficient_len</name><operator>)</operator> <operator>|</operator>
                     <operator>(</operator><name>ip</name><operator>+</operator><name>mlen</name> <operator>==</operator> <name>iLimit</name><operator>)</operator></expr> )</condition> <block>{<block_content>  <comment type="block">/* best possible length */</comment>
                    <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name> <operator>=</operator> <name>curr</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* skip insertion */</comment>
                    <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>   </block_content>}</block></if></if_stmt>   </block_content>}</block></if></if_stmt>
        <comment type="block">/* no dictMatchState lookup: dicts don't have a populated HC3 table */</comment>
    </block_content>}</block></if></if_stmt>  <comment type="block">/* if (mls == 3) */</comment>

    <expr_stmt><expr><name><name>hashTable</name><index>[<expr><name>h</name></expr>]</index></name> <operator>=</operator> <name>curr</name></expr>;</expr_stmt>   <comment type="block">/* Update Hash Table */</comment>

    <for>for <control>(<init>;</init> <condition><expr><name>nbCompares</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>matchIndex</name> <operator>&gt;=</operator> <name>matchLow</name><operator>)</operator></expr>;</condition> <incr><expr><operator>--</operator><name>nbCompares</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>nextPtr</name> <init>= <expr><name>bt</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><operator>(</operator><name>matchIndex</name> <operator>&amp;</operator> <name>btMask</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>match</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>matchLength</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name>commonLengthSmaller</name></expr></argument>, <argument><expr><name>commonLengthLarger</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>   <comment type="block">/* guaranteed minimum nb of common bytes */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>curr</name> <operator>&gt;</operator> <name>matchIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>dictMode</name> <operator>==</operator> <name>ZSTD_noDict</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>dictMode</name> <operator>==</operator> <name>ZSTD_dictMatchState</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>matchIndex</name><operator>+</operator><name>matchLength</name> <operator>&gt;=</operator> <name>dictLimit</name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>matchIndex</name><operator>+</operator><name>matchLength</name> <operator>&gt;=</operator> <name>dictLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* ensure the condition is correct when !extDict */</comment>
            <expr_stmt><expr><name>match</name> <operator>=</operator> <name>base</name> <operator>+</operator> <name>matchIndex</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>matchIndex</name> <operator>&gt;=</operator> <name>dictLimit</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><name>match</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>matchLength</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* ensure early section of match is equal as expected */</comment>
            <expr_stmt><expr><name>matchLength</name> <operator>+=</operator> <call><name>ZSTD_count</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><name>matchLength</name></expr></argument>, <argument><expr><name>match</name><operator>+</operator><name>matchLength</name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>match</name> <operator>=</operator> <name>dictBase</name> <operator>+</operator> <name>matchIndex</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><name>match</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>matchLength</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* ensure early section of match is equal as expected */</comment>
            <expr_stmt><expr><name>matchLength</name> <operator>+=</operator> <call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><name>matchLength</name></expr></argument>, <argument><expr><name>match</name><operator>+</operator><name>matchLength</name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>, <argument><expr><name>dictEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>matchIndex</name><operator>+</operator><name>matchLength</name> <operator>&gt;=</operator> <name>dictLimit</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>match</name> <operator>=</operator> <name>base</name> <operator>+</operator> <name>matchIndex</name></expr>;</expr_stmt></block_content></block></if></if_stmt>   <comment type="block">/* prepare for match[matchLength] read */</comment>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>matchLength</name> <operator>&gt;</operator> <name>bestLength</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">"found match of length %u at distance %u (offBase=%u)"</literal></expr></argument>,
                    <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>matchLength</name></expr></argument>, <argument><expr><name>curr</name> <operator>-</operator> <name>matchIndex</name></expr></argument>, <argument><expr><call><name>OFFSET_TO_OFFBASE</name><argument_list>(<argument><expr><name>curr</name> <operator>-</operator> <name>matchIndex</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>matchEndIdx</name> <operator>&gt;</operator> <name>matchIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>matchLength</name> <operator>&gt;</operator> <name>matchEndIdx</name> <operator>-</operator> <name>matchIndex</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>matchEndIdx</name> <operator>=</operator> <name>matchIndex</name> <operator>+</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>matchLength</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>bestLength</name> <operator>=</operator> <name>matchLength</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>matches</name><index>[<expr><name>mnum</name></expr>]</index></name><operator>.</operator><name>off</name> <operator>=</operator> <call><name>OFFSET_TO_OFFBASE</name><argument_list>(<argument><expr><name>curr</name> <operator>-</operator> <name>matchIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>matches</name><index>[<expr><name>mnum</name></expr>]</index></name><operator>.</operator><name>len</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>matchLength</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>mnum</name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>( <expr><operator>(</operator><name>matchLength</name> <operator>&gt;</operator> <name>ZSTD_OPT_NUM</name><operator>)</operator>
               <operator>|</operator> <operator>(</operator><name>ip</name><operator>+</operator><name>matchLength</name> <operator>==</operator> <name>iLimit</name><operator>)</operator></expr> <comment type="block">/* equal : no way to know if inf or sup */</comment>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_dictMatchState</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nbCompares</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* break should also skip searching dms */</comment>
                <break>break;</break> <comment type="block">/* drop, to preserve bt consistency (miss a little bit of compression) */</comment>
        </block_content>}</block></if></if_stmt>   </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>match</name><index>[<expr><name>matchLength</name></expr>]</index></name> <operator>&lt;</operator> <name><name>ip</name><index>[<expr><name>matchLength</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* match smaller than current */</comment>
            <expr_stmt><expr><operator>*</operator><name>smallerPtr</name> <operator>=</operator> <name>matchIndex</name></expr>;</expr_stmt>             <comment type="block">/* update smaller idx */</comment>
            <expr_stmt><expr><name>commonLengthSmaller</name> <operator>=</operator> <name>matchLength</name></expr>;</expr_stmt>    <comment type="block">/* all smaller will now have at least this guaranteed common length */</comment>
            <if_stmt><if>if <condition>(<expr><name>matchIndex</name> <operator>&lt;=</operator> <name>btLow</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>smallerPtr</name><operator>=</operator><operator>&amp;</operator><name>dummy32</name></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>   <comment type="block">/* beyond tree size, stop the search */</comment>
            <expr_stmt><expr><name>smallerPtr</name> <operator>=</operator> <name>nextPtr</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>               <comment type="block">/* new candidate =&gt; larger than match, which was smaller than current */</comment>
            <expr_stmt><expr><name>matchIndex</name> <operator>=</operator> <name><name>nextPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>              <comment type="block">/* new matchIndex, larger than previous, closer to current */</comment>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>largerPtr</name> <operator>=</operator> <name>matchIndex</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>commonLengthLarger</name> <operator>=</operator> <name>matchLength</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>matchIndex</name> <operator>&lt;=</operator> <name>btLow</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>largerPtr</name><operator>=</operator><operator>&amp;</operator><name>dummy32</name></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>   <comment type="block">/* beyond tree size, stop the search */</comment>
            <expr_stmt><expr><name>largerPtr</name> <operator>=</operator> <name>nextPtr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>matchIndex</name> <operator>=</operator> <name><name>nextPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>   </block_content>}</block></for>

    <expr_stmt><expr><operator>*</operator><name>smallerPtr</name> <operator>=</operator> <operator>*</operator><name>largerPtr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nbCompares</name> <operator>&lt;=</operator> <operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>ZSTD_SEARCHLOG_MAX</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Check we haven't underflowed. */</comment>
    <if_stmt><if>if <condition>(<expr><name>dictMode</name> <operator>==</operator> <name>ZSTD_dictMatchState</name> <operator>&amp;&amp;</operator> <name>nbCompares</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>dmsH</name> <init>= <expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>dmsHashLog</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name></type> <name>dictMatchIndex</name> <init>= <expr><name><name>dms</name><operator>-&gt;</operator><name>hashTable</name><index>[<expr><name>dmsH</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dmsBt</name> <init>= <expr><name><name>dms</name><operator>-&gt;</operator><name>chainTable</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>commonLengthSmaller</name> <operator>=</operator> <name>commonLengthLarger</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init>;</init> <condition><expr><name>nbCompares</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>dictMatchIndex</name> <operator>&gt;</operator> <name>dmsLowLimit</name><operator>)</operator></expr>;</condition> <incr><expr><operator>--</operator><name>nbCompares</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>nextPtr</name> <init>= <expr><name>dmsBt</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><operator>(</operator><name>dictMatchIndex</name> <operator>&amp;</operator> <name>dmsBtMask</name><operator>)</operator></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name></type> <name>matchLength</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name>commonLengthSmaller</name></expr></argument>, <argument><expr><name>commonLengthLarger</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>   <comment type="block">/* guaranteed minimum nb of common bytes */</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>match</name> <init>= <expr><name>dmsBase</name> <operator>+</operator> <name>dictMatchIndex</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>matchLength</name> <operator>+=</operator> <call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><name>matchLength</name></expr></argument>, <argument><expr><name>match</name><operator>+</operator><name>matchLength</name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>, <argument><expr><name>dmsEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>dictMatchIndex</name><operator>+</operator><name>matchLength</name> <operator>&gt;=</operator> <name>dmsHighLimit</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>match</name> <operator>=</operator> <name>base</name> <operator>+</operator> <name>dictMatchIndex</name> <operator>+</operator> <name>dmsIndexDelta</name></expr>;</expr_stmt></block_content></block></if></if_stmt>   <comment type="block">/* to prepare for next usage of match[matchLength] */</comment>

            <if_stmt><if>if <condition>(<expr><name>matchLength</name> <operator>&gt;</operator> <name>bestLength</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>matchIndex</name> <operator>=</operator> <name>dictMatchIndex</name> <operator>+</operator> <name>dmsIndexDelta</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">"found dms match of length %u at distance %u (offBase=%u)"</literal></expr></argument>,
                        <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>matchLength</name></expr></argument>, <argument><expr><name>curr</name> <operator>-</operator> <name>matchIndex</name></expr></argument>, <argument><expr><call><name>OFFSET_TO_OFFBASE</name><argument_list>(<argument><expr><name>curr</name> <operator>-</operator> <name>matchIndex</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>matchLength</name> <operator>&gt;</operator> <name>matchEndIdx</name> <operator>-</operator> <name>matchIndex</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>matchEndIdx</name> <operator>=</operator> <name>matchIndex</name> <operator>+</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>matchLength</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>bestLength</name> <operator>=</operator> <name>matchLength</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>matches</name><index>[<expr><name>mnum</name></expr>]</index></name><operator>.</operator><name>off</name> <operator>=</operator> <call><name>OFFSET_TO_OFFBASE</name><argument_list>(<argument><expr><name>curr</name> <operator>-</operator> <name>matchIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>matches</name><index>[<expr><name>mnum</name></expr>]</index></name><operator>.</operator><name>len</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>matchLength</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>mnum</name><operator>++</operator></expr>;</expr_stmt>
                <if_stmt><if>if <condition>( <expr><operator>(</operator><name>matchLength</name> <operator>&gt;</operator> <name>ZSTD_OPT_NUM</name><operator>)</operator>
                   <operator>|</operator> <operator>(</operator><name>ip</name><operator>+</operator><name>matchLength</name> <operator>==</operator> <name>iLimit</name><operator>)</operator></expr> <comment type="block">/* equal : no way to know if inf or sup */</comment>)</condition> <block>{<block_content>
                    <break>break;</break>   <comment type="block">/* drop, to guarantee consistency (miss a little bit of compression) */</comment>
            </block_content>}</block></if></if_stmt>   </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>dictMatchIndex</name> <operator>&lt;=</operator> <name>dmsBtLow</name></expr>)</condition> <block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt>   <comment type="block">/* beyond tree size, stop the search */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>match</name><index>[<expr><name>matchLength</name></expr>]</index></name> <operator>&lt;</operator> <name><name>ip</name><index>[<expr><name>matchLength</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>commonLengthSmaller</name> <operator>=</operator> <name>matchLength</name></expr>;</expr_stmt>    <comment type="block">/* all smaller will now have at least this guaranteed common length */</comment>
                <expr_stmt><expr><name>dictMatchIndex</name> <operator>=</operator> <name><name>nextPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>              <comment type="block">/* new matchIndex larger than previous (closer to current) */</comment>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <comment type="block">/* match is larger than current */</comment>
                <expr_stmt><expr><name>commonLengthLarger</name> <operator>=</operator> <name>matchLength</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>dictMatchIndex</name> <operator>=</operator> <name><name>nextPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>   </block_content>}</block></for>   </block_content>}</block></if></if_stmt>  <comment type="block">/* if (dictMode == ZSTD_dictMatchState) */</comment>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>matchEndIdx</name> <operator>&gt;</operator> <name>curr</name><operator>+</operator><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name> <operator>=</operator> <name>matchEndIdx</name> <operator>-</operator> <literal type="number">8</literal></expr>;</expr_stmt>  <comment type="block">/* skip repetitive patterns */</comment>
    <return>return <expr><name>mnum</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <function_decl><type><name>U32</name></type> (<modifier>*</modifier><name>ZSTD_getAllMatchesFn</name>)<parameter_list>(
    <parameter><decl><type><name>ZSTD_match_t</name><modifier>*</modifier></type></decl></parameter>,
    <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type></decl></parameter>,
    <parameter><decl><type><name>U32</name><modifier>*</modifier></type></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
    <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>ll0</name></decl></parameter>,
    <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>lengthToBeat</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>U32</name></type> <name>ZSTD_btGetAllMatches_internal</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_match_t</name><modifier>*</modifier></type> <name>matches</name></decl></parameter>,
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>,
        <parameter><decl><type><name>U32</name><modifier>*</modifier></type> <name>nextToUpdate3</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iHighLimit</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>ll0</name></decl></parameter>,
        <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>lengthToBeat</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>ZSTD_dictMode_e</name></type> <name>dictMode</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name>mls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BOUNDED</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name><name>ms</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>minMatch</name></name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>mls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_BtGetAllMatches(dictMode=%d, mls=%u)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>dictMode</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ip</name> <operator>&lt;</operator> <name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name> <operator>+</operator> <name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* skipped area */</comment>
    <expr_stmt><expr><call><name>ZSTD_updateTree_internal</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iHighLimit</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>, <argument><expr><name>dictMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>ZSTD_insertBtAndGetAllMatches</name><argument_list>(<argument><expr><name>matches</name></expr></argument>, <argument><expr><name>ms</name></expr></argument>, <argument><expr><name>nextToUpdate3</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iHighLimit</name></expr></argument>, <argument><expr><name>dictMode</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>ll0</name></expr></argument>, <argument><expr><name>lengthToBeat</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZSTD_BT_GET_ALL_MATCHES_FN</name><parameter_list>(<parameter><type><name>dictMode</name></type></parameter>, <parameter><type><name>mls</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ZSTD_btGetAllMatches_##dictMode##_##mls</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GEN_ZSTD_BT_GET_ALL_MATCHES_</name><parameter_list>(<parameter><type><name>dictMode</name></type></parameter>, <parameter><type><name>mls</name></type></parameter>)</parameter_list></cpp:macro>            \
    <cpp:value>static U32 ZSTD_BT_GET_ALL_MATCHES_FN(dictMode, mls)(      \
            ZSTD_match_t* matches,                             \
            ZSTD_matchState_t* ms,                             \
            U32* nextToUpdate3,                                \
            const BYTE* ip,                                    \
            const BYTE* const iHighLimit,                      \
            const U32 rep[ZSTD_REP_NUM],                       \
            U32 const ll0,                                     \
            U32 const lengthToBeat)                            \
    {                                                          \
        return ZSTD_btGetAllMatches_internal(                  \
                matches, ms, nextToUpdate3, ip, iHighLimit,    \
                rep, ll0, lengthToBeat, ZSTD_##dictMode, mls); \
    }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GEN_ZSTD_BT_GET_ALL_MATCHES</name><parameter_list>(<parameter><type><name>dictMode</name></type></parameter>)</parameter_list></cpp:macro>  \
    <cpp:value>GEN_ZSTD_BT_GET_ALL_MATCHES_(dictMode, 3)  \
    GEN_ZSTD_BT_GET_ALL_MATCHES_(dictMode, 4)  \
    GEN_ZSTD_BT_GET_ALL_MATCHES_(dictMode, 5)  \
    GEN_ZSTD_BT_GET_ALL_MATCHES_(dictMode, 6)</cpp:value></cpp:define>

<macro><name>GEN_ZSTD_BT_GET_ALL_MATCHES</name><argument_list>(<argument>noDict</argument>)</argument_list></macro>
<macro><name>GEN_ZSTD_BT_GET_ALL_MATCHES</name><argument_list>(<argument>extDict</argument>)</argument_list></macro>
<macro><name>GEN_ZSTD_BT_GET_ALL_MATCHES</name><argument_list>(<argument>dictMatchState</argument>)</argument_list></macro>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZSTD_BT_GET_ALL_MATCHES_ARRAY</name><parameter_list>(<parameter><type><name>dictMode</name></type></parameter>)</parameter_list></cpp:macro>  \
    <cpp:value>{                                            \
        ZSTD_BT_GET_ALL_MATCHES_FN(dictMode, 3), \
        ZSTD_BT_GET_ALL_MATCHES_FN(dictMode, 4), \
        ZSTD_BT_GET_ALL_MATCHES_FN(dictMode, 5), \
        ZSTD_BT_GET_ALL_MATCHES_FN(dictMode, 6)  \
    }</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>ZSTD_getAllMatchesFn</name></type>
<name>ZSTD_selectBtGetAllMatches</name><parameter_list>(<parameter><decl><type><name>ZSTD_matchState_t</name> <specifier>const</specifier><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>ZSTD_dictMode_e</name> <specifier>const</specifier></type> <name>dictMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_getAllMatchesFn</name> <specifier>const</specifier></type> <name><name>getAllMatchesFns</name><index>[<expr><literal type="number">3</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{
        <expr><call><name>ZSTD_BT_GET_ALL_MATCHES_ARRAY</name><argument_list>(<argument><expr><name>noDict</name></expr></argument>)</argument_list></call></expr>,
        <expr><call><name>ZSTD_BT_GET_ALL_MATCHES_ARRAY</name><argument_list>(<argument><expr><name>extDict</name></expr></argument>)</argument_list></call></expr>,
        <macro><name>ZSTD_BT_GET_ALL_MATCHES_ARRAY</name><argument_list>(<argument>dictMatchState</argument>)</argument_list></macro>
    }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>mls</name> <init>= <expr><call><name>BOUNDED</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name><name>ms</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>minMatch</name></name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>dictMode</name> <operator>&lt;</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>mls</name> <operator>-</operator> <literal type="number">3</literal> <operator>&lt;</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>getAllMatchesFns</name><index>[<expr><operator>(</operator><name>int</name><operator>)</operator><name>dictMode</name></expr>]</index><index>[<expr><name>mls</name> <operator>-</operator> <literal type="number">3</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*************************
*  LDM helper functions  *
*************************/</comment>

<comment type="block">/* Struct containing info needed to make decision about ldm inclusion */</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>rawSeqStore_t</name></type> <name>seqStore</name></decl>;</decl_stmt>   <comment type="block">/* External match candidates store for this block */</comment>
    <decl_stmt><decl><type><name>U32</name></type> <name>startPosInBlock</name></decl>;</decl_stmt>      <comment type="block">/* Start position of the current match candidate */</comment>
    <decl_stmt><decl><type><name>U32</name></type> <name>endPosInBlock</name></decl>;</decl_stmt>        <comment type="block">/* End position of the current match candidate */</comment>
    <decl_stmt><decl><type><name>U32</name></type> <name>offset</name></decl>;</decl_stmt>               <comment type="block">/* Offset of the match candidate */</comment>
}</block></struct></type> <name>ZSTD_optLdm_t</name>;</typedef>

<comment type="block">/* ZSTD_optLdm_skipRawSeqStoreBytes():
 * Moves forward in @rawSeqStore by @nbBytes,
 * which will update the fields 'pos' and 'posInSequence'.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_optLdm_skipRawSeqStoreBytes</name><parameter_list>(<parameter><decl><type><name>rawSeqStore_t</name><modifier>*</modifier></type> <name>rawSeqStore</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nbBytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name></type> <name>currPos</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name><name>rawSeqStore</name><operator>-&gt;</operator><name>posInSequence</name></name> <operator>+</operator> <name>nbBytes</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>currPos</name> <operator>&amp;&amp;</operator> <name><name>rawSeqStore</name><operator>-&gt;</operator><name>pos</name></name> <operator>&lt;</operator> <name><name>rawSeqStore</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>rawSeq</name></type> <name>currSeq</name> <init>= <expr><name><name>rawSeqStore</name><operator>-&gt;</operator><name>seq</name><index>[<expr><name><name>rawSeqStore</name><operator>-&gt;</operator><name>pos</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>currPos</name> <operator>&gt;=</operator> <name><name>currSeq</name><operator>.</operator><name>litLength</name></name> <operator>+</operator> <name><name>currSeq</name><operator>.</operator><name>matchLength</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>currPos</name> <operator>-=</operator> <name><name>currSeq</name><operator>.</operator><name>litLength</name></name> <operator>+</operator> <name><name>currSeq</name><operator>.</operator><name>matchLength</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rawSeqStore</name><operator>-&gt;</operator><name>pos</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>rawSeqStore</name><operator>-&gt;</operator><name>posInSequence</name></name> <operator>=</operator> <name>currPos</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if <condition>(<expr><name>currPos</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>rawSeqStore</name><operator>-&gt;</operator><name>pos</name></name> <operator>==</operator> <name><name>rawSeqStore</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>rawSeqStore</name><operator>-&gt;</operator><name>posInSequence</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ZSTD_opt_getNextMatchAndUpdateSeqStore():
 * Calculates the beginning and end of the next match in the current block.
 * Updates 'pos' and 'posInSequence' of the ldmSeqStore.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ZSTD_opt_getNextMatchAndUpdateSeqStore</name><parameter_list>(<parameter><decl><type><name>ZSTD_optLdm_t</name><modifier>*</modifier></type> <name>optLdm</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>currPosInBlock</name></decl></parameter>,
                                       <parameter><decl><type><name>U32</name></type> <name>blockBytesRemaining</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>rawSeq</name></type> <name>currSeq</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>currBlockEndPos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>literalsBytesRemaining</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>matchBytesRemaining</name></decl>;</decl_stmt>

    <comment type="block">/* Setting match end position to MAX to ensure we never use an LDM during this block */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>optLdm</name><operator>-&gt;</operator><name>seqStore</name><operator>.</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>optLdm</name><operator>-&gt;</operator><name>seqStore</name><operator>.</operator><name>pos</name></name> <operator>&gt;=</operator> <name><name>optLdm</name><operator>-&gt;</operator><name>seqStore</name><operator>.</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>optLdm</name><operator>-&gt;</operator><name>startPosInBlock</name></name> <operator>=</operator> <name>UINT_MAX</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>optLdm</name><operator>-&gt;</operator><name>endPosInBlock</name></name> <operator>=</operator> <name>UINT_MAX</name></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Calculate appropriate bytes left in matchLength and litLength
     * after adjusting based on ldmSeqStore-&gt;posInSequence */</comment>
    <expr_stmt><expr><name>currSeq</name> <operator>=</operator> <name><name>optLdm</name><operator>-&gt;</operator><name>seqStore</name><operator>.</operator><name>seq</name><index>[<expr><name><name>optLdm</name><operator>-&gt;</operator><name>seqStore</name><operator>.</operator><name>pos</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>optLdm</name><operator>-&gt;</operator><name>seqStore</name><operator>.</operator><name>posInSequence</name></name> <operator>&lt;=</operator> <name><name>currSeq</name><operator>.</operator><name>litLength</name></name> <operator>+</operator> <name><name>currSeq</name><operator>.</operator><name>matchLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>currBlockEndPos</name> <operator>=</operator> <name>currPosInBlock</name> <operator>+</operator> <name>blockBytesRemaining</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>literalsBytesRemaining</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>optLdm</name><operator>-&gt;</operator><name>seqStore</name><operator>.</operator><name>posInSequence</name></name> <operator>&lt;</operator> <name><name>currSeq</name><operator>.</operator><name>litLength</name></name><operator>)</operator></expr> ?</condition><then>
            <expr><name><name>currSeq</name><operator>.</operator><name>litLength</name></name> <operator>-</operator> <operator>(</operator><name>U32</name><operator>)</operator><name><name>optLdm</name><operator>-&gt;</operator><name>seqStore</name><operator>.</operator><name>posInSequence</name></name></expr> </then><else>:
            <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>matchBytesRemaining</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>literalsBytesRemaining</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then>
            <expr><name><name>currSeq</name><operator>.</operator><name>matchLength</name></name> <operator>-</operator> <operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><name><name>optLdm</name><operator>-&gt;</operator><name>seqStore</name><operator>.</operator><name>posInSequence</name></name> <operator>-</operator> <name><name>currSeq</name><operator>.</operator><name>litLength</name></name><operator>)</operator></expr> </then><else>:
            <expr><name><name>currSeq</name><operator>.</operator><name>matchLength</name></name></expr></else></ternary></expr>;</expr_stmt>

    <comment type="block">/* If there are more literal bytes than bytes remaining in block, no ldm is possible */</comment>
    <if_stmt><if>if <condition>(<expr><name>literalsBytesRemaining</name> <operator>&gt;=</operator> <name>blockBytesRemaining</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>optLdm</name><operator>-&gt;</operator><name>startPosInBlock</name></name> <operator>=</operator> <name>UINT_MAX</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>optLdm</name><operator>-&gt;</operator><name>endPosInBlock</name></name> <operator>=</operator> <name>UINT_MAX</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_optLdm_skipRawSeqStoreBytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>optLdm</name><operator>-&gt;</operator><name>seqStore</name></name></expr></argument>, <argument><expr><name>blockBytesRemaining</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Matches may be &lt; MINMATCH by this process. In that case, we will reject them
       when we are deciding whether or not to add the ldm */</comment>
    <expr_stmt><expr><name><name>optLdm</name><operator>-&gt;</operator><name>startPosInBlock</name></name> <operator>=</operator> <name>currPosInBlock</name> <operator>+</operator> <name>literalsBytesRemaining</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>optLdm</name><operator>-&gt;</operator><name>endPosInBlock</name></name> <operator>=</operator> <name><name>optLdm</name><operator>-&gt;</operator><name>startPosInBlock</name></name> <operator>+</operator> <name>matchBytesRemaining</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>optLdm</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name><name>currSeq</name><operator>.</operator><name>offset</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>optLdm</name><operator>-&gt;</operator><name>endPosInBlock</name></name> <operator>&gt;</operator> <name>currBlockEndPos</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Match ends after the block ends, we can't use the whole match */</comment>
        <expr_stmt><expr><name><name>optLdm</name><operator>-&gt;</operator><name>endPosInBlock</name></name> <operator>=</operator> <name>currBlockEndPos</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_optLdm_skipRawSeqStoreBytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>optLdm</name><operator>-&gt;</operator><name>seqStore</name></name></expr></argument>, <argument><expr><name>currBlockEndPos</name> <operator>-</operator> <name>currPosInBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* Consume nb of bytes equal to size of sequence left */</comment>
        <expr_stmt><expr><call><name>ZSTD_optLdm_skipRawSeqStoreBytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>optLdm</name><operator>-&gt;</operator><name>seqStore</name></name></expr></argument>, <argument><expr><name>literalsBytesRemaining</name> <operator>+</operator> <name>matchBytesRemaining</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ZSTD_optLdm_maybeAddMatch():
 * Adds a match if it's long enough,
 * based on it's 'matchStartPosInBlock' and 'matchEndPosInBlock',
 * into 'matches'. Maintains the correct ordering of 'matches'.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_optLdm_maybeAddMatch</name><parameter_list>(<parameter><decl><type><name>ZSTD_match_t</name><modifier>*</modifier></type> <name>matches</name></decl></parameter>, <parameter><decl><type><name>U32</name><modifier>*</modifier></type> <name>nbMatches</name></decl></parameter>,
                                      <parameter><decl><type><specifier>const</specifier> <name>ZSTD_optLdm_t</name><modifier>*</modifier></type> <name>optLdm</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>currPosInBlock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>posDiff</name> <init>= <expr><name>currPosInBlock</name> <operator>-</operator> <name><name>optLdm</name><operator>-&gt;</operator><name>startPosInBlock</name></name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Note: ZSTD_match_t actually contains offBase and matchLength (before subtracting MINMATCH) */</comment>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>candidateMatchLength</name> <init>= <expr><name><name>optLdm</name><operator>-&gt;</operator><name>endPosInBlock</name></name> <operator>-</operator> <name><name>optLdm</name><operator>-&gt;</operator><name>startPosInBlock</name></name> <operator>-</operator> <name>posDiff</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Ensure that current block position is not outside of the match */</comment>
    <if_stmt><if>if <condition>(<expr><name>currPosInBlock</name> <operator>&lt;</operator> <name><name>optLdm</name><operator>-&gt;</operator><name>startPosInBlock</name></name>
      <operator>||</operator> <name>currPosInBlock</name> <operator>&gt;=</operator> <name><name>optLdm</name><operator>-&gt;</operator><name>endPosInBlock</name></name>
      <operator>||</operator> <name>candidateMatchLength</name> <operator>&lt;</operator> <name>MINMATCH</name></expr>)</condition> <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>nbMatches</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><operator>(</operator><name>candidateMatchLength</name> <operator>&gt;</operator> <name><name>matches</name><index>[<expr><operator>*</operator><name>nbMatches</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>len</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>*</operator><name>nbMatches</name> <operator>&lt;</operator> <name>ZSTD_OPT_NUM</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>candidateOffBase</name> <init>= <expr><call><name>OFFSET_TO_OFFBASE</name><argument_list>(<argument><expr><name><name>optLdm</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_optLdm_maybeAddMatch(): Adding ldm candidate match (offBase: %u matchLength %u) at block position=%u"</literal></expr></argument>,
                 <argument><expr><name>candidateOffBase</name></expr></argument>, <argument><expr><name>candidateMatchLength</name></expr></argument>, <argument><expr><name>currPosInBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>matches</name><index>[<expr><operator>*</operator><name>nbMatches</name></expr>]</index></name><operator>.</operator><name>len</name> <operator>=</operator> <name>candidateMatchLength</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>matches</name><index>[<expr><operator>*</operator><name>nbMatches</name></expr>]</index></name><operator>.</operator><name>off</name> <operator>=</operator> <name>candidateOffBase</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>nbMatches</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ZSTD_optLdm_processMatchCandidate():
 * Wrapper function to update ldm seq store and call ldm functions as necessary.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ZSTD_optLdm_processMatchCandidate</name><parameter_list>(<parameter><decl><type><name>ZSTD_optLdm_t</name><modifier>*</modifier></type> <name>optLdm</name></decl></parameter>,
                                  <parameter><decl><type><name>ZSTD_match_t</name><modifier>*</modifier></type> <name>matches</name></decl></parameter>, <parameter><decl><type><name>U32</name><modifier>*</modifier></type> <name>nbMatches</name></decl></parameter>,
                                  <parameter><decl><type><name>U32</name></type> <name>currPosInBlock</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>remainingBytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>optLdm</name><operator>-&gt;</operator><name>seqStore</name><operator>.</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>optLdm</name><operator>-&gt;</operator><name>seqStore</name><operator>.</operator><name>pos</name></name> <operator>&gt;=</operator> <name><name>optLdm</name><operator>-&gt;</operator><name>seqStore</name><operator>.</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>currPosInBlock</name> <operator>&gt;=</operator> <name><name>optLdm</name><operator>-&gt;</operator><name>endPosInBlock</name></name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>currPosInBlock</name> <operator>&gt;</operator> <name><name>optLdm</name><operator>-&gt;</operator><name>endPosInBlock</name></name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* The position at which ZSTD_optLdm_processMatchCandidate() is called is not necessarily
             * at the end of a match from the ldm seq store, and will often be some bytes
             * over beyond matchEndPosInBlock. As such, we need to correct for these "overshoots"
             */</comment>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>posOvershoot</name> <init>= <expr><name>currPosInBlock</name> <operator>-</operator> <name><name>optLdm</name><operator>-&gt;</operator><name>endPosInBlock</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ZSTD_optLdm_skipRawSeqStoreBytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>optLdm</name><operator>-&gt;</operator><name>seqStore</name></name></expr></argument>, <argument><expr><name>posOvershoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>ZSTD_opt_getNextMatchAndUpdateSeqStore</name><argument_list>(<argument><expr><name>optLdm</name></expr></argument>, <argument><expr><name>currPosInBlock</name></expr></argument>, <argument><expr><name>remainingBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>ZSTD_optLdm_maybeAddMatch</name><argument_list>(<argument><expr><name>matches</name></expr></argument>, <argument><expr><name>nbMatches</name></expr></argument>, <argument><expr><name>optLdm</name></expr></argument>, <argument><expr><name>currPosInBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*-*******************************
*  Optimal parser
*********************************/</comment>

<function><type><specifier>static</specifier> <name>U32</name></type> <name>ZSTD_totalLen</name><parameter_list>(<parameter><decl><type><name>ZSTD_optimal_t</name></type> <name>sol</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name><name>sol</name><operator>.</operator><name>litlen</name></name> <operator>+</operator> <name><name>sol</name><operator>.</operator><name>mlen</name></name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> <comment type="block">/* debug */</comment>

static void
listStats(const U32* table, int lastEltID)
{
    int const nbElts = lastEltID + 1;
    int enb;
    for (enb=0; enb &lt; nbElts; enb++) {
        (void)table;
        <comment type="block">/* RAWLOG(2, "%3i:%3i,  ", enb, table[enb]); */</comment>
        RAWLOG(2, "%4i,", table[enb]);
    }
    RAWLOG(2, " \n");
}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>size_t</name></type>
<name>ZSTD_compressBlock_opt_generic</name><parameter_list>(<parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>,
                               <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>,
                               <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
                         <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                         <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>optLevel</name></decl></parameter>,
                         <parameter><decl><type><specifier>const</specifier> <name>ZSTD_dictMode_e</name></type> <name>dictMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>optState_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>optStatePtr</name> <init>= <expr><operator>&amp;</operator><name><name>ms</name><operator>-&gt;</operator><name>opt</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>istart</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><name>istart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>anchor</name> <init>= <expr><name>istart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name> <init>= <expr><name>istart</name> <operator>+</operator> <name>srcSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ilimit</name> <init>= <expr><name>iend</name> <operator>-</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>base</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>prefixStart</name> <init>= <expr><name>base</name> <operator>+</operator> <name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictLimit</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_compressionParameters</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cParams</name> <init>= <expr><operator>&amp;</operator><name><name>ms</name><operator>-&gt;</operator><name>cParams</name></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>ZSTD_getAllMatchesFn</name></type> <name>getAllMatches</name> <init>= <expr><call><name>ZSTD_selectBtGetAllMatches</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>dictMode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>sufficient_len</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name><name>cParams</name><operator>-&gt;</operator><name>targetLength</name></name></expr></argument>, <argument><expr><name>ZSTD_OPT_NUM</name> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>minMatch</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>cParams</name><operator>-&gt;</operator><name>minMatch</name></name> <operator>==</operator> <literal type="number">3</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">3</literal></expr> </then><else>: <expr><literal type="number">4</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>nextToUpdate3</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>ZSTD_optimal_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>opt</name> <init>= <expr><name><name>optStatePtr</name><operator>-&gt;</operator><name>priceTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_match_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>matches</name> <init>= <expr><name><name>optStatePtr</name><operator>-&gt;</operator><name>matchTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_optimal_t</name></type> <name>lastSequence</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_optLdm_t</name></type> <name>optLdm</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>optLdm</name><operator>.</operator><name>seqStore</name></name> <operator>=</operator> <ternary><condition><expr><name><name>ms</name><operator>-&gt;</operator><name>ldmSeqStore</name></name></expr> ?</condition><then> <expr><operator>*</operator><name><name>ms</name><operator>-&gt;</operator><name>ldmSeqStore</name></name></expr> </then><else>: <expr><name>kNullRawSeqStore</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>optLdm</name><operator>.</operator><name>endPosInBlock</name></name> <operator>=</operator> <name><name>optLdm</name><operator>.</operator><name>startPosInBlock</name></name> <operator>=</operator> <name><name>optLdm</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_opt_getNextMatchAndUpdateSeqStore</name><argument_list>(<argument><expr><operator>&amp;</operator><name>optLdm</name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>istart</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>iend</name><operator>-</operator><name>ip</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* init */</comment>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressBlock_opt_generic: current=%u, prefix=%u, nextToUpdate=%u"</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>base</name><operator>)</operator></expr></argument>, <argument><expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictLimit</name></name></expr></argument>, <argument><expr><name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>optLevel</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_rescaleFreqs</name><argument_list>(<argument><expr><name>optStatePtr</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>optLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ip</name> <operator>+=</operator> <operator>(</operator><name>ip</name><operator>==</operator><name>prefixStart</name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* Match Loop */</comment>
    <while>while <condition>(<expr><name>ip</name> <operator>&lt;</operator> <name>ilimit</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name></type> <name>cur</name></decl>, <decl><type ref="prev"/><name>last_pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <comment type="block">/* find first match */</comment>
        <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>litlen</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>anchor</name><operator>)</operator></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>ll0</name> <init>= <expr><operator>!</operator><name>litlen</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name></type> <name>nbMatches</name> <init>= <expr><call><name>getAllMatches</name><argument_list>(<argument><expr><name>matches</name></expr></argument>, <argument><expr><name>ms</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nextToUpdate3</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>ll0</name></expr></argument>, <argument><expr><name>minMatch</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ZSTD_optLdm_processMatchCandidate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>optLdm</name></expr></argument>, <argument><expr><name>matches</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbMatches</name></expr></argument>,
                                              <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>istart</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>iend</name> <operator>-</operator> <name>ip</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>nbMatches</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>ip</name><operator>++</operator></expr>;</expr_stmt> <continue>continue;</continue> </block_content>}</block></if></if_stmt>

            <comment type="block">/* initialize opt[0] */</comment>
            <block>{<block_content> <decl_stmt><decl><type><name>U32</name></type> <name>i</name></decl> ;</decl_stmt> <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>ZSTD_REP_NUM</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>opt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>rep</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>rep</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for> </block_content>}</block>
            <expr_stmt><expr><name><name>opt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>mlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* means is_a_literal */</comment>
            <expr_stmt><expr><name><name>opt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>litlen</name> <operator>=</operator> <name>litlen</name></expr>;</expr_stmt>
            <comment type="block">/* We don't need to include the actual price of the literals because
             * it is static for the duration of the forward pass, and is included
             * in every price. We include the literal length to avoid negative
             * prices when we subtract the previous literal length.
             */</comment>
            <expr_stmt><expr><name><name>opt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>price</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>ZSTD_litLengthPrice</name><argument_list>(<argument><expr><name>litlen</name></expr></argument>, <argument><expr><name>optStatePtr</name></expr></argument>, <argument><expr><name>optLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* large match -&gt; immediate encoding */</comment>
            <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>maxML</name> <init>= <expr><name><name>matches</name><index>[<expr><name>nbMatches</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>len</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>maxOffBase</name> <init>= <expr><name><name>matches</name><index>[<expr><name>nbMatches</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>off</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"found %u matches of maxLength=%u and maxOffBase=%u at cPos=%u =&gt; start new series"</literal></expr></argument>,
                            <argument><expr><name>nbMatches</name></expr></argument>, <argument><expr><name>maxML</name></expr></argument>, <argument><expr><name>maxOffBase</name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>prefixStart</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>maxML</name> <operator>&gt;</operator> <name>sufficient_len</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name><name>lastSequence</name><operator>.</operator><name>litlen</name></name> <operator>=</operator> <name>litlen</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>lastSequence</name><operator>.</operator><name>mlen</name></name> <operator>=</operator> <name>maxML</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>lastSequence</name><operator>.</operator><name>off</name></name> <operator>=</operator> <name>maxOffBase</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"large match (%u&gt;%u), immediate encoding"</literal></expr></argument>,
                                <argument><expr><name>maxML</name></expr></argument>, <argument><expr><name>sufficient_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>cur</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>last_pos</name> <operator>=</operator> <call><name>ZSTD_totalLen</name><argument_list>(<argument><expr><name>lastSequence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <goto>goto <name>_shortestPath</name>;</goto>
            </block_content>}</block></if></if_stmt>   </block_content>}</block>

            <comment type="block">/* set prices for first matches starting position == 0 */</comment>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>opt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>price</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>literalsPrice</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>opt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>price</name> <operator>+</operator> <call><name>ZSTD_litLengthPrice</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>optStatePtr</name></expr></argument>, <argument><expr><name>optLevel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>U32</name></type> <name>pos</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>U32</name></type> <name>matchNb</name></decl>;</decl_stmt>
                <for>for <control>(<init><expr><name>pos</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <name>minMatch</name></expr>;</condition> <incr><expr><name>pos</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <expr_stmt><expr><name><name>opt</name><index>[<expr><name>pos</name></expr>]</index></name><operator>.</operator><name>price</name> <operator>=</operator> <name>ZSTD_MAX_PRICE</name></expr>;</expr_stmt>   <comment type="block">/* mlen, litlen and price will be fixed during forward scanning */</comment>
                </block_content>}</block></for>
                <for>for <control>(<init><expr><name>matchNb</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>matchNb</name> <operator>&lt;</operator> <name>nbMatches</name></expr>;</condition> <incr><expr><name>matchNb</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>offBase</name> <init>= <expr><name><name>matches</name><index>[<expr><name>matchNb</name></expr>]</index></name><operator>.</operator><name>off</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>end</name> <init>= <expr><name><name>matches</name><index>[<expr><name>matchNb</name></expr>]</index></name><operator>.</operator><name>len</name></expr></init></decl>;</decl_stmt>
                    <for>for <control>( <init>;</init> <condition><expr><name>pos</name> <operator>&lt;=</operator> <name>end</name></expr> ;</condition> <incr><expr><name>pos</name><operator>++</operator></expr></incr> )</control> <block>{<block_content>
                        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>matchPrice</name> <init>= <expr><call><name>ZSTD_getMatchPrice</name><argument_list>(<argument><expr><name>offBase</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>optStatePtr</name></expr></argument>, <argument><expr><name>optLevel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>sequencePrice</name> <init>= <expr><name>literalsPrice</name> <operator>+</operator> <name>matchPrice</name></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"rPos:%u =&gt; set initial price : %.2f"</literal></expr></argument>,
                                    <argument><expr><name>pos</name></expr></argument>, <argument><expr><call><name>ZSTD_fCost</name><argument_list>(<argument><expr><name>sequencePrice</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>opt</name><index>[<expr><name>pos</name></expr>]</index></name><operator>.</operator><name>mlen</name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>opt</name><index>[<expr><name>pos</name></expr>]</index></name><operator>.</operator><name>off</name> <operator>=</operator> <name>offBase</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>opt</name><index>[<expr><name>pos</name></expr>]</index></name><operator>.</operator><name>litlen</name> <operator>=</operator> <name>litlen</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>opt</name><index>[<expr><name>pos</name></expr>]</index></name><operator>.</operator><name>price</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>sequencePrice</name></expr>;</expr_stmt>
                </block_content>}</block></for>   </block_content>}</block></for>
                <expr_stmt><expr><name>last_pos</name> <operator>=</operator> <name>pos</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block>

        <comment type="block">/* check further positions */</comment>
        <for>for <control>(<init><expr><name>cur</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>cur</name> <operator>&lt;=</operator> <name>last_pos</name></expr>;</condition> <incr><expr><name>cur</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>inr</name> <init>= <expr><name>ip</name> <operator>+</operator> <name>cur</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>cur</name> <operator>&lt;</operator> <name>ZSTD_OPT_NUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <macro><name>DEBUGLOG</name><argument_list>(<argument><literal type="number">7</literal></argument>, <argument><literal type="string">"cPos:%zi==rPos:%u"</literal></argument>, <argument>inr-istart</argument>, <argument>cur</argument>)</argument_list></macro>

            <comment type="block">/* Fix current position with one literal if cheaper */</comment>
            <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>litlen</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>opt</name><index>[<expr><name>cur</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>mlen</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>opt</name><index>[<expr><name>cur</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>litlen</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>price</name> <init>= <expr><name><name>opt</name><index>[<expr><name>cur</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>price</name>
                                <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>ZSTD_rawLiteralsCost</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><name>cur</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>optStatePtr</name></expr></argument>, <argument><expr><name>optLevel</name></expr></argument>)</argument_list></call>
                                <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>ZSTD_litLengthPrice</name><argument_list>(<argument><expr><name>litlen</name></expr></argument>, <argument><expr><name>optStatePtr</name></expr></argument>, <argument><expr><name>optLevel</name></expr></argument>)</argument_list></call>
                                <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>ZSTD_litLengthPrice</name><argument_list>(<argument><expr><name>litlen</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>optStatePtr</name></expr></argument>, <argument><expr><name>optLevel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>price</name> <operator>&lt;</operator> <literal type="number">1000000000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* overflow check */</comment>
                <if_stmt><if>if <condition>(<expr><name>price</name> <operator>&lt;=</operator> <name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>price</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"cPos:%zi==rPos:%u : better price (%.2f&lt;=%.2f) using literal (ll==%u) (hist:%u,%u,%u)"</literal></expr></argument>,
                                <argument><expr><name>inr</name><operator>-</operator><name>istart</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><call><name>ZSTD_fCost</name><argument_list>(<argument><expr><name>price</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ZSTD_fCost</name><argument_list>(<argument><expr><name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>price</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>litlen</name></expr></argument>,
                                <argument><expr><name><name>opt</name><index>[<expr><name>cur</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>rep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>opt</name><index>[<expr><name>cur</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>rep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>opt</name><index>[<expr><name>cur</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>rep</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>mlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>litlen</name> <operator>=</operator> <name>litlen</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>price</name> <operator>=</operator> <name>price</name></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"cPos:%zi==rPos:%u : literal would cost more (%.2f&gt;%.2f) (hist:%u,%u,%u)"</literal></expr></argument>,
                                <argument><expr><name>inr</name><operator>-</operator><name>istart</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><call><name>ZSTD_fCost</name><argument_list>(<argument><expr><name>price</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ZSTD_fCost</name><argument_list>(<argument><expr><name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>price</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name><name>rep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name><name>rep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name><name>rep</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block>

            <comment type="block">/* Set the repcodes of the current position. We must do it here
             * because we rely on the repcodes of the 2nd to last sequence being
             * correct to set the next chunks repcodes during the backward
             * traversal.
             */</comment>
            <expr_stmt><expr><call><name>ZSTD_STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>rep</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>repcodes_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>cur</name> <operator>&gt;=</operator> <name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>mlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>mlen</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>prev</name> <init>= <expr><name>cur</name> <operator>-</operator> <name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>mlen</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>repcodes_t</name> <specifier>const</specifier></type> <name>newReps</name> <init>= <expr><call><name>ZSTD_newRep</name><argument_list>(<argument><expr><name><name>opt</name><index>[<expr><name>prev</name></expr>]</index></name><operator>.</operator><name>rep</name></expr></argument>, <argument><expr><name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>off</name></expr></argument>, <argument><expr><name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>litlen</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>rep</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newReps</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repcodes_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>rep</name></expr></argument>, <argument><expr><name><name>opt</name><index>[<expr><name>cur</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>rep</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repcodes_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/* last match must start at a minimum distance of 8 from oend */</comment>
            <if_stmt><if>if <condition>(<expr><name>inr</name> <operator>&gt;</operator> <name>ilimit</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>cur</name> <operator>==</operator> <name>last_pos</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>( <expr><operator>(</operator><name>optLevel</name><operator>==</operator><literal type="number">0</literal><operator>)</operator> <comment type="block">/*static_test*/</comment>
              <operator>&amp;&amp;</operator> <operator>(</operator><name><name>opt</name><index>[<expr><name>cur</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>price</name> <operator>&lt;=</operator> <name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>price</name> <operator>+</operator> <operator>(</operator><name>BITCOST_MULTIPLIER</name><operator>/</operator><literal type="number">2</literal><operator>)</operator><operator>)</operator></expr> )</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"move to next rPos:%u : price is &lt;="</literal></expr></argument>, <argument><expr><name>cur</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>  <comment type="block">/* skip unpromising positions; about ~+6% speed, -0.01 ratio */</comment>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>price</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>ll0</name> <init>= <expr><operator>(</operator><name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>mlen</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>litlen</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>mlen</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>litlen</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>previousPrice</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>price</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>basePrice</name> <init>= <expr><name>previousPrice</name> <operator>+</operator> <call><name>ZSTD_litLengthPrice</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>optStatePtr</name></expr></argument>, <argument><expr><name>optLevel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>U32</name></type> <name>nbMatches</name> <init>= <expr><call><name>getAllMatches</name><argument_list>(<argument><expr><name>matches</name></expr></argument>, <argument><expr><name>ms</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nextToUpdate3</name></expr></argument>, <argument><expr><name>inr</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>rep</name></expr></argument>, <argument><expr><name>ll0</name></expr></argument>, <argument><expr><name>minMatch</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>U32</name></type> <name>matchNb</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>ZSTD_optLdm_processMatchCandidate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>optLdm</name></expr></argument>, <argument><expr><name>matches</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbMatches</name></expr></argument>,
                                                  <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>inr</name><operator>-</operator><name>istart</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>iend</name><operator>-</operator><name>inr</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>nbMatches</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"rPos:%u : no match found"</literal></expr></argument>, <argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>

                <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>maxML</name> <init>= <expr><name><name>matches</name><index>[<expr><name>nbMatches</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>len</name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"cPos:%zi==rPos:%u, found %u matches, of maxLength=%u"</literal></expr></argument>,
                                <argument><expr><name>inr</name><operator>-</operator><name>istart</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name>nbMatches</name></expr></argument>, <argument><expr><name>maxML</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>( <expr><operator>(</operator><name>maxML</name> <operator>&gt;</operator> <name>sufficient_len</name><operator>)</operator>
                      <operator>||</operator> <operator>(</operator><name>cur</name> <operator>+</operator> <name>maxML</name> <operator>&gt;=</operator> <name>ZSTD_OPT_NUM</name><operator>)</operator></expr> )</condition> <block>{<block_content>
                        <expr_stmt><expr><name><name>lastSequence</name><operator>.</operator><name>mlen</name></name> <operator>=</operator> <name>maxML</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>lastSequence</name><operator>.</operator><name>off</name></name> <operator>=</operator> <name><name>matches</name><index>[<expr><name>nbMatches</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>off</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>lastSequence</name><operator>.</operator><name>litlen</name></name> <operator>=</operator> <name>litlen</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>cur</name> <operator>-=</operator> <ternary><condition><expr><operator>(</operator><name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>mlen</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>litlen</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>  <comment type="block">/* last sequence is actually only literals, fix cur to last match - note : may underflow, in which case, it's first sequence, and it's okay */</comment>
                        <expr_stmt><expr><name>last_pos</name> <operator>=</operator> <name>cur</name> <operator>+</operator> <call><name>ZSTD_totalLen</name><argument_list>(<argument><expr><name>lastSequence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>cur</name> <operator>&gt;</operator> <name>ZSTD_OPT_NUM</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cur</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>   <comment type="block">/* underflow =&gt; first match */</comment>
                        <goto>goto <name>_shortestPath</name>;</goto>
                </block_content>}</block></if></if_stmt>   </block_content>}</block>

                <comment type="block">/* set prices using matches found at position == cur */</comment>
                <for>for <control>(<init><expr><name>matchNb</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>matchNb</name> <operator>&lt;</operator> <name>nbMatches</name></expr>;</condition> <incr><expr><name>matchNb</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>offset</name> <init>= <expr><name><name>matches</name><index>[<expr><name>matchNb</name></expr>]</index></name><operator>.</operator><name>off</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>lastML</name> <init>= <expr><name><name>matches</name><index>[<expr><name>matchNb</name></expr>]</index></name><operator>.</operator><name>len</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>startML</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>matchNb</name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>matches</name><index>[<expr><name>matchNb</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>len</name><operator>+</operator><literal type="number">1</literal></expr> </then><else>: <expr><name>minMatch</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>U32</name></type> <name>mlen</name></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"testing match %u =&gt; offBase=%4u, mlen=%2u, llen=%2u"</literal></expr></argument>,
                                <argument><expr><name>matchNb</name></expr></argument>, <argument><expr><name><name>matches</name><index>[<expr><name>matchNb</name></expr>]</index></name><operator>.</operator><name>off</name></expr></argument>, <argument><expr><name>lastML</name></expr></argument>, <argument><expr><name>litlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <for>for <control>(<init><expr><name>mlen</name> <operator>=</operator> <name>lastML</name></expr>;</init> <condition><expr><name>mlen</name> <operator>&gt;=</operator> <name>startML</name></expr>;</condition> <incr><expr><name>mlen</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>  <comment type="block">/* scan downward */</comment>
                        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>pos</name> <init>= <expr><name>cur</name> <operator>+</operator> <name>mlen</name></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>price</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name>basePrice</name> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>ZSTD_getMatchPrice</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>mlen</name></expr></argument>, <argument><expr><name>optStatePtr</name></expr></argument>, <argument><expr><name>optLevel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pos</name> <operator>&gt;</operator> <name>last_pos</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>price</name> <operator>&lt;</operator> <name><name>opt</name><index>[<expr><name>pos</name></expr>]</index></name><operator>.</operator><name>price</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"rPos:%u (ml=%2u) =&gt; new better price (%.2f&lt;%.2f)"</literal></expr></argument>,
                                        <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>mlen</name></expr></argument>, <argument><expr><call><name>ZSTD_fCost</name><argument_list>(<argument><expr><name>price</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ZSTD_fCost</name><argument_list>(<argument><expr><name><name>opt</name><index>[<expr><name>pos</name></expr>]</index></name><operator>.</operator><name>price</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <while>while <condition>(<expr><name>last_pos</name> <operator>&lt;</operator> <name>pos</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name><name>opt</name><index>[<expr><name>last_pos</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>price</name> <operator>=</operator> <name>ZSTD_MAX_PRICE</name></expr>;</expr_stmt> <expr_stmt><expr><name>last_pos</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>   <comment type="block">/* fill empty positions */</comment>
                            <expr_stmt><expr><name><name>opt</name><index>[<expr><name>pos</name></expr>]</index></name><operator>.</operator><name>mlen</name> <operator>=</operator> <name>mlen</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>opt</name><index>[<expr><name>pos</name></expr>]</index></name><operator>.</operator><name>off</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>opt</name><index>[<expr><name>pos</name></expr>]</index></name><operator>.</operator><name>litlen</name> <operator>=</operator> <name>litlen</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>opt</name><index>[<expr><name>pos</name></expr>]</index></name><operator>.</operator><name>price</name> <operator>=</operator> <name>price</name></expr>;</expr_stmt>
                        </block_content>}</block></if> <else>else <block>{<block_content>
                            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"rPos:%u (ml=%2u) =&gt; new price is worse (%.2f&gt;=%.2f)"</literal></expr></argument>,
                                        <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>mlen</name></expr></argument>, <argument><expr><call><name>ZSTD_fCost</name><argument_list>(<argument><expr><name>price</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ZSTD_fCost</name><argument_list>(<argument><expr><name><name>opt</name><index>[<expr><name>pos</name></expr>]</index></name><operator>.</operator><name>price</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name>optLevel</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>  <comment type="block">/* early update abort; gets ~+10% speed for about -0.01 ratio loss */</comment>
                        </block_content>}</block></else></if_stmt>
            </block_content>}</block></for>   </block_content>}</block></for>   </block_content>}</block>
        </block_content>}</block></for>  <comment type="block">/* for (cur = 1; cur &lt;= last_pos; cur++) */</comment>

        <expr_stmt><expr><name>lastSequence</name> <operator>=</operator> <name><name>opt</name><index>[<expr><name>last_pos</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>cur</name> <operator>=</operator> <ternary><condition><expr><name>last_pos</name> <operator>&gt;</operator> <call><name>ZSTD_totalLen</name><argument_list>(<argument><expr><name>lastSequence</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>last_pos</name> <operator>-</operator> <call><name>ZSTD_totalLen</name><argument_list>(<argument><expr><name>lastSequence</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>  <comment type="block">/* single sequence, and it starts before `ip` */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>cur</name> <operator>&lt;</operator> <name>ZSTD_OPT_NUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* control overflow*/</comment>

<label><name>_shortestPath</name>:</label>   <comment type="block">/* cur, last_pos, best_mlen, best_off have to be set */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>opt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>mlen</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Set the next chunk's repcodes based on the repcodes of the beginning
         * of the last match, and the last sequence. This avoids us having to
         * update them while traversing the sequences.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>lastSequence</name><operator>.</operator><name>mlen</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>repcodes_t</name> <specifier>const</specifier></type> <name>reps</name> <init>= <expr><call><name>ZSTD_newRep</name><argument_list>(<argument><expr><name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>rep</name></expr></argument>, <argument><expr><name><name>lastSequence</name><operator>.</operator><name>off</name></name></expr></argument>, <argument><expr><name><name>lastSequence</name><operator>.</operator><name>litlen</name></name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>rep</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reps</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>reps</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>rep</name></expr></argument>, <argument><expr><name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>rep</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repcodes_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>storeEnd</name> <init>= <expr><name>cur</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name></type> <name>storeStart</name> <init>= <expr><name>storeEnd</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name></type> <name>seqPos</name> <init>= <expr><name>cur</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"start reverse traversal (last_pos:%u, cur:%u)"</literal></expr></argument>,
                        <argument><expr><name>last_pos</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>last_pos</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>storeEnd</name> <operator>&lt;</operator> <name>ZSTD_OPT_NUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"last sequence copied into pos=%u (llen=%u,mlen=%u,ofc=%u)"</literal></expr></argument>,
                        <argument><expr><name>storeEnd</name></expr></argument>, <argument><expr><name><name>lastSequence</name><operator>.</operator><name>litlen</name></name></expr></argument>, <argument><expr><name><name>lastSequence</name><operator>.</operator><name>mlen</name></name></expr></argument>, <argument><expr><name><name>lastSequence</name><operator>.</operator><name>off</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>opt</name><index>[<expr><name>storeEnd</name></expr>]</index></name> <operator>=</operator> <name>lastSequence</name></expr>;</expr_stmt>
            <while>while <condition>(<expr><name>seqPos</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>backDist</name> <init>= <expr><call><name>ZSTD_totalLen</name><argument_list>(<argument><expr><name><name>opt</name><index>[<expr><name>seqPos</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>storeStart</name><operator>--</operator></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"sequence from rPos=%u copied into pos=%u (llen=%u,mlen=%u,ofc=%u)"</literal></expr></argument>,
                            <argument><expr><name>seqPos</name></expr></argument>, <argument><expr><name>storeStart</name></expr></argument>, <argument><expr><name><name>opt</name><index>[<expr><name>seqPos</name></expr>]</index></name><operator>.</operator><name>litlen</name></expr></argument>, <argument><expr><name><name>opt</name><index>[<expr><name>seqPos</name></expr>]</index></name><operator>.</operator><name>mlen</name></expr></argument>, <argument><expr><name><name>opt</name><index>[<expr><name>seqPos</name></expr>]</index></name><operator>.</operator><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>opt</name><index>[<expr><name>storeStart</name></expr>]</index></name> <operator>=</operator> <name><name>opt</name><index>[<expr><name>seqPos</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>seqPos</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>seqPos</name> <operator>&gt;</operator> <name>backDist</name><operator>)</operator></expr> ?</condition><then> <expr><name>seqPos</name> <operator>-</operator> <name>backDist</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
            </block_content>}</block></while>

            <comment type="block">/* save sequences */</comment>
            <macro><name>DEBUGLOG</name><argument_list>(<argument><literal type="number">6</literal></argument>, <argument><literal type="string">"sending selected sequences into seqStore"</literal></argument>)</argument_list></macro>
            <block>{<block_content>   <decl_stmt><decl><type><name>U32</name></type> <name>storePos</name></decl>;</decl_stmt>
                <for>for <control>(<init><expr><name>storePos</name><operator>=</operator><name>storeStart</name></expr>;</init> <condition><expr><name>storePos</name> <operator>&lt;=</operator> <name>storeEnd</name></expr>;</condition> <incr><expr><name>storePos</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>llen</name> <init>= <expr><name><name>opt</name><index>[<expr><name>storePos</name></expr>]</index></name><operator>.</operator><name>litlen</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>mlen</name> <init>= <expr><name><name>opt</name><index>[<expr><name>storePos</name></expr>]</index></name><operator>.</operator><name>mlen</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>offBase</name> <init>= <expr><name><name>opt</name><index>[<expr><name>storePos</name></expr>]</index></name><operator>.</operator><name>off</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>advance</name> <init>= <expr><name>llen</name> <operator>+</operator> <name>mlen</name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"considering seq starting at %zi, llen=%u, mlen=%u"</literal></expr></argument>,
                                <argument><expr><name>anchor</name> <operator>-</operator> <name>istart</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>llen</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>mlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name>mlen</name><operator>==</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* only literals =&gt; must be last "sequence", actually starting a new stream of sequences */</comment>
                        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>storePos</name> <operator>==</operator> <name>storeEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* must be last sequence */</comment>
                        <expr_stmt><expr><name>ip</name> <operator>=</operator> <name>anchor</name> <operator>+</operator> <name>llen</name></expr>;</expr_stmt>     <comment type="block">/* last "sequence" is a bunch of literals =&gt; don't progress anchor */</comment>
                        <continue>continue;</continue>   <comment type="block">/* will finish */</comment>
                    </block_content>}</block></if></if_stmt>

                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>anchor</name> <operator>+</operator> <name>llen</name> <operator>&lt;=</operator> <name>iend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ZSTD_updateStats</name><argument_list>(<argument><expr><name>optStatePtr</name></expr></argument>, <argument><expr><name>llen</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>offBase</name></expr></argument>, <argument><expr><name>mlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ZSTD_storeSeq</name><argument_list>(<argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>llen</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>offBase</name></expr></argument>, <argument><expr><name>mlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>anchor</name> <operator>+=</operator> <name>advance</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>ip</name> <operator>=</operator> <name>anchor</name></expr>;</expr_stmt>
            </block_content>}</block></for>   </block_content>}</block>
            <expr_stmt><expr><call><name>ZSTD_setBasePrices</name><argument_list>(<argument><expr><name>optStatePtr</name></expr></argument>, <argument><expr><name>optLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></while>   <comment type="block">/* while (ip &lt; ilimit) */</comment>

    <comment type="block">/* Return the last literals size */</comment>
    <return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>iend</name> <operator>-</operator> <name>anchor</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_compressBlock_opt0</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ZSTD_dictMode_e</name></type> <name>dictMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBlock_opt_generic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* optLevel */</comment>, <argument><expr><name>dictMode</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_compressBlock_opt2</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ZSTD_dictMode_e</name></type> <name>dictMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBlock_opt_generic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument> <comment type="block">/* optLevel */</comment>, <argument><expr><name>dictMode</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_btopt</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressBlock_btopt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>ZSTD_compressBlock_opt0</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>ZSTD_noDict</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>




<comment type="block">/* ZSTD_initStats_ultra():
 * make a first compression pass, just to seed stats with more accurate starting values.
 * only works on first block, with no dictionary and no ldm.
 * this function cannot error, hence its contract must be respected.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ZSTD_initStats_ultra</name><parameter_list>(<parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>,
                     <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>,
                     <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
               <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name></type> <name><name>tmpRep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* updated rep codes will sink here */</comment>
    <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>tmpRep</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmpRep</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_initStats_ultra (srcSize=%zu)"</literal></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>litLengthSum</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* first block */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>seqStore</name><operator>-&gt;</operator><name>sequences</name></name> <operator>==</operator> <name><name>seqStore</name><operator>-&gt;</operator><name>sequencesStart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* no ldm */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictLimit</name></name> <operator>==</operator> <name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>lowLimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* no dictionary */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictLimit</name></name> <operator>-</operator> <name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name> <operator>&lt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* no prefix (note: intentional overflow, defined as 2-complement) */</comment>

    <expr_stmt><expr><call><name>ZSTD_compressBlock_opt2</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>tmpRep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>ZSTD_noDict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* generate stats into ms-&gt;opt*/</comment>

    <comment type="block">/* invalidate first scan from history */</comment>
    <expr_stmt><expr><call><name>ZSTD_resetSeqStore</name><argument_list>(<argument><expr><name>seqStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name> <operator>-=</operator> <name>srcSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictLimit</name></name> <operator>+=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>srcSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>lowLimit</name></name> <operator>=</operator> <name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictLimit</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name> <operator>=</operator> <name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictLimit</name></name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_btultra</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressBlock_btultra (srcSize=%zu)"</literal></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>ZSTD_compressBlock_opt2</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>ZSTD_noDict</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_btultra2</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>curr</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name> <operator>-</operator> <name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressBlock_btultra2 (srcSize=%zu)"</literal></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* 2-pass strategy:
     * this strategy makes a first pass over first block to collect statistics
     * and seed next round's statistics with it.
     * After 1st pass, function forgets everything, and starts a new block.
     * Consequently, this can only work if no data has been previously loaded in tables,
     * aka, no dictionary, no prefix, no ldm preprocessing.
     * The compression ratio gain is generally small (~0.5% on first block),
     * the cost is 2x cpu time on first block. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>srcSize</name> <operator>&lt;=</operator> <name>ZSTD_BLOCKSIZE_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>( <expr><operator>(</operator><name><name>ms</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>litLengthSum</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator>   <comment type="block">/* first block */</comment>
      <operator>&amp;&amp;</operator> <operator>(</operator><name><name>seqStore</name><operator>-&gt;</operator><name>sequences</name></name> <operator>==</operator> <name><name>seqStore</name><operator>-&gt;</operator><name>sequencesStart</name></name><operator>)</operator>  <comment type="block">/* no ldm */</comment>
      <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictLimit</name></name> <operator>==</operator> <name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>lowLimit</name></name><operator>)</operator>   <comment type="block">/* no dictionary */</comment>
      <operator>&amp;&amp;</operator> <operator>(</operator><name>curr</name> <operator>==</operator> <name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictLimit</name></name><operator>)</operator>   <comment type="block">/* start of frame, nothing already loaded nor skipped */</comment>
      <operator>&amp;&amp;</operator> <operator>(</operator><name>srcSize</name> <operator>&gt;</operator> <name>ZSTD_PREDEF_THRESHOLD</name><operator>)</operator></expr>
      )</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>ZSTD_initStats_ultra</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><call><name>ZSTD_compressBlock_opt2</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>ZSTD_noDict</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_btopt_dictMatchState</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBlock_opt0</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>ZSTD_dictMatchState</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_btultra_dictMatchState</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBlock_opt2</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>ZSTD_dictMatchState</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_btopt_extDict</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBlock_opt0</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>ZSTD_extDict</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_btultra_extDict</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBlock_opt2</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>ZSTD_extDict</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* note : no btultra2 variant for extDict nor dictMatchState,
 * because btultra2 is not meant to work with dictionaries
 * and is only specific for the first block (no prefix) */</comment>
</unit>
