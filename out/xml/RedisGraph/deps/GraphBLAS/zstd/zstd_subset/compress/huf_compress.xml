<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/zstd/zstd_subset/compress/huf_compress.c"><comment type="block">/* ******************************************************************
 * Huffman encoder, part of New Generation Entropy library
 * Copyright (c) Yann Collet, Facebook, Inc.
 *
 *  You can contact the author at :
 *  - FSE+HUF source repository : https://github.com/Cyan4973/FiniteStateEntropy
 *  - Public forum : https://groups.google.com/forum/#!forum/lz4c
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
****************************************************************** */</comment>

<comment type="block">/* **************************************************************
*  Compiler specifics
****************************************************************/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>    <comment type="block">/* Visual Studio */</comment>
<cpp:pragma>#  <cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name> <name>:</name> <name>4127</name><name>)</name></cpp:pragma>        <comment type="block">/* disable: C4127: conditional expression is constant */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* **************************************************************
*  Includes
****************************************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/zstd_deps.h"</cpp:file></cpp:include>     <comment type="block">/* ZSTD_memcpy, ZSTD_memset */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/compiler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/bitstream.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hist.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FSE_STATIC_LINKING_ONLY</name></cpp:macro></cpp:define>   <comment type="block">/* FSE_optimalTableLog_internal */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/fse.h"</cpp:file></cpp:include>        <comment type="block">/* header compression */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_STATIC_LINKING_ONLY</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/huf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/error_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/bits.h"</cpp:file></cpp:include>       <comment type="block">/* ZSTD_highbit32 */</comment>


<comment type="block">/* **************************************************************
*  Error Management
****************************************************************/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_isError</name></cpp:macro> <cpp:value>ERR_isError</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_STATIC_ASSERT</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>DEBUG_STATIC_ASSERT(c)</cpp:value></cpp:define>   <comment type="block">/* use only *after* variable declarations */</comment>


<comment type="block">/* **************************************************************
*  Required declarations
****************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>nodeElt_s</name> <block>{
    <decl_stmt><decl><type><name>U32</name></type> <name>count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U16</name></type> <name>parent</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name></type> <name>byte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name></type> <name>nbBits</name></decl>;</decl_stmt>
}</block></struct></type> <name>nodeElt</name>;</typedef>


<comment type="block">/* **************************************************************
*  Debug Traces
****************************************************************/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEBUGLEVEL</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></cpp:if>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>showU32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>U32</name><modifier>*</modifier></type> <name>arr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>u</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>u</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>u</name><operator>&lt;</operator><name>size</name></expr>;</condition> <incr><expr><name>u</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>RAWLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">" %u"</literal></expr></argument>, <argument><expr><name><name>arr</name><index>[<expr><name>u</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>arr</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>RAWLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">" \n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>size_t</name></type> <name>HUF_getNbBits</name><parameter_list>(<parameter><decl><type><name>HUF_CElt</name></type> <name>elt</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>showCTableBits</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>HUF_CElt</name><modifier>*</modifier></type> <name>ctable</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>u</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>u</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>u</name><operator>&lt;</operator><name>size</name></expr>;</condition> <incr><expr><name>u</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>RAWLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">" %zu"</literal></expr></argument>, <argument><expr><call><name>HUF_getNbBits</name><argument_list>(<argument><expr><name><name>ctable</name><index>[<expr><name>u</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>ctable</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>RAWLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">" \n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>size</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>showHNodeSymbols</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>nodeElt</name><modifier>*</modifier></type> <name>hnode</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>u</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>u</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>u</name><operator>&lt;</operator><name>size</name></expr>;</condition> <incr><expr><name>u</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>RAWLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">" %u"</literal></expr></argument>, <argument><expr><name><name>hnode</name><index>[<expr><name>u</name></expr>]</index></name><operator>.</operator><name>byte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>hnode</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>RAWLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">" \n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>showHNodeBits</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>nodeElt</name><modifier>*</modifier></type> <name>hnode</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>u</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>u</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>u</name><operator>&lt;</operator><name>size</name></expr>;</condition> <incr><expr><name>u</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>RAWLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">" %u"</literal></expr></argument>, <argument><expr><name><name>hnode</name><index>[<expr><name>u</name></expr>]</index></name><operator>.</operator><name>nbBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>hnode</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>RAWLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">" \n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* *******************************************************
*  HUF : Huffman block compression
*********************************************************/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_WORKSPACE_MAX_ALIGNMENT</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type> <name>HUF_alignUpWorkspace</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workspace</name></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>workspaceSizePtr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>align</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>mask</name> <init>= <expr><name>align</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>rem</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><name>workspace</name> <operator>&amp;</operator> <name>mask</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>add</name> <init>= <expr><operator>(</operator><name>align</name> <operator>-</operator> <name>rem</name><operator>)</operator> <operator>&amp;</operator> <name>mask</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>aligned</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>workspace</name> <operator>+</operator> <name>add</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>align</name> <operator>&amp;</operator> <operator>(</operator><name>align</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* pow 2 */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>align</name> <operator>&lt;=</operator> <name>HUF_WORKSPACE_MAX_ALIGNMENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>workspaceSizePtr</name> <operator>&gt;=</operator> <name>add</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>add</name> <operator>&lt;</operator> <name>align</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><name>aligned</name> <operator>&amp;</operator> <name>mask</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>workspaceSizePtr</name> <operator>-=</operator> <name>add</name></expr>;</expr_stmt>
        <return>return <expr><name>aligned</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>workspaceSizePtr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* HUF_compressWeights() :
 * Same as FSE_compress(), but dedicated to huff0's weights compression.
 * The use case needs much less stack memory.
 * Note : all elements within weightTable are supposed to be &lt;= HUF_TABLELOG_MAX.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_FSE_TABLELOG_FOR_HUFF_HEADER</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>FSE_CTable</name></type> <name><name>CTable</name><index>[<expr><call><name>FSE_CTABLE_SIZE_U32</name><argument_list>(<argument><expr><name>MAX_FSE_TABLELOG_FOR_HUFF_HEADER</name></expr></argument>, <argument><expr><name>HUF_TABLELOG_MAX</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name><name>scratchBuffer</name><index>[<expr><call><name>FSE_BUILD_CTABLE_WORKSPACE_SIZE_U32</name><argument_list>(<argument><expr><name>HUF_TABLELOG_MAX</name></expr></argument>, <argument><expr><name>MAX_FSE_TABLELOG_FOR_HUFF_HEADER</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name><name>count</name><index>[<expr><name>HUF_TABLELOG_MAX</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>S16</name></type> <name><name>norm</name><index>[<expr><name>HUF_TABLELOG_MAX</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>HUF_CompressWeightsWksp</name>;</typedef>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>HUF_compressWeights</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
              <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>weightTable</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wtSize</name></decl></parameter>,
                    <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workspace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>workspaceSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ostart</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator> <name>dst</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><name>ostart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend</name> <init>= <expr><name>ostart</name> <operator>+</operator> <name>dstSize</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>unsigned</name></type> <name>maxSymbolValue</name> <init>= <expr><name>HUF_TABLELOG_MAX</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>tableLog</name> <init>= <expr><name>MAX_FSE_TABLELOG_FOR_HUFF_HEADER</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HUF_CompressWeightsWksp</name><modifier>*</modifier></type> <name>wksp</name> <init>= <expr><operator>(</operator><name>HUF_CompressWeightsWksp</name><operator>*</operator><operator>)</operator><call><name>HUF_alignUpWorkspace</name><argument_list>(<argument><expr><name>workspace</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>workspaceSize</name></expr></argument>, <argument><expr><call><name>ZSTD_ALIGNOF</name><argument_list>(<argument><expr><name>U32</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>workspaceSize</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HUF_CompressWeightsWksp</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>GENERIC</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* init conditions */</comment>
    <if_stmt><if>if <condition>(<expr><name>wtSize</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Not compressible */</comment>

    <comment type="block">/* Scan input and build symbol stats */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>maxCount</name> <init>= <expr><call><name>HIST_count_simple</name><argument_list>(<argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>maxSymbolValue</name></expr></argument>, <argument><expr><name>weightTable</name></expr></argument>, <argument><expr><name>wtSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>   <comment type="block">/* never fails */</comment>
        <if_stmt><if>if <condition>(<expr><name>maxCount</name> <operator>==</operator> <name>wtSize</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* only a single symbol in src : rle */</comment>
        <if_stmt><if>if <condition>(<expr><name>maxCount</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>        <comment type="block">/* each symbol present maximum once =&gt; not compressible */</comment>
    </block_content>}</block>

    <expr_stmt><expr><name>tableLog</name> <operator>=</operator> <call><name>FSE_optimalTableLog</name><argument_list>(<argument><expr><name>tableLog</name></expr></argument>, <argument><expr><name>wtSize</name></expr></argument>, <argument><expr><name>maxSymbolValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_F</name><argument_list>( <argument><expr><call><name>FSE_normalizeCount</name><argument_list>(<argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>norm</name></name></expr></argument>, <argument><expr><name>tableLog</name></expr></argument>, <argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><name>wtSize</name></expr></argument>, <argument><expr><name>maxSymbolValue</name></expr></argument>, <comment type="block">/* useLowProbCount */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Write table description header */</comment>
    <block>{<block_content>   <expr_stmt><expr><call><name>CHECK_V_F</name><argument_list>(<argument><expr><name>hSize</name></expr></argument>, <argument><expr><call><name>FSE_writeNCount</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name><operator>-</operator><name>op</name><operator>)</operator></expr></argument>, <argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>norm</name></name></expr></argument>, <argument><expr><name>maxSymbolValue</name></expr></argument>, <argument><expr><name>tableLog</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>hSize</name></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* Compress */</comment>
    <expr_stmt><expr><call><name>CHECK_F</name><argument_list>( <argument><expr><call><name>FSE_buildCTable_wksp</name><argument_list>(<argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>CTable</name></name></expr></argument>, <argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>norm</name></name></expr></argument>, <argument><expr><name>maxSymbolValue</name></expr></argument>, <argument><expr><name>tableLog</name></expr></argument>, <argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>scratchBuffer</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>scratchBuffer</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>   <expr_stmt><expr><call><name>CHECK_V_F</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>, <argument><expr><call><name>FSE_compress_usingCTable</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name> <operator>-</operator> <name>op</name><operator>)</operator></expr></argument>, <argument><expr><name>weightTable</name></expr></argument>, <argument><expr><name>wtSize</name></expr></argument>, <argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>CTable</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>cSize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* not enough space for compressed data */</comment>
        <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>cSize</name></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>op</name><operator>-</operator><name>ostart</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>HUF_getNbBits</name><parameter_list>(<parameter><decl><type><name>HUF_CElt</name></type> <name>elt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>elt</name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>HUF_getNbBitsFast</name><parameter_list>(<parameter><decl><type><name>HUF_CElt</name></type> <name>elt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>elt</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>HUF_getValue</name><parameter_list>(<parameter><decl><type><name>HUF_CElt</name></type> <name>elt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>elt</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">0xFF</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>HUF_getValueFast</name><parameter_list>(<parameter><decl><type><name>HUF_CElt</name></type> <name>elt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>elt</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>HUF_setNbBits</name><parameter_list>(<parameter><decl><type><name>HUF_CElt</name><modifier>*</modifier></type> <name>elt</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nbBits</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nbBits</name> <operator>&lt;=</operator> <name>HUF_TABLELOG_ABSOLUTEMAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>elt</name> <operator>=</operator> <name>nbBits</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>HUF_setValue</name><parameter_list>(<parameter><decl><type><name>HUF_CElt</name><modifier>*</modifier></type> <name>elt</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>nbBits</name> <init>= <expr><call><name>HUF_getNbBits</name><argument_list>(<argument><expr><operator>*</operator><name>elt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>nbBits</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>value</name> <operator>&gt;&gt;</operator> <name>nbBits</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>elt</name> <operator>|=</operator> <name>value</name> <operator>&lt;&lt;</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>HUF_CElt</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">8</literal> <operator>-</operator> <name>nbBits</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>HUF_CompressWeightsWksp</name></type> <name>wksp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name></type> <name><name>bitsToWeight</name><index>[<expr><name>HUF_TABLELOG_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>   <comment type="block">/* precomputed conversion table */</comment>
    <decl_stmt><decl><type><name>BYTE</name></type> <name><name>huffWeight</name><index>[<expr><name>HUF_SYMBOLVALUE_MAX</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>HUF_WriteCTableWksp</name>;</typedef>

<function><type><name>size_t</name></type> <name>HUF_writeCTable_wksp</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>maxDstSize</name></decl></parameter>,
                            <parameter><decl><type><specifier>const</specifier> <name>HUF_CElt</name><modifier>*</modifier></type> <name>CTable</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>maxSymbolValue</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>huffLog</name></decl></parameter>,
                            <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workspace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>workspaceSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HUF_CElt</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>ct</name> <init>= <expr><name>CTable</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HUF_WriteCTableWksp</name><modifier>*</modifier></type> <name>wksp</name> <init>= <expr><operator>(</operator><name>HUF_WriteCTableWksp</name><operator>*</operator><operator>)</operator><call><name>HUF_alignUpWorkspace</name><argument_list>(<argument><expr><name>workspace</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>workspaceSize</name></expr></argument>, <argument><expr><call><name>ZSTD_ALIGNOF</name><argument_list>(<argument><expr><name>U32</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* check conditions */</comment>
    <if_stmt><if>if <condition>(<expr><name>workspaceSize</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HUF_WriteCTableWksp</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>GENERIC</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>maxSymbolValue</name> <operator>&gt;</operator> <name>HUF_SYMBOLVALUE_MAX</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>maxSymbolValue_tooLarge</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* convert to weight */</comment>
    <expr_stmt><expr><name><name>wksp</name><operator>-&gt;</operator><name>bitsToWeight</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>n</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>n</name><operator>&lt;</operator><name>huffLog</name><operator>+</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>wksp</name><operator>-&gt;</operator><name>bitsToWeight</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><operator>(</operator><name>huffLog</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>n</name><operator>)</operator></expr>;</expr_stmt></block_content></block></for>
    <for>for <control>(<init><expr><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name><operator>&lt;</operator><name>maxSymbolValue</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>wksp</name><operator>-&gt;</operator><name>huffWeight</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name><name>wksp</name><operator>-&gt;</operator><name>bitsToWeight</name><index>[<expr><call><name>HUF_getNbBits</name><argument_list>(<argument><expr><name><name>ct</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/* attempt weights compression by FSE */</comment>
    <if_stmt><if>if <condition>(<expr><name>maxDstSize</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>dstSize_tooSmall</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <block>{<block_content>   <expr_stmt><expr><call><name>CHECK_V_F</name><argument_list>(<argument><expr><name>hSize</name></expr></argument>, <argument><expr><call><name>HUF_compressWeights</name><argument_list>(<argument><expr><name>op</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>maxDstSize</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>huffWeight</name></name></expr></argument>, <argument><expr><name>maxSymbolValue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>wksp</name><operator>-&gt;</operator><name>wksp</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>wksp</name><operator>-&gt;</operator><name>wksp</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>hSize</name><operator>&gt;</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>hSize</name> <operator>&lt;</operator> <name>maxSymbolValue</name><operator>/</operator><literal type="number">2</literal><operator>)</operator></expr>)</condition> <block>{<block_content>   <comment type="block">/* FSE compressed */</comment>
            <expr_stmt><expr><name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><name>hSize</name></expr>;</expr_stmt>
            <return>return <expr><name>hSize</name><operator>+</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>   </block_content>}</block>

    <comment type="block">/* write raw values as 4-bits (max : 15) */</comment>
    <if_stmt><if>if <condition>(<expr><name>maxSymbolValue</name> <operator>&gt;</operator> <operator>(</operator><literal type="number">256</literal><operator>-</operator><literal type="number">128</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>GENERIC</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* should not happen : likely means source cannot be compressed */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>maxSymbolValue</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><literal type="number">2</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name>maxDstSize</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>dstSize_tooSmall</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* not enough space within dst buffer */</comment>
    <expr_stmt><expr><name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><operator>(</operator><literal type="number">128</literal> <comment type="block">/*special case*/</comment> <operator>+</operator> <operator>(</operator><name>maxSymbolValue</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>wksp</name><operator>-&gt;</operator><name>huffWeight</name><index>[<expr><name>maxSymbolValue</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>   <comment type="block">/* to be sure it doesn't cause msan issue in final combination */</comment>
    <for>for <control>(<init><expr><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name><operator>&lt;</operator><name>maxSymbolValue</name></expr>;</condition> <incr><expr><name>n</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>op</name><index>[<expr><operator>(</operator><name>n</name><operator>/</operator><literal type="number">2</literal><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>wksp</name><operator>-&gt;</operator><name>huffWeight</name><index>[<expr><name>n</name></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>+</operator> <name><name>wksp</name><operator>-&gt;</operator><name>huffWeight</name><index>[<expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt></block_content></block></for>
    <return>return <expr><operator>(</operator><operator>(</operator><name>maxSymbolValue</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><literal type="number">2</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! HUF_writeCTable() :
    `CTable` : Huffman tree to save, using huf representation.
    @return : size of saved CTable */</comment>
<function><type><name>size_t</name></type> <name>HUF_writeCTable</name> <parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>maxDstSize</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>HUF_CElt</name><modifier>*</modifier></type> <name>CTable</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>maxSymbolValue</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>huffLog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HUF_WriteCTableWksp</name></type> <name>wksp</name></decl>;</decl_stmt>
    <return>return <expr><call><name>HUF_writeCTable_wksp</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>, <argument><expr><name>CTable</name></expr></argument>, <argument><expr><name>maxSymbolValue</name></expr></argument>, <argument><expr><name>huffLog</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wksp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>wksp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>size_t</name></type> <name>HUF_readCTable</name> <parameter_list>(<parameter><decl><type><name>HUF_CElt</name><modifier>*</modifier></type> <name>CTable</name></decl></parameter>, <parameter><decl><type><name>unsigned</name><modifier>*</modifier></type> <name>maxSymbolValuePtr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>unsigned</name><modifier>*</modifier></type> <name>hasZeroWeights</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BYTE</name></type> <name><name>huffWeight</name><index>[<expr><name>HUF_SYMBOLVALUE_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>   <comment type="block">/* init not required, even though some static analyzer may complain */</comment>
    <decl_stmt><decl><type><name>U32</name></type> <name><name>rankVal</name><index>[<expr><name>HUF_TABLELOG_ABSOLUTEMAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>   <comment type="block">/* large enough for values from 0 to 16 */</comment>
    <decl_stmt><decl><type><name>U32</name></type> <name>tableLog</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>nbSymbols</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HUF_CElt</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ct</name> <init>= <expr><name>CTable</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* get symbol weights */</comment>
    <expr_stmt><expr><call><name>CHECK_V_F</name><argument_list>(<argument><expr><name>readSize</name></expr></argument>, <argument><expr><call><name>HUF_readStats</name><argument_list>(<argument><expr><name>huffWeight</name></expr></argument>, <argument><expr><name>HUF_SYMBOLVALUE_MAX</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>rankVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbSymbols</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tableLog</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>hasZeroWeights</name> <operator>=</operator> <operator>(</operator><name><name>rankVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* check result */</comment>
    <if_stmt><if>if <condition>(<expr><name>tableLog</name> <operator>&gt;</operator> <name>HUF_TABLELOG_MAX</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>tableLog_tooLarge</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>nbSymbols</name> <operator>&gt;</operator> <operator>*</operator><name>maxSymbolValuePtr</name><operator>+</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>maxSymbolValue_tooSmall</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>CTable</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>tableLog</name></expr>;</expr_stmt>

    <comment type="block">/* Prepare base value per rank */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>U32</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>nextRankStart</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>n</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>n</name><operator>&lt;=</operator><name>tableLog</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>U32</name></type> <name>curr</name> <init>= <expr><name>nextRankStart</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>nextRankStart</name> <operator>+=</operator> <operator>(</operator><name><name>rankVal</name><index>[<expr><name>n</name></expr>]</index></name> <operator>&lt;&lt;</operator> <operator>(</operator><name>n</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rankVal</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name>curr</name></expr>;</expr_stmt>
    </block_content>}</block></for>   </block_content>}</block>

    <comment type="block">/* fill nbBits */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>U32</name></type> <name>n</name></decl>;</decl_stmt> <for>for <control>(<init><expr><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name><operator>&lt;</operator><name>nbSymbols</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>w</name> <init>= <expr><name><name>huffWeight</name><index>[<expr><name>n</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>HUF_setNbBits</name><argument_list>(<argument><expr><name>ct</name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><operator>(</operator><name>BYTE</name><operator>)</operator><operator>(</operator><name>tableLog</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>w</name><operator>)</operator> <operator>&amp;</operator> <operator>-</operator><operator>(</operator><name>w</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>   </block_content>}</block>

    <comment type="block">/* fill val */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>U16</name></type> <name><name>nbPerRank</name><index>[<expr><name>HUF_TABLELOG_MAX</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name>  <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>  <comment type="block">/* support w=0=&gt;n=tableLog+1 */</comment>
        <decl_stmt><decl><type><name>U16</name></type> <name><name>valPerRank</name><index>[<expr><name>HUF_TABLELOG_MAX</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
        <block>{<block_content> <decl_stmt><decl><type><name>U32</name></type> <name>n</name></decl>;</decl_stmt> <for>for <control>(<init><expr><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name><operator>&lt;</operator><name>nbSymbols</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>nbPerRank</name><index>[<expr><call><name>HUF_getNbBits</name><argument_list>(<argument><expr><name><name>ct</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block_content></block></for> </block_content>}</block>
        <comment type="block">/* determine stating value per rank */</comment>
        <expr_stmt><expr><name><name>valPerRank</name><index>[<expr><name>tableLog</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>   <comment type="block">/* for w==0 */</comment>
        <block>{<block_content>   <decl_stmt><decl><type><name>U16</name></type> <name>min</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name></type> <name>n</name></decl>;</decl_stmt> <for>for <control>(<init><expr><name>n</name><operator>=</operator><name>tableLog</name></expr>;</init> <condition><expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>n</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>  <comment type="block">/* start at n=tablelog &lt;-&gt; w=1 */</comment>
                <expr_stmt><expr><name><name>valPerRank</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name>min</name></expr>;</expr_stmt>     <comment type="block">/* get starting value within each rank */</comment>
                <expr_stmt><expr><name>min</name> <operator>+=</operator> <name><name>nbPerRank</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>min</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></for>   </block_content>}</block>
        <comment type="block">/* assign value within rank, symbol order */</comment>
        <block>{<block_content> <decl_stmt><decl><type><name>U32</name></type> <name>n</name></decl>;</decl_stmt> <for>for <control>(<init><expr><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name><operator>&lt;</operator><name>nbSymbols</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>HUF_setValue</name><argument_list>(<argument><expr><name>ct</name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name><name>valPerRank</name><index>[<expr><call><name>HUF_getNbBits</name><argument_list>(<argument><expr><name><name>ct</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>]</index></name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for> </block_content>}</block>
    </block_content>}</block>

    <expr_stmt><expr><operator>*</operator><name>maxSymbolValuePtr</name> <operator>=</operator> <name>nbSymbols</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><name>readSize</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>U32</name></type> <name>HUF_getNbBitsFromCTable</name><parameter_list>(<parameter><decl><type><name>HUF_CElt</name> <specifier>const</specifier><modifier>*</modifier></type> <name>CTable</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>symbolValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>HUF_CElt</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ct</name> <init>= <expr><name>CTable</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>symbolValue</name> <operator>&lt;=</operator> <name>HUF_SYMBOLVALUE_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>U32</name><operator>)</operator><call><name>HUF_getNbBits</name><argument_list>(<argument><expr><name><name>ct</name><index>[<expr><name>symbolValue</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
 * HUF_setMaxHeight():
 * Try to enforce @targetNbBits on the Huffman tree described in @huffNode.
 *
 * It attempts to convert all nodes with nbBits &gt; @targetNbBits
 * to employ @targetNbBits instead. Then it adjusts the tree
 * so that it remains a valid canonical Huffman tree.
 *
 * @pre               The sum of the ranks of each symbol == 2^largestBits,
 *                    where largestBits == huffNode[lastNonNull].nbBits.
 * @post              The sum of the ranks of each symbol == 2^largestBits,
 *                    where largestBits is the return value (expected &lt;= targetNbBits).
 *
 * @param huffNode    The Huffman tree modified in place to enforce targetNbBits.
 *                    It's presumed sorted, from most frequent to rarest symbol.
 * @param lastNonNull The symbol with the lowest count in the Huffman tree.
 * @param targetNbBits  The allowed number of bits, which the Huffman tree
 *                    may not respect. After this function the Huffman tree will
 *                    respect targetNbBits.
 * @return            The maximum number of bits of the Huffman tree after adjustment.
 */</comment>
<function><type><specifier>static</specifier> <name>U32</name></type> <name>HUF_setMaxHeight</name><parameter_list>(<parameter><decl><type><name>nodeElt</name><modifier>*</modifier></type> <name>huffNode</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>lastNonNull</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>targetNbBits</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>largestBits</name> <init>= <expr><name><name>huffNode</name><index>[<expr><name>lastNonNull</name></expr>]</index></name><operator>.</operator><name>nbBits</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* early exit : no elt &gt; targetNbBits, so the tree is already valid. */</comment>
    <if_stmt><if>if <condition>(<expr><name>largestBits</name> <operator>&lt;=</operator> <name>targetNbBits</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>largestBits</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"HUF_setMaxHeight (targetNbBits = %u)"</literal></expr></argument>, <argument><expr><name>targetNbBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* there are several too large elements (at least &gt;= 2) */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>int</name></type> <name>totalCost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>baseCost</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>largestBits</name> <operator>-</operator> <name>targetNbBits</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name>lastNonNull</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Adjust any ranks &gt; targetNbBits to targetNbBits.
         * Compute totalCost, which is how far the sum of the ranks is
         * we are over 2^largestBits after adjust the offending ranks.
         */</comment>
        <while>while <condition>(<expr><name><name>huffNode</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>nbBits</name> <operator>&gt;</operator> <name>targetNbBits</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>totalCost</name> <operator>+=</operator> <name>baseCost</name> <operator>-</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>largestBits</name> <operator>-</operator> <name><name>huffNode</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>nbBits</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>huffNode</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>nbBits</name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><name>targetNbBits</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
        <comment type="block">/* n stops at huffNode[n].nbBits &lt;= targetNbBits */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>huffNode</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>nbBits</name> <operator>&lt;=</operator> <name>targetNbBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* n end at index of smallest symbol using &lt; targetNbBits */</comment>
        <while>while <condition>(<expr><name><name>huffNode</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>nbBits</name> <operator>==</operator> <name>targetNbBits</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>--</operator><name>n</name></expr>;</expr_stmt></block_content></block></while>

        <comment type="block">/* renorm totalCost from 2^largestBits to 2^targetNbBits
         * note : totalCost is necessarily a multiple of baseCost */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>totalCost</name> <operator>&amp;</operator> <operator>(</operator><name>baseCost</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>totalCost</name> <operator>&gt;&gt;=</operator> <operator>(</operator><name>largestBits</name> <operator>-</operator> <name>targetNbBits</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>totalCost</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* repay normalized cost */</comment>
        <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>noSymbol</name> <init>= <expr><literal type="number">0xF0F0F0F0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name></type> <name><name>rankLast</name><index>[<expr><name>HUF_TABLELOG_MAX</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

            <comment type="block">/* Get pos of last (smallest = lowest cum. count) symbol per rank */</comment>
            <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><name>rankLast</name></expr></argument>, <argument><expr><literal type="number">0xF0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rankLast</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <block>{<block_content>   <decl_stmt><decl><type><name>U32</name></type> <name>currentNbBits</name> <init>= <expr><name>targetNbBits</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>
                <for>for <control>(<init><expr><name>pos</name><operator>=</operator><name>n</name></expr> ;</init> <condition><expr><name>pos</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>pos</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>huffNode</name><index>[<expr><name>pos</name></expr>]</index></name><operator>.</operator><name>nbBits</name> <operator>&gt;=</operator> <name>currentNbBits</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name>currentNbBits</name> <operator>=</operator> <name><name>huffNode</name><index>[<expr><name>pos</name></expr>]</index></name><operator>.</operator><name>nbBits</name></expr>;</expr_stmt>   <comment type="block">/* &lt; targetNbBits */</comment>
                    <expr_stmt><expr><name><name>rankLast</name><index>[<expr><name>targetNbBits</name><operator>-</operator><name>currentNbBits</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>pos</name></expr>;</expr_stmt>
            </block_content>}</block></for>   </block_content>}</block>

            <while>while <condition>(<expr><name>totalCost</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <comment type="block">/* Try to reduce the next power of 2 above totalCost because we
                 * gain back half the rank.
                 */</comment>
                <decl_stmt><decl><type><name>U32</name></type> <name>nBitsToDecrease</name> <init>= <expr><call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>totalCost</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
                <for>for <control>( <init>;</init> <condition><expr><name>nBitsToDecrease</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>nBitsToDecrease</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
                    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>highPos</name> <init>= <expr><name><name>rankLast</name><index>[<expr><name>nBitsToDecrease</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>lowPos</name> <init>= <expr><name><name>rankLast</name><index>[<expr><name>nBitsToDecrease</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>highPos</name> <operator>==</operator> <name>noSymbol</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
                    <comment type="block">/* Decrease highPos if no symbols of lowPos or if it is
                     * not cheaper to remove 2 lowPos than highPos.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name>lowPos</name> <operator>==</operator> <name>noSymbol</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
                    <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>highTotal</name> <init>= <expr><name><name>huffNode</name><index>[<expr><name>highPos</name></expr>]</index></name><operator>.</operator><name>count</name></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>lowTotal</name> <init>= <expr><literal type="number">2</literal> <operator>*</operator> <name><name>huffNode</name><index>[<expr><name>lowPos</name></expr>]</index></name><operator>.</operator><name>count</name></expr></init></decl>;</decl_stmt>
                        <if_stmt><if>if <condition>(<expr><name>highTotal</name> <operator>&lt;=</operator> <name>lowTotal</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
                </block_content>}</block>   </block_content>}</block></for>
                <comment type="block">/* only triggered when no more rank 1 symbol left =&gt; find closest one (note : there is necessarily at least one !) */</comment>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>rankLast</name><index>[<expr><name>nBitsToDecrease</name></expr>]</index></name> <operator>!=</operator> <name>noSymbol</name> <operator>||</operator> <name>nBitsToDecrease</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* HUF_MAX_TABLELOG test just to please gcc 5+; but it should not be necessary */</comment>
                <while>while <condition>(<expr><operator>(</operator><name>nBitsToDecrease</name><operator>&lt;=</operator><name>HUF_TABLELOG_MAX</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>rankLast</name><index>[<expr><name>nBitsToDecrease</name></expr>]</index></name> <operator>==</operator> <name>noSymbol</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>nBitsToDecrease</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>rankLast</name><index>[<expr><name>nBitsToDecrease</name></expr>]</index></name> <operator>!=</operator> <name>noSymbol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* Increase the number of bits to gain back half the rank cost. */</comment>
                <expr_stmt><expr><name>totalCost</name> <operator>-=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>nBitsToDecrease</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>huffNode</name><index>[<expr><name><name>rankLast</name><index>[<expr><name>nBitsToDecrease</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>nbBits</name><operator>++</operator></expr>;</expr_stmt>

                <comment type="block">/* Fix up the new rank.
                 * If the new rank was empty, this symbol is now its smallest.
                 * Otherwise, this symbol will be the largest in the new rank so no adjustment.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>rankLast</name><index>[<expr><name>nBitsToDecrease</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>noSymbol</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>rankLast</name><index>[<expr><name>nBitsToDecrease</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>rankLast</name><index>[<expr><name>nBitsToDecrease</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <comment type="block">/* Fix up the old rank.
                 * If the symbol was at position 0, meaning it was the highest weight symbol in the tree,
                 * it must be the only symbol in its rank, so the old rank now has no symbols.
                 * Otherwise, since the Huffman nodes are sorted by count, the previous position is now
                 * the smallest node in the rank. If the previous position belongs to a different rank,
                 * then the rank is now empty.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>rankLast</name><index>[<expr><name>nBitsToDecrease</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* special case, reached largest symbol */</comment>
                    <expr_stmt><expr><name><name>rankLast</name><index>[<expr><name>nBitsToDecrease</name></expr>]</index></name> <operator>=</operator> <name>noSymbol</name></expr>;</expr_stmt></block_content></block></if>
                <else>else <block>{<block_content>
                    <expr_stmt><expr><name><name>rankLast</name><index>[<expr><name>nBitsToDecrease</name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>huffNode</name><index>[<expr><name><name>rankLast</name><index>[<expr><name>nBitsToDecrease</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>nbBits</name> <operator>!=</operator> <name>targetNbBits</name><operator>-</operator><name>nBitsToDecrease</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>rankLast</name><index>[<expr><name>nBitsToDecrease</name></expr>]</index></name> <operator>=</operator> <name>noSymbol</name></expr>;</expr_stmt></block_content></block></if></if_stmt>   <comment type="block">/* this rank is now empty */</comment>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></while>   <comment type="block">/* while (totalCost &gt; 0) */</comment>

            <comment type="block">/* If we've removed too much weight, then we have to add it back.
             * To avoid overshooting again, we only adjust the smallest rank.
             * We take the largest nodes from the lowest rank 0 and move them
             * to rank 1. There's guaranteed to be enough rank 0 symbols because
             * TODO.
             */</comment>
            <while>while <condition>(<expr><name>totalCost</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Sometimes, cost correction overshoot */</comment>
                <comment type="block">/* special case : no rank 1 symbol (using targetNbBits-1);
                 * let's create one from largest rank 0 (using targetNbBits).
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>rankLast</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>noSymbol</name></expr>)</condition> <block>{<block_content>
                    <while>while <condition>(<expr><name><name>huffNode</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>nbBits</name> <operator>==</operator> <name>targetNbBits</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
                    <expr_stmt><expr><name><name>huffNode</name><index>[<expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>nbBits</name><operator>--</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>rankLast</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>n</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name>totalCost</name><operator>++</operator></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>huffNode</name><index>[ <expr><name><name>rankLast</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr> ]</index></name><operator>.</operator><name>nbBits</name><operator>--</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>rankLast</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>totalCost</name> <operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
        </block_content>}</block>   <comment type="block">/* repay normalized cost */</comment>
    </block_content>}</block>   <comment type="block">/* there are several too large elements (at least &gt;= 2) */</comment>

    <return>return <expr><name>targetNbBits</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>U16</name></type> <name>base</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U16</name></type> <name>curr</name></decl>;</decl_stmt>
}</block></struct></type> <name>rankPos</name>;</typedef>

<typedef>typedef <type><name>nodeElt</name></type> <name><name>huffNodeTable</name><index>[<expr><name>HUF_CTABLE_WORKSPACE_SIZE_U32</name></expr>]</index></name>;</typedef>

<comment type="block">/* Number of buckets available for HUF_sort() */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RANK_POSITION_TABLE_SIZE</name></cpp:macro> <cpp:value>192</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{
  <decl_stmt><decl><type><name>huffNodeTable</name></type> <name>huffNodeTbl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>rankPos</name></type> <name><name>rankPosition</name><index>[<expr><name>RANK_POSITION_TABLE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>HUF_buildCTable_wksp_tables</name>;</typedef>

<comment type="block">/* RANK_POSITION_DISTINCT_COUNT_CUTOFF == Cutoff point in HUF_sort() buckets for which we use log2 bucketing.
 * Strategy is to use as many buckets as possible for representing distinct
 * counts while using the remainder to represent all "large" counts.
 *
 * To satisfy this requirement for 192 buckets, we can do the following:
 * Let buckets 0-166 represent distinct counts of [0, 166]
 * Let buckets 166 to 192 represent all remaining counts up to RANK_POSITION_MAX_COUNT_LOG using log2 bucketing.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RANK_POSITION_MAX_COUNT_LOG</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RANK_POSITION_LOG_BUCKETS_BEGIN</name></cpp:macro> <cpp:value>(RANK_POSITION_TABLE_SIZE - 1) - RANK_POSITION_MAX_COUNT_LOG - 1</cpp:value></cpp:define> <comment type="block">/* == 158 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RANK_POSITION_DISTINCT_COUNT_CUTOFF</name></cpp:macro> <cpp:value>RANK_POSITION_LOG_BUCKETS_BEGIN + ZSTD_highbit32(RANK_POSITION_LOG_BUCKETS_BEGIN)</cpp:value></cpp:define> <comment type="block">/* == 166 */</comment>

<comment type="block">/* Return the appropriate bucket index for a given count. See definition of
 * RANK_POSITION_DISTINCT_COUNT_CUTOFF for explanation of bucketing strategy.
 */</comment>
<function><type><specifier>static</specifier> <name>U32</name></type> <name>HUF_getIndex</name><parameter_list>(<parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><ternary><condition><expr><operator>(</operator><name>count</name> <operator>&lt;</operator> <name>RANK_POSITION_DISTINCT_COUNT_CUTOFF</name><operator>)</operator></expr>
        ?</condition><then> <expr><name>count</name></expr>
        </then><else>: <expr><call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>RANK_POSITION_LOG_BUCKETS_BEGIN</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Helper swap function for HUF_quickSortPartition() */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>HUF_swapNodes</name><parameter_list>(<parameter><decl><type><name>nodeElt</name><modifier>*</modifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>nodeElt</name><modifier>*</modifier></type> <name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>nodeElt</name></type> <name>tmp</name> <init>= <expr><operator>*</operator><name>a</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><operator>*</operator><name>a</name> <operator>=</operator> <operator>*</operator><name>b</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>b</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Returns 0 if the huffNode array is not sorted by descending count */</comment>
<function><type><name>MEM_STATIC</name> <name>int</name></type> <name>HUF_isSorted</name><parameter_list>(<parameter><decl><type><name>nodeElt</name></type> <name><name>huffNode</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>maxSymbolValue1</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>U32</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>maxSymbolValue1</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>huffNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>&gt;</operator> <name><name>huffNode</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>count</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Insertion sort by descending order */</comment>
<function><type><name>HINT_INLINE</name> <name>void</name></type> <name>HUF_insertionSort</name><parameter_list>(<parameter><decl><type><name>nodeElt</name></type> <name><name>huffNode</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name> <specifier>const</specifier></type> <name>low</name></decl></parameter>, <parameter><decl><type><name>int</name> <specifier>const</specifier></type> <name>high</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>size</name> <init>= <expr><name>high</name><operator>-</operator><name>low</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>huffNode</name> <operator>+=</operator> <name>low</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>nodeElt</name> <specifier>const</specifier></type> <name>key</name> <init>= <expr><name><name>huffNode</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>j</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>huffNode</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>&lt;</operator> <name><name>key</name><operator>.</operator><name>count</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>huffNode</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>huffNode</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><name><name>huffNode</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Pivot helper function for quicksort. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>HUF_quickSortPartition</name><parameter_list>(<parameter><decl><type><name>nodeElt</name></type> <name><name>arr</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name> <specifier>const</specifier></type> <name>low</name></decl></parameter>, <parameter><decl><type><name>int</name> <specifier>const</specifier></type> <name>high</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* Simply select rightmost element as pivot. "Better" selectors like
     * median-of-three don't experimentally appear to have any benefit.
     */</comment>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>pivot</name> <init>= <expr><name><name>arr</name><index>[<expr><name>high</name></expr>]</index></name><operator>.</operator><name>count</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>low</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name>low</name></expr></init></decl>;</decl_stmt>
    <for>for <control>( <init>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>high</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>arr</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>&gt;</operator> <name>pivot</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>HUF_swapNodes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arr</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>HUF_swapNodes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arr</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arr</name><index>[<expr><name>high</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Classic quicksort by descending with partially iterative calls
 * to reduce worst case callstack size.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>HUF_simpleQuickSort</name><parameter_list>(<parameter><decl><type><name>nodeElt</name></type> <name><name>arr</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>low</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>high</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>kInsertionSortThreshold</name> <init>= <expr><literal type="number">8</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>high</name> <operator>-</operator> <name>low</name> <operator>&lt;</operator> <name>kInsertionSortThreshold</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>HUF_insertionSort</name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><name>low</name></expr></argument>, <argument><expr><name>high</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <while>while <condition>(<expr><name>low</name> <operator>&lt;</operator> <name>high</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>idx</name> <init>= <expr><call><name>HUF_quickSortPartition</name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><name>low</name></expr></argument>, <argument><expr><name>high</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>idx</name> <operator>-</operator> <name>low</name> <operator>&lt;</operator> <name>high</name> <operator>-</operator> <name>idx</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>HUF_simpleQuickSort</name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><name>low</name></expr></argument>, <argument><expr><name>idx</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>low</name> <operator>=</operator> <name>idx</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>HUF_simpleQuickSort</name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><name>idx</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>high</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>high</name> <operator>=</operator> <name>idx</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * HUF_sort():
 * Sorts the symbols [0, maxSymbolValue] by count[symbol] in decreasing order.
 * This is a typical bucket sorting strategy that uses either quicksort or insertion sort to sort each bucket.
 *
 * @param[out] huffNode       Sorted symbols by decreasing count. Only members `.count` and `.byte` are filled.
 *                            Must have (maxSymbolValue + 1) entries.
 * @param[in]  count          Histogram of the symbols.
 * @param[in]  maxSymbolValue Maximum symbol value.
 * @param      rankPosition   This is a scratch workspace. Must have RANK_POSITION_TABLE_SIZE entries.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>HUF_sort</name><parameter_list>(<parameter><decl><type><name>nodeElt</name></type> <name><name>huffNode</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name><name>count</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>maxSymbolValue</name></decl></parameter>, <parameter><decl><type><name>rankPos</name></type> <name><name>rankPosition</name><index>[]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>U32</name></type> <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>maxSymbolValue1</name> <init>= <expr><name>maxSymbolValue</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Compute base and set curr to base.
     * For symbol s let lowerRank = HUF_getIndex(count[n]) and rank = lowerRank + 1.
     * See HUF_getIndex to see bucketing strategy.
     * We attribute each symbol to lowerRank's base value, because we want to know where
     * each rank begins in the output, so for rank R we want to count ranks R+1 and above.
     */</comment>
    <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><name>rankPosition</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>rankPosition</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>RANK_POSITION_TABLE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>maxSymbolValue1</name></expr>;</condition> <incr><expr><operator>++</operator><name>n</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name></type> <name>lowerRank</name> <init>= <expr><call><name>HUF_getIndex</name><argument_list>(<argument><expr><name><name>count</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lowerRank</name> <operator>&lt;</operator> <name>RANK_POSITION_TABLE_SIZE</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rankPosition</name><index>[<expr><name>lowerRank</name></expr>]</index></name><operator>.</operator><name>base</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>rankPosition</name><index>[<expr><name>RANK_POSITION_TABLE_SIZE</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>base</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Set up the rankPosition table */</comment>
    <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <name>RANK_POSITION_TABLE_SIZE</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>n</name></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>rankPosition</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>base</name> <operator>+=</operator> <name><name>rankPosition</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>base</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rankPosition</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>curr</name> <operator>=</operator> <name><name>rankPosition</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>base</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Insert each symbol into their appropriate bucket, setting up rankPosition table. */</comment>
    <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>maxSymbolValue1</name></expr>;</condition> <incr><expr><operator>++</operator><name>n</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>c</name> <init>= <expr><name><name>count</name><index>[<expr><name>n</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>r</name> <init>= <expr><call><name>HUF_getIndex</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>pos</name> <init>= <expr><name><name>rankPosition</name><index>[<expr><name>r</name></expr>]</index></name><operator>.</operator><name>curr</name><operator>++</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pos</name> <operator>&lt;</operator> <name>maxSymbolValue1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>huffNode</name><index>[<expr><name>pos</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>huffNode</name><index>[<expr><name>pos</name></expr>]</index></name><operator>.</operator><name>byte</name>  <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><name>n</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Sort each bucket. */</comment>
    <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <name>RANK_POSITION_DISTINCT_COUNT_CUTOFF</name></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>RANK_POSITION_TABLE_SIZE</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><operator>++</operator><name>n</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>bucketSize</name> <init>= <expr><name><name>rankPosition</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>curr</name> <operator>-</operator> <name><name>rankPosition</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>base</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>bucketStartIdx</name> <init>= <expr><name><name>rankPosition</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>base</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>bucketSize</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>bucketStartIdx</name> <operator>&lt;</operator> <name>maxSymbolValue1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>HUF_simpleQuickSort</name><argument_list>(<argument><expr><name>huffNode</name> <operator>+</operator> <name>bucketStartIdx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>bucketSize</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>HUF_isSorted</name><argument_list>(<argument><expr><name>huffNode</name></expr></argument>, <argument><expr><name>maxSymbolValue1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/** HUF_buildCTable_wksp() :
 *  Same as HUF_buildCTable(), but using externally allocated scratch buffer.
 *  `workSpace` must be aligned on 4-bytes boundaries, and be at least as large as sizeof(HUF_buildCTable_wksp_tables).
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STARTNODE</name></cpp:macro> <cpp:value>(HUF_SYMBOLVALUE_MAX+1)</cpp:value></cpp:define>

<comment type="block">/* HUF_buildTree():
 * Takes the huffNode array sorted by HUF_sort() and builds an unlimited-depth Huffman tree.
 *
 * @param huffNode        The array sorted by HUF_sort(). Builds the Huffman tree in this array.
 * @param maxSymbolValue  The maximum symbol value.
 * @return                The smallest node in the Huffman tree (by count).
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>HUF_buildTree</name><parameter_list>(<parameter><decl><type><name>nodeElt</name><modifier>*</modifier></type> <name>huffNode</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>maxSymbolValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>nodeElt</name><modifier>*</modifier> <specifier>const</specifier></type> <name>huffNode0</name> <init>= <expr><name>huffNode</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nonNullRank</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>lowS</name></decl>, <decl><type ref="prev"/><name>lowN</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nodeNb</name> <init>= <expr><name>STARTNODE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>nodeRoot</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"HUF_buildTree (alphabet size = %u)"</literal></expr></argument>, <argument><expr><name>maxSymbolValue</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* init for parents */</comment>
    <expr_stmt><expr><name>nonNullRank</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>maxSymbolValue</name></expr>;</expr_stmt>
    <while>while<condition>(<expr><name><name>huffNode</name><index>[<expr><name>nonNullRank</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nonNullRank</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
    <expr_stmt><expr><name>lowS</name> <operator>=</operator> <name>nonNullRank</name></expr>;</expr_stmt> <expr_stmt><expr><name>nodeRoot</name> <operator>=</operator> <name>nodeNb</name> <operator>+</operator> <name>lowS</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt> <expr_stmt><expr><name>lowN</name> <operator>=</operator> <name>nodeNb</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>huffNode</name><index>[<expr><name>nodeNb</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>=</operator> <name><name>huffNode</name><index>[<expr><name>lowS</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>+</operator> <name><name>huffNode</name><index>[<expr><name>lowS</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>count</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>huffNode</name><index>[<expr><name>lowS</name></expr>]</index></name><operator>.</operator><name>parent</name> <operator>=</operator> <name><name>huffNode</name><index>[<expr><name>lowS</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>parent</name> <operator>=</operator> <operator>(</operator><name>U16</name><operator>)</operator><name>nodeNb</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nodeNb</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>lowS</name><operator>-=</operator><literal type="number">2</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>n</name><operator>=</operator><name>nodeNb</name></expr>;</init> <condition><expr><name>n</name><operator>&lt;=</operator><name>nodeRoot</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>huffNode</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><literal type="number">1U</literal><operator>&lt;&lt;</operator><literal type="number">30</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><name><name>huffNode0</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>count</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><literal type="number">1U</literal><operator>&lt;&lt;</operator><literal type="number">31</literal><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* fake entry, strong barrier */</comment>

    <comment type="block">/* create parents */</comment>
    <while>while <condition>(<expr><name>nodeNb</name> <operator>&lt;=</operator> <name>nodeRoot</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>n1</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>huffNode</name><index>[<expr><name>lowS</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>&lt;</operator> <name><name>huffNode</name><index>[<expr><name>lowN</name></expr>]</index></name><operator>.</operator><name>count</name><operator>)</operator></expr> ?</condition><then> <expr><name>lowS</name><operator>--</operator></expr> </then><else>: <expr><name>lowN</name><operator>++</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>n2</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>huffNode</name><index>[<expr><name>lowS</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>&lt;</operator> <name><name>huffNode</name><index>[<expr><name>lowN</name></expr>]</index></name><operator>.</operator><name>count</name><operator>)</operator></expr> ?</condition><then> <expr><name>lowS</name><operator>--</operator></expr> </then><else>: <expr><name>lowN</name><operator>++</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>huffNode</name><index>[<expr><name>nodeNb</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>=</operator> <name><name>huffNode</name><index>[<expr><name>n1</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>+</operator> <name><name>huffNode</name><index>[<expr><name>n2</name></expr>]</index></name><operator>.</operator><name>count</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>huffNode</name><index>[<expr><name>n1</name></expr>]</index></name><operator>.</operator><name>parent</name> <operator>=</operator> <name><name>huffNode</name><index>[<expr><name>n2</name></expr>]</index></name><operator>.</operator><name>parent</name> <operator>=</operator> <operator>(</operator><name>U16</name><operator>)</operator><name>nodeNb</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nodeNb</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* distribute weights (unlimited tree height) */</comment>
    <expr_stmt><expr><name><name>huffNode</name><index>[<expr><name>nodeRoot</name></expr>]</index></name><operator>.</operator><name>nbBits</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>n</name><operator>=</operator><name>nodeRoot</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>n</name><operator>&gt;=</operator><name>STARTNODE</name></expr>;</condition> <incr><expr><name>n</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>huffNode</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>nbBits</name> <operator>=</operator> <name><name>huffNode</name><index>[ <expr><name><name>huffNode</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>parent</name></expr> ]</index></name><operator>.</operator><name>nbBits</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
    <for>for <control>(<init><expr><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name><operator>&lt;=</operator><name>nonNullRank</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>huffNode</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>nbBits</name> <operator>=</operator> <name><name>huffNode</name><index>[ <expr><name><name>huffNode</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>parent</name></expr> ]</index></name><operator>.</operator><name>nbBits</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"Initial distribution of bits completed (%zu sorted symbols)"</literal></expr></argument>, <argument><expr><call><name>showHNodeBits</name><argument_list>(<argument><expr><name>huffNode</name></expr></argument>, <argument><expr><name>maxSymbolValue</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>nonNullRank</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * HUF_buildCTableFromTree():
 * Build the CTable given the Huffman tree in huffNode.
 *
 * @param[out] CTable         The output Huffman CTable.
 * @param      huffNode       The Huffman tree.
 * @param      nonNullRank    The last and smallest node in the Huffman tree.
 * @param      maxSymbolValue The maximum symbol value.
 * @param      maxNbBits      The exact maximum number of bits used in the Huffman tree.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>HUF_buildCTableFromTree</name><parameter_list>(<parameter><decl><type><name>HUF_CElt</name><modifier>*</modifier></type> <name>CTable</name></decl></parameter>, <parameter><decl><type><name>nodeElt</name> <specifier>const</specifier><modifier>*</modifier></type> <name>huffNode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nonNullRank</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>maxSymbolValue</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>maxNbBits</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HUF_CElt</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ct</name> <init>= <expr><name>CTable</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <comment type="block">/* fill result into ctable (val, nbBits) */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U16</name></type> <name><name>nbPerRank</name><index>[<expr><name>HUF_TABLELOG_MAX</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U16</name></type> <name><name>valPerRank</name><index>[<expr><name>HUF_TABLELOG_MAX</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>alphabetSize</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>maxSymbolValue</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name><operator>&lt;=</operator><name>nonNullRank</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>nbPerRank</name><index>[<expr><name><name>huffNode</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>nbBits</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>
    <comment type="block">/* determine starting value per rank */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>U16</name></type> <name>min</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>n</name><operator>=</operator><operator>(</operator><name>int</name><operator>)</operator><name>maxNbBits</name></expr>;</init> <condition><expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>n</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><name><name>valPerRank</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name>min</name></expr>;</expr_stmt>      <comment type="block">/* get starting value within each rank */</comment>
            <expr_stmt><expr><name>min</name> <operator>+=</operator> <name><name>nbPerRank</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>min</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></for>   </block_content>}</block>
    <for>for <control>(<init><expr><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name><operator>&lt;</operator><name>alphabetSize</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>HUF_setNbBits</name><argument_list>(<argument><expr><name>ct</name> <operator>+</operator> <name><name>huffNode</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>byte</name></expr></argument>, <argument><expr><name><name>huffNode</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>nbBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>   <comment type="block">/* push nbBits per symbol, symbol order */</comment>
    <for>for <control>(<init><expr><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name><operator>&lt;</operator><name>alphabetSize</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>HUF_setValue</name><argument_list>(<argument><expr><name>ct</name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name><name>valPerRank</name><index>[<expr><call><name>HUF_getNbBits</name><argument_list>(<argument><expr><name><name>ct</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>]</index></name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>   <comment type="block">/* assign value within rank, symbol order */</comment>
    <expr_stmt><expr><name><name>CTable</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>maxNbBits</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>size_t</name></type>
<name>HUF_buildCTable_wksp</name><parameter_list>(<parameter><decl><type><name>HUF_CElt</name><modifier>*</modifier></type> <name>CTable</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name><modifier>*</modifier></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>maxSymbolValue</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>maxNbBits</name></decl></parameter>,
                     <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workSpace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HUF_buildCTable_wksp_tables</name><modifier>*</modifier> <specifier>const</specifier></type> <name>wksp_tables</name> <init>=
        <expr><operator>(</operator><name>HUF_buildCTable_wksp_tables</name><operator>*</operator><operator>)</operator><call><name>HUF_alignUpWorkspace</name><argument_list>(<argument><expr><name>workSpace</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wkspSize</name></expr></argument>, <argument><expr><call><name>ZSTD_ALIGNOF</name><argument_list>(<argument><expr><name>U32</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nodeElt</name><modifier>*</modifier> <specifier>const</specifier></type> <name>huffNode0</name> <init>= <expr><name><name>wksp_tables</name><operator>-&gt;</operator><name>huffNodeTbl</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nodeElt</name><modifier>*</modifier> <specifier>const</specifier></type> <name>huffNode</name> <init>= <expr><name>huffNode0</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nonNullRank</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"HUF_buildCTable_wksp (alphabet size = %u)"</literal></expr></argument>, <argument><expr><name>maxSymbolValue</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* safety checks */</comment>
    <if_stmt><if>if <condition>(<expr><name>wkspSize</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HUF_buildCTable_wksp_tables</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>workSpace_tooSmall</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>maxNbBits</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>maxNbBits</name> <operator>=</operator> <name>HUF_TABLELOG_DEFAULT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>maxSymbolValue</name> <operator>&gt;</operator> <name>HUF_SYMBOLVALUE_MAX</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>maxSymbolValue_tooLarge</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><name>huffNode0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>huffNodeTable</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* sort, decreasing order */</comment>
    <expr_stmt><expr><call><name>HUF_sort</name><argument_list>(<argument><expr><name>huffNode</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>maxSymbolValue</name></expr></argument>, <argument><expr><name><name>wksp_tables</name><operator>-&gt;</operator><name>rankPosition</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"sorted symbols completed (%zu symbols)"</literal></expr></argument>, <argument><expr><call><name>showHNodeSymbols</name><argument_list>(<argument><expr><name>huffNode</name></expr></argument>, <argument><expr><name>maxSymbolValue</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* build tree */</comment>
    <expr_stmt><expr><name>nonNullRank</name> <operator>=</operator> <call><name>HUF_buildTree</name><argument_list>(<argument><expr><name>huffNode</name></expr></argument>, <argument><expr><name>maxSymbolValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* determine and enforce maxTableLog */</comment>
    <expr_stmt><expr><name>maxNbBits</name> <operator>=</operator> <call><name>HUF_setMaxHeight</name><argument_list>(<argument><expr><name>huffNode</name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>nonNullRank</name></expr></argument>, <argument><expr><name>maxNbBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>maxNbBits</name> <operator>&gt;</operator> <name>HUF_TABLELOG_MAX</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>GENERIC</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* check fit into table */</comment>

    <expr_stmt><expr><call><name>HUF_buildCTableFromTree</name><argument_list>(<argument><expr><name>CTable</name></expr></argument>, <argument><expr><name>huffNode</name></expr></argument>, <argument><expr><name>nonNullRank</name></expr></argument>, <argument><expr><name>maxSymbolValue</name></expr></argument>, <argument><expr><name>maxNbBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>maxNbBits</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>HUF_estimateCompressedSize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>HUF_CElt</name><modifier>*</modifier></type> <name>CTable</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name><modifier>*</modifier></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>maxSymbolValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HUF_CElt</name> <specifier>const</specifier><modifier>*</modifier></type> <name>ct</name> <init>= <expr><name>CTable</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>nbBits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>s</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>s</name> <operator>&lt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>maxSymbolValue</name></expr>;</condition> <incr><expr><operator>++</operator><name>s</name></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name>nbBits</name> <operator>+=</operator> <call><name>HUF_getNbBits</name><argument_list>(<argument><expr><name><name>ct</name><index>[<expr><name>s</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <name><name>count</name><index>[<expr><name>s</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>nbBits</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>HUF_validateCTable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>HUF_CElt</name><modifier>*</modifier></type> <name>CTable</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name><modifier>*</modifier></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>maxSymbolValue</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>HUF_CElt</name> <specifier>const</specifier><modifier>*</modifier></type> <name>ct</name> <init>= <expr><name>CTable</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bad</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>s</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>s</name> <operator>&lt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>maxSymbolValue</name></expr>;</condition> <incr><expr><operator>++</operator><name>s</name></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name>bad</name> <operator>|=</operator> <operator>(</operator><name><name>count</name><index>[<expr><name>s</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><call><name>HUF_getNbBits</name><argument_list>(<argument><expr><name><name>ct</name><index>[<expr><name>s</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><operator>!</operator><name>bad</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>HUF_compressBound</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>HUF_COMPRESSBOUND</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>

<comment type="block" format="doxygen">/** HUF_CStream_t:
 * Huffman uses its own BIT_CStream_t implementation.
 * There are three major differences from BIT_CStream_t:
 *   1. HUF_addBits() takes a HUF_CElt (size_t) which is
 *      the pair (nbBits, value) in the format:
 *      format:
 *        - Bits [0, 4)            = nbBits
 *        - Bits [4, 64 - nbBits)  = 0
 *        - Bits [64 - nbBits, 64) = value
 *   2. The bitContainer is built from the upper bits and
 *      right shifted. E.g. to add a new value of N bits
 *      you right shift the bitContainer by N, then or in
 *      the new value into the N upper bits.
 *   3. The bitstream has two bit containers. You can add
 *      bits to the second container and merge them into
 *      the first container.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_BITS_IN_CONTAINER</name></cpp:macro> <cpp:value>(sizeof(size_t) * 8)</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name><name>bitContainer</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name><name>bitPos</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>startPtr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>endPtr</name></decl>;</decl_stmt>
}</block></struct></type> <name>HUF_CStream_t</name>;</typedef>

<comment type="block" format="doxygen">/**! HUF_initCStream():
 * Initializes the bitstream.
 * @returns 0 or an error code.
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>HUF_initCStream</name><parameter_list>(<parameter><decl><type><name>HUF_CStream_t</name><modifier>*</modifier></type> <name>bitC</name></decl></parameter>,
                                  <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>startPtr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><name>bitC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>bitC</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bitC</name><operator>-&gt;</operator><name>startPtr</name></name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>startPtr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bitC</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name><name>bitC</name><operator>-&gt;</operator><name>startPtr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bitC</name><operator>-&gt;</operator><name>endPtr</name></name> <operator>=</operator> <name><name>bitC</name><operator>-&gt;</operator><name>startPtr</name></name> <operator>+</operator> <name>dstCapacity</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>bitC</name><operator>-&gt;</operator><name>bitContainer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>dstCapacity</name> <operator>&lt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>bitC</name><operator>-&gt;</operator><name>bitContainer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>dstSize_tooSmall</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! HUF_addBits():
 * Adds the symbol stored in HUF_CElt elt to the bitstream.
 *
 * @param elt   The element we're adding. This is a (nbBits, value) pair.
 *              See the HUF_CStream_t docs for the format.
 * @param idx   Insert into the bitstream at this idx.
 * @param kFast This is a template parameter. If the bitstream is guaranteed
 *              to have at least 4 unused bits after this call it may be 1,
 *              otherwise it must be 0. HUF_addBits() is faster when fast is set.
 */</comment>
<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>void</name></type> <name>HUF_addBits</name><parameter_list>(<parameter><decl><type><name>HUF_CStream_t</name><modifier>*</modifier></type> <name>bitC</name></decl></parameter>, <parameter><decl><type><name>HUF_CElt</name></type> <name>elt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kFast</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>idx</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>HUF_getNbBits</name><argument_list>(<argument><expr><name>elt</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>HUF_TABLELOG_ABSOLUTEMAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* This is efficient on x86-64 with BMI2 because shrx
     * only reads the low 6 bits of the register. The compiler
     * knows this and elides the mask. When fast is set,
     * every operation can use the same value loaded from elt.
     */</comment>
    <expr_stmt><expr><name><name>bitC</name><operator>-&gt;</operator><name>bitContainer</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>&gt;&gt;=</operator> <call><name>HUF_getNbBits</name><argument_list>(<argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bitC</name><operator>-&gt;</operator><name>bitContainer</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>|=</operator> <ternary><condition><expr><name>kFast</name></expr> ?</condition><then> <expr><call><name>HUF_getValueFast</name><argument_list>(<argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>HUF_getValue</name><argument_list>(<argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
    <comment type="block">/* We only read the low 8 bits of bitC-&gt;bitPos[idx] so it
     * doesn't matter that the high bits have noise from the value.
     */</comment>
    <expr_stmt><expr><name><name>bitC</name><operator>-&gt;</operator><name>bitPos</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>+=</operator> <call><name>HUF_getNbBitsFast</name><argument_list>(<argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>bitC</name><operator>-&gt;</operator><name>bitPos</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator> <operator>&lt;=</operator> <name>HUF_BITS_IN_CONTAINER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* The last 4-bits of elt are dirty if fast is set,
     * so we must not be overwriting bits that have already been
     * inserted into the bit container.
     */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEBUGLEVEL</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></cpp:if>
    <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>nbBits</name> <init>= <expr><call><name>HUF_getNbBits</name><argument_list>(<argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>dirtyBits</name> <init>= <expr><ternary><condition><expr><name>nbBits</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>nbBits</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>dirtyBits</name></expr>;</expr_stmt>
        <comment type="block">/* Middle bits are 0. */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>elt</name> <operator>&gt;&gt;</operator> <name>dirtyBits</name><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><name>dirtyBits</name> <operator>+</operator> <name>nbBits</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* We didn't overwrite any bits in the bit container. */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>kFast</name> <operator>||</operator> <operator>(</operator><name><name>bitC</name><operator>-&gt;</operator><name>bitPos</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator> <operator>&lt;=</operator> <name>HUF_BITS_IN_CONTAINER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>dirtyBits</name></expr>;</expr_stmt>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>void</name></type> <name>HUF_zeroIndex1</name><parameter_list>(<parameter><decl><type><name>HUF_CStream_t</name><modifier>*</modifier></type> <name>bitC</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>bitC</name><operator>-&gt;</operator><name>bitContainer</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bitC</name><operator>-&gt;</operator><name>bitPos</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! HUF_mergeIndex1() :
 * Merges the bit container @ index 1 into the bit container @ index 0
 * and zeros the bit container @ index 1.
 */</comment>
<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>void</name></type> <name>HUF_mergeIndex1</name><parameter_list>(<parameter><decl><type><name>HUF_CStream_t</name><modifier>*</modifier></type> <name>bitC</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>bitC</name><operator>-&gt;</operator><name>bitPos</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator> <operator>&lt;</operator> <name>HUF_BITS_IN_CONTAINER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bitC</name><operator>-&gt;</operator><name>bitContainer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;&gt;=</operator> <operator>(</operator><name><name>bitC</name><operator>-&gt;</operator><name>bitPos</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bitC</name><operator>-&gt;</operator><name>bitContainer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|=</operator> <name><name>bitC</name><operator>-&gt;</operator><name>bitContainer</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bitC</name><operator>-&gt;</operator><name>bitPos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <name><name>bitC</name><operator>-&gt;</operator><name>bitPos</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>bitC</name><operator>-&gt;</operator><name>bitPos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator> <operator>&lt;=</operator> <name>HUF_BITS_IN_CONTAINER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! HUF_flushBits() :
* Flushes the bits in the bit container @ index 0.
*
* @post bitPos will be &lt; 8.
* @param kFast If kFast is set then we must know a-priori that
*              the bit container will not overflow.
*/</comment>
<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>void</name></type> <name>HUF_flushBits</name><parameter_list>(<parameter><decl><type><name>HUF_CStream_t</name><modifier>*</modifier></type> <name>bitC</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kFast</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* The upper bits of bitPos are noisy, so we must mask by 0xFF. */</comment>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>nbBits</name> <init>= <expr><name><name>bitC</name><operator>-&gt;</operator><name>bitPos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>nbBytes</name> <init>= <expr><name>nbBits</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
    <comment type="block">/* The top nbBits bits of bitContainer are the ones we need. */</comment>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>bitContainer</name> <init>= <expr><name><name>bitC</name><operator>-&gt;</operator><name>bitContainer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <operator>(</operator><name>HUF_BITS_IN_CONTAINER</name> <operator>-</operator> <name>nbBits</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Mask bitPos to account for the bytes we consumed. */</comment>
    <expr_stmt><expr><name><name>bitC</name><operator>-&gt;</operator><name>bitPos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nbBits</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nbBits</name> <operator>&lt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>bitC</name><operator>-&gt;</operator><name>bitContainer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>bitC</name><operator>-&gt;</operator><name>ptr</name></name> <operator>&lt;=</operator> <name><name>bitC</name><operator>-&gt;</operator><name>endPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MEM_writeLEST</name><argument_list>(<argument><expr><name><name>bitC</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>bitContainer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bitC</name><operator>-&gt;</operator><name>ptr</name></name> <operator>+=</operator> <name>nbBytes</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>kFast</name> <operator>||</operator> <name><name>bitC</name><operator>-&gt;</operator><name>ptr</name></name> <operator>&lt;=</operator> <name><name>bitC</name><operator>-&gt;</operator><name>endPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>kFast</name> <operator>&amp;&amp;</operator> <name><name>bitC</name><operator>-&gt;</operator><name>ptr</name></name> <operator>&gt;</operator> <name><name>bitC</name><operator>-&gt;</operator><name>endPtr</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>bitC</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name><name>bitC</name><operator>-&gt;</operator><name>endPtr</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* bitContainer doesn't need to be modified because the leftover
     * bits are already the top bitPos bits. And we don't care about
     * noise in the lower values.
     */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! HUF_endMark()
 * @returns The Huffman stream end mark: A 1-bit value = 1.
 */</comment>
<function><type><specifier>static</specifier> <name>HUF_CElt</name></type> <name>HUF_endMark</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HUF_CElt</name></type> <name>endMark</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>HUF_setNbBits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>endMark</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HUF_setValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>endMark</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>endMark</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! HUF_closeCStream() :
 *  @return Size of CStream, in bytes,
 *          or 0 if it could not fit into dstBuffer */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>HUF_closeCStream</name><parameter_list>(<parameter><decl><type><name>HUF_CStream_t</name><modifier>*</modifier></type> <name>bitC</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>HUF_addBits</name><argument_list>(<argument><expr><name>bitC</name></expr></argument>, <argument><expr><call><name>HUF_endMark</name><argument_list>()</argument_list></call></expr></argument>, <comment type="block">/* idx */</comment> <argument><expr><literal type="number">0</literal></expr></argument>, <comment type="block">/* kFast */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HUF_flushBits</name><argument_list>(<argument><expr><name>bitC</name></expr></argument>, <comment type="block">/* kFast */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>nbBits</name> <init>= <expr><name><name>bitC</name><operator>-&gt;</operator><name>bitPos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>bitC</name><operator>-&gt;</operator><name>ptr</name></name> <operator>&gt;=</operator> <name><name>bitC</name><operator>-&gt;</operator><name>endPtr</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* overflow detected */</comment>
        <return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>bitC</name><operator>-&gt;</operator><name>ptr</name></name> <operator>-</operator> <name><name>bitC</name><operator>-&gt;</operator><name>startPtr</name></name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>nbBits</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>

<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>void</name></type>
<name>HUF_encodeSymbol</name><parameter_list>(<parameter><decl><type><name>HUF_CStream_t</name><modifier>*</modifier></type> <name>bitCPtr</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>symbol</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>HUF_CElt</name><modifier>*</modifier></type> <name>CTable</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fast</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>HUF_addBits</name><argument_list>(<argument><expr><name>bitCPtr</name></expr></argument>, <argument><expr><name><name>CTable</name><index>[<expr><name>symbol</name></expr>]</index></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>fast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>void</name></type>
<name>HUF_compress1X_usingCTable_internal_body_loop</name><parameter_list>(<parameter><decl><type><name>HUF_CStream_t</name><modifier>*</modifier></type> <name>bitC</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>HUF_CElt</name><modifier>*</modifier></type> <name>ct</name></decl></parameter>,
                                   <parameter><decl><type><name>int</name></type> <name>kUnroll</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kFastFlush</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kLastFast</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Join to kUnroll */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name>srcSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rem</name> <init>= <expr><name>n</name> <operator>%</operator> <name>kUnroll</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>rem</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init>;</init> <condition><expr><name>rem</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>rem</name></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>HUF_encodeSymbol</name><argument_list>(<argument><expr><name>bitC</name></expr></argument>, <argument><expr><name><name>ip</name><index>[<expr><operator>--</operator><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <comment type="block">/* fast */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>HUF_flushBits</name><argument_list>(<argument><expr><name>bitC</name></expr></argument>, <argument><expr><name>kFastFlush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>%</operator> <name>kUnroll</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Join to 2 * kUnroll */</comment>
    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>%</operator> <operator>(</operator><literal type="number">2</literal> <operator>*</operator> <name>kUnroll</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>u</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>u</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>u</name> <operator>&lt;</operator> <name>kUnroll</name></expr>;</condition> <incr><expr><operator>++</operator><name>u</name></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>HUF_encodeSymbol</name><argument_list>(<argument><expr><name>bitC</name></expr></argument>, <argument><expr><name><name>ip</name><index>[<expr><name>n</name> <operator>-</operator> <name>u</name></expr>]</index></name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>HUF_encodeSymbol</name><argument_list>(<argument><expr><name>bitC</name></expr></argument>, <argument><expr><name><name>ip</name><index>[<expr><name>n</name> <operator>-</operator> <name>kUnroll</name></expr>]</index></name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>kLastFast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>HUF_flushBits</name><argument_list>(<argument><expr><name>bitC</name></expr></argument>, <argument><expr><name>kFastFlush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name> <operator>-=</operator> <name>kUnroll</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>%</operator> <operator>(</operator><literal type="number">2</literal> <operator>*</operator> <name>kUnroll</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init>;</init> <condition><expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>n</name><operator>-=</operator> <literal type="number">2</literal> <operator>*</operator> <name>kUnroll</name></expr></incr>)</control> <block>{<block_content>
        <comment type="block">/* Encode kUnroll symbols into the bitstream @ index 0. */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>u</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>u</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>u</name> <operator>&lt;</operator> <name>kUnroll</name></expr>;</condition> <incr><expr><operator>++</operator><name>u</name></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>HUF_encodeSymbol</name><argument_list>(<argument><expr><name>bitC</name></expr></argument>, <argument><expr><name><name>ip</name><index>[<expr><name>n</name> <operator>-</operator> <name>u</name></expr>]</index></name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <comment type="block">/* idx */</comment> <argument><expr><literal type="number">0</literal></expr></argument>, <comment type="block">/* fast */</comment> <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>HUF_encodeSymbol</name><argument_list>(<argument><expr><name>bitC</name></expr></argument>, <argument><expr><name><name>ip</name><index>[<expr><name>n</name> <operator>-</operator> <name>kUnroll</name></expr>]</index></name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <comment type="block">/* idx */</comment> <argument><expr><literal type="number">0</literal></expr></argument>, <comment type="block">/* fast */</comment> <argument><expr><name>kLastFast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>HUF_flushBits</name><argument_list>(<argument><expr><name>bitC</name></expr></argument>, <argument><expr><name>kFastFlush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Encode kUnroll symbols into the bitstream @ index 1.
         * This allows us to start filling the bit container
         * without any data dependencies.
         */</comment>
        <expr_stmt><expr><call><name>HUF_zeroIndex1</name><argument_list>(<argument><expr><name>bitC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>u</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>u</name> <operator>&lt;</operator> <name>kUnroll</name></expr>;</condition> <incr><expr><operator>++</operator><name>u</name></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>HUF_encodeSymbol</name><argument_list>(<argument><expr><name>bitC</name></expr></argument>, <argument><expr><name><name>ip</name><index>[<expr><name>n</name> <operator>-</operator> <name>kUnroll</name> <operator>-</operator> <name>u</name></expr>]</index></name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <comment type="block">/* idx */</comment> <argument><expr><literal type="number">1</literal></expr></argument>, <comment type="block">/* fast */</comment> <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>HUF_encodeSymbol</name><argument_list>(<argument><expr><name>bitC</name></expr></argument>, <argument><expr><name><name>ip</name><index>[<expr><name>n</name> <operator>-</operator> <name>kUnroll</name> <operator>-</operator> <name>kUnroll</name></expr>]</index></name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <comment type="block">/* idx */</comment> <argument><expr><literal type="number">1</literal></expr></argument>, <comment type="block">/* fast */</comment> <argument><expr><name>kLastFast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Merge bitstream @ index 1 into the bitstream @ index 0 */</comment>
        <expr_stmt><expr><call><name>HUF_mergeIndex1</name><argument_list>(<argument><expr><name>bitC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>HUF_flushBits</name><argument_list>(<argument><expr><name>bitC</name></expr></argument>, <argument><expr><name>kFastFlush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Returns a tight upper bound on the output space needed by Huffman
 * with 8 bytes buffer to handle over-writes. If the output is at least
 * this large we don't need to do bounds checks during Huffman encoding.
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>HUF_tightCompressBound</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>tableLog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><operator>(</operator><name>srcSize</name> <operator>*</operator> <name>tableLog</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>+</operator> <literal type="number">8</literal></expr>;</return>
</block_content>}</block></function>


<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>size_t</name></type>
<name>HUF_compress1X_usingCTable_internal_body</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>HUF_CElt</name><modifier>*</modifier></type> <name>CTable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>tableLog</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>CTable</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HUF_CElt</name> <specifier>const</specifier><modifier>*</modifier></type> <name>ct</name> <init>= <expr><name>CTable</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator> <name>src</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ostart</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend</name> <init>= <expr><name>ostart</name> <operator>+</operator> <name>dstSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><name>ostart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HUF_CStream_t</name></type> <name>bitC</name></decl>;</decl_stmt>

    <comment type="block">/* init */</comment>
    <if_stmt><if>if <condition>(<expr><name>dstSize</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* not enough space to compress */</comment>
    <block>{<block_content> <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>initErr</name> <init>= <expr><call><name>HUF_initCStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitC</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name><operator>-</operator><name>op</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>HUF_isError</name><argument_list>(<argument><expr><name>initErr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> </block_content>}</block>

    <if_stmt><if>if <condition>(<expr><name><name>dstSize</name> <argument_list type="generic">&lt; <argument><expr><name>HUF_tightCompressBound</name><operator>(</operator><name>srcSize</name>, <operator>(</operator><name>size_t</name><operator>)</operator><name>tableLog</name><operator>)</operator> <operator>||</operator> <name>tableLog</name></expr></argument> &gt;</argument_list></name> <literal type="number">11</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>HUF_compress1X_usingCTable_internal_body_loop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitC</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <comment type="block">/* kUnroll */</comment> <argument><expr><ternary><condition><expr><call><name>MEM_32bits</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">4</literal></expr></else></ternary></expr></argument>, <comment type="block">/* kFast */</comment> <argument><expr><literal type="number">0</literal></expr></argument>, <comment type="block">/* kLastFast */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>MEM_32bits</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <switch>switch <condition>(<expr><name>tableLog</name></expr>)</condition> <block>{<block_content>
            <case>case <expr><literal type="number">11</literal></expr>:</case>
                <expr_stmt><expr><call><name>HUF_compress1X_usingCTable_internal_body_loop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitC</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <comment type="block">/* kUnroll */</comment> <argument><expr><literal type="number">2</literal></expr></argument>, <comment type="block">/* kFastFlush */</comment> <argument><expr><literal type="number">1</literal></expr></argument>, <comment type="block">/* kLastFast */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">10</literal></expr>:</case> <expr_stmt><expr><name>ZSTD_FALLTHROUGH</name></expr>;</expr_stmt>
            <case>case <expr><literal type="number">9</literal></expr>:</case> <expr_stmt><expr><name>ZSTD_FALLTHROUGH</name></expr>;</expr_stmt>
            <case>case <expr><literal type="number">8</literal></expr>:</case>
                <expr_stmt><expr><call><name>HUF_compress1X_usingCTable_internal_body_loop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitC</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <comment type="block">/* kUnroll */</comment> <argument><expr><literal type="number">2</literal></expr></argument>, <comment type="block">/* kFastFlush */</comment> <argument><expr><literal type="number">1</literal></expr></argument>, <comment type="block">/* kLastFast */</comment> <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">7</literal></expr>:</case> <expr_stmt><expr><name>ZSTD_FALLTHROUGH</name></expr>;</expr_stmt>
            <default>default:</default>
                <expr_stmt><expr><call><name>HUF_compress1X_usingCTable_internal_body_loop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitC</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <comment type="block">/* kUnroll */</comment> <argument><expr><literal type="number">3</literal></expr></argument>, <comment type="block">/* kFastFlush */</comment> <argument><expr><literal type="number">1</literal></expr></argument>, <comment type="block">/* kLastFast */</comment> <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></switch>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <switch>switch <condition>(<expr><name>tableLog</name></expr>)</condition> <block>{<block_content>
            <case>case <expr><literal type="number">11</literal></expr>:</case>
                <expr_stmt><expr><call><name>HUF_compress1X_usingCTable_internal_body_loop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitC</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <comment type="block">/* kUnroll */</comment> <argument><expr><literal type="number">5</literal></expr></argument>, <comment type="block">/* kFastFlush */</comment> <argument><expr><literal type="number">1</literal></expr></argument>, <comment type="block">/* kLastFast */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">10</literal></expr>:</case>
                <expr_stmt><expr><call><name>HUF_compress1X_usingCTable_internal_body_loop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitC</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <comment type="block">/* kUnroll */</comment> <argument><expr><literal type="number">5</literal></expr></argument>, <comment type="block">/* kFastFlush */</comment> <argument><expr><literal type="number">1</literal></expr></argument>, <comment type="block">/* kLastFast */</comment> <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">9</literal></expr>:</case>
                <expr_stmt><expr><call><name>HUF_compress1X_usingCTable_internal_body_loop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitC</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <comment type="block">/* kUnroll */</comment> <argument><expr><literal type="number">6</literal></expr></argument>, <comment type="block">/* kFastFlush */</comment> <argument><expr><literal type="number">1</literal></expr></argument>, <comment type="block">/* kLastFast */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">8</literal></expr>:</case>
                <expr_stmt><expr><call><name>HUF_compress1X_usingCTable_internal_body_loop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitC</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <comment type="block">/* kUnroll */</comment> <argument><expr><literal type="number">7</literal></expr></argument>, <comment type="block">/* kFastFlush */</comment> <argument><expr><literal type="number">1</literal></expr></argument>, <comment type="block">/* kLastFast */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">7</literal></expr>:</case>
                <expr_stmt><expr><call><name>HUF_compress1X_usingCTable_internal_body_loop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitC</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <comment type="block">/* kUnroll */</comment> <argument><expr><literal type="number">8</literal></expr></argument>, <comment type="block">/* kFastFlush */</comment> <argument><expr><literal type="number">1</literal></expr></argument>, <comment type="block">/* kLastFast */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">6</literal></expr>:</case> <expr_stmt><expr><name>ZSTD_FALLTHROUGH</name></expr>;</expr_stmt>
            <default>default:</default>
                <expr_stmt><expr><call><name>HUF_compress1X_usingCTable_internal_body_loop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitC</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <comment type="block">/* kUnroll */</comment> <argument><expr><literal type="number">9</literal></expr></argument>, <comment type="block">/* kFastFlush */</comment> <argument><expr><literal type="number">1</literal></expr></argument>, <comment type="block">/* kLastFast */</comment> <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></switch>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>bitC</name><operator>.</operator><name>ptr</name></name> <operator>&lt;=</operator> <name><name>bitC</name><operator>.</operator><name>endPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>HUF_closeCStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bitC</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DYNAMIC_BMI2</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>BMI2_TARGET_ATTRIBUTE</name> <name>size_t</name></type>
<name>HUF_compress1X_usingCTable_internal_bmi2</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>HUF_CElt</name><modifier>*</modifier></type> <name>CTable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>HUF_compress1X_usingCTable_internal_body</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>CTable</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>HUF_compress1X_usingCTable_internal_default</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
                                      <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                                      <parameter><decl><type><specifier>const</specifier> <name>HUF_CElt</name><modifier>*</modifier></type> <name>CTable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>HUF_compress1X_usingCTable_internal_body</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>CTable</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>HUF_compress1X_usingCTable_internal</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
                              <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                              <parameter><decl><type><specifier>const</specifier> <name>HUF_CElt</name><modifier>*</modifier></type> <name>CTable</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>bmi2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>bmi2</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>HUF_compress1X_usingCTable_internal_bmi2</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>CTable</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name>HUF_compress1X_usingCTable_internal_default</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>CTable</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>HUF_compress1X_usingCTable_internal</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
                              <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                              <parameter><decl><type><specifier>const</specifier> <name>HUF_CElt</name><modifier>*</modifier></type> <name>CTable</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>bmi2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>bmi2</name></expr>;</expr_stmt>
    <return>return <expr><call><name>HUF_compress1X_usingCTable_internal_body</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>CTable</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>size_t</name></type> <name>HUF_compress1X_usingCTable</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>HUF_CElt</name><modifier>*</modifier></type> <name>CTable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>HUF_compress1X_usingCTable_bmi2</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>CTable</name></expr></argument>, <comment type="block">/* bmi2 */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>HUF_compress1X_usingCTable_bmi2</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>HUF_CElt</name><modifier>*</modifier></type> <name>CTable</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bmi2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>HUF_compress1X_usingCTable_internal</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>CTable</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>HUF_compress4X_usingCTable_internal</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
                              <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                              <parameter><decl><type><specifier>const</specifier> <name>HUF_CElt</name><modifier>*</modifier></type> <name>CTable</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bmi2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>segmentSize</name> <init>= <expr><operator>(</operator><name>srcSize</name><operator>+</operator><literal type="number">3</literal><operator>)</operator><operator>/</operator><literal type="number">4</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* first 3 segments */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator> <name>src</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name> <init>= <expr><name>ip</name> <operator>+</operator> <name>srcSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ostart</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator> <name>dst</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend</name> <init>= <expr><name>ostart</name> <operator>+</operator> <name>dstSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><name>ostart</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>dstSize</name> <operator>&lt;</operator> <literal type="number">6</literal> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* minimum space to compress successfully */</comment>
    <if_stmt><if>if <condition>(<expr><name>srcSize</name> <operator>&lt;</operator> <literal type="number">12</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* no saving possible : too small input */</comment>
    <expr_stmt><expr><name>op</name> <operator>+=</operator> <literal type="number">6</literal></expr>;</expr_stmt>   <comment type="block">/* jumpTable */</comment>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name> <operator>&lt;=</operator> <name>oend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>   <expr_stmt><expr><call><name>CHECK_V_F</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>, <argument><expr><call><name>HUF_compress1X_usingCTable_internal</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name><operator>-</operator><name>op</name><operator>)</operator></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>segmentSize</name></expr></argument>, <argument><expr><name>CTable</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>cSize</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>cSize</name> <operator>&gt;</operator> <literal type="number">65535</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>MEM_writeLE16</name><argument_list>(<argument><expr><name>ostart</name></expr></argument>, <argument><expr><operator>(</operator><name>U16</name><operator>)</operator><name>cSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>cSize</name></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>segmentSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name> <operator>&lt;=</operator> <name>oend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>   <expr_stmt><expr><call><name>CHECK_V_F</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>, <argument><expr><call><name>HUF_compress1X_usingCTable_internal</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name><operator>-</operator><name>op</name><operator>)</operator></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>segmentSize</name></expr></argument>, <argument><expr><name>CTable</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>cSize</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>cSize</name> <operator>&gt;</operator> <literal type="number">65535</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>MEM_writeLE16</name><argument_list>(<argument><expr><name>ostart</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>U16</name><operator>)</operator><name>cSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>cSize</name></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>segmentSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name> <operator>&lt;=</operator> <name>oend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>   <expr_stmt><expr><call><name>CHECK_V_F</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>, <argument><expr><call><name>HUF_compress1X_usingCTable_internal</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name><operator>-</operator><name>op</name><operator>)</operator></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>segmentSize</name></expr></argument>, <argument><expr><name>CTable</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>cSize</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>cSize</name> <operator>&gt;</operator> <literal type="number">65535</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>MEM_writeLE16</name><argument_list>(<argument><expr><name>ostart</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><operator>(</operator><name>U16</name><operator>)</operator><name>cSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>cSize</name></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>segmentSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name> <operator>&lt;=</operator> <name>oend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ip</name> <operator>&lt;=</operator> <name>iend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>   <expr_stmt><expr><call><name>CHECK_V_F</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>, <argument><expr><call><name>HUF_compress1X_usingCTable_internal</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name><operator>-</operator><name>op</name><operator>)</operator></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>iend</name><operator>-</operator><name>ip</name><operator>)</operator></expr></argument>, <argument><expr><name>CTable</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>cSize</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>cSize</name> <operator>&gt;</operator> <literal type="number">65535</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>cSize</name></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>op</name><operator>-</operator><name>ostart</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>HUF_compress4X_usingCTable</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>HUF_CElt</name><modifier>*</modifier></type> <name>CTable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>HUF_compress4X_usingCTable_bmi2</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>CTable</name></expr></argument>, <comment type="block">/* bmi2 */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>HUF_compress4X_usingCTable_bmi2</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>HUF_CElt</name><modifier>*</modifier></type> <name>CTable</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bmi2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>HUF_compress4X_usingCTable_internal</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>CTable</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><enum>enum <block>{ <decl><name>HUF_singleStream</name></decl>, <decl><name>HUF_fourStreams</name></decl> }</block></enum></type> <name>HUF_nbStreams_e</name>;</typedef>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>HUF_compressCTable_internal</name><parameter_list>(
                <parameter><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ostart</name></decl></parameter>, <parameter><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                <parameter><decl><type><name>HUF_nbStreams_e</name></type> <name>nbStreams</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>HUF_CElt</name><modifier>*</modifier></type> <name>CTable</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>bmi2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>cSize</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>nbStreams</name><operator>==</operator><name>HUF_singleStream</name><operator>)</operator></expr> ?</condition><then>
                         <expr><call><name>HUF_compress1X_usingCTable_internal</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name> <operator>-</operator> <name>op</name><operator>)</operator></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>CTable</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr> </then><else>:
                         <expr><call><name>HUF_compress4X_usingCTable_internal</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name> <operator>-</operator> <name>op</name><operator>)</operator></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>CTable</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HUF_isError</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <return>return <expr><name>cSize</name></expr>;</return> </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>cSize</name><operator>==</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content> <return>return <expr><literal type="number">0</literal></expr>;</return> </block_content>}</block></if></if_stmt>   <comment type="block">/* uncompressible */</comment>
    <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>cSize</name></expr>;</expr_stmt>
    <comment type="block">/* check compressibility */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name> <operator>&gt;=</operator> <name>ostart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>op</name><operator>-</operator><name>ostart</name><operator>)</operator> <operator>&gt;=</operator> <name>srcSize</name><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content> <return>return <expr><literal type="number">0</literal></expr>;</return> </block_content>}</block></if></if_stmt>
    <return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>op</name><operator>-</operator><name>ostart</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><name>unsigned</name></type> <name>HUF_optimalTableLog</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>maxTableLog</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>maxSymbolValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>tableLog</name> <init>= <expr><call><name>FSE_optimalTableLog_internal</name><argument_list>(<argument><expr><name>maxTableLog</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>maxSymbolValue</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tableLog</name> <operator>&lt;=</operator> <name>HUF_TABLELOG_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>tableLog</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name><name>count</name><index>[<expr><name>HUF_SYMBOLVALUE_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HUF_CElt</name></type> <name><name>CTable</name><index>[<expr><call><name>HUF_CTABLE_SIZE_ST</name><argument_list>(<argument><expr><name>HUF_SYMBOLVALUE_MAX</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>
    <union>union <block>{
        <decl_stmt><decl><type><name>HUF_buildCTable_wksp_tables</name></type> <name>buildCTable_wksp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HUF_WriteCTableWksp</name></type> <name>writeCTable_wksp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name></type> <name><name>hist_wksp</name><index>[<expr><name>HIST_WKSP_SIZE_U32</name></expr>]</index></name></decl>;</decl_stmt>
    }</block> <decl><name>wksps</name></decl>;</union>
}</block></struct></type> <name>HUF_compress_tables_t</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUSPECT_INCOMPRESSIBLE_SAMPLE_SIZE</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUSPECT_INCOMPRESSIBLE_SAMPLE_RATIO</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>  <comment type="block">/* Must be &gt;= 2 */</comment>

<comment type="block">/* HUF_compress_internal() :
 * `workSpace_align4` must be aligned on 4-bytes boundaries,
 * and occupies the same space as a table of HUF_WORKSPACE_SIZE_U64 unsigned */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>HUF_compress_internal</name> <parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
                 <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                       <parameter><decl><type><name>unsigned</name></type> <name>maxSymbolValue</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>huffLog</name></decl></parameter>,
                       <parameter><decl><type><name>HUF_nbStreams_e</name></type> <name>nbStreams</name></decl></parameter>,
                       <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workSpace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>,
                       <parameter><decl><type><name>HUF_CElt</name><modifier>*</modifier></type> <name>oldHufTable</name></decl></parameter>, <parameter><decl><type><name>HUF_repeat</name><modifier>*</modifier></type> <name>repeat</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>preferRepeat</name></decl></parameter>,
                 <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>bmi2</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>suspectUncompressible</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HUF_compress_tables_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>table</name> <init>= <expr><operator>(</operator><name>HUF_compress_tables_t</name><operator>*</operator><operator>)</operator><call><name>HUF_alignUpWorkspace</name><argument_list>(<argument><expr><name>workSpace</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wkspSize</name></expr></argument>, <argument><expr><call><name>ZSTD_ALIGNOF</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ostart</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend</name> <init>= <expr><name>ostart</name> <operator>+</operator> <name>dstSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><name>ostart</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"HUF_compress_internal (srcSize=%zu)"</literal></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HUF_STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>table</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>HUF_WORKSPACE_MAX_ALIGNMENT</name> <operator>&lt;=</operator> <name>HUF_WORKSPACE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* checks &amp; inits */</comment>
    <if_stmt><if>if <condition>(<expr><name>wkspSize</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>table</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>workSpace_tooSmall</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>srcSize</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Uncompressed */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>dstSize</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* cannot fit anything within dst budget */</comment>
    <if_stmt><if>if <condition>(<expr><name>srcSize</name> <operator>&gt;</operator> <name>HUF_BLOCKSIZE_MAX</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>srcSize_wrong</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* current block size limit */</comment>
    <if_stmt><if>if <condition>(<expr><name>huffLog</name> <operator>&gt;</operator> <name>HUF_TABLELOG_MAX</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>tableLog_tooLarge</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>maxSymbolValue</name> <operator>&gt;</operator> <name>HUF_SYMBOLVALUE_MAX</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>maxSymbolValue_tooLarge</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>maxSymbolValue</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>maxSymbolValue</name> <operator>=</operator> <name>HUF_SYMBOLVALUE_MAX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>huffLog</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>huffLog</name> <operator>=</operator> <name>HUF_TABLELOG_DEFAULT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Heuristic : If old table is valid, use it for small inputs */</comment>
    <if_stmt><if>if <condition>(<expr><name>preferRepeat</name> <operator>&amp;&amp;</operator> <name>repeat</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>repeat</name> <operator>==</operator> <name>HUF_repeat_valid</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>HUF_compressCTable_internal</name><argument_list>(<argument><expr><name>ostart</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>,
                                           <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>,
                                           <argument><expr><name>nbStreams</name></expr></argument>, <argument><expr><name>oldHufTable</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If uncompressible data is suspected, do a smaller sampling first */</comment>
    <expr_stmt><expr><call><name>DEBUG_STATIC_ASSERT</name><argument_list>(<argument><expr><name>SUSPECT_INCOMPRESSIBLE_SAMPLE_RATIO</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>suspectUncompressible</name> <operator>&amp;&amp;</operator> <name>srcSize</name> <operator>&gt;=</operator> <operator>(</operator><name>SUSPECT_INCOMPRESSIBLE_SAMPLE_SIZE</name> <operator>*</operator> <name>SUSPECT_INCOMPRESSIBLE_SAMPLE_RATIO</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>largestTotal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"input suspected incompressible : sampling to check"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <block>{<block_content>   <decl_stmt><decl><type><name>unsigned</name></type> <name>maxSymbolValueBegin</name> <init>= <expr><name>maxSymbolValue</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>CHECK_V_F</name><argument_list>(<argument><expr><name>largestBegin</name></expr></argument>, <argument><expr><call><name>HIST_count_simple</name> <argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>maxSymbolValueBegin</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name></expr></argument>, <argument><expr><name>SUSPECT_INCOMPRESSIBLE_SAMPLE_SIZE</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>largestTotal</name> <operator>+=</operator> <name>largestBegin</name></expr>;</expr_stmt>
        </block_content>}</block>
        <block>{<block_content>   <decl_stmt><decl><type><name>unsigned</name></type> <name>maxSymbolValueEnd</name> <init>= <expr><name>maxSymbolValue</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>CHECK_V_F</name><argument_list>(<argument><expr><name>largestEnd</name></expr></argument>, <argument><expr><call><name>HIST_count_simple</name> <argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>maxSymbolValueEnd</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <name>srcSize</name> <operator>-</operator> <name>SUSPECT_INCOMPRESSIBLE_SAMPLE_SIZE</name></expr></argument>, <argument><expr><name>SUSPECT_INCOMPRESSIBLE_SAMPLE_SIZE</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>largestTotal</name> <operator>+=</operator> <name>largestEnd</name></expr>;</expr_stmt>
        </block_content>}</block>
        <if_stmt><if>if <condition>(<expr><name>largestTotal</name> <operator>&lt;=</operator> <operator>(</operator><operator>(</operator><literal type="number">2</literal> <operator>*</operator> <name>SUSPECT_INCOMPRESSIBLE_SAMPLE_SIZE</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">7</literal><operator>)</operator><operator>+</operator><literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* heuristic : probably not compressible enough */</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Scan input and build symbol stats */</comment>
    <block>{<block_content>   <expr_stmt><expr><call><name>CHECK_V_F</name><argument_list>(<argument><expr><name>largest</name></expr></argument>, <argument><expr><call><name>HIST_count_wksp</name> <argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>maxSymbolValue</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>wksps</name><operator>.</operator><name>hist_wksp</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>wksps</name><operator>.</operator><name>hist_wksp</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>largest</name> <operator>==</operator> <name>srcSize</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><operator>*</operator><name>ostart</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt> <return>return <expr><literal type="number">1</literal></expr>;</return> </block_content>}</block></if></if_stmt>   <comment type="block">/* single symbol, rle */</comment>
        <if_stmt><if>if <condition>(<expr><name>largest</name> <operator>&lt;=</operator> <operator>(</operator><name>srcSize</name> <operator>&gt;&gt;</operator> <literal type="number">7</literal><operator>)</operator><operator>+</operator><literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* heuristic : probably not compressible enough */</comment>
    </block_content>}</block>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"histogram detail completed (%zu symbols)"</literal></expr></argument>, <argument><expr><call><name>showU32</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><name>maxSymbolValue</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check validity of previous table */</comment>
    <if_stmt><if>if <condition>( <expr><name>repeat</name>
      <operator>&amp;&amp;</operator> <operator>*</operator><name>repeat</name> <operator>==</operator> <name>HUF_repeat_check</name>
      <operator>&amp;&amp;</operator> <operator>!</operator><call><name>HUF_validateCTable</name><argument_list>(<argument><expr><name>oldHufTable</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><name>maxSymbolValue</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>repeat</name> <operator>=</operator> <name>HUF_repeat_none</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Heuristic : use existing table for small inputs */</comment>
    <if_stmt><if>if <condition>(<expr><name>preferRepeat</name> <operator>&amp;&amp;</operator> <name>repeat</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>repeat</name> <operator>!=</operator> <name>HUF_repeat_none</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>HUF_compressCTable_internal</name><argument_list>(<argument><expr><name>ostart</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>,
                                           <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>,
                                           <argument><expr><name>nbStreams</name></expr></argument>, <argument><expr><name>oldHufTable</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Build Huffman Tree */</comment>
    <expr_stmt><expr><name>huffLog</name> <operator>=</operator> <call><name>HUF_optimalTableLog</name><argument_list>(<argument><expr><name>huffLog</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>maxSymbolValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>maxBits</name> <init>= <expr><call><name>HUF_buildCTable_wksp</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>CTable</name></name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>count</name></name></expr></argument>,
                                            <argument><expr><name>maxSymbolValue</name></expr></argument>, <argument><expr><name>huffLog</name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name><name>table</name><operator>-&gt;</operator><name>wksps</name><operator>.</operator><name>buildCTable_wksp</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>wksps</name><operator>.</operator><name>buildCTable_wksp</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>CHECK_F</name><argument_list>(<argument><expr><name>maxBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>huffLog</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>maxBits</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"bit distribution completed (%zu symbols)"</literal></expr></argument>, <argument><expr><call><name>showCTableBits</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>CTable</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>maxSymbolValue</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <comment type="block">/* Zero unused symbols in CTable, so we can check it for validity */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>ctableSize</name> <init>= <expr><call><name>HUF_CTABLE_SIZE_ST</name><argument_list>(<argument><expr><name>maxSymbolValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>unusedSize</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>CTable</name></name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>ctableSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HUF_CElt</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>CTable</name></name> <operator>+</operator> <name>ctableSize</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>unusedSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* Write table description header */</comment>
    <block>{<block_content>   <expr_stmt><expr><call><name>CHECK_V_F</name><argument_list>(<argument><expr><name>hSize</name></expr></argument>, <argument><expr><call><name>HUF_writeCTable_wksp</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>CTable</name></name></expr></argument>, <argument><expr><name>maxSymbolValue</name></expr></argument>, <argument><expr><name>huffLog</name></expr></argument>,
                                              <argument><expr><operator>&amp;</operator><name><name>table</name><operator>-&gt;</operator><name>wksps</name><operator>.</operator><name>writeCTable_wksp</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>wksps</name><operator>.</operator><name>writeCTable_wksp</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Check if using previous huffman table is beneficial */</comment>
        <if_stmt><if>if <condition>(<expr><name>repeat</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>repeat</name> <operator>!=</operator> <name>HUF_repeat_none</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>oldSize</name> <init>= <expr><call><name>HUF_estimateCompressedSize</name><argument_list>(<argument><expr><name>oldHufTable</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><name>maxSymbolValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>newSize</name> <init>= <expr><call><name>HUF_estimateCompressedSize</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>CTable</name></name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><name>maxSymbolValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>oldSize</name> <operator>&lt;=</operator> <name>hSize</name> <operator>+</operator> <name>newSize</name> <operator>||</operator> <name>hSize</name> <operator>+</operator> <literal type="number">12</literal> <operator>&gt;=</operator> <name>srcSize</name></expr>)</condition> <block>{<block_content>
                <return>return <expr><call><name>HUF_compressCTable_internal</name><argument_list>(<argument><expr><name>ostart</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>,
                                                   <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>,
                                                   <argument><expr><name>nbStreams</name></expr></argument>, <argument><expr><name>oldHufTable</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>   </block_content>}</block></if></if_stmt>

        <comment type="block">/* Use the new huffman table */</comment>
        <if_stmt><if>if <condition>(<expr><name>hSize</name> <operator>+</operator> <literal type="number">12ul</literal> <operator>&gt;=</operator> <name>srcSize</name></expr>)</condition> <block>{<block_content> <return>return <expr><literal type="number">0</literal></expr>;</return> </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>hSize</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>repeat</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><operator>*</operator><name>repeat</name> <operator>=</operator> <name>HUF_repeat_none</name></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>oldHufTable</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>oldHufTable</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>CTable</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>CTable</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Save new table */</comment>
    </block_content>}</block>
    <return>return <expr><call><name>HUF_compressCTable_internal</name><argument_list>(<argument><expr><name>ostart</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>,
                                       <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>,
                                       <argument><expr><name>nbStreams</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>CTable</name></name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>size_t</name></type> <name>HUF_compress1X_wksp</name> <parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
                      <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                      <parameter><decl><type><name>unsigned</name></type> <name>maxSymbolValue</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>huffLog</name></decl></parameter>,
                      <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workSpace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>HUF_compress_internal</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>,
                                 <argument><expr><name>maxSymbolValue</name></expr></argument>, <argument><expr><name>huffLog</name></expr></argument>, <argument><expr><name>HUF_singleStream</name></expr></argument>,
                                 <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/*bmi2*/</comment>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>HUF_compress1X_repeat</name> <parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
                      <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                      <parameter><decl><type><name>unsigned</name></type> <name>maxSymbolValue</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>huffLog</name></decl></parameter>,
                      <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workSpace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>,
                      <parameter><decl><type><name>HUF_CElt</name><modifier>*</modifier></type> <name>hufTable</name></decl></parameter>, <parameter><decl><type><name>HUF_repeat</name><modifier>*</modifier></type> <name>repeat</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>preferRepeat</name></decl></parameter>,
                      <parameter><decl><type><name>int</name></type> <name>bmi2</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>suspectUncompressible</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"HUF_compress1X_repeat (srcSize = %zu)"</literal></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>HUF_compress_internal</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>,
                                 <argument><expr><name>maxSymbolValue</name></expr></argument>, <argument><expr><name>huffLog</name></expr></argument>, <argument><expr><name>HUF_singleStream</name></expr></argument>,
                                 <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>, <argument><expr><name>hufTable</name></expr></argument>,
                                 <argument><expr><name>repeat</name></expr></argument>, <argument><expr><name>preferRepeat</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>, <argument><expr><name>suspectUncompressible</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* HUF_compress4X_repeat():
 * compress input using 4 streams.
 * provide workspace to generate compression tables */</comment>
<function><type><name>size_t</name></type> <name>HUF_compress4X_wksp</name> <parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
                      <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                      <parameter><decl><type><name>unsigned</name></type> <name>maxSymbolValue</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>huffLog</name></decl></parameter>,
                      <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workSpace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"HUF_compress4X_wksp (srcSize = %zu)"</literal></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>HUF_compress_internal</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>,
                                 <argument><expr><name>maxSymbolValue</name></expr></argument>, <argument><expr><name>huffLog</name></expr></argument>, <argument><expr><name>HUF_fourStreams</name></expr></argument>,
                                 <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/*bmi2*/</comment>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* HUF_compress4X_repeat():
 * compress input using 4 streams.
 * consider skipping quickly
 * re-use an existing huffman compression table */</comment>
<function><type><name>size_t</name></type> <name>HUF_compress4X_repeat</name> <parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
                      <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                      <parameter><decl><type><name>unsigned</name></type> <name>maxSymbolValue</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>huffLog</name></decl></parameter>,
                      <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workSpace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>,
                      <parameter><decl><type><name>HUF_CElt</name><modifier>*</modifier></type> <name>hufTable</name></decl></parameter>, <parameter><decl><type><name>HUF_repeat</name><modifier>*</modifier></type> <name>repeat</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>preferRepeat</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bmi2</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>suspectUncompressible</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"HUF_compress4X_repeat (srcSize = %zu)"</literal></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>HUF_compress_internal</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>,
                                 <argument><expr><name>maxSymbolValue</name></expr></argument>, <argument><expr><name>huffLog</name></expr></argument>, <argument><expr><name>HUF_fourStreams</name></expr></argument>,
                                 <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>,
                                 <argument><expr><name>hufTable</name></expr></argument>, <argument><expr><name>repeat</name></expr></argument>, <argument><expr><name>preferRepeat</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>, <argument><expr><name>suspectUncompressible</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ZSTD_NO_UNUSED_FUNCTIONS</name></cpp:ifndef>
<comment type="block" format="doxygen">/** HUF_buildCTable() :
 * @return : maxNbBits
 *  Note : count is used before tree is written, so they can safely overlap
 */</comment>
<function><type><name>size_t</name></type> <name>HUF_buildCTable</name> <parameter_list>(<parameter><decl><type><name>HUF_CElt</name><modifier>*</modifier></type> <name>tree</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name><modifier>*</modifier></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>maxSymbolValue</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>maxNbBits</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HUF_buildCTable_wksp_tables</name></type> <name>workspace</name></decl>;</decl_stmt>
    <return>return <expr><call><name>HUF_buildCTable_wksp</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>maxSymbolValue</name></expr></argument>, <argument><expr><name>maxNbBits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>workspace</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>workspace</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>HUF_compress1X</name> <parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
                 <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                 <parameter><decl><type><name>unsigned</name></type> <name>maxSymbolValue</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>huffLog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U64</name></type> <name><name>workSpace</name><index>[<expr><name>HUF_WORKSPACE_SIZE_U64</name></expr>]</index></name></decl>;</decl_stmt>
    <return>return <expr><call><name>HUF_compress1X_wksp</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>maxSymbolValue</name></expr></argument>, <argument><expr><name>huffLog</name></expr></argument>, <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>workSpace</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>HUF_compress2</name> <parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                <parameter><decl><type><name>unsigned</name></type> <name>maxSymbolValue</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>huffLog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U64</name></type> <name><name>workSpace</name><index>[<expr><name>HUF_WORKSPACE_SIZE_U64</name></expr>]</index></name></decl>;</decl_stmt>
    <return>return <expr><call><name>HUF_compress4X_wksp</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>maxSymbolValue</name></expr></argument>, <argument><expr><name>huffLog</name></expr></argument>, <argument><expr><name>workSpace</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>workSpace</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>HUF_compress</name> <parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>maxDstSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>HUF_compress2</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>, <argument><expr><name>HUF_TABLELOG_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
