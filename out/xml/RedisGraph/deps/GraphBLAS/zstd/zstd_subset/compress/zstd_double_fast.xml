<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/zstd/zstd_subset/compress/zstd_double_fast.c"><comment type="block">/*
 * Copyright (c) Yann Collet, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_compress_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_double_fast.h"</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_fillDoubleHashTableForCDict</name><parameter_list>(<parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>,
                              <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>ZSTD_dictTableLoadMethod_e</name></type> <name>dtlm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_compressionParameters</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cParams</name> <init>= <expr><operator>&amp;</operator><name><name>ms</name><operator>-&gt;</operator><name>cParams</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>hashLarge</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>hashTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>  <specifier>const</specifier></type> <name>hBitsL</name> <init>= <expr><name><name>cParams</name><operator>-&gt;</operator><name>hashLog</name></name> <operator>+</operator> <name>ZSTD_SHORT_CACHE_TAG_BITS</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>  <specifier>const</specifier></type> <name>mls</name> <init>= <expr><name><name>cParams</name><operator>-&gt;</operator><name>minMatch</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>hashSmall</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>chainTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>  <specifier>const</specifier></type> <name>hBitsS</name> <init>= <expr><name><name>cParams</name><operator>-&gt;</operator><name>chainLog</name></name> <operator>+</operator> <name>ZSTD_SHORT_CACHE_TAG_BITS</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>base</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><name>base</name> <operator>+</operator> <name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>end</name><operator>)</operator> <operator>-</operator> <name>HASH_READ_SIZE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>fastHashFillStep</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Always insert every fastHashFillStep position into the hash tables.
     * Insert the other positions into the large hash table if their entry
     * is empty.
     */</comment>
    <for>for <control>(<init>;</init> <condition><expr><name>ip</name> <operator>+</operator> <name>fastHashFillStep</name> <operator>-</operator> <literal type="number">1</literal> <operator>&lt;=</operator> <name>iend</name></expr>;</condition> <incr><expr><name>ip</name> <operator>+=</operator> <name>fastHashFillStep</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>curr</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>fastHashFillStep</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>smHashAndTag</name> <init>= <expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>hBitsS</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>lgHashAndTag</name> <init>= <expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>hBitsL</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>ZSTD_writeTaggedIndex</name><argument_list>(<argument><expr><name>hashSmall</name></expr></argument>, <argument><expr><name>smHashAndTag</name></expr></argument>, <argument><expr><name>curr</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>hashLarge</name><index>[<expr><name>lgHashAndTag</name> <operator>&gt;&gt;</operator> <name>ZSTD_SHORT_CACHE_TAG_BITS</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>ZSTD_writeTaggedIndex</name><argument_list>(<argument><expr><name>hashLarge</name></expr></argument>, <argument><expr><name>lgHashAndTag</name></expr></argument>, <argument><expr><name>curr</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* Only load extra positions for ZSTD_dtlm_full */</comment>
            <if_stmt><if>if <condition>(<expr><name>dtlm</name> <operator>==</operator> <name>ZSTD_dtlm_fast</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>   </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_fillDoubleHashTableForCCtx</name><parameter_list>(<parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>,
                              <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>ZSTD_dictTableLoadMethod_e</name></type> <name>dtlm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_compressionParameters</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cParams</name> <init>= <expr><operator>&amp;</operator><name><name>ms</name><operator>-&gt;</operator><name>cParams</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>hashLarge</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>hashTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>  <specifier>const</specifier></type> <name>hBitsL</name> <init>= <expr><name><name>cParams</name><operator>-&gt;</operator><name>hashLog</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>  <specifier>const</specifier></type> <name>mls</name> <init>= <expr><name><name>cParams</name><operator>-&gt;</operator><name>minMatch</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>hashSmall</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>chainTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>  <specifier>const</specifier></type> <name>hBitsS</name> <init>= <expr><name><name>cParams</name><operator>-&gt;</operator><name>chainLog</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>base</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><name>base</name> <operator>+</operator> <name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>end</name><operator>)</operator> <operator>-</operator> <name>HASH_READ_SIZE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>fastHashFillStep</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Always insert every fastHashFillStep position into the hash tables.
     * Insert the other positions into the large hash table if their entry
     * is empty.
     */</comment>
    <for>for <control>(<init>;</init> <condition><expr><name>ip</name> <operator>+</operator> <name>fastHashFillStep</name> <operator>-</operator> <literal type="number">1</literal> <operator>&lt;=</operator> <name>iend</name></expr>;</condition> <incr><expr><name>ip</name> <operator>+=</operator> <name>fastHashFillStep</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>curr</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>fastHashFillStep</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>smHash</name> <init>= <expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>hBitsS</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>lgHash</name> <init>= <expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>hBitsL</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>hashSmall</name><index>[<expr><name>smHash</name></expr>]</index></name> <operator>=</operator> <name>curr</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>hashLarge</name><index>[<expr><name>lgHash</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>hashLarge</name><index>[<expr><name>lgHash</name></expr>]</index></name> <operator>=</operator> <name>curr</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <comment type="block">/* Only load extra positions for ZSTD_dtlm_full */</comment>
            <if_stmt><if>if <condition>(<expr><name>dtlm</name> <operator>==</operator> <name>ZSTD_dtlm_fast</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>   </block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>ZSTD_fillDoubleHashTable</name><parameter_list>(<parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier> <specifier>const</specifier></type> <name>end</name></decl></parameter>,
                        <parameter><decl><type><name>ZSTD_dictTableLoadMethod_e</name></type> <name>dtlm</name></decl></parameter>,
                        <parameter><decl><type><name>ZSTD_tableFillPurpose_e</name></type> <name>tfp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>tfp</name> <operator>==</operator> <name>ZSTD_tfp_forCDict</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>ZSTD_fillDoubleHashTableForCDict</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>dtlm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>ZSTD_fillDoubleHashTableForCCtx</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>dtlm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><name>FORCE_INLINE_TEMPLATE</name>
<name>size_t</name></type> <name>ZSTD_compressBlock_doubleFast_noDict_generic</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>mls</name></decl></parameter> <comment type="block">/* template */</comment>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_compressionParameters</name> <specifier>const</specifier><modifier>*</modifier></type> <name>cParams</name> <init>= <expr><operator>&amp;</operator><name><name>ms</name><operator>-&gt;</operator><name>cParams</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>hashLong</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>hashTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>hBitsL</name> <init>= <expr><name><name>cParams</name><operator>-&gt;</operator><name>hashLog</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>hashSmall</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>chainTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>hBitsS</name> <init>= <expr><name><name>cParams</name><operator>-&gt;</operator><name>chainLog</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>base</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>istart</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>anchor</name> <init>= <expr><name>istart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>endIndex</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>istart</name> <operator>-</operator> <name>base</name><operator>)</operator> <operator>+</operator> <name>srcSize</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <comment type="block">/* presumes that, if there is a dictionary, it must be using Attach mode */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>prefixLowestIndex</name> <init>= <expr><call><name>ZSTD_getLowestPrefixIndex</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>endIndex</name></expr></argument>, <argument><expr><name><name>cParams</name><operator>-&gt;</operator><name>windowLog</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>prefixLowest</name> <init>= <expr><name>base</name> <operator>+</operator> <name>prefixLowestIndex</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name> <init>= <expr><name>istart</name> <operator>+</operator> <name>srcSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ilimit</name> <init>= <expr><name>iend</name> <operator>-</operator> <name>HASH_READ_SIZE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>offset_1</name><init>=<expr><name><name>rep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>, <decl><type ref="prev"/><name>offset_2</name><init>=<expr><name><name>rep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>offsetSaved1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>offsetSaved2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>size_t</name></type> <name>mLength</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>curr</name></decl>;</decl_stmt>

    <comment type="block">/* how many positions to search before increasing step size */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>kStepIncr</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>kSearchStrength</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* the position at which to increment the step size if no match is found */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>nextStep</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>step</name></decl>;</decl_stmt> <comment type="block">/* the current step size */</comment>

    <decl_stmt><decl><type><name>size_t</name></type> <name>hl0</name></decl>;</decl_stmt> <comment type="block">/* the long hash at ip */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>hl1</name></decl>;</decl_stmt> <comment type="block">/* the long hash at ip1 */</comment>

    <decl_stmt><decl><type><name>U32</name></type> <name>idxl0</name></decl>;</decl_stmt> <comment type="block">/* the long match index for ip */</comment>
    <decl_stmt><decl><type><name>U32</name></type> <name>idxl1</name></decl>;</decl_stmt> <comment type="block">/* the long match index for ip1 */</comment>

    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>matchl0</name></decl>;</decl_stmt> <comment type="block">/* the long match for ip */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>matchs0</name></decl>;</decl_stmt> <comment type="block">/* the short match for ip */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>matchl1</name></decl>;</decl_stmt> <comment type="block">/* the long match for ip1 */</comment>

    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><name>istart</name></expr></init></decl>;</decl_stmt> <comment type="block">/* the current position */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip1</name></decl>;</decl_stmt> <comment type="block">/* the next position */</comment>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressBlock_doubleFast_noDict_generic"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* init */</comment>
    <expr_stmt><expr><name>ip</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>prefixLowest</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
    <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>current</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>windowLow</name> <init>= <expr><call><name>ZSTD_getLowestPrefixIndex</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>current</name></expr></argument>, <argument><expr><name><name>cParams</name><operator>-&gt;</operator><name>windowLog</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>maxRep</name> <init>= <expr><name>current</name> <operator>-</operator> <name>windowLow</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>offset_2</name> <operator>&gt;</operator> <name>maxRep</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>offsetSaved2</name> <operator>=</operator> <name>offset_2</name></expr><operator>,</operator> <expr><name>offset_2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>offset_1</name> <operator>&gt;</operator> <name>maxRep</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>offsetSaved1</name> <operator>=</operator> <name>offset_1</name></expr><operator>,</operator> <expr><name>offset_1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/* Outer Loop: one iteration per match found and stored */</comment>
    <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>step</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>nextStep</name> <operator>=</operator> <name>ip</name> <operator>+</operator> <name>kStepIncr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ip1</name> <operator>=</operator> <name>ip</name> <operator>+</operator> <name>step</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>ip1</name> <operator>&gt;</operator> <name>ilimit</name></expr>)</condition> <block>{<block_content>
            <goto>goto <name>_cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>hl0</name> <operator>=</operator> <call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>hBitsL</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>idxl0</name> <operator>=</operator> <name><name>hashLong</name><index>[<expr><name>hl0</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>matchl0</name> <operator>=</operator> <name>base</name> <operator>+</operator> <name>idxl0</name></expr>;</expr_stmt>

        <comment type="block">/* Inner Loop: one iteration per search / position */</comment>
        <do>do <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>hs0</name> <init>= <expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>hBitsS</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>idxs0</name> <init>= <expr><name><name>hashSmall</name><index>[<expr><name>hs0</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>curr</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>base</name><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>matchs0</name> <operator>=</operator> <name>base</name> <operator>+</operator> <name>idxs0</name></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>hashLong</name><index>[<expr><name>hl0</name></expr>]</index></name> <operator>=</operator> <name><name>hashSmall</name><index>[<expr><name>hs0</name></expr>]</index></name> <operator>=</operator> <name>curr</name></expr>;</expr_stmt>   <comment type="block">/* update hash tables */</comment>

            <comment type="block">/* check noDict repcode */</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>offset_1</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">1</literal><operator>-</operator><name>offset_1</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>mLength</name> <operator>=</operator> <call><name>ZSTD_count</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>ip</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><literal type="number">4</literal><operator>-</operator><name>offset_1</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>ip</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ZSTD_storeSeq</name><argument_list>(<argument><expr><name>seqStore</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>anchor</name><operator>)</operator></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>REPCODE1_TO_OFFBASE</name></expr></argument>, <argument><expr><name>mLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>_match_stored</name>;</goto>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>hl1</name> <operator>=</operator> <call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip1</name></expr></argument>, <argument><expr><name>hBitsL</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>idxl0</name> <operator>&gt;</operator> <name>prefixLowestIndex</name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* check prefix long match */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>MEM_read64</name><argument_list>(<argument><expr><name>matchl0</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read64</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>mLength</name> <operator>=</operator> <call><name>ZSTD_count</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">8</literal></expr></argument>, <argument><expr><name>matchl0</name><operator>+</operator><literal type="number">8</literal></expr></argument>, <argument><expr><name>iend</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">8</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>matchl0</name><operator>)</operator></expr>;</expr_stmt>
                    <while>while <condition>(<expr><operator>(</operator><operator>(</operator><name>ip</name><operator>&gt;</operator><name>anchor</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>matchl0</name><operator>&gt;</operator><name>prefixLowest</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ip</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>matchl0</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>ip</name><operator>--</operator></expr>;</expr_stmt> <expr_stmt><expr><name>matchl0</name><operator>--</operator></expr>;</expr_stmt> <expr_stmt><expr><name>mLength</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while> <comment type="block">/* catch up */</comment>
                    <goto>goto <name>_match_found</name>;</goto>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>idxl1</name> <operator>=</operator> <name><name>hashLong</name><index>[<expr><name>hl1</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>matchl1</name> <operator>=</operator> <name>base</name> <operator>+</operator> <name>idxl1</name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>idxs0</name> <operator>&gt;</operator> <name>prefixLowestIndex</name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* check prefix short match */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>MEM_read32</name><argument_list>(<argument><expr><name>matchs0</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <goto>goto <name>_search_next_long</name>;</goto>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>ip1</name> <operator>&gt;=</operator> <name>nextStep</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>PREFETCH_L1</name><argument_list>(<argument><expr><name>ip1</name> <operator>+</operator> <literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>PREFETCH_L1</name><argument_list>(<argument><expr><name>ip1</name> <operator>+</operator> <literal type="number">128</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>step</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>nextStep</name> <operator>+=</operator> <name>kStepIncr</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>ip</name> <operator>=</operator> <name>ip1</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ip1</name> <operator>+=</operator> <name>step</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>hl0</name> <operator>=</operator> <name>hl1</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>idxl0</name> <operator>=</operator> <name>idxl1</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>matchl0</name> <operator>=</operator> <name>matchl1</name></expr>;</expr_stmt>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__aarch64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
            <expr_stmt><expr><call><name>PREFETCH_L1</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">256</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block> while <condition>(<expr><name>ip1</name> <operator>&lt;=</operator> <name>ilimit</name></expr>)</condition>;</do>

<label><name>_cleanup</name>:</label>
        <comment type="block">/* If offset_1 started invalid (offsetSaved1 != 0) and became valid (offset_1 != 0),
         * rotate saved offsets. See comment in ZSTD_compressBlock_fast_noDict for more context. */</comment>
        <expr_stmt><expr><name>offsetSaved2</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>(</operator><name>offsetSaved1</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>offset_1</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><name>offsetSaved1</name></expr> </then><else>: <expr><name>offsetSaved2</name></expr></else></ternary></expr>;</expr_stmt>

        <comment type="block">/* save reps for next block */</comment>
        <expr_stmt><expr><name><name>rep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>offset_1</name></expr> ?</condition><then> <expr><name>offset_1</name></expr> </then><else>: <expr><name>offsetSaved1</name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>offset_2</name></expr> ?</condition><then> <expr><name>offset_2</name></expr> </then><else>: <expr><name>offsetSaved2</name></expr></else></ternary></expr>;</expr_stmt>

        <comment type="block">/* Return the last literals size */</comment>
        <return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>iend</name> <operator>-</operator> <name>anchor</name><operator>)</operator></expr>;</return>

<label><name>_search_next_long</name>:</label>

        <comment type="block">/* check prefix long +1 match */</comment>
        <if_stmt><if>if <condition>(<expr><name>idxl1</name> <operator>&gt;</operator> <name>prefixLowestIndex</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>MEM_read64</name><argument_list>(<argument><expr><name>matchl1</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read64</name><argument_list>(<argument><expr><name>ip1</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>ip</name> <operator>=</operator> <name>ip1</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>mLength</name> <operator>=</operator> <call><name>ZSTD_count</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">8</literal></expr></argument>, <argument><expr><name>matchl1</name><operator>+</operator><literal type="number">8</literal></expr></argument>, <argument><expr><name>iend</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">8</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>matchl1</name><operator>)</operator></expr>;</expr_stmt>
                <while>while <condition>(<expr><operator>(</operator><operator>(</operator><name>ip</name><operator>&gt;</operator><name>anchor</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>matchl1</name><operator>&gt;</operator><name>prefixLowest</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ip</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>matchl1</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>ip</name><operator>--</operator></expr>;</expr_stmt> <expr_stmt><expr><name>matchl1</name><operator>--</operator></expr>;</expr_stmt> <expr_stmt><expr><name>mLength</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while> <comment type="block">/* catch up */</comment>
                <goto>goto <name>_match_found</name>;</goto>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* if no long +1 match, explore the short match we found */</comment>
        <expr_stmt><expr><name>mLength</name> <operator>=</operator> <call><name>ZSTD_count</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>matchs0</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>iend</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>matchs0</name><operator>)</operator></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><operator>(</operator><name>ip</name><operator>&gt;</operator><name>anchor</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>matchs0</name><operator>&gt;</operator><name>prefixLowest</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ip</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>matchs0</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>ip</name><operator>--</operator></expr>;</expr_stmt> <expr_stmt><expr><name>matchs0</name><operator>--</operator></expr>;</expr_stmt> <expr_stmt><expr><name>mLength</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while> <comment type="block">/* catch up */</comment>

        <comment type="block">/* fall-through */</comment>

<label><name>_match_found</name>:</label> <comment type="block">/* requires ip, offset, mLength */</comment>
        <expr_stmt><expr><name>offset_2</name> <operator>=</operator> <name>offset_1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>offset_1</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>step</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* It is unsafe to write this value back to the hashtable when ip1 is
             * greater than or equal to the new ip we will have after we're done
             * processing this match. Rather than perform that test directly
             * (ip1 &gt;= ip + mLength), which costs speed in practice, we do a simpler
             * more predictable test. The minmatch even if we take a short match is
             * 4 bytes, so as long as step, the distance between ip and ip1
             * (initially) is less than 4, we know ip1 &lt; new ip. */</comment>
            <expr_stmt><expr><name><name>hashLong</name><index>[<expr><name>hl1</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip1</name> <operator>-</operator> <name>base</name><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>ZSTD_storeSeq</name><argument_list>(<argument><expr><name>seqStore</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>anchor</name><operator>)</operator></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><call><name>OFFSET_TO_OFFBASE</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>_match_stored</name>:</label>
        <comment type="block">/* match found */</comment>
        <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>mLength</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>anchor</name> <operator>=</operator> <name>ip</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>ip</name> <operator>&lt;=</operator> <name>ilimit</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Complementary insertion */</comment>
            <comment type="block">/* done after iLimit test, as candidates could be &gt; iend-8 */</comment>
            <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>indexToInsert</name> <init>= <expr><name>curr</name><operator>+</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>hashLong</name><index>[<expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>base</name><operator>+</operator><name>indexToInsert</name></expr></argument>, <argument><expr><name>hBitsL</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>indexToInsert</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>hashLong</name><index>[<expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>hBitsL</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><literal type="number">2</literal><operator>-</operator><name>base</name><operator>)</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>hashSmall</name><index>[<expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>base</name><operator>+</operator><name>indexToInsert</name></expr></argument>, <argument><expr><name>hBitsS</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>indexToInsert</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>hashSmall</name><index>[<expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>hBitsS</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>base</name><operator>)</operator></expr>;</expr_stmt>
            </block_content>}</block>

            <comment type="block">/* check immediate repcode */</comment>
            <while>while <condition>( <expr><operator>(</operator><name>ip</name> <operator>&lt;=</operator> <name>ilimit</name><operator>)</operator>
                 <operator>&amp;&amp;</operator> <operator>(</operator> <operator>(</operator><name>offset_2</name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator>
                    <operator>&amp;</operator> <operator>(</operator><call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip</name> <operator>-</operator> <name>offset_2</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>)</operator></expr>)</condition> <block>{<block_content>
                <comment type="block">/* store sequence */</comment>
                <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>rLength</name> <init>= <expr><call><name>ZSTD_count</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>ip</name><operator>+</operator><literal type="number">4</literal><operator>-</operator><name>offset_2</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>tmpOff</name> <init>= <expr><name>offset_2</name></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name>offset_2</name> <operator>=</operator> <name>offset_1</name></expr>;</expr_stmt> <expr_stmt><expr><name>offset_1</name> <operator>=</operator> <name>tmpOff</name></expr>;</expr_stmt>  <comment type="block">/* swap offset_2 &lt;=&gt; offset_1 */</comment>
                <expr_stmt><expr><name><name>hashSmall</name><index>[<expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>hBitsS</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>base</name><operator>)</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>hashLong</name><index>[<expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>hBitsL</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>base</name><operator>)</operator></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ZSTD_storeSeq</name><argument_list>(<argument><expr><name>seqStore</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>REPCODE1_TO_OFFBASE</name></expr></argument>, <argument><expr><name>rLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>rLength</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>anchor</name> <operator>=</operator> <name>ip</name></expr>;</expr_stmt>
                <continue>continue;</continue>   <comment type="block">/* faster when present ... (?) */</comment>
            </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>


<function><type><name>FORCE_INLINE_TEMPLATE</name>
<name>size_t</name></type> <name>ZSTD_compressBlock_doubleFast_dictMatchState_generic</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
        <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>mls</name></decl></parameter> <comment type="block">/* template */</comment>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_compressionParameters</name> <specifier>const</specifier><modifier>*</modifier></type> <name>cParams</name> <init>= <expr><operator>&amp;</operator><name><name>ms</name><operator>-&gt;</operator><name>cParams</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>hashLong</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>hashTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>hBitsL</name> <init>= <expr><name><name>cParams</name><operator>-&gt;</operator><name>hashLog</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>hashSmall</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>chainTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>hBitsS</name> <init>= <expr><name><name>cParams</name><operator>-&gt;</operator><name>chainLog</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>base</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>istart</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><name>istart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>anchor</name> <init>= <expr><name>istart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>endIndex</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>istart</name> <operator>-</operator> <name>base</name><operator>)</operator> <operator>+</operator> <name>srcSize</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <comment type="block">/* presumes that, if there is a dictionary, it must be using Attach mode */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>prefixLowestIndex</name> <init>= <expr><call><name>ZSTD_getLowestPrefixIndex</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>endIndex</name></expr></argument>, <argument><expr><name><name>cParams</name><operator>-&gt;</operator><name>windowLog</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>prefixLowest</name> <init>= <expr><name>base</name> <operator>+</operator> <name>prefixLowestIndex</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name> <init>= <expr><name>istart</name> <operator>+</operator> <name>srcSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ilimit</name> <init>= <expr><name>iend</name> <operator>-</operator> <name>HASH_READ_SIZE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>offset_1</name><init>=<expr><name><name>rep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>, <decl><type ref="prev"/><name>offset_2</name><init>=<expr><name><name>rep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_matchState_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dms</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>dictMatchState</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_compressionParameters</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictCParams</name> <init>= <expr><operator>&amp;</operator><name><name>dms</name><operator>-&gt;</operator><name>cParams</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictHashLong</name>  <init>= <expr><name><name>dms</name><operator>-&gt;</operator><name>hashTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictHashSmall</name> <init>= <expr><name><name>dms</name><operator>-&gt;</operator><name>chainTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dictStartIndex</name>       <init>= <expr><name><name>dms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictLimit</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictBase</name>     <init>= <expr><name><name>dms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictStart</name>    <init>= <expr><name>dictBase</name> <operator>+</operator> <name>dictStartIndex</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictEnd</name>      <init>= <expr><name><name>dms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>nextSrc</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dictIndexDelta</name>       <init>= <expr><name>prefixLowestIndex</name> <operator>-</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>dictEnd</name> <operator>-</operator> <name>dictBase</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dictHBitsL</name>           <init>= <expr><name><name>dictCParams</name><operator>-&gt;</operator><name>hashLog</name></name> <operator>+</operator> <name>ZSTD_SHORT_CACHE_TAG_BITS</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dictHBitsS</name>           <init>= <expr><name><name>dictCParams</name><operator>-&gt;</operator><name>chainLog</name></name> <operator>+</operator> <name>ZSTD_SHORT_CACHE_TAG_BITS</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dictAndPrefixLength</name>  <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>prefixLowest</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>dictEnd</name> <operator>-</operator> <name>dictStart</name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressBlock_doubleFast_dictMatchState_generic"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if a dictionary is attached, it must be within window range */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictLimit</name></name> <operator>+</operator> <operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name><name>cParams</name><operator>-&gt;</operator><name>windowLog</name></name><operator>)</operator> <operator>&gt;=</operator> <name>endIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>ms</name><operator>-&gt;</operator><name>prefetchCDictTables</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>hashTableBytes</name> <init>= <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name><name>dictCParams</name><operator>-&gt;</operator><name>hashLog</name></name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>U32</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>chainTableBytes</name> <init>= <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name><name>dictCParams</name><operator>-&gt;</operator><name>chainLog</name></name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>U32</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
        <macro><name>PREFETCH_AREA</name><argument_list>(<argument>dictHashLong</argument>, <argument>hashTableBytes</argument>)</argument_list></macro>
        <macro><name>PREFETCH_AREA</name><argument_list>(<argument>dictHashSmall</argument>, <argument>chainTableBytes</argument>)</argument_list></macro>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* init */</comment>
    <expr_stmt><expr><name>ip</name> <operator>+=</operator> <operator>(</operator><name>dictAndPrefixLength</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* dictMatchState repCode checks don't currently handle repCode == 0
     * disabling. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>offset_1</name> <operator>&lt;=</operator> <name>dictAndPrefixLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>offset_2</name> <operator>&lt;=</operator> <name>dictAndPrefixLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Main Search Loop */</comment>
    <while>while <condition>(<expr><name>ip</name> <operator>&lt;</operator> <name>ilimit</name></expr>)</condition> <block>{<block_content>   <comment type="block">/* &lt; instead of &lt;=, because repcode check at (ip+1) */</comment>
        <decl_stmt><decl><type><name>size_t</name></type> <name>mLength</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name></type> <name>offset</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>h2</name> <init>= <expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>hBitsL</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>h</name> <init>= <expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>hBitsS</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>dictHashAndTagL</name> <init>= <expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>dictHBitsL</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>dictHashAndTagS</name> <init>= <expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>dictHBitsS</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>dictMatchIndexAndTagL</name> <init>= <expr><name><name>dictHashLong</name><index>[<expr><name>dictHashAndTagL</name> <operator>&gt;&gt;</operator> <name>ZSTD_SHORT_CACHE_TAG_BITS</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>dictMatchIndexAndTagS</name> <init>= <expr><name><name>dictHashSmall</name><index>[<expr><name>dictHashAndTagS</name> <operator>&gt;&gt;</operator> <name>ZSTD_SHORT_CACHE_TAG_BITS</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>dictTagsMatchL</name> <init>= <expr><call><name>ZSTD_comparePackedTags</name><argument_list>(<argument><expr><name>dictMatchIndexAndTagL</name></expr></argument>, <argument><expr><name>dictHashAndTagL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>dictTagsMatchS</name> <init>= <expr><call><name>ZSTD_comparePackedTags</name><argument_list>(<argument><expr><name>dictMatchIndexAndTagS</name></expr></argument>, <argument><expr><name>dictHashAndTagS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>curr</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>matchIndexL</name> <init>= <expr><name><name>hashLong</name><index>[<expr><name>h2</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name></type> <name>matchIndexS</name> <init>= <expr><name><name>hashSmall</name><index>[<expr><name>h</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>matchLong</name> <init>= <expr><name>base</name> <operator>+</operator> <name>matchIndexL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>match</name> <init>= <expr><name>base</name> <operator>+</operator> <name>matchIndexS</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>repIndex</name> <init>= <expr><name>curr</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>offset_1</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>repMatch</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>repIndex</name> <operator>&lt;</operator> <name>prefixLowestIndex</name><operator>)</operator></expr> ?</condition><then>
                               <expr><name>dictBase</name> <operator>+</operator> <operator>(</operator><name>repIndex</name> <operator>-</operator> <name>dictIndexDelta</name><operator>)</operator></expr> </then><else>:
                               <expr><name>base</name> <operator>+</operator> <name>repIndex</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>hashLong</name><index>[<expr><name>h2</name></expr>]</index></name> <operator>=</operator> <name><name>hashSmall</name><index>[<expr><name>h</name></expr>]</index></name> <operator>=</operator> <name>curr</name></expr>;</expr_stmt>   <comment type="block">/* update hash tables */</comment>

        <comment type="block">/* check repcode */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>prefixLowestIndex</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name>repIndex</name><operator>)</operator> <operator>&gt;=</operator> <literal type="number">3</literal> <comment type="block">/* intentional underflow */</comment><operator>)</operator>
            <operator>&amp;&amp;</operator> <operator>(</operator><call><name>MEM_read32</name><argument_list>(<argument><expr><name>repMatch</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition> <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>repMatchEnd</name> <init>= <expr><ternary><condition><expr><name>repIndex</name> <operator>&lt;</operator> <name>prefixLowestIndex</name></expr> ?</condition><then> <expr><name>dictEnd</name></expr> </then><else>: <expr><name>iend</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>mLength</name> <operator>=</operator> <call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>repMatch</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>repMatchEnd</name></expr></argument>, <argument><expr><name>prefixLowest</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>ip</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ZSTD_storeSeq</name><argument_list>(<argument><expr><name>seqStore</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>anchor</name><operator>)</operator></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>REPCODE1_TO_OFFBASE</name></expr></argument>, <argument><expr><name>mLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>_match_stored</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>matchIndexL</name> <operator>&gt;</operator> <name>prefixLowestIndex</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* check prefix long match */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>MEM_read64</name><argument_list>(<argument><expr><name>matchLong</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read64</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>mLength</name> <operator>=</operator> <call><name>ZSTD_count</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">8</literal></expr></argument>, <argument><expr><name>matchLong</name><operator>+</operator><literal type="number">8</literal></expr></argument>, <argument><expr><name>iend</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">8</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>matchLong</name><operator>)</operator></expr>;</expr_stmt>
                <while>while <condition>(<expr><operator>(</operator><operator>(</operator><name>ip</name><operator>&gt;</operator><name>anchor</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>matchLong</name><operator>&gt;</operator><name>prefixLowest</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ip</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>matchLong</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>ip</name><operator>--</operator></expr>;</expr_stmt> <expr_stmt><expr><name>matchLong</name><operator>--</operator></expr>;</expr_stmt> <expr_stmt><expr><name>mLength</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while> <comment type="block">/* catch up */</comment>
                <goto>goto <name>_match_found</name>;</goto>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>dictTagsMatchL</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* check dictMatchState long match */</comment>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>dictMatchIndexL</name> <init>= <expr><name>dictMatchIndexAndTagL</name> <operator>&gt;&gt;</operator> <name>ZSTD_SHORT_CACHE_TAG_BITS</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>dictMatchL</name> <init>= <expr><name>dictBase</name> <operator>+</operator> <name>dictMatchIndexL</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dictMatchL</name> <operator>&lt;</operator> <name>dictEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>dictMatchL</name> <operator>&gt;</operator> <name>dictStart</name> <operator>&amp;&amp;</operator> <call><name>MEM_read64</name><argument_list>(<argument><expr><name>dictMatchL</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read64</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>mLength</name> <operator>=</operator> <call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">8</literal></expr></argument>, <argument><expr><name>dictMatchL</name><operator>+</operator><literal type="number">8</literal></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>dictEnd</name></expr></argument>, <argument><expr><name>prefixLowest</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">8</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>curr</name> <operator>-</operator> <name>dictMatchIndexL</name> <operator>-</operator> <name>dictIndexDelta</name><operator>)</operator></expr>;</expr_stmt>
                <while>while <condition>(<expr><operator>(</operator><operator>(</operator><name>ip</name><operator>&gt;</operator><name>anchor</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>dictMatchL</name><operator>&gt;</operator><name>dictStart</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ip</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>dictMatchL</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>ip</name><operator>--</operator></expr>;</expr_stmt> <expr_stmt><expr><name>dictMatchL</name><operator>--</operator></expr>;</expr_stmt> <expr_stmt><expr><name>mLength</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while> <comment type="block">/* catch up */</comment>
                <goto>goto <name>_match_found</name>;</goto>
        </block_content>}</block></if></if_stmt>   </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>matchIndexS</name> <operator>&gt;</operator> <name>prefixLowestIndex</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* check prefix short match */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>MEM_read32</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <goto>goto <name>_search_next_long</name>;</goto>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>dictTagsMatchS</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* check dictMatchState short match */</comment>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>dictMatchIndexS</name> <init>= <expr><name>dictMatchIndexAndTagS</name> <operator>&gt;&gt;</operator> <name>ZSTD_SHORT_CACHE_TAG_BITS</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>match</name> <operator>=</operator> <name>dictBase</name> <operator>+</operator> <name>dictMatchIndexS</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>matchIndexS</name> <operator>=</operator> <name>dictMatchIndexS</name> <operator>+</operator> <name>dictIndexDelta</name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>match</name> <operator>&gt;</operator> <name>dictStart</name> <operator>&amp;&amp;</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <goto>goto <name>_search_next_long</name>;</goto>
        </block_content>}</block></if></if_stmt>   </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>ip</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>ip</name><operator>-</operator><name>anchor</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>kSearchStrength</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__aarch64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <expr_stmt><expr><call><name>PREFETCH_L1</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">256</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <continue>continue;</continue>

<label><name>_search_next_long</name>:</label>
        <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>hl3</name> <init>= <expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>hBitsL</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>dictHashAndTagL3</name> <init>= <expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>dictHBitsL</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>matchIndexL3</name> <init>= <expr><name><name>hashLong</name><index>[<expr><name>hl3</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>dictMatchIndexAndTagL3</name> <init>= <expr><name><name>dictHashLong</name><index>[<expr><name>dictHashAndTagL3</name> <operator>&gt;&gt;</operator> <name>ZSTD_SHORT_CACHE_TAG_BITS</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>dictTagsMatchL3</name> <init>= <expr><call><name>ZSTD_comparePackedTags</name><argument_list>(<argument><expr><name>dictMatchIndexAndTagL3</name></expr></argument>, <argument><expr><name>dictHashAndTagL3</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>matchL3</name> <init>= <expr><name>base</name> <operator>+</operator> <name>matchIndexL3</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>hashLong</name><index>[<expr><name>hl3</name></expr>]</index></name> <operator>=</operator> <name>curr</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

            <comment type="block">/* check prefix long +1 match */</comment>
            <if_stmt><if>if <condition>(<expr><name>matchIndexL3</name> <operator>&gt;</operator> <name>prefixLowestIndex</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>MEM_read64</name><argument_list>(<argument><expr><name>matchL3</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read64</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>mLength</name> <operator>=</operator> <call><name>ZSTD_count</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">9</literal></expr></argument>, <argument><expr><name>matchL3</name><operator>+</operator><literal type="number">8</literal></expr></argument>, <argument><expr><name>iend</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">8</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>ip</name><operator>++</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>matchL3</name><operator>)</operator></expr>;</expr_stmt>
                    <while>while <condition>(<expr><operator>(</operator><operator>(</operator><name>ip</name><operator>&gt;</operator><name>anchor</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>matchL3</name><operator>&gt;</operator><name>prefixLowest</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ip</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>matchL3</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>ip</name><operator>--</operator></expr>;</expr_stmt> <expr_stmt><expr><name>matchL3</name><operator>--</operator></expr>;</expr_stmt> <expr_stmt><expr><name>mLength</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while> <comment type="block">/* catch up */</comment>
                    <goto>goto <name>_match_found</name>;</goto>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>dictTagsMatchL3</name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* check dict long +1 match */</comment>
                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>dictMatchIndexL3</name> <init>= <expr><name>dictMatchIndexAndTagL3</name> <operator>&gt;&gt;</operator> <name>ZSTD_SHORT_CACHE_TAG_BITS</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>dictMatchL3</name> <init>= <expr><name>dictBase</name> <operator>+</operator> <name>dictMatchIndexL3</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dictMatchL3</name> <operator>&lt;</operator> <name>dictEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>dictMatchL3</name> <operator>&gt;</operator> <name>dictStart</name> <operator>&amp;&amp;</operator> <call><name>MEM_read64</name><argument_list>(<argument><expr><name>dictMatchL3</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read64</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>mLength</name> <operator>=</operator> <call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><literal type="number">8</literal></expr></argument>, <argument><expr><name>dictMatchL3</name><operator>+</operator><literal type="number">8</literal></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>dictEnd</name></expr></argument>, <argument><expr><name>prefixLowest</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">8</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>ip</name><operator>++</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>curr</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>dictMatchIndexL3</name> <operator>-</operator> <name>dictIndexDelta</name><operator>)</operator></expr>;</expr_stmt>
                    <while>while <condition>(<expr><operator>(</operator><operator>(</operator><name>ip</name><operator>&gt;</operator><name>anchor</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>dictMatchL3</name><operator>&gt;</operator><name>dictStart</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ip</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>dictMatchL3</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>ip</name><operator>--</operator></expr>;</expr_stmt> <expr_stmt><expr><name>dictMatchL3</name><operator>--</operator></expr>;</expr_stmt> <expr_stmt><expr><name>mLength</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while> <comment type="block">/* catch up */</comment>
                    <goto>goto <name>_match_found</name>;</goto>
        </block_content>}</block></if></if_stmt>   </block_content>}</block></if></if_stmt>   </block_content>}</block>

        <comment type="block">/* if no long +1 match, explore the short match we found */</comment>
        <if_stmt><if>if <condition>(<expr><name>matchIndexS</name> <operator>&lt;</operator> <name>prefixLowestIndex</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>mLength</name> <operator>=</operator> <call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>match</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>dictEnd</name></expr></argument>, <argument><expr><name>prefixLowest</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>curr</name> <operator>-</operator> <name>matchIndexS</name><operator>)</operator></expr>;</expr_stmt>
            <while>while <condition>(<expr><operator>(</operator><operator>(</operator><name>ip</name><operator>&gt;</operator><name>anchor</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>match</name><operator>&gt;</operator><name>dictStart</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ip</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>match</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>ip</name><operator>--</operator></expr>;</expr_stmt> <expr_stmt><expr><name>match</name><operator>--</operator></expr>;</expr_stmt> <expr_stmt><expr><name>mLength</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while> <comment type="block">/* catch up */</comment>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>mLength</name> <operator>=</operator> <call><name>ZSTD_count</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>match</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>iend</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>match</name><operator>)</operator></expr>;</expr_stmt>
            <while>while <condition>(<expr><operator>(</operator><operator>(</operator><name>ip</name><operator>&gt;</operator><name>anchor</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>match</name><operator>&gt;</operator><name>prefixLowest</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ip</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>match</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>ip</name><operator>--</operator></expr>;</expr_stmt> <expr_stmt><expr><name>match</name><operator>--</operator></expr>;</expr_stmt> <expr_stmt><expr><name>mLength</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while> <comment type="block">/* catch up */</comment>
        </block_content>}</block></else></if_stmt>

<label><name>_match_found</name>:</label>
        <expr_stmt><expr><name>offset_2</name> <operator>=</operator> <name>offset_1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>offset_1</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ZSTD_storeSeq</name><argument_list>(<argument><expr><name>seqStore</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>anchor</name><operator>)</operator></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><call><name>OFFSET_TO_OFFBASE</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>_match_stored</name>:</label>
        <comment type="block">/* match found */</comment>
        <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>mLength</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>anchor</name> <operator>=</operator> <name>ip</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>ip</name> <operator>&lt;=</operator> <name>ilimit</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Complementary insertion */</comment>
            <comment type="block">/* done after iLimit test, as candidates could be &gt; iend-8 */</comment>
            <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>indexToInsert</name> <init>= <expr><name>curr</name><operator>+</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>hashLong</name><index>[<expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>base</name><operator>+</operator><name>indexToInsert</name></expr></argument>, <argument><expr><name>hBitsL</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>indexToInsert</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>hashLong</name><index>[<expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>hBitsL</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><literal type="number">2</literal><operator>-</operator><name>base</name><operator>)</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>hashSmall</name><index>[<expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>base</name><operator>+</operator><name>indexToInsert</name></expr></argument>, <argument><expr><name>hBitsS</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>indexToInsert</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>hashSmall</name><index>[<expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>hBitsS</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>base</name><operator>)</operator></expr>;</expr_stmt>
            </block_content>}</block>

            <comment type="block">/* check immediate repcode */</comment>
            <while>while <condition>(<expr><name>ip</name> <operator>&lt;=</operator> <name>ilimit</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>current2</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>repIndex2</name> <init>= <expr><name>current2</name> <operator>-</operator> <name>offset_2</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>repMatch2</name> <init>= <expr><ternary><condition><expr><name>repIndex2</name> <operator>&lt;</operator> <name>prefixLowestIndex</name></expr> ?</condition><then>
                        <expr><name>dictBase</name> <operator>+</operator> <name>repIndex2</name> <operator>-</operator> <name>dictIndexDelta</name></expr> </then><else>:
                        <expr><name>base</name> <operator>+</operator> <name>repIndex2</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>( <expr><operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>prefixLowestIndex</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>-</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>repIndex2</name><operator>)</operator> <operator>&gt;=</operator> <literal type="number">3</literal> <comment type="block">/* intentional overflow */</comment><operator>)</operator>
                   <operator>&amp;&amp;</operator> <operator>(</operator><call><name>MEM_read32</name><argument_list>(<argument><expr><name>repMatch2</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition> <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>repEnd2</name> <init>= <expr><ternary><condition><expr><name>repIndex2</name> <operator>&lt;</operator> <name>prefixLowestIndex</name></expr> ?</condition><then> <expr><name>dictEnd</name></expr> </then><else>: <expr><name>iend</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>repLength2</name> <init>= <expr><call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>repMatch2</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>repEnd2</name></expr></argument>, <argument><expr><name>prefixLowest</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>U32</name></type> <name>tmpOffset</name> <init>= <expr><name>offset_2</name></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name>offset_2</name> <operator>=</operator> <name>offset_1</name></expr>;</expr_stmt> <expr_stmt><expr><name>offset_1</name> <operator>=</operator> <name>tmpOffset</name></expr>;</expr_stmt>   <comment type="block">/* swap offset_2 &lt;=&gt; offset_1 */</comment>
                    <expr_stmt><expr><call><name>ZSTD_storeSeq</name><argument_list>(<argument><expr><name>seqStore</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>REPCODE1_TO_OFFBASE</name></expr></argument>, <argument><expr><name>repLength2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>hashSmall</name><index>[<expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>hBitsS</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>current2</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>hashLong</name><index>[<expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>hBitsL</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>current2</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>repLength2</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>anchor</name> <operator>=</operator> <name>ip</name></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>   <comment type="block">/* while (ip &lt; ilimit) */</comment>

    <comment type="block">/* save reps for next block */</comment>
    <expr_stmt><expr><name><name>rep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>offset_1</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>offset_2</name></expr>;</expr_stmt>

    <comment type="block">/* Return the last literals size */</comment>
    <return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>iend</name> <operator>-</operator> <name>anchor</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZSTD_GEN_DFAST_FN</name><parameter_list>(<parameter><type><name>dictMode</name></type></parameter>, <parameter><type><name>mls</name></type></parameter>)</parameter_list></cpp:macro>                                                                 \
    <cpp:value>static size_t ZSTD_compressBlock_doubleFast_##dictMode##_##mls(                                      \
            ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],                          \
            void const* src, size_t srcSize)                                                             \
    {                                                                                                    \
        return ZSTD_compressBlock_doubleFast_##dictMode##_generic(ms, seqStore, rep, src, srcSize, mls); \
    }</cpp:value></cpp:define>

<macro><name>ZSTD_GEN_DFAST_FN</name><argument_list>(<argument>noDict</argument>, <argument><literal type="number">4</literal></argument>)</argument_list></macro>
<macro><name>ZSTD_GEN_DFAST_FN</name><argument_list>(<argument>noDict</argument>, <argument><literal type="number">5</literal></argument>)</argument_list></macro>
<macro><name>ZSTD_GEN_DFAST_FN</name><argument_list>(<argument>noDict</argument>, <argument><literal type="number">6</literal></argument>)</argument_list></macro>
<macro><name>ZSTD_GEN_DFAST_FN</name><argument_list>(<argument>noDict</argument>, <argument><literal type="number">7</literal></argument>)</argument_list></macro>

<macro><name>ZSTD_GEN_DFAST_FN</name><argument_list>(<argument>dictMatchState</argument>, <argument><literal type="number">4</literal></argument>)</argument_list></macro>
<macro><name>ZSTD_GEN_DFAST_FN</name><argument_list>(<argument>dictMatchState</argument>, <argument><literal type="number">5</literal></argument>)</argument_list></macro>
<macro><name>ZSTD_GEN_DFAST_FN</name><argument_list>(<argument>dictMatchState</argument>, <argument><literal type="number">6</literal></argument>)</argument_list></macro>
<macro><name>ZSTD_GEN_DFAST_FN</name><argument_list>(<argument>dictMatchState</argument>, <argument><literal type="number">7</literal></argument>)</argument_list></macro>


<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_doubleFast</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>mls</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>minMatch</name></name></expr></init></decl>;</decl_stmt>
    <switch>switch<condition>(<expr><name>mls</name></expr>)</condition>
    <block>{<block_content>
    <default>default:</default> <comment type="block">/* includes case 3 */</comment>
    <case>case <expr><literal type="number">4</literal></expr> :</case>
        <return>return <expr><call><name>ZSTD_compressBlock_doubleFast_noDict_4</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><literal type="number">5</literal></expr> :</case>
        <return>return <expr><call><name>ZSTD_compressBlock_doubleFast_noDict_5</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><literal type="number">6</literal></expr> :</case>
        <return>return <expr><call><name>ZSTD_compressBlock_doubleFast_noDict_6</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><literal type="number">7</literal></expr> :</case>
        <return>return <expr><call><name>ZSTD_compressBlock_doubleFast_noDict_7</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>


<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_doubleFast_dictMatchState</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>mls</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>minMatch</name></name></expr></init></decl>;</decl_stmt>
    <switch>switch<condition>(<expr><name>mls</name></expr>)</condition>
    <block>{<block_content>
    <default>default:</default> <comment type="block">/* includes case 3 */</comment>
    <case>case <expr><literal type="number">4</literal></expr> :</case>
        <return>return <expr><call><name>ZSTD_compressBlock_doubleFast_dictMatchState_4</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><literal type="number">5</literal></expr> :</case>
        <return>return <expr><call><name>ZSTD_compressBlock_doubleFast_dictMatchState_5</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><literal type="number">6</literal></expr> :</case>
        <return>return <expr><call><name>ZSTD_compressBlock_doubleFast_dictMatchState_6</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><literal type="number">7</literal></expr> :</case>
        <return>return <expr><call><name>ZSTD_compressBlock_doubleFast_dictMatchState_7</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_compressBlock_doubleFast_extDict_generic</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
        <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>mls</name></decl></parameter> <comment type="block">/* template */</comment>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_compressionParameters</name> <specifier>const</specifier><modifier>*</modifier></type> <name>cParams</name> <init>= <expr><operator>&amp;</operator><name><name>ms</name><operator>-&gt;</operator><name>cParams</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>hashLong</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>hashTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>  <specifier>const</specifier></type> <name>hBitsL</name> <init>= <expr><name><name>cParams</name><operator>-&gt;</operator><name>hashLog</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>hashSmall</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>chainTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>  <specifier>const</specifier></type> <name>hBitsS</name> <init>= <expr><name><name>cParams</name><operator>-&gt;</operator><name>chainLog</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>istart</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><name>istart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>anchor</name> <init>= <expr><name>istart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name> <init>= <expr><name>istart</name> <operator>+</operator> <name>srcSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ilimit</name> <init>= <expr><name>iend</name> <operator>-</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>base</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type>   <name>endIndex</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>istart</name> <operator>-</operator> <name>base</name><operator>)</operator> <operator>+</operator> <name>srcSize</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type>   <name>lowLimit</name> <init>= <expr><call><name>ZSTD_getLowestMatchIndex</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>endIndex</name></expr></argument>, <argument><expr><name><name>cParams</name><operator>-&gt;</operator><name>windowLog</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type>   <name>dictStartIndex</name> <init>= <expr><name>lowLimit</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type>   <name>dictLimit</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictLimit</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type>   <name>prefixStartIndex</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>dictLimit</name> <operator>&gt;</operator> <name>lowLimit</name><operator>)</operator></expr> ?</condition><then> <expr><name>dictLimit</name></expr> </then><else>: <expr><name>lowLimit</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>prefixStart</name> <init>= <expr><name>base</name> <operator>+</operator> <name>prefixStartIndex</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictBase</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictBase</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictStart</name> <init>= <expr><name>dictBase</name> <operator>+</operator> <name>dictStartIndex</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictEnd</name> <init>= <expr><name>dictBase</name> <operator>+</operator> <name>prefixStartIndex</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>offset_1</name><init>=<expr><name><name>rep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>, <decl><type ref="prev"/><name>offset_2</name><init>=<expr><name><name>rep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressBlock_doubleFast_extDict_generic (srcSize=%zu)"</literal></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if extDict is invalidated due to maxDistance, switch to "regular" variant */</comment>
    <if_stmt><if>if <condition>(<expr><name>prefixStartIndex</name> <operator>==</operator> <name>dictStartIndex</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>ZSTD_compressBlock_doubleFast</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Search Loop */</comment>
    <while>while <condition>(<expr><name>ip</name> <operator>&lt;</operator> <name>ilimit</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* &lt; instead of &lt;=, because (ip+1) */</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>hSmall</name> <init>= <expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>hBitsS</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>matchIndex</name> <init>= <expr><name><name>hashSmall</name><index>[<expr><name>hSmall</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>matchBase</name> <init>= <expr><ternary><condition><expr><name>matchIndex</name> <operator>&lt;</operator> <name>prefixStartIndex</name></expr> ?</condition><then> <expr><name>dictBase</name></expr> </then><else>: <expr><name>base</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>match</name> <init>= <expr><name>matchBase</name> <operator>+</operator> <name>matchIndex</name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>hLong</name> <init>= <expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>hBitsL</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>matchLongIndex</name> <init>= <expr><name><name>hashLong</name><index>[<expr><name>hLong</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>matchLongBase</name> <init>= <expr><ternary><condition><expr><name>matchLongIndex</name> <operator>&lt;</operator> <name>prefixStartIndex</name></expr> ?</condition><then> <expr><name>dictBase</name></expr> </then><else>: <expr><name>base</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>matchLong</name> <init>= <expr><name>matchLongBase</name> <operator>+</operator> <name>matchLongIndex</name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>curr</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>repIndex</name> <init>= <expr><name>curr</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>offset_1</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* offset_1 expected &lt;= curr +1 */</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>repBase</name> <init>= <expr><ternary><condition><expr><name>repIndex</name> <operator>&lt;</operator> <name>prefixStartIndex</name></expr> ?</condition><then> <expr><name>dictBase</name></expr> </then><else>: <expr><name>base</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>repMatch</name> <init>= <expr><name>repBase</name> <operator>+</operator> <name>repIndex</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>mLength</name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>hashSmall</name><index>[<expr><name>hSmall</name></expr>]</index></name> <operator>=</operator> <name><name>hashLong</name><index>[<expr><name>hLong</name></expr>]</index></name> <operator>=</operator> <name>curr</name></expr>;</expr_stmt>   <comment type="block">/* update hash table */</comment>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>prefixStartIndex</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name>repIndex</name><operator>)</operator> <operator>&gt;=</operator> <literal type="number">3</literal><operator>)</operator> <comment type="block">/* intentional underflow : ensure repIndex doesn't overlap dict + prefix */</comment>
            <operator>&amp;</operator> <operator>(</operator><name>offset_1</name> <operator>&lt;=</operator> <name>curr</name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name>dictStartIndex</name><operator>)</operator><operator>)</operator> <comment type="block">/* note: we are searching at curr+1 */</comment>
          <operator>&amp;&amp;</operator> <operator>(</operator><call><name>MEM_read32</name><argument_list>(<argument><expr><name>repMatch</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition> <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>repMatchEnd</name> <init>= <expr><ternary><condition><expr><name>repIndex</name> <operator>&lt;</operator> <name>prefixStartIndex</name></expr> ?</condition><then> <expr><name>dictEnd</name></expr> </then><else>: <expr><name>iend</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>mLength</name> <operator>=</operator> <call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>repMatch</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>repMatchEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>ip</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ZSTD_storeSeq</name><argument_list>(<argument><expr><name>seqStore</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>anchor</name><operator>)</operator></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>REPCODE1_TO_OFFBASE</name></expr></argument>, <argument><expr><name>mLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>matchLongIndex</name> <operator>&gt;</operator> <name>dictStartIndex</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>MEM_read64</name><argument_list>(<argument><expr><name>matchLong</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read64</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>matchEnd</name> <init>= <expr><ternary><condition><expr><name>matchLongIndex</name> <operator>&lt;</operator> <name>prefixStartIndex</name></expr> ?</condition><then> <expr><name>dictEnd</name></expr> </then><else>: <expr><name>iend</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>lowMatchPtr</name> <init>= <expr><ternary><condition><expr><name>matchLongIndex</name> <operator>&lt;</operator> <name>prefixStartIndex</name></expr> ?</condition><then> <expr><name>dictStart</name></expr> </then><else>: <expr><name>prefixStart</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>U32</name></type> <name>offset</name></decl>;</decl_stmt>
                <expr_stmt><expr><name>mLength</name> <operator>=</operator> <call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">8</literal></expr></argument>, <argument><expr><name>matchLong</name><operator>+</operator><literal type="number">8</literal></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>matchEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">8</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>curr</name> <operator>-</operator> <name>matchLongIndex</name></expr>;</expr_stmt>
                <while>while <condition>(<expr><operator>(</operator><operator>(</operator><name>ip</name><operator>&gt;</operator><name>anchor</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>matchLong</name><operator>&gt;</operator><name>lowMatchPtr</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ip</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>matchLong</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>ip</name><operator>--</operator></expr>;</expr_stmt> <expr_stmt><expr><name>matchLong</name><operator>--</operator></expr>;</expr_stmt> <expr_stmt><expr><name>mLength</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>   <comment type="block">/* catch up */</comment>
                <expr_stmt><expr><name>offset_2</name> <operator>=</operator> <name>offset_1</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>offset_1</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ZSTD_storeSeq</name><argument_list>(<argument><expr><name>seqStore</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>anchor</name><operator>)</operator></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><call><name>OFFSET_TO_OFFBASE</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>matchIndex</name> <operator>&gt;</operator> <name>dictStartIndex</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>MEM_read32</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>h3</name> <init>= <expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>hBitsL</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>matchIndex3</name> <init>= <expr><name><name>hashLong</name><index>[<expr><name>h3</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>match3Base</name> <init>= <expr><ternary><condition><expr><name>matchIndex3</name> <operator>&lt;</operator> <name>prefixStartIndex</name></expr> ?</condition><then> <expr><name>dictBase</name></expr> </then><else>: <expr><name>base</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>match3</name> <init>= <expr><name>match3Base</name> <operator>+</operator> <name>matchIndex3</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>U32</name></type> <name>offset</name></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>hashLong</name><index>[<expr><name>h3</name></expr>]</index></name> <operator>=</operator> <name>curr</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <if_stmt><if>if <condition>( <expr><operator>(</operator><name>matchIndex3</name> <operator>&gt;</operator> <name>dictStartIndex</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>MEM_read64</name><argument_list>(<argument><expr><name>match3</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read64</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition> <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>matchEnd</name> <init>= <expr><ternary><condition><expr><name>matchIndex3</name> <operator>&lt;</operator> <name>prefixStartIndex</name></expr> ?</condition><then> <expr><name>dictEnd</name></expr> </then><else>: <expr><name>iend</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>lowMatchPtr</name> <init>= <expr><ternary><condition><expr><name>matchIndex3</name> <operator>&lt;</operator> <name>prefixStartIndex</name></expr> ?</condition><then> <expr><name>dictStart</name></expr> </then><else>: <expr><name>prefixStart</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>mLength</name> <operator>=</operator> <call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">9</literal></expr></argument>, <argument><expr><name>match3</name><operator>+</operator><literal type="number">8</literal></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>matchEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">8</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>ip</name><operator>++</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>curr</name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name>matchIndex3</name></expr>;</expr_stmt>
                    <while>while <condition>(<expr><operator>(</operator><operator>(</operator><name>ip</name><operator>&gt;</operator><name>anchor</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>match3</name><operator>&gt;</operator><name>lowMatchPtr</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ip</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>match3</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>ip</name><operator>--</operator></expr>;</expr_stmt> <expr_stmt><expr><name>match3</name><operator>--</operator></expr>;</expr_stmt> <expr_stmt><expr><name>mLength</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while> <comment type="block">/* catch up */</comment>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>matchEnd</name> <init>= <expr><ternary><condition><expr><name>matchIndex</name> <operator>&lt;</operator> <name>prefixStartIndex</name></expr> ?</condition><then> <expr><name>dictEnd</name></expr> </then><else>: <expr><name>iend</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>lowMatchPtr</name> <init>= <expr><ternary><condition><expr><name>matchIndex</name> <operator>&lt;</operator> <name>prefixStartIndex</name></expr> ?</condition><then> <expr><name>dictStart</name></expr> </then><else>: <expr><name>prefixStart</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>mLength</name> <operator>=</operator> <call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>match</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>matchEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>curr</name> <operator>-</operator> <name>matchIndex</name></expr>;</expr_stmt>
                    <while>while <condition>(<expr><operator>(</operator><operator>(</operator><name>ip</name><operator>&gt;</operator><name>anchor</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>match</name><operator>&gt;</operator><name>lowMatchPtr</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ip</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>match</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>ip</name><operator>--</operator></expr>;</expr_stmt> <expr_stmt><expr><name>match</name><operator>--</operator></expr>;</expr_stmt> <expr_stmt><expr><name>mLength</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>   <comment type="block">/* catch up */</comment>
                </block_content>}</block></else></if_stmt>
                <expr_stmt><expr><name>offset_2</name> <operator>=</operator> <name>offset_1</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>offset_1</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ZSTD_storeSeq</name><argument_list>(<argument><expr><name>seqStore</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>anchor</name><operator>)</operator></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><call><name>OFFSET_TO_OFFBASE</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>ip</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>ip</name><operator>-</operator><name>anchor</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>kSearchStrength</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <continue>continue;</continue>
        </block_content>}</block></else></if_stmt>   </block_content>}</block></else></if_stmt>

        <comment type="block">/* move to next sequence start */</comment>
        <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>mLength</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>anchor</name> <operator>=</operator> <name>ip</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>ip</name> <operator>&lt;=</operator> <name>ilimit</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Complementary insertion */</comment>
            <comment type="block">/* done after iLimit test, as candidates could be &gt; iend-8 */</comment>
            <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>indexToInsert</name> <init>= <expr><name>curr</name><operator>+</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>hashLong</name><index>[<expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>base</name><operator>+</operator><name>indexToInsert</name></expr></argument>, <argument><expr><name>hBitsL</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>indexToInsert</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>hashLong</name><index>[<expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>hBitsL</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><literal type="number">2</literal><operator>-</operator><name>base</name><operator>)</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>hashSmall</name><index>[<expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>base</name><operator>+</operator><name>indexToInsert</name></expr></argument>, <argument><expr><name>hBitsS</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>indexToInsert</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>hashSmall</name><index>[<expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>hBitsS</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>base</name><operator>)</operator></expr>;</expr_stmt>
            </block_content>}</block>

            <comment type="block">/* check immediate repcode */</comment>
            <while>while <condition>(<expr><name>ip</name> <operator>&lt;=</operator> <name>ilimit</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>current2</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>repIndex2</name> <init>= <expr><name>current2</name> <operator>-</operator> <name>offset_2</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>repMatch2</name> <init>= <expr><ternary><condition><expr><name>repIndex2</name> <operator>&lt;</operator> <name>prefixStartIndex</name></expr> ?</condition><then> <expr><name>dictBase</name> <operator>+</operator> <name>repIndex2</name></expr> </then><else>: <expr><name>base</name> <operator>+</operator> <name>repIndex2</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>( <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>prefixStartIndex</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name>repIndex2</name><operator>)</operator> <operator>&gt;=</operator> <literal type="number">3</literal><operator>)</operator>   <comment type="block">/* intentional overflow : ensure repIndex2 doesn't overlap dict + prefix */</comment>
                    <operator>&amp;</operator> <operator>(</operator><name>offset_2</name> <operator>&lt;=</operator> <name>current2</name> <operator>-</operator> <name>dictStartIndex</name><operator>)</operator><operator>)</operator>
                  <operator>&amp;&amp;</operator> <operator>(</operator><call><name>MEM_read32</name><argument_list>(<argument><expr><name>repMatch2</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MEM_read32</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition> <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>repEnd2</name> <init>= <expr><ternary><condition><expr><name>repIndex2</name> <operator>&lt;</operator> <name>prefixStartIndex</name></expr> ?</condition><then> <expr><name>dictEnd</name></expr> </then><else>: <expr><name>iend</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>repLength2</name> <init>= <expr><call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>repMatch2</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>repEnd2</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>tmpOffset</name> <init>= <expr><name>offset_2</name></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name>offset_2</name> <operator>=</operator> <name>offset_1</name></expr>;</expr_stmt> <expr_stmt><expr><name>offset_1</name> <operator>=</operator> <name>tmpOffset</name></expr>;</expr_stmt>   <comment type="block">/* swap offset_2 &lt;=&gt; offset_1 */</comment>
                    <expr_stmt><expr><call><name>ZSTD_storeSeq</name><argument_list>(<argument><expr><name>seqStore</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>REPCODE1_TO_OFFBASE</name></expr></argument>, <argument><expr><name>repLength2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>hashSmall</name><index>[<expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>hBitsS</name></expr></argument>, <argument><expr><name>mls</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>current2</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>hashLong</name><index>[<expr><call><name>ZSTD_hashPtr</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>hBitsL</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>current2</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>repLength2</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>anchor</name> <operator>=</operator> <name>ip</name></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
    </block_content>}</block></while>   </block_content>}</block></if></if_stmt>   </block_content>}</block></while>

    <comment type="block">/* save reps for next block */</comment>
    <expr_stmt><expr><name><name>rep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>offset_1</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>offset_2</name></expr>;</expr_stmt>

    <comment type="block">/* Return the last literals size */</comment>
    <return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>iend</name> <operator>-</operator> <name>anchor</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<macro><name>ZSTD_GEN_DFAST_FN</name><argument_list>(<argument>extDict</argument>, <argument><literal type="number">4</literal></argument>)</argument_list></macro>
<macro><name>ZSTD_GEN_DFAST_FN</name><argument_list>(<argument>extDict</argument>, <argument><literal type="number">5</literal></argument>)</argument_list></macro>
<macro><name>ZSTD_GEN_DFAST_FN</name><argument_list>(<argument>extDict</argument>, <argument><literal type="number">6</literal></argument>)</argument_list></macro>
<macro><name>ZSTD_GEN_DFAST_FN</name><argument_list>(<argument>extDict</argument>, <argument><literal type="number">7</literal></argument>)</argument_list></macro>

<function><type><name>size_t</name></type> <name>ZSTD_compressBlock_doubleFast_extDict</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
        <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>mls</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>minMatch</name></name></expr></init></decl>;</decl_stmt>
    <switch>switch<condition>(<expr><name>mls</name></expr>)</condition>
    <block>{<block_content>
    <default>default:</default> <comment type="block">/* includes case 3 */</comment>
    <case>case <expr><literal type="number">4</literal></expr> :</case>
        <return>return <expr><call><name>ZSTD_compressBlock_doubleFast_extDict_4</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><literal type="number">5</literal></expr> :</case>
        <return>return <expr><call><name>ZSTD_compressBlock_doubleFast_extDict_5</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><literal type="number">6</literal></expr> :</case>
        <return>return <expr><call><name>ZSTD_compressBlock_doubleFast_extDict_6</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><literal type="number">7</literal></expr> :</case>
        <return>return <expr><call><name>ZSTD_compressBlock_doubleFast_extDict_7</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>
</unit>
