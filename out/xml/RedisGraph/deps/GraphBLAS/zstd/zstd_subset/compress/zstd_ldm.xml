<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/zstd/zstd_subset/compress/zstd_ldm.c"><comment type="block">/*
 * Copyright (c) Yann Collet, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_ldm.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/xxhash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_fast.h"</cpp:file></cpp:include>          <comment type="block">/* ZSTD_fillHashTable() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_double_fast.h"</cpp:file></cpp:include>   <comment type="block">/* ZSTD_fillDoubleHashTable() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_ldm_geartab.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LDM_BUCKET_SIZE_LOG</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LDM_MIN_MATCH_LENGTH</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LDM_HASH_RLOG</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>U64</name></type> <name>rolling</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U64</name></type> <name>stopMask</name></decl>;</decl_stmt>
}</block></struct></type> <name>ldmRollingHashState_t</name>;</typedef>

<comment type="block" format="doxygen">/** ZSTD_ldm_gear_init():
 *
 * Initializes the rolling hash state such that it will honor the
 * settings in params. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_ldm_gear_init</name><parameter_list>(<parameter><decl><type><name>ldmRollingHashState_t</name><modifier>*</modifier></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>ldmParams_t</name> <specifier>const</specifier><modifier>*</modifier></type> <name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>maxBitsInMask</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>minMatchLength</name></name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>hashRateLog</name> <init>= <expr><name><name>params</name><operator>-&gt;</operator><name>hashRateLog</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>rolling</name></name> <operator>=</operator> <operator>~</operator><operator>(</operator><name>U32</name><operator>)</operator><literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* The choice of the splitting criterion is subject to two conditions:
     *   1. it has to trigger on average every 2^(hashRateLog) bytes;
     *   2. ideally, it has to depend on a window of minMatchLength bytes.
     *
     * In the gear hash algorithm, bit n depends on the last n bytes;
     * so in order to obtain a good quality splitting criterion it is
     * preferable to use bits with high weight.
     *
     * To match condition 1 we use a mask with hashRateLog bits set
     * and, because of the previous remark, we make sure these bits
     * have the highest possible weight while still respecting
     * condition 2.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>hashRateLog</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>hashRateLog</name> <operator>&lt;=</operator> <name>maxBitsInMask</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stopMask</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>U64</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>hashRateLog</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><name>maxBitsInMask</name> <operator>-</operator> <name>hashRateLog</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* In this degenerate case we simply honor the hash rate. */</comment>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stopMask</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>U64</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>hashRateLog</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** ZSTD_ldm_gear_reset()
 * Feeds [data, data + minMatchLength) into the hash without registering any
 * splits. This effectively resets the hash state. This is used when skipping
 * over data, either at the beginning of a block, or skipping sections.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_ldm_gear_reset</name><parameter_list>(<parameter><decl><type><name>ldmRollingHashState_t</name><modifier>*</modifier></type> <name>state</name></decl></parameter>,
                                <parameter><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>minMatchLength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U64</name></type> <name>hash</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>rolling</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GEAR_ITER_ONCE</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>do {                                  \
        hash = (hash &lt;&lt; 1) + ZSTD_ldm_gearTab[data[n] &amp; 0xff]; \
        n += 1;                                                \
    } while (0)</cpp:value></cpp:define>
    <while>while <condition>(<expr><name>n</name> <operator>+</operator> <literal type="number">3</literal> <operator>&lt;</operator> <name>minMatchLength</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>GEAR_ITER_ONCE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>GEAR_ITER_ONCE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>GEAR_ITER_ONCE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>GEAR_ITER_ONCE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <while>while <condition>(<expr><name>n</name> <operator>&lt;</operator> <name>minMatchLength</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>GEAR_ITER_ONCE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GEAR_ITER_ONCE</name></cpp:undef>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** ZSTD_ldm_gear_feed():
 *
 * Registers in the splits array all the split points found in the first
 * size bytes following the data pointer. This function terminates when
 * either all the data has been processed or LDM_BATCH_SIZE splits are
 * present in the splits array.
 *
 * Precondition: The splits array must not be full.
 * Returns: The number of bytes processed. */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_ldm_gear_feed</name><parameter_list>(<parameter><decl><type><name>ldmRollingHashState_t</name><modifier>*</modifier></type> <name>state</name></decl></parameter>,
                                 <parameter><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,
                                 <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>splits</name></decl></parameter>, <parameter><decl><type><name>unsigned</name><modifier>*</modifier></type> <name>numSplits</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U64</name></type> <name>hash</name></decl>, <decl><type ref="prev"/><name>mask</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>hash</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>rolling</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mask</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>stopMask</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GEAR_ITER_ONCE</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>do { \
        hash = (hash &lt;&lt; 1) + ZSTD_ldm_gearTab[data[n] &amp; 0xff]; \
        n += 1; \
        if (UNLIKELY((hash &amp; mask) == 0)) { \
            splits[*numSplits] = n; \
            *numSplits += 1; \
            if (*numSplits == LDM_BATCH_SIZE) \
                goto done; \
        } \
    } while (0)</cpp:value></cpp:define>

    <while>while <condition>(<expr><name>n</name> <operator>+</operator> <literal type="number">3</literal> <operator>&lt;</operator> <name>size</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>GEAR_ITER_ONCE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>GEAR_ITER_ONCE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>GEAR_ITER_ONCE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>GEAR_ITER_ONCE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <while>while <condition>(<expr><name>n</name> <operator>&lt;</operator> <name>size</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>GEAR_ITER_ONCE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GEAR_ITER_ONCE</name></cpp:undef>

<label><name>done</name>:</label>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>rolling</name></name> <operator>=</operator> <name>hash</name></expr>;</expr_stmt>
    <return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>ZSTD_ldm_adjustParameters</name><parameter_list>(<parameter><decl><type><name>ldmParams_t</name><modifier>*</modifier></type> <name>params</name></decl></parameter>,
                               <parameter><decl><type><name>ZSTD_compressionParameters</name> <specifier>const</specifier><modifier>*</modifier></type> <name>cParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>windowLog</name></name> <operator>=</operator> <name><name>cParams</name><operator>-&gt;</operator><name>windowLog</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_STATIC_ASSERT</name><argument_list>(<argument><expr><name>LDM_BUCKET_SIZE_LOG</name> <operator>&lt;=</operator> <name>ZSTD_LDM_BUCKETSIZELOG_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_ldm_adjustParameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>params</name><operator>-&gt;</operator><name>bucketSizeLog</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>bucketSizeLog</name></name> <operator>=</operator> <name>LDM_BUCKET_SIZE_LOG</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>params</name><operator>-&gt;</operator><name>minMatchLength</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>minMatchLength</name></name> <operator>=</operator> <name>LDM_MIN_MATCH_LENGTH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>hashLog</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>hashLog</name></name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name>ZSTD_HASHLOG_MIN</name></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>windowLog</name></name> <operator>-</operator> <name>LDM_HASH_RLOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>hashLog</name></name> <operator>&lt;=</operator> <name>ZSTD_HASHLOG_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>hashRateLog</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>hashRateLog</name></name> <operator>=</operator> <ternary><condition><expr><name><name>params</name><operator>-&gt;</operator><name>windowLog</name></name> <operator>&lt;</operator> <name><name>params</name><operator>-&gt;</operator><name>hashLog</name></name></expr>
                                   ?</condition><then> <expr><literal type="number">0</literal></expr>
                                   </then><else>: <expr><name><name>params</name><operator>-&gt;</operator><name>windowLog</name></name> <operator>-</operator> <name><name>params</name><operator>-&gt;</operator><name>hashLog</name></name></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>bucketSizeLog</name></name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>bucketSizeLog</name></name></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>hashLog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_ldm_getTableSize</name><parameter_list>(<parameter><decl><type><name>ldmParams_t</name></type> <name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>ldmHSize</name> <init>= <expr><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name><name>params</name><operator>.</operator><name>hashLog</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>ldmBucketSizeLog</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name><name>params</name><operator>.</operator><name>bucketSizeLog</name></name></expr></argument>, <argument><expr><name><name>params</name><operator>.</operator><name>hashLog</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>ldmBucketSize</name> <init>= <expr><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><name><name>params</name><operator>.</operator><name>hashLog</name></name> <operator>-</operator> <name>ldmBucketSizeLog</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>totalSize</name> <init>= <expr><call><name>ZSTD_cwksp_alloc_size</name><argument_list>(<argument><expr><name>ldmBucketSize</name></expr></argument>)</argument_list></call>
                           <operator>+</operator> <call><name>ZSTD_cwksp_alloc_size</name><argument_list>(<argument><expr><name>ldmHSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ldmEntry_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><ternary><condition><expr><name><name>params</name><operator>.</operator><name>enableLdm</name></name> <operator>==</operator> <name>ZSTD_ps_enable</name></expr> ?</condition><then> <expr><name>totalSize</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_ldm_getMaxNbSeq</name><parameter_list>(<parameter><decl><type><name>ldmParams_t</name></type> <name>params</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>maxChunkSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><ternary><condition><expr><name><name>params</name><operator>.</operator><name>enableLdm</name></name> <operator>==</operator> <name>ZSTD_ps_enable</name></expr> ?</condition><then> <expr><operator>(</operator><name>maxChunkSize</name> <operator>/</operator> <name><name>params</name><operator>.</operator><name>minMatchLength</name></name><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** ZSTD_ldm_getBucket() :
 *  Returns a pointer to the start of the bucket associated with hash. */</comment>
<function><type><specifier>static</specifier> <name>ldmEntry_t</name><modifier>*</modifier></type> <name>ZSTD_ldm_getBucket</name><parameter_list>(
        <parameter><decl><type><name>ldmState_t</name><modifier>*</modifier></type> <name>ldmState</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>ldmParams_t</name> <specifier>const</specifier></type> <name>ldmParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name><name>ldmState</name><operator>-&gt;</operator><name>hashTable</name></name> <operator>+</operator> <operator>(</operator><name>hash</name> <operator>&lt;&lt;</operator> <name><name>ldmParams</name><operator>.</operator><name>bucketSizeLog</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** ZSTD_ldm_insertEntry() :
 *  Insert the entry with corresponding hash into the hash table */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_ldm_insertEntry</name><parameter_list>(<parameter><decl><type><name>ldmState_t</name><modifier>*</modifier></type> <name>ldmState</name></decl></parameter>,
                                 <parameter><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>hash</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ldmEntry_t</name></type> <name>entry</name></decl></parameter>,
                                 <parameter><decl><type><name>ldmParams_t</name> <specifier>const</specifier></type> <name>ldmParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>pOffset</name> <init>= <expr><name><name>ldmState</name><operator>-&gt;</operator><name>bucketOffsets</name></name> <operator>+</operator> <name>hash</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>offset</name> <init>= <expr><operator>*</operator><name>pOffset</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><operator>*</operator><operator>(</operator><call><name>ZSTD_ldm_getBucket</name><argument_list>(<argument><expr><name>ldmState</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>ldmParams</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>offset</name><operator>)</operator> <operator>=</operator> <name>entry</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pOffset</name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><operator>(</operator><operator>(</operator><name>offset</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name><name>ldmParams</name><operator>.</operator><name>bucketSizeLog</name></name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></function>

<comment type="block" format="doxygen">/** ZSTD_ldm_countBackwardsMatch() :
 *  Returns the number of bytes that match backwards before pIn and pMatch.
 *
 *  We count only bytes where pMatch &gt;= pBase and pIn &gt;= pAnchor. */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_ldm_countBackwardsMatch</name><parameter_list>(
            <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>pIn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>pAnchor</name></decl></parameter>,
            <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>pMatch</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>pMatchBase</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>matchLength</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>pIn</name> <operator>&gt;</operator> <name>pAnchor</name> <operator>&amp;&amp;</operator> <name>pMatch</name> <operator>&gt;</operator> <name>pMatchBase</name> <operator>&amp;&amp;</operator> <name><name>pIn</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>pMatch</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>pIn</name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>pMatch</name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>matchLength</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>matchLength</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** ZSTD_ldm_countBackwardsMatch_2segments() :
 *  Returns the number of bytes that match backwards from pMatch,
 *  even with the backwards match spanning 2 different segments.
 *
 *  On reaching `pMatchBase`, start counting from mEnd */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_ldm_countBackwardsMatch_2segments</name><parameter_list>(
                    <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>pIn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>pAnchor</name></decl></parameter>,
                    <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>pMatch</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>pMatchBase</name></decl></parameter>,
                    <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>pExtDictStart</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>pExtDictEnd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>matchLength</name> <init>= <expr><call><name>ZSTD_ldm_countBackwardsMatch</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>pAnchor</name></expr></argument>, <argument><expr><name>pMatch</name></expr></argument>, <argument><expr><name>pMatchBase</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>pMatch</name> <operator>-</operator> <name>matchLength</name> <operator>!=</operator> <name>pMatchBase</name> <operator>||</operator> <name>pMatchBase</name> <operator>==</operator> <name>pExtDictStart</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* If backwards match is entirely in the extDict or prefix, immediately return */</comment>
        <return>return <expr><name>matchLength</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_ldm_countBackwardsMatch_2segments: found 2-parts backwards match (length in prefix==%zu)"</literal></expr></argument>, <argument><expr><name>matchLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>matchLength</name> <operator>+=</operator> <call><name>ZSTD_ldm_countBackwardsMatch</name><argument_list>(<argument><expr><name>pIn</name> <operator>-</operator> <name>matchLength</name></expr></argument>, <argument><expr><name>pAnchor</name></expr></argument>, <argument><expr><name>pExtDictEnd</name></expr></argument>, <argument><expr><name>pExtDictStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"final backwards match length = %zu"</literal></expr></argument>, <argument><expr><name>matchLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>matchLength</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** ZSTD_ldm_fillFastTables() :
 *
 *  Fills the relevant tables for the ZSTD_fast and ZSTD_dfast strategies.
 *  This is similar to ZSTD_loadDictionaryContent.
 *
 *  The tables for the other strategies are filled within their
 *  block compressors. */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_ldm_fillFastTables</name><parameter_list>(<parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>,
                                      <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>end</name></expr></init></decl>;</decl_stmt>

    <switch>switch<condition>(<expr><name><name>ms</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>strategy</name></name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>ZSTD_fast</name></expr>:</case>
        <expr_stmt><expr><call><name>ZSTD_fillHashTable</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>ZSTD_dtlm_fast</name></expr></argument>, <argument><expr><name>ZSTD_tfp_forCCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

    <case>case <expr><name>ZSTD_dfast</name></expr>:</case>
        <expr_stmt><expr><call><name>ZSTD_fillDoubleHashTable</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>ZSTD_dtlm_fast</name></expr></argument>, <argument><expr><name>ZSTD_tfp_forCCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

    <case>case <expr><name>ZSTD_greedy</name></expr>:</case>
    <case>case <expr><name>ZSTD_lazy</name></expr>:</case>
    <case>case <expr><name>ZSTD_lazy2</name></expr>:</case>
    <case>case <expr><name>ZSTD_btlazy2</name></expr>:</case>
    <case>case <expr><name>ZSTD_btopt</name></expr>:</case>
    <case>case <expr><name>ZSTD_btultra</name></expr>:</case>
    <case>case <expr><name>ZSTD_btultra2</name></expr>:</case>
        <break>break;</break>
    <default>default:</default>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* not possible : not a valid strategy id */</comment>
    </block_content>}</block></switch>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>ZSTD_ldm_fillHashTable</name><parameter_list>(
            <parameter><decl><type><name>ldmState_t</name><modifier>*</modifier></type> <name>ldmState</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name></decl></parameter>,
            <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>iend</name></decl></parameter>, <parameter><decl><type><name>ldmParams_t</name> <specifier>const</specifier><modifier>*</modifier></type> <name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>minMatchLength</name> <init>= <expr><name><name>params</name><operator>-&gt;</operator><name>minMatchLength</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>hBits</name> <init>= <expr><name><name>params</name><operator>-&gt;</operator><name>hashLog</name></name> <operator>-</operator> <name><name>params</name><operator>-&gt;</operator><name>bucketSizeLog</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>base</name> <init>= <expr><name><name>ldmState</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>istart</name> <init>= <expr><name>ip</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ldmRollingHashState_t</name></type> <name>hashState</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>splits</name> <init>= <expr><name><name>ldmState</name><operator>-&gt;</operator><name>splitIndices</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>numSplits</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_ldm_fillHashTable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ZSTD_ldm_gear_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hashState</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>ip</name> <operator>&lt;</operator> <name>iend</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>hashed</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name></type> <name>n</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>numSplits</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>hashed</name> <operator>=</operator> <call><name>ZSTD_ldm_gear_feed</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hashState</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iend</name> <operator>-</operator> <name>ip</name></expr></argument>, <argument><expr><name>splits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numSplits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>numSplits</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>ip</name> <operator>+</operator> <name><name>splits</name><index>[<expr><name>n</name></expr>]</index></name> <operator>&gt;=</operator> <name>istart</name> <operator>+</operator> <name>minMatchLength</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>split</name> <init>= <expr><name>ip</name> <operator>+</operator> <name><name>splits</name><index>[<expr><name>n</name></expr>]</index></name> <operator>-</operator> <name>minMatchLength</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>U64</name> <specifier>const</specifier></type> <name>xxhash</name> <init>= <expr><call><name>XXH64</name><argument_list>(<argument><expr><name>split</name></expr></argument>, <argument><expr><name>minMatchLength</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>hash</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>xxhash</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>hBits</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ldmEntry_t</name></type> <name>entry</name></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>entry</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>split</name> <operator>-</operator> <name>base</name><operator>)</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>entry</name><operator>.</operator><name>checksum</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>xxhash</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ZSTD_ldm_insertEntry</name><argument_list>(<argument><expr><name>ldmState</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><operator>*</operator><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>hashed</name></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>


<comment type="block" format="doxygen">/** ZSTD_ldm_limitTableUpdate() :
 *
 *  Sets cctx-&gt;nextToUpdate to a position corresponding closer to anchor
 *  if it is far way
 *  (after a long match, only update tables a limited amount). */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_ldm_limitTableUpdate</name><parameter_list>(<parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>anchor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>curr</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>anchor</name> <operator>-</operator> <name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>curr</name> <operator>&gt;</operator> <name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name> <operator>+</operator> <literal type="number">1024</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name> <operator>=</operator>
            <name>curr</name> <operator>-</operator> <call><name>MIN</name><argument_list>(<argument><expr><literal type="number">512</literal></expr></argument>, <argument><expr><name>curr</name> <operator>-</operator> <name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name> <operator>-</operator> <literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_ldm_generateSequences_internal</name><parameter_list>(
        <parameter><decl><type><name>ldmState_t</name><modifier>*</modifier></type> <name>ldmState</name></decl></parameter>, <parameter><decl><type><name>rawSeqStore_t</name><modifier>*</modifier></type> <name>rawSeqStore</name></decl></parameter>,
        <parameter><decl><type><name>ldmParams_t</name> <specifier>const</specifier><modifier>*</modifier></type> <name>params</name></decl></parameter>, <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* LDM parameters */</comment>
    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>extDict</name> <init>= <expr><call><name>ZSTD_window_hasExtDict</name><argument_list>(<argument><expr><name><name>ldmState</name><operator>-&gt;</operator><name>window</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>minMatchLength</name> <init>= <expr><name><name>params</name><operator>-&gt;</operator><name>minMatchLength</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>entsPerBucket</name> <init>= <expr><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name><name>params</name><operator>-&gt;</operator><name>bucketSizeLog</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>hBits</name> <init>= <expr><name><name>params</name><operator>-&gt;</operator><name>hashLog</name></name> <operator>-</operator> <name><name>params</name><operator>-&gt;</operator><name>bucketSizeLog</name></name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Prefix and extDict parameters */</comment>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>dictLimit</name> <init>= <expr><name><name>ldmState</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictLimit</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>lowestIndex</name> <init>= <expr><ternary><condition><expr><name>extDict</name></expr> ?</condition><then> <expr><name><name>ldmState</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>lowLimit</name></name></expr> </then><else>: <expr><name>dictLimit</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>base</name> <init>= <expr><name><name>ldmState</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>dictBase</name> <init>= <expr><ternary><condition><expr><name>extDict</name></expr> ?</condition><then> <expr><name><name>ldmState</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictBase</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>dictStart</name> <init>= <expr><ternary><condition><expr><name>extDict</name></expr> ?</condition><then> <expr><name>dictBase</name> <operator>+</operator> <name>lowestIndex</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>dictEnd</name> <init>= <expr><ternary><condition><expr><name>extDict</name></expr> ?</condition><then> <expr><name>dictBase</name> <operator>+</operator> <name>dictLimit</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>lowPrefixPtr</name> <init>= <expr><name>base</name> <operator>+</operator> <name>dictLimit</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Input bounds */</comment>
    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>istart</name> <init>= <expr><operator>(</operator><name>BYTE</name> <specifier>const</specifier><operator>*</operator><operator>)</operator><name>src</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name> <init>= <expr><name>istart</name> <operator>+</operator> <name>srcSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>ilimit</name> <init>= <expr><name>iend</name> <operator>-</operator> <name>HASH_READ_SIZE</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Input positions */</comment>
    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>anchor</name> <init>= <expr><name>istart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>ip</name> <init>= <expr><name>istart</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Rolling hash state */</comment>
    <decl_stmt><decl><type><name>ldmRollingHashState_t</name></type> <name>hashState</name></decl>;</decl_stmt>
    <comment type="block">/* Arrays for staged-processing */</comment>
    <decl_stmt><decl><type><name>size_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>splits</name> <init>= <expr><name><name>ldmState</name><operator>-&gt;</operator><name>splitIndices</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ldmMatchCandidate_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>candidates</name> <init>= <expr><name><name>ldmState</name><operator>-&gt;</operator><name>matchCandidates</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>numSplits</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>srcSize</name> <operator>&lt;</operator> <name>minMatchLength</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>iend</name> <operator>-</operator> <name>anchor</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Initialize the rolling hash state with the first minMatchLength bytes */</comment>
    <expr_stmt><expr><call><name>ZSTD_ldm_gear_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hashState</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_ldm_gear_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hashState</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>minMatchLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>minMatchLength</name></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>ip</name> <operator>&lt;</operator> <name>ilimit</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>hashed</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name></type> <name>n</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>numSplits</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>hashed</name> <operator>=</operator> <call><name>ZSTD_ldm_gear_feed</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hashState</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>ilimit</name> <operator>-</operator> <name>ip</name></expr></argument>,
                                    <argument><expr><name>splits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numSplits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>numSplits</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>split</name> <init>= <expr><name>ip</name> <operator>+</operator> <name><name>splits</name><index>[<expr><name>n</name></expr>]</index></name> <operator>-</operator> <name>minMatchLength</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U64</name> <specifier>const</specifier></type> <name>xxhash</name> <init>= <expr><call><name>XXH64</name><argument_list>(<argument><expr><name>split</name></expr></argument>, <argument><expr><name>minMatchLength</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>hash</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>xxhash</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>hBits</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>candidates</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>split</name> <operator>=</operator> <name>split</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>candidates</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>hash</name> <operator>=</operator> <name>hash</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>candidates</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>checksum</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>xxhash</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>candidates</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>bucket</name> <operator>=</operator> <call><name>ZSTD_ldm_getBucket</name><argument_list>(<argument><expr><name>ldmState</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><operator>*</operator><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PREFETCH_L1</name><argument_list>(<argument><expr><name><name>candidates</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>numSplits</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>size_t</name></type> <name>forwardMatchLength</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>backwardMatchLength</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
                   <decl><type ref="prev"/><name>bestMatchLength</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>mLength</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name></type> <name>offset</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>split</name> <init>= <expr><name><name>candidates</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>split</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>checksum</name> <init>= <expr><name><name>candidates</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>checksum</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>hash</name> <init>= <expr><name><name>candidates</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>hash</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ldmEntry_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>bucket</name> <init>= <expr><name><name>candidates</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>bucket</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ldmEntry_t</name> <specifier>const</specifier><modifier>*</modifier></type> <name>cur</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ldmEntry_t</name> <specifier>const</specifier><modifier>*</modifier></type> <name>bestEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ldmEntry_t</name></type> <name>newEntry</name></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>newEntry</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>split</name> <operator>-</operator> <name>base</name><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>newEntry</name><operator>.</operator><name>checksum</name></name> <operator>=</operator> <name>checksum</name></expr>;</expr_stmt>

            <comment type="block">/* If a split point would generate a sequence overlapping with
             * the previous one, we merely register it in the hash table and
             * move on */</comment>
            <if_stmt><if>if <condition>(<expr><name>split</name> <operator>&lt;</operator> <name>anchor</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>ZSTD_ldm_insertEntry</name><argument_list>(<argument><expr><name>ldmState</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>newEntry</name></expr></argument>, <argument><expr><operator>*</operator><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>

            <for>for <control>(<init><expr><name>cur</name> <operator>=</operator> <name>bucket</name></expr>;</init> <condition><expr><name>cur</name> <operator>&lt;</operator> <name>bucket</name> <operator>+</operator> <name>entsPerBucket</name></expr>;</condition> <incr><expr><name>cur</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>size_t</name></type> <name>curForwardMatchLength</name></decl>, <decl><type ref="prev"/><name>curBackwardMatchLength</name></decl>,
                       <decl><type ref="prev"/><name>curTotalMatchLength</name></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>checksum</name></name> <operator>!=</operator> <name>checksum</name> <operator>||</operator> <name><name>cur</name><operator>-&gt;</operator><name>offset</name></name> <operator>&lt;=</operator> <name>lowestIndex</name></expr>)</condition> <block>{<block_content>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>extDict</name></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>curMatchBase</name> <init>=
                        <expr><ternary><condition><expr><name><name>cur</name><operator>-&gt;</operator><name>offset</name></name> <operator>&lt;</operator> <name>dictLimit</name></expr> ?</condition><then> <expr><name>dictBase</name></expr> </then><else>: <expr><name>base</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>pMatch</name> <init>= <expr><name>curMatchBase</name> <operator>+</operator> <name><name>cur</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>matchEnd</name> <init>=
                        <expr><ternary><condition><expr><name><name>cur</name><operator>-&gt;</operator><name>offset</name></name> <operator>&lt;</operator> <name>dictLimit</name></expr> ?</condition><then> <expr><name>dictEnd</name></expr> </then><else>: <expr><name>iend</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>lowMatchPtr</name> <init>=
                        <expr><ternary><condition><expr><name><name>cur</name><operator>-&gt;</operator><name>offset</name></name> <operator>&lt;</operator> <name>dictLimit</name></expr> ?</condition><then> <expr><name>dictStart</name></expr> </then><else>: <expr><name>lowPrefixPtr</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>curForwardMatchLength</name> <operator>=</operator>
                        <call><name>ZSTD_count_2segments</name><argument_list>(<argument><expr><name>split</name></expr></argument>, <argument><expr><name>pMatch</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>matchEnd</name></expr></argument>, <argument><expr><name>lowPrefixPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>curForwardMatchLength</name> <operator>&lt;</operator> <name>minMatchLength</name></expr>)</condition> <block>{<block_content>
                        <continue>continue;</continue>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name>curBackwardMatchLength</name> <operator>=</operator> <call><name>ZSTD_ldm_countBackwardsMatch_2segments</name><argument_list>(
                            <argument><expr><name>split</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>pMatch</name></expr></argument>, <argument><expr><name>lowMatchPtr</name></expr></argument>, <argument><expr><name>dictStart</name></expr></argument>, <argument><expr><name>dictEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content> <comment type="block">/* !extDict */</comment>
                    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>pMatch</name> <init>= <expr><name>base</name> <operator>+</operator> <name><name>cur</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>curForwardMatchLength</name> <operator>=</operator> <call><name>ZSTD_count</name><argument_list>(<argument><expr><name>split</name></expr></argument>, <argument><expr><name>pMatch</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>curForwardMatchLength</name> <operator>&lt;</operator> <name>minMatchLength</name></expr>)</condition> <block>{<block_content>
                        <continue>continue;</continue>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name>curBackwardMatchLength</name> <operator>=</operator>
                        <call><name>ZSTD_ldm_countBackwardsMatch</name><argument_list>(<argument><expr><name>split</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>pMatch</name></expr></argument>, <argument><expr><name>lowPrefixPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <expr_stmt><expr><name>curTotalMatchLength</name> <operator>=</operator> <name>curForwardMatchLength</name> <operator>+</operator> <name>curBackwardMatchLength</name></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>curTotalMatchLength</name> <operator>&gt;</operator> <name>bestMatchLength</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>bestMatchLength</name> <operator>=</operator> <name>curTotalMatchLength</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>forwardMatchLength</name> <operator>=</operator> <name>curForwardMatchLength</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>backwardMatchLength</name> <operator>=</operator> <name>curBackwardMatchLength</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>bestEntry</name> <operator>=</operator> <name>cur</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>

            <comment type="block">/* No match found -- insert an entry into the hash table
             * and process the next candidate match */</comment>
            <if_stmt><if>if <condition>(<expr><name>bestEntry</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>ZSTD_ldm_insertEntry</name><argument_list>(<argument><expr><name>ldmState</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>newEntry</name></expr></argument>, <argument><expr><operator>*</operator><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Match found */</comment>
            <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>split</name> <operator>-</operator> <name>base</name><operator>)</operator> <operator>-</operator> <name><name>bestEntry</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>mLength</name> <operator>=</operator> <name>forwardMatchLength</name> <operator>+</operator> <name>backwardMatchLength</name></expr>;</expr_stmt>
            <block>{<block_content>
                <decl_stmt><decl><type><name>rawSeq</name><modifier>*</modifier> <specifier>const</specifier></type> <name>seq</name> <init>= <expr><name><name>rawSeqStore</name><operator>-&gt;</operator><name>seq</name></name> <operator>+</operator> <name><name>rawSeqStore</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

                <comment type="block">/* Out of sequence storage */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>rawSeqStore</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <name><name>rawSeqStore</name><operator>-&gt;</operator><name>capacity</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><call><name>ERROR</name><argument_list>(<argument><expr><name>dstSize_tooSmall</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                <expr_stmt><expr><name><name>seq</name><operator>-&gt;</operator><name>litLength</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>split</name> <operator>-</operator> <name>backwardMatchLength</name> <operator>-</operator> <name>anchor</name><operator>)</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>seq</name><operator>-&gt;</operator><name>matchLength</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>mLength</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>seq</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>rawSeqStore</name><operator>-&gt;</operator><name>size</name></name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block>

            <comment type="block">/* Insert the current entry into the hash table --- it must be
             * done after the previous block to avoid clobbering bestEntry */</comment>
            <expr_stmt><expr><call><name>ZSTD_ldm_insertEntry</name><argument_list>(<argument><expr><name>ldmState</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>newEntry</name></expr></argument>, <argument><expr><operator>*</operator><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>anchor</name> <operator>=</operator> <name>split</name> <operator>+</operator> <name>forwardMatchLength</name></expr>;</expr_stmt>

            <comment type="block">/* If we find a match that ends after the data that we've hashed
             * then we have a repeating, overlapping, pattern. E.g. all zeros.
             * If one repetition of the pattern matches our `stopMask` then all
             * repetitions will. We don't need to insert them all into out table,
             * only the first one. So skip over overlapping matches.
             * This is a major speed boost (20x) for compressing a single byte
             * repeated, when that byte ends up in the table.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>anchor</name> <operator>&gt;</operator> <name>ip</name> <operator>+</operator> <name>hashed</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>ZSTD_ldm_gear_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hashState</name></expr></argument>, <argument><expr><name>anchor</name> <operator>-</operator> <name>minMatchLength</name></expr></argument>, <argument><expr><name>minMatchLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* Continue the outer loop at anchor (ip + hashed == anchor). */</comment>
                <expr_stmt><expr><name>ip</name> <operator>=</operator> <name>anchor</name> <operator>-</operator> <name>hashed</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>hashed</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <return>return <expr><name>iend</name> <operator>-</operator> <name>anchor</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! ZSTD_ldm_reduceTable() :
 *  reduce table indexes by `reducerValue` */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_ldm_reduceTable</name><parameter_list>(<parameter><decl><type><name>ldmEntry_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>table</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>size</name></decl></parameter>,
                                 <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>reducerValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name></type> <name>u</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>u</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>u</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>u</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>table</name><index>[<expr><name>u</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>&lt;</operator> <name>reducerValue</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>table</name><index>[<expr><name>u</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name><name>table</name><index>[<expr><name>u</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>-=</operator> <name>reducerValue</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_ldm_generateSequences</name><parameter_list>(
        <parameter><decl><type><name>ldmState_t</name><modifier>*</modifier></type> <name>ldmState</name></decl></parameter>, <parameter><decl><type><name>rawSeqStore_t</name><modifier>*</modifier></type> <name>sequences</name></decl></parameter>,
        <parameter><decl><type><name>ldmParams_t</name> <specifier>const</specifier><modifier>*</modifier></type> <name>params</name></decl></parameter>, <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>maxDist</name> <init>= <expr><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name><name>params</name><operator>-&gt;</operator><name>windowLog</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>istart</name> <init>= <expr><operator>(</operator><name>BYTE</name> <specifier>const</specifier><operator>*</operator><operator>)</operator><name>src</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name> <init>= <expr><name>istart</name> <operator>+</operator> <name>srcSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>kMaxChunkSize</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">20</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>nbChunks</name> <init>= <expr><operator>(</operator><name>srcSize</name> <operator>/</operator> <name>kMaxChunkSize</name><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><name>srcSize</name> <operator>%</operator> <name>kMaxChunkSize</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>chunk</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>leftoverSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ZSTD_CHUNKSIZE_MAX</name> <operator>&gt;=</operator> <name>kMaxChunkSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Check that ZSTD_window_update() has been called for this chunk prior
     * to passing it to this function.
     */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ldmState</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>nextSrc</name></name> <operator>&gt;=</operator> <operator>(</operator><name>BYTE</name> <specifier>const</specifier><operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* The input could be very large (in zstdmt), so it must be broken up into
     * chunks to enforce the maximum distance and handle overflow correction.
     */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>sequences</name><operator>-&gt;</operator><name>pos</name></name> <operator>&lt;=</operator> <name><name>sequences</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>sequences</name><operator>-&gt;</operator><name>size</name></name> <operator>&lt;=</operator> <name><name>sequences</name><operator>-&gt;</operator><name>capacity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>chunk</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>chunk</name> <operator>&lt;</operator> <name>nbChunks</name> <operator>&amp;&amp;</operator> <name><name>sequences</name><operator>-&gt;</operator><name>size</name></name> <operator>&lt;</operator> <name><name>sequences</name><operator>-&gt;</operator><name>capacity</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>chunk</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>chunkStart</name> <init>= <expr><name>istart</name> <operator>+</operator> <name>chunk</name> <operator>*</operator> <name>kMaxChunkSize</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>remaining</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>iend</name> <operator>-</operator> <name>chunkStart</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier> <modifier>*</modifier><specifier>const</specifier></type> <name>chunkEnd</name> <init>=
            <expr><ternary><condition><expr><operator>(</operator><name>remaining</name> <operator>&lt;</operator> <name>kMaxChunkSize</name><operator>)</operator></expr> ?</condition><then> <expr><name>iend</name></expr> </then><else>: <expr><name>chunkStart</name> <operator>+</operator> <name>kMaxChunkSize</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>chunkSize</name> <init>= <expr><name>chunkEnd</name> <operator>-</operator> <name>chunkStart</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>newLeftoverSize</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>prevSize</name> <init>= <expr><name><name>sequences</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>chunkStart</name> <operator>&lt;</operator> <name>iend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* 1. Perform overflow correction if necessary. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>ZSTD_window_needOverflowCorrection</name><argument_list>(<argument><expr><name><name>ldmState</name><operator>-&gt;</operator><name>window</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>maxDist</name></expr></argument>, <argument><expr><name><name>ldmState</name><operator>-&gt;</operator><name>loadedDictEnd</name></name></expr></argument>, <argument><expr><name>chunkStart</name></expr></argument>, <argument><expr><name>chunkEnd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>ldmHSize</name> <init>= <expr><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name><name>params</name><operator>-&gt;</operator><name>hashLog</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>correction</name> <init>= <expr><call><name>ZSTD_window_correctOverflow</name><argument_list>(
                <argument><expr><operator>&amp;</operator><name><name>ldmState</name><operator>-&gt;</operator><name>window</name></name></expr></argument>, <comment type="block">/* cycleLog */</comment> <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>maxDist</name></expr></argument>, <argument><expr><name>chunkStart</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ZSTD_ldm_reduceTable</name><argument_list>(<argument><expr><name><name>ldmState</name><operator>-&gt;</operator><name>hashTable</name></name></expr></argument>, <argument><expr><name>ldmHSize</name></expr></argument>, <argument><expr><name>correction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* invalidate dictionaries on overflow correction */</comment>
            <expr_stmt><expr><name><name>ldmState</name><operator>-&gt;</operator><name>loadedDictEnd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* 2. We enforce the maximum offset allowed.
         *
         * kMaxChunkSize should be small enough that we don't lose too much of
         * the window through early invalidation.
         * TODO: * Test the chunk size.
         *       * Try invalidation after the sequence generation and test the
         *         offset against maxDist directly.
         *
         * NOTE: Because of dictionaries + sequence splitting we MUST make sure
         * that any offset used is valid at the END of the sequence, since it may
         * be split into two sequences. This condition holds when using
         * ZSTD_window_enforceMaxDist(), but if we move to checking offsets
         * against maxDist directly, we'll have to carefully handle that case.
         */</comment>
        <expr_stmt><expr><call><name>ZSTD_window_enforceMaxDist</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ldmState</name><operator>-&gt;</operator><name>window</name></name></expr></argument>, <argument><expr><name>chunkEnd</name></expr></argument>, <argument><expr><name>maxDist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ldmState</name><operator>-&gt;</operator><name>loadedDictEnd</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* 3. Generate the sequences for the chunk, and get newLeftoverSize. */</comment>
        <expr_stmt><expr><name>newLeftoverSize</name> <operator>=</operator> <call><name>ZSTD_ldm_generateSequences_internal</name><argument_list>(
            <argument><expr><name>ldmState</name></expr></argument>, <argument><expr><name>sequences</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>chunkStart</name></expr></argument>, <argument><expr><name>chunkSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>newLeftoverSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>newLeftoverSize</name></expr>;</return></block_content></block></if></if_stmt>
        <comment type="block">/* 4. We add the leftover literals from previous iterations to the first
         *    newly generated sequence, or add the `newLeftoverSize` if none are
         *    generated.
         */</comment>
        <comment type="block">/* Prepend the leftover literals from the last call */</comment>
        <if_stmt><if>if <condition>(<expr><name>prevSize</name> <operator>&lt;</operator> <name><name>sequences</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>sequences</name><operator>-&gt;</operator><name>seq</name><index>[<expr><name>prevSize</name></expr>]</index></name><operator>.</operator><name>litLength</name> <operator>+=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>leftoverSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>leftoverSize</name> <operator>=</operator> <name>newLeftoverSize</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>newLeftoverSize</name> <operator>==</operator> <name>chunkSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>leftoverSize</name> <operator>+=</operator> <name>chunkSize</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ZSTD_ldm_skipSequences</name><parameter_list>(<parameter><decl><type><name>rawSeqStore_t</name><modifier>*</modifier></type> <name>rawSeqStore</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>minMatch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <while>while <condition>(<expr><name>srcSize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>rawSeqStore</name><operator>-&gt;</operator><name>pos</name></name> <operator>&lt;</operator> <name><name>rawSeqStore</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>rawSeq</name><modifier>*</modifier></type> <name>seq</name> <init>= <expr><name><name>rawSeqStore</name><operator>-&gt;</operator><name>seq</name></name> <operator>+</operator> <name><name>rawSeqStore</name><operator>-&gt;</operator><name>pos</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>srcSize</name> <operator>&lt;=</operator> <name><name>seq</name><operator>-&gt;</operator><name>litLength</name></name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Skip past srcSize literals */</comment>
            <expr_stmt><expr><name><name>seq</name><operator>-&gt;</operator><name>litLength</name></name> <operator>-=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>srcSize</name></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>srcSize</name> <operator>-=</operator> <name><name>seq</name><operator>-&gt;</operator><name>litLength</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>seq</name><operator>-&gt;</operator><name>litLength</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>srcSize</name> <operator>&lt;</operator> <name><name>seq</name><operator>-&gt;</operator><name>matchLength</name></name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Skip past the first srcSize of the match */</comment>
            <expr_stmt><expr><name><name>seq</name><operator>-&gt;</operator><name>matchLength</name></name> <operator>-=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>srcSize</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>seq</name><operator>-&gt;</operator><name>matchLength</name></name> <operator>&lt;</operator> <name>minMatch</name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* The match is too short, omit it */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>rawSeqStore</name><operator>-&gt;</operator><name>pos</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>rawSeqStore</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name><name>seq</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>litLength</name> <operator>+=</operator> <name><name>seq</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>matchLength</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>rawSeqStore</name><operator>-&gt;</operator><name>pos</name></name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>srcSize</name> <operator>-=</operator> <name><name>seq</name><operator>-&gt;</operator><name>matchLength</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>seq</name><operator>-&gt;</operator><name>matchLength</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rawSeqStore</name><operator>-&gt;</operator><name>pos</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * If the sequence length is longer than remaining then the sequence is split
 * between this block and the next.
 *
 * Returns the current sequence to handle, or if the rest of the block should
 * be literals, it returns a sequence with offset == 0.
 */</comment>
<function><type><specifier>static</specifier> <name>rawSeq</name></type> <name>maybeSplitSequence</name><parameter_list>(<parameter><decl><type><name>rawSeqStore_t</name><modifier>*</modifier></type> <name>rawSeqStore</name></decl></parameter>,
                                 <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>remaining</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>minMatch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>rawSeq</name></type> <name>sequence</name> <init>= <expr><name><name>rawSeqStore</name><operator>-&gt;</operator><name>seq</name><index>[<expr><name><name>rawSeqStore</name><operator>-&gt;</operator><name>pos</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>sequence</name><operator>.</operator><name>offset</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Likely: No partial sequence */</comment>
    <if_stmt><if>if <condition>(<expr><name>remaining</name> <operator>&gt;=</operator> <name><name>sequence</name><operator>.</operator><name>litLength</name></name> <operator>+</operator> <name><name>sequence</name><operator>.</operator><name>matchLength</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>rawSeqStore</name><operator>-&gt;</operator><name>pos</name></name><operator>++</operator></expr>;</expr_stmt>
        <return>return <expr><name>sequence</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Cut the sequence short (offset == 0 ==&gt; rest is literals). */</comment>
    <if_stmt><if>if <condition>(<expr><name>remaining</name> <operator>&lt;=</operator> <name><name>sequence</name><operator>.</operator><name>litLength</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>sequence</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>remaining</name> <operator>&lt;</operator> <name><name>sequence</name><operator>.</operator><name>litLength</name></name> <operator>+</operator> <name><name>sequence</name><operator>.</operator><name>matchLength</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>sequence</name><operator>.</operator><name>matchLength</name></name> <operator>=</operator> <name>remaining</name> <operator>-</operator> <name><name>sequence</name><operator>.</operator><name>litLength</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>sequence</name><operator>.</operator><name>matchLength</name></name> <operator>&lt;</operator> <name>minMatch</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>sequence</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Skip past `remaining` bytes for the future sequences. */</comment>
    <expr_stmt><expr><call><name>ZSTD_ldm_skipSequences</name><argument_list>(<argument><expr><name>rawSeqStore</name></expr></argument>, <argument><expr><name>remaining</name></expr></argument>, <argument><expr><name>minMatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>sequence</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>ZSTD_ldm_skipRawSeqStoreBytes</name><parameter_list>(<parameter><decl><type><name>rawSeqStore_t</name><modifier>*</modifier></type> <name>rawSeqStore</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nbBytes</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>U32</name></type> <name>currPos</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name><name>rawSeqStore</name><operator>-&gt;</operator><name>posInSequence</name></name> <operator>+</operator> <name>nbBytes</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>currPos</name> <operator>&amp;&amp;</operator> <name><name>rawSeqStore</name><operator>-&gt;</operator><name>pos</name></name> <operator>&lt;</operator> <name><name>rawSeqStore</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>rawSeq</name></type> <name>currSeq</name> <init>= <expr><name><name>rawSeqStore</name><operator>-&gt;</operator><name>seq</name><index>[<expr><name><name>rawSeqStore</name><operator>-&gt;</operator><name>pos</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>currPos</name> <operator>&gt;=</operator> <name><name>currSeq</name><operator>.</operator><name>litLength</name></name> <operator>+</operator> <name><name>currSeq</name><operator>.</operator><name>matchLength</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>currPos</name> <operator>-=</operator> <name><name>currSeq</name><operator>.</operator><name>litLength</name></name> <operator>+</operator> <name><name>currSeq</name><operator>.</operator><name>matchLength</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rawSeqStore</name><operator>-&gt;</operator><name>pos</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>rawSeqStore</name><operator>-&gt;</operator><name>posInSequence</name></name> <operator>=</operator> <name>currPos</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if <condition>(<expr><name>currPos</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>rawSeqStore</name><operator>-&gt;</operator><name>pos</name></name> <operator>==</operator> <name><name>rawSeqStore</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>rawSeqStore</name><operator>-&gt;</operator><name>posInSequence</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_ldm_blockCompress</name><parameter_list>(<parameter><decl><type><name>rawSeqStore_t</name><modifier>*</modifier></type> <name>rawSeqStore</name></decl></parameter>,
    <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>,
    <parameter><decl><type><name>ZSTD_paramSwitch_e</name></type> <name>useRowMatchFinder</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_compressionParameters</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cParams</name> <init>= <expr><operator>&amp;</operator><name><name>ms</name><operator>-&gt;</operator><name>cParams</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>minMatch</name> <init>= <expr><name><name>cParams</name><operator>-&gt;</operator><name>minMatch</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_blockCompressor</name> <specifier>const</specifier></type> <name>blockCompressor</name> <init>=
        <expr><call><name>ZSTD_selectBlockCompressor</name><argument_list>(<argument><expr><name><name>cParams</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>, <argument><expr><name>useRowMatchFinder</name></expr></argument>, <argument><expr><call><name>ZSTD_matchState_dictMode</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Input bounds */</comment>
    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>istart</name> <init>= <expr><operator>(</operator><name>BYTE</name> <specifier>const</specifier><operator>*</operator><operator>)</operator><name>src</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name> <init>= <expr><name>istart</name> <operator>+</operator> <name>srcSize</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Input positions */</comment>
    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>ip</name> <init>= <expr><name>istart</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_ldm_blockCompress: srcSize=%zu"</literal></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* If using opt parser, use LDMs only as candidates rather than always accepting them */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cParams</name><operator>-&gt;</operator><name>strategy</name></name> <operator>&gt;=</operator> <name>ZSTD_btopt</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>lastLLSize</name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>ldmSeqStore</name></name> <operator>=</operator> <name>rawSeqStore</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>lastLLSize</name> <operator>=</operator> <call><name>blockCompressor</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_ldm_skipRawSeqStoreBytes</name><argument_list>(<argument><expr><name>rawSeqStore</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>lastLLSize</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>rawSeqStore</name><operator>-&gt;</operator><name>pos</name></name> <operator>&lt;=</operator> <name><name>rawSeqStore</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>rawSeqStore</name><operator>-&gt;</operator><name>size</name></name> <operator>&lt;=</operator> <name><name>rawSeqStore</name><operator>-&gt;</operator><name>capacity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Loop through each sequence and apply the block compressor to the literals */</comment>
    <while>while <condition>(<expr><name><name>rawSeqStore</name><operator>-&gt;</operator><name>pos</name></name> <operator>&lt;</operator> <name><name>rawSeqStore</name><operator>-&gt;</operator><name>size</name></name> <operator>&amp;&amp;</operator> <name>ip</name> <operator>&lt;</operator> <name>iend</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* maybeSplitSequence updates rawSeqStore-&gt;pos */</comment>
        <decl_stmt><decl><type><name>rawSeq</name> <specifier>const</specifier></type> <name>sequence</name> <init>= <expr><call><name>maybeSplitSequence</name><argument_list>(<argument><expr><name>rawSeqStore</name></expr></argument>,
                                                   <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>iend</name> <operator>-</operator> <name>ip</name><operator>)</operator></expr></argument>, <argument><expr><name>minMatch</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <comment type="block">/* End signal */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>sequence</name><operator>.</operator><name>offset</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ip</name> <operator>+</operator> <name><name>sequence</name><operator>.</operator><name>litLength</name></name> <operator>+</operator> <name><name>sequence</name><operator>.</operator><name>matchLength</name></name> <operator>&lt;=</operator> <name>iend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Fill tables for block compressor */</comment>
        <expr_stmt><expr><call><name>ZSTD_ldm_limitTableUpdate</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_ldm_fillFastTables</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Run the block compressor */</comment>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"pos %u : calling block compressor on segment of size %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>istart</name><operator>)</operator></expr></argument>, <argument><expr><name><name>sequence</name><operator>.</operator><name>litLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <block>{<block_content>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>newLitLength</name> <init>=
                <expr><call><name>blockCompressor</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name><name>sequence</name><operator>.</operator><name>litLength</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name><name>sequence</name><operator>.</operator><name>litLength</name></name></expr>;</expr_stmt>
            <comment type="block">/* Update the repcodes */</comment>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>ZSTD_REP_NUM</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>rep</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>rep</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
            <expr_stmt><expr><name><name>rep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>sequence</name><operator>.</operator><name>offset</name></name></expr>;</expr_stmt>
            <comment type="block">/* Store the sequence */</comment>
            <expr_stmt><expr><call><name>ZSTD_storeSeq</name><argument_list>(<argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>newLitLength</name></expr></argument>, <argument><expr><name>ip</name> <operator>-</operator> <name>newLitLength</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>,
                          <argument><expr><call><name>OFFSET_TO_OFFBASE</name><argument_list>(<argument><expr><name><name>sequence</name><operator>.</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name><name>sequence</name><operator>.</operator><name>matchLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name><name>sequence</name><operator>.</operator><name>matchLength</name></name></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></while>
    <comment type="block">/* Fill the tables for the block compressor */</comment>
    <expr_stmt><expr><call><name>ZSTD_ldm_limitTableUpdate</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_ldm_fillFastTables</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Compress the last literals */</comment>
    <return>return <expr><call><name>blockCompressor</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iend</name> <operator>-</operator> <name>ip</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
