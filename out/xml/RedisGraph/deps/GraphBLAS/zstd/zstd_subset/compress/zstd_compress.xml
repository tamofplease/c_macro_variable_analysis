<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/zstd/zstd_subset/compress/zstd_compress.c"><comment type="block">/*
 * Copyright (c) Yann Collet, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
 */</comment>

<comment type="block">/*-*************************************
*  Dependencies
***************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/zstd_deps.h"</cpp:file></cpp:include>  <comment type="block">/* INT_MAX, ZSTD_memset, ZSTD_memcpy */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/mem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hist.h"</cpp:file></cpp:include>           <comment type="block">/* HIST_countFast_wksp */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FSE_STATIC_LINKING_ONLY</name></cpp:macro></cpp:define>   <comment type="block">/* FSE_encodeSymbol */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/fse.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_STATIC_LINKING_ONLY</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/huf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_compress_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_compress_sequences.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_compress_literals.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_fast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_double_fast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_lazy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_opt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_ldm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_compress_superblock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive>  <cpp:file>"../common/bits.h"</cpp:file></cpp:include>      <comment type="block">/* ZSTD_highbit32 */</comment>

<comment type="block">/* ***************************************************************
*  Tuning parameters
*****************************************************************/</comment>
<comment type="block" format="doxygen">/*!
 * COMPRESS_HEAPMODE :
 * Select how default decompression function ZSTD_compress() allocates its context,
 * on stack (0, default), or into heap (1).
 * Note that functions with explicit context such as ZSTD_compressCCtx() are unaffected.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ZSTD_COMPRESS_HEAPMODE</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>ZSTD_COMPRESS_HEAPMODE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/*!
 * ZSTD_HASHLOG3_MAX :
 * Maximum size of the hash table dedicated to find 3-bytes matches,
 * in log format, aka 17 =&gt; 1 &lt;&lt; 17 == 128Ki positions.
 * This structure is only used in zstd_opt.
 * Since allocation is centralized for all strategies, it has to be known here.
 * The actual (selected) size of the hash table is then stored in ZSTD_matchState_t.hashLog3,
 * so that zstd_opt.c doesn't need to know about this constant.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ZSTD_HASHLOG3_MAX</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>ZSTD_HASHLOG3_MAX</name></cpp:macro> <cpp:value>17</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*-*************************************
*  Helper functions
***************************************/</comment>
<comment type="block">/* ZSTD_compressBound()
 * Note that the result from this function is only compatible with the "normal"
 * full-block strategy.
 * When there are a lot of small blocks due to frequent flush in streaming mode
 * the overhead of headers can make the compressed data to be larger than the
 * return value of ZSTD_compressBound().
 */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_compressBound</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>ZSTD_COMPRESSBOUND</name><argument_list>(<argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*-*************************************
*  Context memory management
***************************************/</comment>
<struct>struct <name>ZSTD_CDict_s</name> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dictContent</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>dictContentSize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_dictContentType_e</name></type> <name>dictContentType</name></decl>;</decl_stmt> <comment type="block">/* The dictContentType the CDict was created with */</comment>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier></type> <name>entropyWorkspace</name></decl>;</decl_stmt> <comment type="block">/* entropy workspace of HUF_WORKSPACE_SIZE bytes */</comment>
    <decl_stmt><decl><type><name>ZSTD_cwksp</name></type> <name>workspace</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_matchState_t</name></type> <name>matchState</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_compressedBlockState_t</name></type> <name>cBlockState</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_customMem</name></type> <name>customMem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>dictID</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>compressionLevel</name></decl>;</decl_stmt> <comment type="block">/* 0 indicates that advanced API was used to select CDict params */</comment>
    <decl_stmt><decl><type><name>ZSTD_paramSwitch_e</name></type> <name>useRowMatchFinder</name></decl>;</decl_stmt> <comment type="block">/* Indicates whether the CDict was created with params that would use
                                           * row-based matchfinder. Unless the cdict is reloaded, we will use
                                           * the same greedy/lazy matchfinder at compression time.
                                           */</comment>
}</block>;</struct>  <comment type="block">/* typedef'd to ZSTD_CDict within "zstd.h" */</comment>

<function><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>ZSTD_createCCtx</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_createCCtx_advanced</name><argument_list>(<argument><expr><name>ZSTD_defaultCMem</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_initCCtx</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>, <parameter><decl><type><name>ZSTD_customMem</name></type> <name>memManager</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>cctx</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>cctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>customMem</name></name> <operator>=</operator> <name>memManager</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>bmi2</name></name> <operator>=</operator> <call><name>ZSTD_cpuSupportsBmi2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>err</name> <init>= <expr><call><name>ZSTD_CCtx_reset</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ZSTD_reset_parameters</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>err</name></expr>;</expr_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<function><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>ZSTD_createCCtx_advanced</name><parameter_list>(<parameter><decl><type><name>ZSTD_customMem</name></type> <name>customMem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>ZSTD_STATIC_ASSERT</name><argument_list>(<argument><expr><name>zcss_init</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_STATIC_ASSERT</name><argument_list>(<argument><expr><name>ZSTD_CONTENTSIZE_UNKNOWN</name><operator>==</operator><operator>(</operator><literal type="number">0ULL</literal> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name><name>customMem</name><operator>.</operator><name>customAlloc</name></name><operator>)</operator> <operator>^</operator> <operator>(</operator><operator>!</operator><name><name>customMem</name><operator>.</operator><name>customFree</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cctx</name> <init>= <expr><operator>(</operator><name>ZSTD_CCtx</name><operator>*</operator><operator>)</operator><call><name>ZSTD_customMalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_CCtx</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>customMem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>cctx</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>ZSTD_initCCtx</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>customMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>cctx</name></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>

<function><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>ZSTD_initStaticCCtx</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workspace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>workspaceSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_cwksp</name></type> <name>ws</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>workspaceSize</name> <operator>&lt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_CCtx</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* minimum size */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><name>workspace</name> <operator>&amp;</operator> <literal type="number">7</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* must be 8-aligned */</comment>
    <expr_stmt><expr><call><name>ZSTD_cwksp_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ws</name></expr></argument>, <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>workspaceSize</name></expr></argument>, <argument><expr><name>ZSTD_cwksp_static_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>cctx</name> <operator>=</operator> <operator>(</operator><name>ZSTD_CCtx</name><operator>*</operator><operator>)</operator><call><name>ZSTD_cwksp_reserve_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ws</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_CCtx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>cctx</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_CCtx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_cwksp_move</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ws</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>staticSize</name></name> <operator>=</operator> <name>workspaceSize</name></expr>;</expr_stmt>

    <comment type="block">/* statically sized space. entropyWorkspace never moves (but prev/next block swap places) */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ZSTD_cwksp_check_available</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>, <argument><expr><name>ENTROPY_WORKSPACE_SIZE</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_compressedBlockState_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name></name> <operator>=</operator> <operator>(</operator><name>ZSTD_compressedBlockState_t</name><operator>*</operator><operator>)</operator><call><name>ZSTD_cwksp_reserve_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_compressedBlockState_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>nextCBlock</name></name> <operator>=</operator> <operator>(</operator><name>ZSTD_compressedBlockState_t</name><operator>*</operator><operator>)</operator><call><name>ZSTD_cwksp_reserve_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_compressedBlockState_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>entropyWorkspace</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>*</operator><operator>)</operator><call><name>ZSTD_cwksp_reserve_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>, <argument><expr><name>ENTROPY_WORKSPACE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>bmi2</name></name> <operator>=</operator> <call><name>ZSTD_cpuid_bmi2</name><argument_list>(<argument><expr><call><name>ZSTD_cpuid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>cctx</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Clears and frees all of the dictionaries in the CCtx.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_clearAllDicts</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>ZSTD_customFree</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>localDict</name><operator>.</operator><name>dictBuffer</name></name></expr></argument>, <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>customMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_freeCDict</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>localDict</name><operator>.</operator><name>cdict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>localDict</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>localDict</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>prefixDict</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>prefixDict</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>cdict</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_sizeof_localDict</name><parameter_list>(<parameter><decl><type><name>ZSTD_localDict</name></type> <name>dict</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>bufferSize</name> <init>= <expr><ternary><condition><expr><name><name>dict</name><operator>.</operator><name>dictBuffer</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name><name>dict</name><operator>.</operator><name>dictSize</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>cdictSize</name> <init>= <expr><call><name>ZSTD_sizeof_CDict</name><argument_list>(<argument><expr><name><name>dict</name><operator>.</operator><name>cdict</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>bufferSize</name> <operator>+</operator> <name>cdictSize</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_freeCCtxContent</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>cctx</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>staticSize</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_clearAllDicts</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ZSTD_MULTITHREAD</name></cpp:ifdef>
    <expr_stmt><expr><call><name>ZSTDMT_freeCCtx</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>mtctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>mtctx</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>ZSTD_cwksp_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>, <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>customMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_freeCCtx</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>cctx</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* support free on NULL */</comment>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>staticSize</name></name></expr></argument>, <argument><expr><name>memory_allocation</name></expr></argument>,
                    <argument><expr><literal type="string">"not compatible with static CCtx"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>int</name></type> <name>cctxInWorkspace</name> <init>= <expr><call><name>ZSTD_cwksp_owns_buffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ZSTD_freeCCtxContent</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>cctxInWorkspace</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ZSTD_customFree</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>customMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_sizeof_mtctx</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ZSTD_MULTITHREAD</name></cpp:ifdef>
    <return>return <expr><call><name>ZSTDMT_sizeof_CCtx</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>mtctx</name></name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>cctx</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<function><type><name>size_t</name></type> <name>ZSTD_sizeof_CCtx</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>cctx</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* support sizeof on NULL */</comment>
    <comment type="block">/* cctx may be in the workspace */</comment>
    <return>return <expr><operator>(</operator><ternary><condition><expr><name><name>cctx</name><operator>-&gt;</operator><name>workspace</name><operator>.</operator><name>workspace</name></name> <operator>==</operator> <name>cctx</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>cctx</name></expr></argument>)</argument_list></sizeof></expr></else></ternary><operator>)</operator>
           <operator>+</operator> <call><name>ZSTD_cwksp_sizeof</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>)</argument_list></call>
           <operator>+</operator> <call><name>ZSTD_sizeof_localDict</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>localDict</name></name></expr></argument>)</argument_list></call>
           <operator>+</operator> <call><name>ZSTD_sizeof_mtctx</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_sizeof_CStream</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ZSTD_CStream</name><modifier>*</modifier></type> <name>zcs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_sizeof_CCtx</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>)</argument_list></call></expr>;</return>  <comment type="block">/* same object */</comment>
</block_content>}</block></function>

<comment type="block">/* private API call, for dictBuilder only */</comment>
<function><type><specifier>const</specifier> <name>seqStore_t</name><modifier>*</modifier></type> <name>ZSTD_getSeqStore</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>&amp;</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>seqStore</name></name><operator>)</operator></expr>;</return> </block_content>}</block></function>

<comment type="block">/* Returns true if the strategy supports using a row based matchfinder */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ZSTD_rowMatchFinderSupported</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ZSTD_strategy</name></type> <name>strategy</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><operator>(</operator><name>strategy</name> <operator>&gt;=</operator> <name>ZSTD_greedy</name> <operator>&amp;&amp;</operator> <name>strategy</name> <operator>&lt;=</operator> <name>ZSTD_lazy2</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Returns true if the strategy and useRowMatchFinder mode indicate that we will use the row based matchfinder
 * for this compression.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ZSTD_rowMatchFinderUsed</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ZSTD_strategy</name></type> <name>strategy</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ZSTD_paramSwitch_e</name></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>mode</name> <operator>!=</operator> <name>ZSTD_ps_auto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>ZSTD_rowMatchFinderSupported</name><argument_list>(<argument><expr><name>strategy</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>mode</name> <operator>==</operator> <name>ZSTD_ps_enable</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Returns row matchfinder usage given an initial mode and cParams */</comment>
<function><type><specifier>static</specifier> <name>ZSTD_paramSwitch_e</name></type> <name>ZSTD_resolveRowMatchFinderMode</name><parameter_list>(<parameter><decl><type><name>ZSTD_paramSwitch_e</name></type> <name>mode</name></decl></parameter>,
                                                         <parameter><decl><type><specifier>const</specifier> <name>ZSTD_compressionParameters</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cParams</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ZSTD_ARCH_X86_SSE2</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>ZSTD_ARCH_ARM_NEON</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>kHasSIMD128</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>kHasSIMD128</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><name>mode</name> <operator>!=</operator> <name>ZSTD_ps_auto</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>mode</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* if requested enabled, but no SIMD, we still will use row matchfinder */</comment>
    <expr_stmt><expr><name>mode</name> <operator>=</operator> <name>ZSTD_ps_disable</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ZSTD_rowMatchFinderSupported</name><argument_list>(<argument><expr><name><name>cParams</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>mode</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>kHasSIMD128</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>cParams</name><operator>-&gt;</operator><name>windowLog</name></name> <operator>&gt;</operator> <literal type="number">14</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mode</name> <operator>=</operator> <name>ZSTD_ps_enable</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>cParams</name><operator>-&gt;</operator><name>windowLog</name></name> <operator>&gt;</operator> <literal type="number">17</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mode</name> <operator>=</operator> <name>ZSTD_ps_enable</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>mode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Returns block splitter usage (generally speaking, when using slower/stronger compression modes) */</comment>
<function><type><specifier>static</specifier> <name>ZSTD_paramSwitch_e</name></type> <name>ZSTD_resolveBlockSplitterMode</name><parameter_list>(<parameter><decl><type><name>ZSTD_paramSwitch_e</name></type> <name>mode</name></decl></parameter>,
                                                        <parameter><decl><type><specifier>const</specifier> <name>ZSTD_compressionParameters</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cParams</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>mode</name> <operator>!=</operator> <name>ZSTD_ps_auto</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>mode</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><ternary><condition><expr><operator>(</operator><name><name>cParams</name><operator>-&gt;</operator><name>strategy</name></name> <operator>&gt;=</operator> <name>ZSTD_btopt</name> <operator>&amp;&amp;</operator> <name><name>cParams</name><operator>-&gt;</operator><name>windowLog</name></name> <operator>&gt;=</operator> <literal type="number">17</literal><operator>)</operator></expr> ?</condition><then> <expr><name>ZSTD_ps_enable</name></expr> </then><else>: <expr><name>ZSTD_ps_disable</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Returns 1 if the arguments indicate that we should allocate a chainTable, 0 otherwise */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ZSTD_allocateChainTable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ZSTD_strategy</name></type> <name>strategy</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>ZSTD_paramSwitch_e</name></type> <name>useRowMatchFinder</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name>forDDSDict</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>useRowMatchFinder</name> <operator>!=</operator> <name>ZSTD_ps_auto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* We always should allocate a chaintable if we are allocating a matchstate for a DDS dictionary matchstate.
     * We do not allocate a chaintable if we are using ZSTD_fast, or are using the row-based matchfinder.
     */</comment>
    <return>return <expr><name>forDDSDict</name> <operator>||</operator> <operator>(</operator><operator>(</operator><name>strategy</name> <operator>!=</operator> <name>ZSTD_fast</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ZSTD_rowMatchFinderUsed</name><argument_list>(<argument><expr><name>strategy</name></expr></argument>, <argument><expr><name>useRowMatchFinder</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Returns 1 if compression parameters are such that we should
 * enable long distance matching (wlog &gt;= 27, strategy &gt;= btopt).
 * Returns 0 otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>ZSTD_paramSwitch_e</name></type> <name>ZSTD_resolveEnableLdm</name><parameter_list>(<parameter><decl><type><name>ZSTD_paramSwitch_e</name></type> <name>mode</name></decl></parameter>,
                                 <parameter><decl><type><specifier>const</specifier> <name>ZSTD_compressionParameters</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cParams</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>mode</name> <operator>!=</operator> <name>ZSTD_ps_auto</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>mode</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><ternary><condition><expr><operator>(</operator><name><name>cParams</name><operator>-&gt;</operator><name>strategy</name></name> <operator>&gt;=</operator> <name>ZSTD_btopt</name> <operator>&amp;&amp;</operator> <name><name>cParams</name><operator>-&gt;</operator><name>windowLog</name></name> <operator>&gt;=</operator> <literal type="number">27</literal><operator>)</operator></expr> ?</condition><then> <expr><name>ZSTD_ps_enable</name></expr> </then><else>: <expr><name>ZSTD_ps_disable</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Returns 1 if compression parameters are such that CDict hashtable and chaintable indices are tagged.
 * If so, the tags need to be removed in ZSTD_resetCCtx_byCopyingCDict. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ZSTD_CDictIndicesAreTagged</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ZSTD_compressionParameters</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cParams</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><name><name>cParams</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>ZSTD_fast</name> <operator>||</operator> <name><name>cParams</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>ZSTD_dfast</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ZSTD_CCtx_params</name></type> <name>ZSTD_makeCCtxParamsFromCParams</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_compressionParameters</name></type> <name>cParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_CCtx_params</name></type> <name>cctxParams</name></decl>;</decl_stmt>
    <comment type="block">/* should not matter, as all cParams are presumed properly defined */</comment>
    <expr_stmt><expr><call><name>ZSTD_CCtxParams_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cctxParams</name></expr></argument>, <argument><expr><name>ZSTD_CLEVEL_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctxParams</name><operator>.</operator><name>cParams</name></name> <operator>=</operator> <name>cParams</name></expr>;</expr_stmt>

    <comment type="block">/* Adjust advanced params according to cParams */</comment>
    <expr_stmt><expr><name><name>cctxParams</name><operator>.</operator><name>ldmParams</name><operator>.</operator><name>enableLdm</name></name> <operator>=</operator> <call><name>ZSTD_resolveEnableLdm</name><argument_list>(<argument><expr><name><name>cctxParams</name><operator>.</operator><name>ldmParams</name><operator>.</operator><name>enableLdm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cctxParams</name><operator>.</operator><name>ldmParams</name><operator>.</operator><name>enableLdm</name></name> <operator>==</operator> <name>ZSTD_ps_enable</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>ZSTD_ldm_adjustParameters</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctxParams</name><operator>.</operator><name>ldmParams</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cctxParams</name><operator>.</operator><name>ldmParams</name><operator>.</operator><name>hashLog</name></name> <operator>&gt;=</operator> <name><name>cctxParams</name><operator>.</operator><name>ldmParams</name><operator>.</operator><name>bucketSizeLog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cctxParams</name><operator>.</operator><name>ldmParams</name><operator>.</operator><name>hashRateLog</name></name> <operator>&lt;</operator> <literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>cctxParams</name><operator>.</operator><name>useBlockSplitter</name></name> <operator>=</operator> <call><name>ZSTD_resolveBlockSplitterMode</name><argument_list>(<argument><expr><name><name>cctxParams</name><operator>.</operator><name>useBlockSplitter</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctxParams</name><operator>.</operator><name>useRowMatchFinder</name></name> <operator>=</operator> <call><name>ZSTD_resolveRowMatchFinderMode</name><argument_list>(<argument><expr><name><name>cctxParams</name><operator>.</operator><name>useRowMatchFinder</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ZSTD_checkCParams</name><argument_list>(<argument><expr><name>cParams</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>cctxParams</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>ZSTD_createCCtxParams_advanced</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_customMem</name></type> <name>customMem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>params</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name><name>customMem</name><operator>.</operator><name>customAlloc</name></name><operator>)</operator> <operator>^</operator> <operator>(</operator><operator>!</operator><name><name>customMem</name><operator>.</operator><name>customFree</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>params</name> <operator>=</operator> <operator>(</operator><name>ZSTD_CCtx_params</name><operator>*</operator><operator>)</operator><call><name>ZSTD_customCalloc</name><argument_list>(
            <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_CCtx_params</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>customMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>params</name></expr>)</condition> <block>{<block_content> <return>return <expr><name>NULL</name></expr>;</return> </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>ZSTD_CCtxParams_init</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>ZSTD_CLEVEL_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>customMem</name></name> <operator>=</operator> <name>customMem</name></expr>;</expr_stmt>
    <return>return <expr><name>params</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>ZSTD_createCCtxParams</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_createCCtxParams_advanced</name><argument_list>(<argument><expr><name>ZSTD_defaultCMem</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_freeCCtxParams</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>params</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content> <return>return <expr><literal type="number">0</literal></expr>;</return> </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>ZSTD_customFree</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>customMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_CCtxParams_reset</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_CCtxParams_init</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>ZSTD_CLEVEL_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_CCtxParams_init</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>cctxParams</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compressionLevel</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><operator>!</operator><name>cctxParams</name></expr></argument>, <argument><expr><name>GENERIC</name></expr></argument>, <argument><expr><literal type="string">"NULL pointer!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><name>cctxParams</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>cctxParams</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctxParams</name><operator>-&gt;</operator><name>compressionLevel</name></name> <operator>=</operator> <name>compressionLevel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctxParams</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>contentSizeFlag</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZSTD_NO_CLEVEL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<comment type="block" format="doxygen">/**
 * Initializes the cctxParams from params and compressionLevel.
 * @param compressionLevel If params are derived from a compression level then that compression level, otherwise ZSTD_NO_CLEVEL.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_CCtxParams_init_internal</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>cctxParams</name></decl></parameter>, <parameter><decl><type><name>ZSTD_parameters</name> <specifier>const</specifier><modifier>*</modifier></type> <name>params</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compressionLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ZSTD_checkCParams</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>cParams</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><name>cctxParams</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>cctxParams</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctxParams</name><operator>-&gt;</operator><name>cParams</name></name> <operator>=</operator> <name><name>params</name><operator>-&gt;</operator><name>cParams</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctxParams</name><operator>-&gt;</operator><name>fParams</name></name> <operator>=</operator> <name><name>params</name><operator>-&gt;</operator><name>fParams</name></name></expr>;</expr_stmt>
    <comment type="block">/* Should not matter, as all cParams are presumed properly defined.
     * But, set it for tracing anyway.
     */</comment>
    <expr_stmt><expr><name><name>cctxParams</name><operator>-&gt;</operator><name>compressionLevel</name></name> <operator>=</operator> <name>compressionLevel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctxParams</name><operator>-&gt;</operator><name>useRowMatchFinder</name></name> <operator>=</operator> <call><name>ZSTD_resolveRowMatchFinderMode</name><argument_list>(<argument><expr><name><name>cctxParams</name><operator>-&gt;</operator><name>useRowMatchFinder</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>params</name><operator>-&gt;</operator><name>cParams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctxParams</name><operator>-&gt;</operator><name>useBlockSplitter</name></name> <operator>=</operator> <call><name>ZSTD_resolveBlockSplitterMode</name><argument_list>(<argument><expr><name><name>cctxParams</name><operator>-&gt;</operator><name>useBlockSplitter</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>params</name><operator>-&gt;</operator><name>cParams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctxParams</name><operator>-&gt;</operator><name>ldmParams</name><operator>.</operator><name>enableLdm</name></name> <operator>=</operator> <call><name>ZSTD_resolveEnableLdm</name><argument_list>(<argument><expr><name><name>cctxParams</name><operator>-&gt;</operator><name>ldmParams</name><operator>.</operator><name>enableLdm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>params</name><operator>-&gt;</operator><name>cParams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_CCtxParams_init_internal: useRowMatchFinder=%d, useBlockSplitter=%d ldm=%d"</literal></expr></argument>,
                <argument><expr><name><name>cctxParams</name><operator>-&gt;</operator><name>useRowMatchFinder</name></name></expr></argument>, <argument><expr><name><name>cctxParams</name><operator>-&gt;</operator><name>useBlockSplitter</name></name></expr></argument>, <argument><expr><name><name>cctxParams</name><operator>-&gt;</operator><name>ldmParams</name><operator>.</operator><name>enableLdm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_CCtxParams_init_advanced</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>cctxParams</name></decl></parameter>, <parameter><decl><type><name>ZSTD_parameters</name></type> <name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><operator>!</operator><name>cctxParams</name></expr></argument>, <argument><expr><name>GENERIC</name></expr></argument>, <argument><expr><literal type="string">"NULL pointer!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_checkCParams</name><argument_list>(<argument><expr><name><name>params</name><operator>.</operator><name>cParams</name></name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_CCtxParams_init_internal</name><argument_list>(<argument><expr><name>cctxParams</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><name>ZSTD_NO_CLEVEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Sets cctxParams' cParams and fParams from params, but otherwise leaves them alone.
 * @param param Validated zstd parameters.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_CCtxParams_setZstdParams</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>cctxParams</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ZSTD_parameters</name><modifier>*</modifier></type> <name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ZSTD_checkCParams</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>cParams</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctxParams</name><operator>-&gt;</operator><name>cParams</name></name> <operator>=</operator> <name><name>params</name><operator>-&gt;</operator><name>cParams</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctxParams</name><operator>-&gt;</operator><name>fParams</name></name> <operator>=</operator> <name><name>params</name><operator>-&gt;</operator><name>fParams</name></name></expr>;</expr_stmt>
    <comment type="block">/* Should not matter, as all cParams are presumed properly defined.
     * But, set it for tracing anyway.
     */</comment>
    <expr_stmt><expr><name><name>cctxParams</name><operator>-&gt;</operator><name>compressionLevel</name></name> <operator>=</operator> <name>ZSTD_NO_CLEVEL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>ZSTD_bounds</name></type> <name>ZSTD_cParam_getBounds</name><parameter_list>(<parameter><decl><type><name>ZSTD_cParameter</name></type> <name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_bounds</name></type> <name>bounds</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

    <switch>switch<condition>(<expr><name>param</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>ZSTD_c_compressionLevel</name></expr>:</case>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <call><name>ZSTD_minCLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <call><name>ZSTD_maxCLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>bounds</name></expr>;</return>

    <case>case <expr><name>ZSTD_c_windowLog</name></expr>:</case>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <name>ZSTD_WINDOWLOG_MIN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <name>ZSTD_WINDOWLOG_MAX</name></expr>;</expr_stmt>
        <return>return <expr><name>bounds</name></expr>;</return>

    <case>case <expr><name>ZSTD_c_hashLog</name></expr>:</case>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <name>ZSTD_HASHLOG_MIN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <name>ZSTD_HASHLOG_MAX</name></expr>;</expr_stmt>
        <return>return <expr><name>bounds</name></expr>;</return>

    <case>case <expr><name>ZSTD_c_chainLog</name></expr>:</case>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <name>ZSTD_CHAINLOG_MIN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <name>ZSTD_CHAINLOG_MAX</name></expr>;</expr_stmt>
        <return>return <expr><name>bounds</name></expr>;</return>

    <case>case <expr><name>ZSTD_c_searchLog</name></expr>:</case>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <name>ZSTD_SEARCHLOG_MIN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <name>ZSTD_SEARCHLOG_MAX</name></expr>;</expr_stmt>
        <return>return <expr><name>bounds</name></expr>;</return>

    <case>case <expr><name>ZSTD_c_minMatch</name></expr>:</case>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <name>ZSTD_MINMATCH_MIN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <name>ZSTD_MINMATCH_MAX</name></expr>;</expr_stmt>
        <return>return <expr><name>bounds</name></expr>;</return>

    <case>case <expr><name>ZSTD_c_targetLength</name></expr>:</case>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <name>ZSTD_TARGETLENGTH_MIN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <name>ZSTD_TARGETLENGTH_MAX</name></expr>;</expr_stmt>
        <return>return <expr><name>bounds</name></expr>;</return>

    <case>case <expr><name>ZSTD_c_strategy</name></expr>:</case>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <name>ZSTD_STRATEGY_MIN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <name>ZSTD_STRATEGY_MAX</name></expr>;</expr_stmt>
        <return>return <expr><name>bounds</name></expr>;</return>

    <case>case <expr><name>ZSTD_c_contentSizeFlag</name></expr>:</case>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <return>return <expr><name>bounds</name></expr>;</return>

    <case>case <expr><name>ZSTD_c_checksumFlag</name></expr>:</case>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <return>return <expr><name>bounds</name></expr>;</return>

    <case>case <expr><name>ZSTD_c_dictIDFlag</name></expr>:</case>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <return>return <expr><name>bounds</name></expr>;</return>

    <case>case <expr><name>ZSTD_c_nbWorkers</name></expr>:</case>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ZSTD_MULTITHREAD</name></cpp:ifdef>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <name>ZSTDMT_NBWORKERS_MAX</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return <expr><name>bounds</name></expr>;</return>

    <case>case <expr><name>ZSTD_c_jobSize</name></expr>:</case>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ZSTD_MULTITHREAD</name></cpp:ifdef>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <name>ZSTDMT_JOBSIZE_MAX</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return <expr><name>bounds</name></expr>;</return>

    <case>case <expr><name>ZSTD_c_overlapLog</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ZSTD_MULTITHREAD</name></cpp:ifdef>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <name>ZSTD_OVERLAPLOG_MIN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <name>ZSTD_OVERLAPLOG_MAX</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return <expr><name>bounds</name></expr>;</return>

    <case>case <expr><name>ZSTD_c_enableDedicatedDictSearch</name></expr>:</case>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <return>return <expr><name>bounds</name></expr>;</return>

    <case>case <expr><name>ZSTD_c_enableLongDistanceMatching</name></expr>:</case>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <return>return <expr><name>bounds</name></expr>;</return>

    <case>case <expr><name>ZSTD_c_ldmHashLog</name></expr>:</case>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <name>ZSTD_LDM_HASHLOG_MIN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <name>ZSTD_LDM_HASHLOG_MAX</name></expr>;</expr_stmt>
        <return>return <expr><name>bounds</name></expr>;</return>

    <case>case <expr><name>ZSTD_c_ldmMinMatch</name></expr>:</case>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <name>ZSTD_LDM_MINMATCH_MIN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <name>ZSTD_LDM_MINMATCH_MAX</name></expr>;</expr_stmt>
        <return>return <expr><name>bounds</name></expr>;</return>

    <case>case <expr><name>ZSTD_c_ldmBucketSizeLog</name></expr>:</case>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <name>ZSTD_LDM_BUCKETSIZELOG_MIN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <name>ZSTD_LDM_BUCKETSIZELOG_MAX</name></expr>;</expr_stmt>
        <return>return <expr><name>bounds</name></expr>;</return>

    <case>case <expr><name>ZSTD_c_ldmHashRateLog</name></expr>:</case>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <name>ZSTD_LDM_HASHRATELOG_MIN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <name>ZSTD_LDM_HASHRATELOG_MAX</name></expr>;</expr_stmt>
        <return>return <expr><name>bounds</name></expr>;</return>

    <comment type="block">/* experimental parameters */</comment>
    <case>case <expr><name>ZSTD_c_rsyncable</name></expr>:</case>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <return>return <expr><name>bounds</name></expr>;</return>

    <case>case <expr><name>ZSTD_c_forceMaxWindow</name></expr> :</case>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <return>return <expr><name>bounds</name></expr>;</return>

    <case>case <expr><name>ZSTD_c_format</name></expr>:</case>
        <expr_stmt><expr><call><name>ZSTD_STATIC_ASSERT</name><argument_list>(<argument><expr><name>ZSTD_f_zstd1</name> <operator>&lt;</operator> <name>ZSTD_f_zstd1_magicless</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <name>ZSTD_f_zstd1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <name>ZSTD_f_zstd1_magicless</name></expr>;</expr_stmt>   <comment type="block">/* note : how to ensure at compile time that this is the highest value enum ? */</comment>
        <return>return <expr><name>bounds</name></expr>;</return>

    <case>case <expr><name>ZSTD_c_forceAttachDict</name></expr>:</case>
        <expr_stmt><expr><call><name>ZSTD_STATIC_ASSERT</name><argument_list>(<argument><expr><name>ZSTD_dictDefaultAttach</name> <operator>&lt;</operator> <name>ZSTD_dictForceLoad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <name>ZSTD_dictDefaultAttach</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <name>ZSTD_dictForceLoad</name></expr>;</expr_stmt>       <comment type="block">/* note : how to ensure at compile time that this is the highest value enum ? */</comment>
        <return>return <expr><name>bounds</name></expr>;</return>

    <case>case <expr><name>ZSTD_c_literalCompressionMode</name></expr>:</case>
        <expr_stmt><expr><call><name>ZSTD_STATIC_ASSERT</name><argument_list>(<argument><expr><name>ZSTD_ps_auto</name> <operator>&lt;</operator> <name>ZSTD_ps_enable</name> <operator>&amp;&amp;</operator> <name>ZSTD_ps_enable</name> <operator>&lt;</operator> <name>ZSTD_ps_disable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>ZSTD_ps_auto</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>ZSTD_ps_disable</name></expr>;</expr_stmt>
        <return>return <expr><name>bounds</name></expr>;</return>

    <case>case <expr><name>ZSTD_c_targetCBlockSize</name></expr>:</case>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <name>ZSTD_TARGETCBLOCKSIZE_MIN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <name>ZSTD_TARGETCBLOCKSIZE_MAX</name></expr>;</expr_stmt>
        <return>return <expr><name>bounds</name></expr>;</return>

    <case>case <expr><name>ZSTD_c_srcSizeHint</name></expr>:</case>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <name>ZSTD_SRCSIZEHINT_MIN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <name>ZSTD_SRCSIZEHINT_MAX</name></expr>;</expr_stmt>
        <return>return <expr><name>bounds</name></expr>;</return>

    <case>case <expr><name>ZSTD_c_stableInBuffer</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_stableOutBuffer</name></expr>:</case>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>ZSTD_bm_buffered</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>ZSTD_bm_stable</name></expr>;</expr_stmt>
        <return>return <expr><name>bounds</name></expr>;</return>

    <case>case <expr><name>ZSTD_c_blockDelimiters</name></expr>:</case>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>ZSTD_sf_noBlockDelimiters</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>ZSTD_sf_explicitBlockDelimiters</name></expr>;</expr_stmt>
        <return>return <expr><name>bounds</name></expr>;</return>

    <case>case <expr><name>ZSTD_c_validateSequences</name></expr>:</case>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <return>return <expr><name>bounds</name></expr>;</return>

    <case>case <expr><name>ZSTD_c_useBlockSplitter</name></expr>:</case>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>ZSTD_ps_auto</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>ZSTD_ps_disable</name></expr>;</expr_stmt>
        <return>return <expr><name>bounds</name></expr>;</return>

    <case>case <expr><name>ZSTD_c_useRowMatchFinder</name></expr>:</case>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>ZSTD_ps_auto</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>ZSTD_ps_disable</name></expr>;</expr_stmt>
        <return>return <expr><name>bounds</name></expr>;</return>

    <case>case <expr><name>ZSTD_c_deterministicRefPrefix</name></expr>:</case>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <return>return <expr><name>bounds</name></expr>;</return>

    <case>case <expr><name>ZSTD_c_prefetchCDictTables</name></expr>:</case>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>lowerBound</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>ZSTD_ps_auto</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>upperBound</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>ZSTD_ps_disable</name></expr>;</expr_stmt>
        <return>return <expr><name>bounds</name></expr>;</return>

    <default>default:</default>
        <expr_stmt><expr><name><name>bounds</name><operator>.</operator><name>error</name></name> <operator>=</operator> <call><name>ERROR</name><argument_list>(<argument><expr><name>parameter_unsupported</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>bounds</name></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* ZSTD_cParam_clampBounds:
 * Clamps the value into the bounded range.
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_cParam_clampBounds</name><parameter_list>(<parameter><decl><type><name>ZSTD_cParameter</name></type> <name>cParam</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_bounds</name> <specifier>const</specifier></type> <name>bounds</name> <init>= <expr><call><name>ZSTD_cParam_getBounds</name><argument_list>(<argument><expr><name>cParam</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name><name>bounds</name><operator>.</operator><name>error</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name><name>bounds</name><operator>.</operator><name>error</name></name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>value</name> <operator>&lt;</operator> <name><name>bounds</name><operator>.</operator><name>lowerBound</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name><name>bounds</name><operator>.</operator><name>lowerBound</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>value</name> <operator>&gt;</operator> <name><name>bounds</name><operator>.</operator><name>upperBound</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name><name>bounds</name><operator>.</operator><name>upperBound</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BOUNDCHECK</name><parameter_list>(<parameter><type><name>cParam</name></type></parameter>, <parameter><type><name>val</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ \
    RETURN_ERROR_IF(!ZSTD_cParam_withinBounds(cParam,val), \
                    parameter_outOfBound, "Param out of bounds"); \
}</cpp:value></cpp:define>


<function><type><specifier>static</specifier> <name>int</name></type> <name>ZSTD_isUpdateAuthorized</name><parameter_list>(<parameter><decl><type><name>ZSTD_cParameter</name></type> <name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch<condition>(<expr><name>param</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>ZSTD_c_compressionLevel</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_hashLog</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_chainLog</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_searchLog</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_minMatch</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_targetLength</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_strategy</name></expr>:</case>
        <return>return <expr><literal type="number">1</literal></expr>;</return>

    <case>case <expr><name>ZSTD_c_format</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_windowLog</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_contentSizeFlag</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_checksumFlag</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_dictIDFlag</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_forceMaxWindow</name></expr> :</case>
    <case>case <expr><name>ZSTD_c_nbWorkers</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_jobSize</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_overlapLog</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_rsyncable</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_enableDedicatedDictSearch</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_enableLongDistanceMatching</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_ldmHashLog</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_ldmMinMatch</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_ldmBucketSizeLog</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_ldmHashRateLog</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_forceAttachDict</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_literalCompressionMode</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_targetCBlockSize</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_srcSizeHint</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_stableInBuffer</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_stableOutBuffer</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_blockDelimiters</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_validateSequences</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_useBlockSplitter</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_useRowMatchFinder</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_deterministicRefPrefix</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_prefetchCDictTables</name></expr>:</case>
    <default>default:</default>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_CCtx_setParameter</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>, <parameter><decl><type><name>ZSTD_cParameter</name></type> <name>param</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_CCtx_setParameter (%i, %i)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>param</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>!=</operator> <name>zcss_init</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isUpdateAuthorized</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>cParamsChanged</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr><name>stage_wrong</name></expr></argument>, <argument><expr><literal type="string">"can only set params in ctx init stage"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>   </block_content>}</block></if></if_stmt>

    <switch>switch<condition>(<expr><name>param</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>ZSTD_c_nbWorkers</name></expr>:</case>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><operator>(</operator><name>value</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>cctx</name><operator>-&gt;</operator><name>staticSize</name></name></expr></argument>, <argument><expr><name>parameter_unsupported</name></expr></argument>,
                        <argument><expr><literal type="string">"MT not compatible with static alloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

    <case>case <expr><name>ZSTD_c_compressionLevel</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_windowLog</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_hashLog</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_chainLog</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_searchLog</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_minMatch</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_targetLength</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_strategy</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_ldmHashRateLog</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_format</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_contentSizeFlag</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_checksumFlag</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_dictIDFlag</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_forceMaxWindow</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_forceAttachDict</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_literalCompressionMode</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_jobSize</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_overlapLog</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_rsyncable</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_enableDedicatedDictSearch</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_enableLongDistanceMatching</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_ldmHashLog</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_ldmMinMatch</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_ldmBucketSizeLog</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_targetCBlockSize</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_srcSizeHint</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_stableInBuffer</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_stableOutBuffer</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_blockDelimiters</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_validateSequences</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_useBlockSplitter</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_useRowMatchFinder</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_deterministicRefPrefix</name></expr>:</case>
    <case>case <expr><name>ZSTD_c_prefetchCDictTables</name></expr>:</case>
        <break>break;</break>

    <default>default:</default> <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr><name>parameter_unsupported</name></expr></argument>, <argument><expr><literal type="string">"unknown parameter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
    <return>return <expr><call><name>ZSTD_CCtxParams_setParameter</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>requestedParams</name></name></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_CCtxParams_setParameter</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>CCtxParams</name></decl></parameter>,
                                    <parameter><decl><type><name>ZSTD_cParameter</name></type> <name>param</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_CCtxParams_setParameter (%i, %i)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>param</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch<condition>(<expr><name>param</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>ZSTD_c_format</name></expr> :</case>
        <expr_stmt><expr><call><name>BOUNDCHECK</name><argument_list>(<argument><expr><name>ZSTD_c_format</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <operator>(</operator><name>ZSTD_format_e</name><operator>)</operator><name>value</name></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>CCtxParams</name><operator>-&gt;</operator><name>format</name></name></expr>;</return>

    <case>case <expr><name>ZSTD_c_compressionLevel</name></expr> :</case> <block>{<block_content>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_cParam_clampBounds</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>compressionLevel</name></name> <operator>=</operator> <name>ZSTD_CLEVEL_DEFAULT</name></expr>;</expr_stmt></block_content></block></if> <comment type="block">/* 0 == default */</comment>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>compressionLevel</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>compressionLevel</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>CCtxParams</name><operator>-&gt;</operator><name>compressionLevel</name></name></expr>;</return></block_content></block></if></if_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* return type (size_t) cannot represent negative values */</comment>
    </block_content>}</block>

    <case>case <expr><name>ZSTD_c_windowLog</name></expr> :</case>
        <if_stmt><if>if <condition>(<expr><name>value</name><operator>!=</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>   <comment type="block">/* 0 =&gt; use default */</comment>
            <expr_stmt><expr><call><name>BOUNDCHECK</name><argument_list>(<argument><expr><name>ZSTD_c_windowLog</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>windowLog</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>value</name></expr>;</expr_stmt>
        <return>return <expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>windowLog</name></name></expr>;</return>

    <case>case <expr><name>ZSTD_c_hashLog</name></expr> :</case>
        <if_stmt><if>if <condition>(<expr><name>value</name><operator>!=</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>   <comment type="block">/* 0 =&gt; use default */</comment>
            <expr_stmt><expr><call><name>BOUNDCHECK</name><argument_list>(<argument><expr><name>ZSTD_c_hashLog</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>hashLog</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>value</name></expr>;</expr_stmt>
        <return>return <expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>hashLog</name></name></expr>;</return>

    <case>case <expr><name>ZSTD_c_chainLog</name></expr> :</case>
        <if_stmt><if>if <condition>(<expr><name>value</name><operator>!=</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>   <comment type="block">/* 0 =&gt; use default */</comment>
            <expr_stmt><expr><call><name>BOUNDCHECK</name><argument_list>(<argument><expr><name>ZSTD_c_chainLog</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>chainLog</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>value</name></expr>;</expr_stmt>
        <return>return <expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>chainLog</name></name></expr>;</return>

    <case>case <expr><name>ZSTD_c_searchLog</name></expr> :</case>
        <if_stmt><if>if <condition>(<expr><name>value</name><operator>!=</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>   <comment type="block">/* 0 =&gt; use default */</comment>
            <expr_stmt><expr><call><name>BOUNDCHECK</name><argument_list>(<argument><expr><name>ZSTD_c_searchLog</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>searchLog</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>value</name></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><name>value</name></expr>;</return>

    <case>case <expr><name>ZSTD_c_minMatch</name></expr> :</case>
        <if_stmt><if>if <condition>(<expr><name>value</name><operator>!=</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>   <comment type="block">/* 0 =&gt; use default */</comment>
            <expr_stmt><expr><call><name>BOUNDCHECK</name><argument_list>(<argument><expr><name>ZSTD_c_minMatch</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>minMatch</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>value</name></expr>;</expr_stmt>
        <return>return <expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>minMatch</name></name></expr>;</return>

    <case>case <expr><name>ZSTD_c_targetLength</name></expr> :</case>
        <expr_stmt><expr><call><name>BOUNDCHECK</name><argument_list>(<argument><expr><name>ZSTD_c_targetLength</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>targetLength</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>value</name></expr>;</expr_stmt>
        <return>return <expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>targetLength</name></name></expr>;</return>

    <case>case <expr><name>ZSTD_c_strategy</name></expr> :</case>
        <if_stmt><if>if <condition>(<expr><name>value</name><operator>!=</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>   <comment type="block">/* 0 =&gt; use default */</comment>
            <expr_stmt><expr><call><name>BOUNDCHECK</name><argument_list>(<argument><expr><name>ZSTD_c_strategy</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>strategy</name></name> <operator>=</operator> <operator>(</operator><name>ZSTD_strategy</name><operator>)</operator><name>value</name></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>CCtxParams</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>strategy</name></name></expr>;</return>

    <case>case <expr><name>ZSTD_c_contentSizeFlag</name></expr> :</case>
        <comment type="block">/* Content size written in frame header _when known_ (default:1) */</comment>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"set content size flag = %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>value</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>contentSizeFlag</name></name> <operator>=</operator> <name>value</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>CCtxParams</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>contentSizeFlag</name></name></expr>;</return>

    <case>case <expr><name>ZSTD_c_checksumFlag</name></expr> :</case>
        <comment type="block">/* A 32-bits content checksum will be calculated and written at end of frame (default:0) */</comment>
        <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>checksumFlag</name></name> <operator>=</operator> <name>value</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>CCtxParams</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>checksumFlag</name></name></expr>;</return>

    <case>case <expr><name>ZSTD_c_dictIDFlag</name></expr> :</case> <comment type="block">/* When applicable, dictionary's dictID is provided in frame header (default:1) */</comment>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"set dictIDFlag = %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>value</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>noDictIDFlag</name></name> <operator>=</operator> <operator>!</operator><name>value</name></expr>;</expr_stmt>
        <return>return <expr><operator>!</operator><name><name>CCtxParams</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>noDictIDFlag</name></name></expr>;</return>

    <case>case <expr><name>ZSTD_c_forceMaxWindow</name></expr> :</case>
        <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>forceWindow</name></name> <operator>=</operator> <operator>(</operator><name>value</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>CCtxParams</name><operator>-&gt;</operator><name>forceWindow</name></name></expr>;</return>

    <case>case <expr><name>ZSTD_c_forceAttachDict</name></expr> :</case> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_dictAttachPref_e</name></type> <name>pref</name> <init>= <expr><operator>(</operator><name>ZSTD_dictAttachPref_e</name><operator>)</operator><name>value</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>BOUNDCHECK</name><argument_list>(<argument><expr><name>ZSTD_c_forceAttachDict</name></expr></argument>, <argument><expr><name>pref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>attachDictPref</name></name> <operator>=</operator> <name>pref</name></expr>;</expr_stmt>
        <return>return <expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>attachDictPref</name></name></expr>;</return>
    </block_content>}</block>

    <case>case <expr><name>ZSTD_c_literalCompressionMode</name></expr> :</case> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_paramSwitch_e</name></type> <name>lcm</name> <init>= <expr><operator>(</operator><name>ZSTD_paramSwitch_e</name><operator>)</operator><name>value</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>BOUNDCHECK</name><argument_list>(<argument><expr><name>ZSTD_c_literalCompressionMode</name></expr></argument>, <argument><expr><name>lcm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>literalCompressionMode</name></name> <operator>=</operator> <name>lcm</name></expr>;</expr_stmt>
        <return>return <expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>literalCompressionMode</name></name></expr>;</return>
    </block_content>}</block>

    <case>case <expr><name>ZSTD_c_nbWorkers</name></expr> :</case>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ZSTD_MULTITHREAD</name></cpp:ifndef>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>value</name><operator>!=</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>parameter_unsupported</name></expr></argument>, <argument><expr><literal type="string">"not compiled with multithreading"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_cParam_clampBounds</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>nbWorkers</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
        <return>return <expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>nbWorkers</name></name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <case>case <expr><name>ZSTD_c_jobSize</name></expr> :</case>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ZSTD_MULTITHREAD</name></cpp:ifndef>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>value</name><operator>!=</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>parameter_unsupported</name></expr></argument>, <argument><expr><literal type="string">"not compiled with multithreading"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <comment type="block">/* Adjust to the minimum non-default value. */</comment>
        <if_stmt><if>if <condition>(<expr><name>value</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>value</name> <operator>&lt;</operator> <name>ZSTDMT_JOBSIZE_MIN</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>value</name> <operator>=</operator> <name>ZSTDMT_JOBSIZE_MIN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_cParam_clampBounds</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>value</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>jobSize</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
        <return>return <expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>jobSize</name></name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <case>case <expr><name>ZSTD_c_overlapLog</name></expr> :</case>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ZSTD_MULTITHREAD</name></cpp:ifndef>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>value</name><operator>!=</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>parameter_unsupported</name></expr></argument>, <argument><expr><literal type="string">"not compiled with multithreading"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_cParam_clampBounds</name><argument_list>(<argument><expr><name>ZSTD_c_overlapLog</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>overlapLog</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
        <return>return <expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>overlapLog</name></name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <case>case <expr><name>ZSTD_c_rsyncable</name></expr> :</case>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ZSTD_MULTITHREAD</name></cpp:ifndef>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>value</name><operator>!=</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>parameter_unsupported</name></expr></argument>, <argument><expr><literal type="string">"not compiled with multithreading"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_cParam_clampBounds</name><argument_list>(<argument><expr><name>ZSTD_c_overlapLog</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>rsyncable</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
        <return>return <expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>rsyncable</name></name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <case>case <expr><name>ZSTD_c_enableDedicatedDictSearch</name></expr> :</case>
        <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>enableDedicatedDictSearch</name></name> <operator>=</operator> <operator>(</operator><name>value</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>CCtxParams</name><operator>-&gt;</operator><name>enableDedicatedDictSearch</name></name></expr>;</return>

    <case>case <expr><name>ZSTD_c_enableLongDistanceMatching</name></expr> :</case>
        <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>ldmParams</name><operator>.</operator><name>enableLdm</name></name> <operator>=</operator> <operator>(</operator><name>ZSTD_paramSwitch_e</name><operator>)</operator><name>value</name></expr>;</expr_stmt>
        <return>return <expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>ldmParams</name><operator>.</operator><name>enableLdm</name></name></expr>;</return>

    <case>case <expr><name>ZSTD_c_ldmHashLog</name></expr> :</case>
        <if_stmt><if>if <condition>(<expr><name>value</name><operator>!=</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>   <comment type="block">/* 0 ==&gt; auto */</comment>
            <expr_stmt><expr><call><name>BOUNDCHECK</name><argument_list>(<argument><expr><name>ZSTD_c_ldmHashLog</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>ldmParams</name><operator>.</operator><name>hashLog</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>value</name></expr>;</expr_stmt>
        <return>return <expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>ldmParams</name><operator>.</operator><name>hashLog</name></name></expr>;</return>

    <case>case <expr><name>ZSTD_c_ldmMinMatch</name></expr> :</case>
        <if_stmt><if>if <condition>(<expr><name>value</name><operator>!=</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>   <comment type="block">/* 0 ==&gt; default */</comment>
            <expr_stmt><expr><call><name>BOUNDCHECK</name><argument_list>(<argument><expr><name>ZSTD_c_ldmMinMatch</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>ldmParams</name><operator>.</operator><name>minMatchLength</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>value</name></expr>;</expr_stmt>
        <return>return <expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>ldmParams</name><operator>.</operator><name>minMatchLength</name></name></expr>;</return>

    <case>case <expr><name>ZSTD_c_ldmBucketSizeLog</name></expr> :</case>
        <if_stmt><if>if <condition>(<expr><name>value</name><operator>!=</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>   <comment type="block">/* 0 ==&gt; default */</comment>
            <expr_stmt><expr><call><name>BOUNDCHECK</name><argument_list>(<argument><expr><name>ZSTD_c_ldmBucketSizeLog</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>ldmParams</name><operator>.</operator><name>bucketSizeLog</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>value</name></expr>;</expr_stmt>
        <return>return <expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>ldmParams</name><operator>.</operator><name>bucketSizeLog</name></name></expr>;</return>

    <case>case <expr><name>ZSTD_c_ldmHashRateLog</name></expr> :</case>
        <if_stmt><if>if <condition>(<expr><name>value</name><operator>!=</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>   <comment type="block">/* 0 ==&gt; default */</comment>
            <expr_stmt><expr><call><name>BOUNDCHECK</name><argument_list>(<argument><expr><name>ZSTD_c_ldmHashRateLog</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>ldmParams</name><operator>.</operator><name>hashRateLog</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>value</name></expr>;</expr_stmt>
        <return>return <expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>ldmParams</name><operator>.</operator><name>hashRateLog</name></name></expr>;</return>

    <case>case <expr><name>ZSTD_c_targetCBlockSize</name></expr> :</case>
        <if_stmt><if>if <condition>(<expr><name>value</name><operator>!=</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>   <comment type="block">/* 0 ==&gt; default */</comment>
            <expr_stmt><expr><call><name>BOUNDCHECK</name><argument_list>(<argument><expr><name>ZSTD_c_targetCBlockSize</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>targetCBlockSize</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>value</name></expr>;</expr_stmt>
        <return>return <expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>targetCBlockSize</name></name></expr>;</return>

    <case>case <expr><name>ZSTD_c_srcSizeHint</name></expr> :</case>
        <if_stmt><if>if <condition>(<expr><name>value</name><operator>!=</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* 0 ==&gt; default */</comment>
            <expr_stmt><expr><call><name>BOUNDCHECK</name><argument_list>(<argument><expr><name>ZSTD_c_srcSizeHint</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>srcSizeHint</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>CCtxParams</name><operator>-&gt;</operator><name>srcSizeHint</name></name></expr>;</return>

    <case>case <expr><name>ZSTD_c_stableInBuffer</name></expr>:</case>
        <expr_stmt><expr><call><name>BOUNDCHECK</name><argument_list>(<argument><expr><name>ZSTD_c_stableInBuffer</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>inBufferMode</name></name> <operator>=</operator> <operator>(</operator><name>ZSTD_bufferMode_e</name><operator>)</operator><name>value</name></expr>;</expr_stmt>
        <return>return <expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>inBufferMode</name></name></expr>;</return>

    <case>case <expr><name>ZSTD_c_stableOutBuffer</name></expr>:</case>
        <expr_stmt><expr><call><name>BOUNDCHECK</name><argument_list>(<argument><expr><name>ZSTD_c_stableOutBuffer</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>outBufferMode</name></name> <operator>=</operator> <operator>(</operator><name>ZSTD_bufferMode_e</name><operator>)</operator><name>value</name></expr>;</expr_stmt>
        <return>return <expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>outBufferMode</name></name></expr>;</return>

    <case>case <expr><name>ZSTD_c_blockDelimiters</name></expr>:</case>
        <expr_stmt><expr><call><name>BOUNDCHECK</name><argument_list>(<argument><expr><name>ZSTD_c_blockDelimiters</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>blockDelimiters</name></name> <operator>=</operator> <operator>(</operator><name>ZSTD_sequenceFormat_e</name><operator>)</operator><name>value</name></expr>;</expr_stmt>
        <return>return <expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>blockDelimiters</name></name></expr>;</return>

    <case>case <expr><name>ZSTD_c_validateSequences</name></expr>:</case>
        <expr_stmt><expr><call><name>BOUNDCHECK</name><argument_list>(<argument><expr><name>ZSTD_c_validateSequences</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>validateSequences</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
        <return>return <expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>validateSequences</name></name></expr>;</return>

    <case>case <expr><name>ZSTD_c_useBlockSplitter</name></expr>:</case>
        <expr_stmt><expr><call><name>BOUNDCHECK</name><argument_list>(<argument><expr><name>ZSTD_c_useBlockSplitter</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>useBlockSplitter</name></name> <operator>=</operator> <operator>(</operator><name>ZSTD_paramSwitch_e</name><operator>)</operator><name>value</name></expr>;</expr_stmt>
        <return>return <expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>useBlockSplitter</name></name></expr>;</return>

    <case>case <expr><name>ZSTD_c_useRowMatchFinder</name></expr>:</case>
        <expr_stmt><expr><call><name>BOUNDCHECK</name><argument_list>(<argument><expr><name>ZSTD_c_useRowMatchFinder</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>useRowMatchFinder</name></name> <operator>=</operator> <operator>(</operator><name>ZSTD_paramSwitch_e</name><operator>)</operator><name>value</name></expr>;</expr_stmt>
        <return>return <expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>useRowMatchFinder</name></name></expr>;</return>

    <case>case <expr><name>ZSTD_c_deterministicRefPrefix</name></expr>:</case>
        <expr_stmt><expr><call><name>BOUNDCHECK</name><argument_list>(<argument><expr><name>ZSTD_c_deterministicRefPrefix</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>deterministicRefPrefix</name></name> <operator>=</operator> <operator>!</operator><operator>!</operator><name>value</name></expr>;</expr_stmt>
        <return>return <expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>deterministicRefPrefix</name></name></expr>;</return>

    <case>case <expr><name>ZSTD_c_prefetchCDictTables</name></expr>:</case>
        <expr_stmt><expr><call><name>BOUNDCHECK</name><argument_list>(<argument><expr><name>ZSTD_c_prefetchCDictTables</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>prefetchCDictTables</name></name> <operator>=</operator> <operator>(</operator><name>ZSTD_paramSwitch_e</name><operator>)</operator><name>value</name></expr>;</expr_stmt>
        <return>return <expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>prefetchCDictTables</name></name></expr>;</return>

    <default>default:</default> <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr><name>parameter_unsupported</name></expr></argument>, <argument><expr><literal type="string">"unknown parameter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_CCtx_getParameter</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name> <specifier>const</specifier><modifier>*</modifier></type> <name>cctx</name></decl></parameter>, <parameter><decl><type><name>ZSTD_cParameter</name></type> <name>param</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_CCtxParams_getParameter</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>requestedParams</name></name></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_CCtxParams_getParameter</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_CCtx_params</name> <specifier>const</specifier><modifier>*</modifier></type> <name>CCtxParams</name></decl></parameter>, <parameter><decl><type><name>ZSTD_cParameter</name></type> <name>param</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch<condition>(<expr><name>param</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>ZSTD_c_format</name></expr> :</case>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name><name>CCtxParams</name><operator>-&gt;</operator><name>format</name></name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>ZSTD_c_compressionLevel</name></expr> :</case>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name><name>CCtxParams</name><operator>-&gt;</operator><name>compressionLevel</name></name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>ZSTD_c_windowLog</name></expr> :</case>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>CCtxParams</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>windowLog</name></name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>ZSTD_c_hashLog</name></expr> :</case>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>CCtxParams</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>hashLog</name></name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>ZSTD_c_chainLog</name></expr> :</case>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>CCtxParams</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>chainLog</name></name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>ZSTD_c_searchLog</name></expr> :</case>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name><name>CCtxParams</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>searchLog</name></name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>ZSTD_c_minMatch</name></expr> :</case>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name><name>CCtxParams</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>minMatch</name></name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>ZSTD_c_targetLength</name></expr> :</case>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name><name>CCtxParams</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>targetLength</name></name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>ZSTD_c_strategy</name></expr> :</case>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name><name>CCtxParams</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>strategy</name></name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>ZSTD_c_contentSizeFlag</name></expr> :</case>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name><name>CCtxParams</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>contentSizeFlag</name></name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>ZSTD_c_checksumFlag</name></expr> :</case>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name><name>CCtxParams</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>checksumFlag</name></name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>ZSTD_c_dictIDFlag</name></expr> :</case>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <operator>!</operator><name><name>CCtxParams</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>noDictIDFlag</name></name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>ZSTD_c_forceMaxWindow</name></expr> :</case>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name><name>CCtxParams</name><operator>-&gt;</operator><name>forceWindow</name></name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>ZSTD_c_forceAttachDict</name></expr> :</case>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name><name>CCtxParams</name><operator>-&gt;</operator><name>attachDictPref</name></name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>ZSTD_c_literalCompressionMode</name></expr> :</case>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name><name>CCtxParams</name><operator>-&gt;</operator><name>literalCompressionMode</name></name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>ZSTD_c_nbWorkers</name></expr> :</case>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ZSTD_MULTITHREAD</name></cpp:ifndef>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>nbWorkers</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name><name>CCtxParams</name><operator>-&gt;</operator><name>nbWorkers</name></name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>ZSTD_c_jobSize</name></expr> :</case>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ZSTD_MULTITHREAD</name></cpp:ifndef>
        <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr><name>parameter_unsupported</name></expr></argument>, <argument><expr><literal type="string">"not compiled with multithreading"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>jobSize</name></name> <operator>&lt;=</operator> <name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>CCtxParams</name><operator>-&gt;</operator><name>jobSize</name></name></expr>;</expr_stmt>
        <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <case>case <expr><name>ZSTD_c_overlapLog</name></expr> :</case>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ZSTD_MULTITHREAD</name></cpp:ifndef>
        <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr><name>parameter_unsupported</name></expr></argument>, <argument><expr><literal type="string">"not compiled with multithreading"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name><name>CCtxParams</name><operator>-&gt;</operator><name>overlapLog</name></name></expr>;</expr_stmt>
        <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <case>case <expr><name>ZSTD_c_rsyncable</name></expr> :</case>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ZSTD_MULTITHREAD</name></cpp:ifndef>
        <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr><name>parameter_unsupported</name></expr></argument>, <argument><expr><literal type="string">"not compiled with multithreading"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name><name>CCtxParams</name><operator>-&gt;</operator><name>rsyncable</name></name></expr>;</expr_stmt>
        <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <case>case <expr><name>ZSTD_c_enableDedicatedDictSearch</name></expr> :</case>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name><name>CCtxParams</name><operator>-&gt;</operator><name>enableDedicatedDictSearch</name></name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>ZSTD_c_enableLongDistanceMatching</name></expr> :</case>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name><name>CCtxParams</name><operator>-&gt;</operator><name>ldmParams</name><operator>.</operator><name>enableLdm</name></name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>ZSTD_c_ldmHashLog</name></expr> :</case>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name><name>CCtxParams</name><operator>-&gt;</operator><name>ldmParams</name><operator>.</operator><name>hashLog</name></name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>ZSTD_c_ldmMinMatch</name></expr> :</case>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name><name>CCtxParams</name><operator>-&gt;</operator><name>ldmParams</name><operator>.</operator><name>minMatchLength</name></name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>ZSTD_c_ldmBucketSizeLog</name></expr> :</case>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name><name>CCtxParams</name><operator>-&gt;</operator><name>ldmParams</name><operator>.</operator><name>bucketSizeLog</name></name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>ZSTD_c_ldmHashRateLog</name></expr> :</case>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name><name>CCtxParams</name><operator>-&gt;</operator><name>ldmParams</name><operator>.</operator><name>hashRateLog</name></name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>ZSTD_c_targetCBlockSize</name></expr> :</case>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>CCtxParams</name><operator>-&gt;</operator><name>targetCBlockSize</name></name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>ZSTD_c_srcSizeHint</name></expr> :</case>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>CCtxParams</name><operator>-&gt;</operator><name>srcSizeHint</name></name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>ZSTD_c_stableInBuffer</name></expr> :</case>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>CCtxParams</name><operator>-&gt;</operator><name>inBufferMode</name></name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>ZSTD_c_stableOutBuffer</name></expr> :</case>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>CCtxParams</name><operator>-&gt;</operator><name>outBufferMode</name></name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>ZSTD_c_blockDelimiters</name></expr> :</case>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>CCtxParams</name><operator>-&gt;</operator><name>blockDelimiters</name></name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>ZSTD_c_validateSequences</name></expr> :</case>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>CCtxParams</name><operator>-&gt;</operator><name>validateSequences</name></name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>ZSTD_c_useBlockSplitter</name></expr> :</case>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>CCtxParams</name><operator>-&gt;</operator><name>useBlockSplitter</name></name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>ZSTD_c_useRowMatchFinder</name></expr> :</case>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>CCtxParams</name><operator>-&gt;</operator><name>useRowMatchFinder</name></name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>ZSTD_c_deterministicRefPrefix</name></expr>:</case>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>CCtxParams</name><operator>-&gt;</operator><name>deterministicRefPrefix</name></name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>ZSTD_c_prefetchCDictTables</name></expr>:</case>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>CCtxParams</name><operator>-&gt;</operator><name>prefetchCDictTables</name></name></expr>;</expr_stmt>
        <break>break;</break>
    <default>default:</default> <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr><name>parameter_unsupported</name></expr></argument>, <argument><expr><literal type="string">"unknown parameter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** ZSTD_CCtx_setParametersUsingCCtxParams() :
 *  just applies `params` into `cctx`
 *  no action is performed, parameters are merely stored.
 *  If ZSTDMT is enabled, parameters are pushed to cctx-&gt;mtctx.
 *    This is possible even if a compression is ongoing.
 *    In which case, new parameters will be applied on the fly, starting with next compression job.
 */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_CCtx_setParametersUsingCCtxParams</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_CCtx_setParametersUsingCCtxParams"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>!=</operator> <name>zcss_init</name></expr></argument>, <argument><expr><name>stage_wrong</name></expr></argument>,
                    <argument><expr><literal type="string">"The context is in the wrong stage!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>cdict</name></name></expr></argument>, <argument><expr><name>stage_wrong</name></expr></argument>,
                    <argument><expr><literal type="string">"Can't override parameters with cdict attached (some must "</literal>
                    <literal type="string">"be inherited from the cdict)."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>requestedParams</name></name> <operator>=</operator> <operator>*</operator><name>params</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_CCtx_setPledgedSrcSize</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>pledgedSrcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_CCtx_setPledgedSrcSize to %u bytes"</literal></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>pledgedSrcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>!=</operator> <name>zcss_init</name></expr></argument>, <argument><expr><name>stage_wrong</name></expr></argument>,
                    <argument><expr><literal type="string">"Can't set pledgedSrcSize when not in init stage."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>pledgedSrcSizePlusOne</name></name> <operator>=</operator> <name>pledgedSrcSize</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>ZSTD_compressionParameters</name></type> <name>ZSTD_dedicatedDictSearch_getCParams</name><parameter_list>(
        <parameter><decl><type><name>int</name> <specifier>const</specifier></type> <name>compressionLevel</name></decl></parameter>,
        <parameter><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>dictSize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ZSTD_dedicatedDictSearch_isSupported</name><parameter_list>(
        <parameter><decl><type><specifier>const</specifier> <name>ZSTD_compressionParameters</name><modifier>*</modifier></type> <name>cParams</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_dedicatedDictSearch_revertCParams</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_compressionParameters</name><modifier>*</modifier></type> <name>cParams</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/**
 * Initializes the local dict using the requested parameters.
 * NOTE: This does not use the pledged src size, because it may be used for more
 * than one compression.
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_initLocalDict</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_localDict</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dl</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>localDict</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>dl</name><operator>-&gt;</operator><name>dict</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* No local dictionary. */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dl</name><operator>-&gt;</operator><name>dictBuffer</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dl</name><operator>-&gt;</operator><name>cdict</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dl</name><operator>-&gt;</operator><name>dictSize</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>dl</name><operator>-&gt;</operator><name>cdict</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>cdict</name></name> <operator>==</operator> <name><name>dl</name><operator>-&gt;</operator><name>cdict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Local dictionary already initialized. */</comment>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dl</name><operator>-&gt;</operator><name>dictSize</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>cdict</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>prefixDict</name><operator>.</operator><name>dict</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>dl</name><operator>-&gt;</operator><name>cdict</name></name> <operator>=</operator> <call><name>ZSTD_createCDict_advanced2</name><argument_list>(
            <argument><expr><name><name>dl</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,
            <argument><expr><name><name>dl</name><operator>-&gt;</operator><name>dictSize</name></name></expr></argument>,
            <argument><expr><name>ZSTD_dlm_byRef</name></expr></argument>,
            <argument><expr><name><name>dl</name><operator>-&gt;</operator><name>dictContentType</name></name></expr></argument>,
            <argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>requestedParams</name></name></expr></argument>,
            <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>customMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><operator>!</operator><name><name>dl</name><operator>-&gt;</operator><name>cdict</name></name></expr></argument>, <argument><expr><name>memory_allocation</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_createCDict_advanced failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>cdict</name></name> <operator>=</operator> <name><name>dl</name><operator>-&gt;</operator><name>cdict</name></name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_CCtx_loadDictionary_advanced</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>,
        <parameter><decl><type><name>ZSTD_dictLoadMethod_e</name></type> <name>dictLoadMethod</name></decl></parameter>, <parameter><decl><type><name>ZSTD_dictContentType_e</name></type> <name>dictContentType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>!=</operator> <name>zcss_init</name></expr></argument>, <argument><expr><name>stage_wrong</name></expr></argument>,
                    <argument><expr><literal type="string">"Can't load a dictionary when ctx is not in init stage."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_CCtx_loadDictionary_advanced (size: %u)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>dictSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_clearAllDicts</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* in case one already exists */</comment>
    <if_stmt><if>if <condition>(<expr><name>dict</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>dictSize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* no dictionary mode */</comment>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>dictLoadMethod</name> <operator>==</operator> <name>ZSTD_dlm_byRef</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>localDict</name><operator>.</operator><name>dict</name></name> <operator>=</operator> <name>dict</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>dictBuffer</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>staticSize</name></name></expr></argument>, <argument><expr><name>memory_allocation</name></expr></argument>,
                        <argument><expr><literal type="string">"no malloc for static CCtx"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dictBuffer</name> <operator>=</operator> <call><name>ZSTD_customMalloc</name><argument_list>(<argument><expr><name>dictSize</name></expr></argument>, <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>customMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><operator>!</operator><name>dictBuffer</name></expr></argument>, <argument><expr><name>memory_allocation</name></expr></argument>, <argument><expr><literal type="string">"NULL pointer!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>dictBuffer</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>localDict</name><operator>.</operator><name>dictBuffer</name></name> <operator>=</operator> <name>dictBuffer</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>localDict</name><operator>.</operator><name>dict</name></name> <operator>=</operator> <name>dictBuffer</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>localDict</name><operator>.</operator><name>dictSize</name></name> <operator>=</operator> <name>dictSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>localDict</name><operator>.</operator><name>dictContentType</name></name> <operator>=</operator> <name>dictContentType</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_CCtx_loadDictionary_byReference</name><parameter_list>(
      <parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_CCtx_loadDictionary_advanced</name><argument_list>(
            <argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>, <argument><expr><name>ZSTD_dlm_byRef</name></expr></argument>, <argument><expr><name>ZSTD_dct_auto</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_CCtx_loadDictionary</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_CCtx_loadDictionary_advanced</name><argument_list>(
            <argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>, <argument><expr><name>ZSTD_dlm_byCopy</name></expr></argument>, <argument><expr><name>ZSTD_dct_auto</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>size_t</name></type> <name>ZSTD_CCtx_refCDict</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CDict</name><modifier>*</modifier></type> <name>cdict</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>!=</operator> <name>zcss_init</name></expr></argument>, <argument><expr><name>stage_wrong</name></expr></argument>,
                    <argument><expr><literal type="string">"Can't ref a dict when ctx not in init stage."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Free the existing local cdict (if any) to save memory. */</comment>
    <expr_stmt><expr><call><name>ZSTD_clearAllDicts</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>cdict</name></name> <operator>=</operator> <name>cdict</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_CCtx_refThreadPool</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>, <parameter><decl><type><name>ZSTD_threadPool</name><modifier>*</modifier></type> <name>pool</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>!=</operator> <name>zcss_init</name></expr></argument>, <argument><expr><name>stage_wrong</name></expr></argument>,
                    <argument><expr><literal type="string">"Can't ref a pool when ctx not in init stage."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>pool</name></name> <operator>=</operator> <name>pool</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_CCtx_refPrefix</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>prefix</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>prefixSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_CCtx_refPrefix_advanced</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>prefixSize</name></expr></argument>, <argument><expr><name>ZSTD_dct_rawContent</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_CCtx_refPrefix_advanced</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>prefix</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>prefixSize</name></decl></parameter>, <parameter><decl><type><name>ZSTD_dictContentType_e</name></type> <name>dictContentType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>!=</operator> <name>zcss_init</name></expr></argument>, <argument><expr><name>stage_wrong</name></expr></argument>,
                    <argument><expr><literal type="string">"Can't ref a prefix when ctx not in init stage."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_clearAllDicts</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>prefix</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>prefixSize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>prefixDict</name><operator>.</operator><name>dict</name></name> <operator>=</operator> <name>prefix</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>prefixDict</name><operator>.</operator><name>dictSize</name></name> <operator>=</operator> <name>prefixSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>prefixDict</name><operator>.</operator><name>dictContentType</name></name> <operator>=</operator> <name>dictContentType</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! ZSTD_CCtx_reset() :
 *  Also dumps dictionary */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_CCtx_reset</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>, <parameter><decl><type><name>ZSTD_ResetDirective</name></type> <name>reset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>( <expr><operator>(</operator><name>reset</name> <operator>==</operator> <name>ZSTD_reset_session_only</name><operator>)</operator>
      <operator>||</operator> <operator>(</operator><name>reset</name> <operator>==</operator> <name>ZSTD_reset_session_and_parameters</name><operator>)</operator></expr> )</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>=</operator> <name>zcss_init</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>pledgedSrcSizePlusOne</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>( <expr><operator>(</operator><name>reset</name> <operator>==</operator> <name>ZSTD_reset_parameters</name><operator>)</operator>
      <operator>||</operator> <operator>(</operator><name>reset</name> <operator>==</operator> <name>ZSTD_reset_session_and_parameters</name><operator>)</operator></expr> )</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>!=</operator> <name>zcss_init</name></expr></argument>, <argument><expr><name>stage_wrong</name></expr></argument>,
                        <argument><expr><literal type="string">"Can't reset parameters only when not in init stage."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_clearAllDicts</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>ZSTD_CCtxParams_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>requestedParams</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/** ZSTD_checkCParams() :
    control CParam values remain within authorized range.
    @return : 0, or an error code if one value is beyond authorized range */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_checkCParams</name><parameter_list>(<parameter><decl><type><name>ZSTD_compressionParameters</name></type> <name>cParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>BOUNDCHECK</name><argument_list>(<argument><expr><name>ZSTD_c_windowLog</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>cParams</name><operator>.</operator><name>windowLog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOUNDCHECK</name><argument_list>(<argument><expr><name>ZSTD_c_chainLog</name></expr></argument>,  <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>cParams</name><operator>.</operator><name>chainLog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOUNDCHECK</name><argument_list>(<argument><expr><name>ZSTD_c_hashLog</name></expr></argument>,   <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>cParams</name><operator>.</operator><name>hashLog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOUNDCHECK</name><argument_list>(<argument><expr><name>ZSTD_c_searchLog</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>cParams</name><operator>.</operator><name>searchLog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOUNDCHECK</name><argument_list>(<argument><expr><name>ZSTD_c_minMatch</name></expr></argument>,  <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>cParams</name><operator>.</operator><name>minMatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOUNDCHECK</name><argument_list>(<argument><expr><name>ZSTD_c_targetLength</name></expr></argument>,<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>cParams</name><operator>.</operator><name>targetLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOUNDCHECK</name><argument_list>(<argument><expr><name>ZSTD_c_strategy</name></expr></argument>,  <argument><expr><name><name>cParams</name><operator>.</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** ZSTD_clampCParams() :
 *  make CParam values within valid range.
 *  @return : valid CParams */</comment>
<function><type><specifier>static</specifier> <name>ZSTD_compressionParameters</name></type>
<name>ZSTD_clampCParams</name><parameter_list>(<parameter><decl><type><name>ZSTD_compressionParameters</name></type> <name>cParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>CLAMP_TYPE</name><parameter_list>(<parameter><type><name>cParam</name></type></parameter>, <parameter><type><name>val</name></type></parameter>, <parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{                                \
        ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);         \
        if ((int)val&lt;bounds.lowerBound) val=(type)bounds.lowerBound;      \
        else if ((int)val&gt;bounds.upperBound) val=(type)bounds.upperBound; \
    }</cpp:value></cpp:define>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>CLAMP</name><parameter_list>(<parameter><type><name>cParam</name></type></parameter>, <parameter><type><name>val</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>CLAMP_TYPE(cParam, val, unsigned)</cpp:value></cpp:define>
    <expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><name>ZSTD_c_windowLog</name></expr></argument>, <argument><expr><name><name>cParams</name><operator>.</operator><name>windowLog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><name>ZSTD_c_chainLog</name></expr></argument>,  <argument><expr><name><name>cParams</name><operator>.</operator><name>chainLog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><name>ZSTD_c_hashLog</name></expr></argument>,   <argument><expr><name><name>cParams</name><operator>.</operator><name>hashLog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><name>ZSTD_c_searchLog</name></expr></argument>, <argument><expr><name><name>cParams</name><operator>.</operator><name>searchLog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><name>ZSTD_c_minMatch</name></expr></argument>,  <argument><expr><name><name>cParams</name><operator>.</operator><name>minMatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><name>ZSTD_c_targetLength</name></expr></argument>,<argument><expr><name><name>cParams</name><operator>.</operator><name>targetLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CLAMP_TYPE</name><argument_list>(<argument><expr><name>ZSTD_c_strategy</name></expr></argument>,<argument><expr><name><name>cParams</name><operator>.</operator><name>strategy</name></name></expr></argument>, <argument><expr><name>ZSTD_strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>cParams</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** ZSTD_cycleLog() :
 *  condition for correct operation : hashLog &gt; 1 */</comment>
<function><type><name>U32</name></type> <name>ZSTD_cycleLog</name><parameter_list>(<parameter><decl><type><name>U32</name></type> <name>hashLog</name></decl></parameter>, <parameter><decl><type><name>ZSTD_strategy</name></type> <name>strat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>btScale</name> <init>= <expr><operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><name>strat</name> <operator>&gt;=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>ZSTD_btlazy2</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>hashLog</name> <operator>-</operator> <name>btScale</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** ZSTD_dictAndWindowLog() :
 * Returns an adjusted window log that is large enough to fit the source and the dictionary.
 * The zstd format says that the entire dictionary is valid if one byte of the dictionary
 * is within the window. So the hashLog and chainLog should be large enough to reference both
 * the dictionary and the window. So we must use this adjusted dictAndWindowLog when downsizing
 * the hashLog and windowLog.
 * NOTE: srcSize must not be ZSTD_CONTENTSIZE_UNKNOWN.
 */</comment>
<function><type><specifier>static</specifier> <name>U32</name></type> <name>ZSTD_dictAndWindowLog</name><parameter_list>(<parameter><decl><type><name>U32</name></type> <name>windowLog</name></decl></parameter>, <parameter><decl><type><name>U64</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>U64</name></type> <name>dictSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U64</name></type> <name>maxWindowSize</name> <init>= <expr><literal type="number">1ULL</literal> <operator>&lt;&lt;</operator> <name>ZSTD_WINDOWLOG_MAX</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* No dictionary ==&gt; No change */</comment>
    <if_stmt><if>if <condition>(<expr><name>dictSize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>windowLog</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>windowLog</name> <operator>&lt;=</operator> <name>ZSTD_WINDOWLOG_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>srcSize</name> <operator>!=</operator> <name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Handled in ZSTD_adjustCParams_internal() */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><name>U64</name> <specifier>const</specifier></type> <name>windowSize</name> <init>= <expr><literal type="number">1ULL</literal> <operator>&lt;&lt;</operator> <name>windowLog</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U64</name> <specifier>const</specifier></type> <name>dictAndWindowSize</name> <init>= <expr><name>dictSize</name> <operator>+</operator> <name>windowSize</name></expr></init></decl>;</decl_stmt>
        <comment type="block">/* If the window size is already large enough to fit both the source and the dictionary
         * then just use the window size. Otherwise adjust so that it fits the dictionary and
         * the window.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>windowSize</name> <operator>&gt;=</operator> <name>dictSize</name> <operator>+</operator> <name>srcSize</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>windowLog</name></expr>;</return> <comment type="block">/* Window size large enough already */</comment>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>dictAndWindowSize</name> <operator>&gt;=</operator> <name>maxWindowSize</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>ZSTD_WINDOWLOG_MAX</name></expr>;</return> <comment type="block">/* Larger than max window log */</comment>
        </block_content>}</block></if> <else>else  <block>{<block_content>
            <return>return <expr><call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>dictAndWindowSize</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** ZSTD_adjustCParams_internal() :
 *  optimize `cPar` for a specified input (`srcSize` and `dictSize`).
 *  mostly downsize to reduce memory consumption and initialization latency.
 * `srcSize` can be ZSTD_CONTENTSIZE_UNKNOWN when not known.
 * `mode` is the mode for parameter adjustment. See docs for `ZSTD_cParamMode_e`.
 *  note : `srcSize==0` means 0!
 *  condition : cPar is presumed validated (can be checked using ZSTD_checkCParams()). */</comment>
<function><type><specifier>static</specifier> <name>ZSTD_compressionParameters</name></type>
<name>ZSTD_adjustCParams_internal</name><parameter_list>(<parameter><decl><type><name>ZSTD_compressionParameters</name></type> <name>cPar</name></decl></parameter>,
                            <parameter><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>srcSize</name></decl></parameter>,
                            <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>,
                            <parameter><decl><type><name>ZSTD_cParamMode_e</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U64</name></type> <name>minSrcSize</name> <init>= <expr><literal type="number">513</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* (1&lt;&lt;9) + 1 */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U64</name></type> <name>maxWindowResize</name> <init>= <expr><literal type="number">1ULL</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>ZSTD_WINDOWLOG_MAX</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>ZSTD_checkCParams</name><argument_list>(<argument><expr><name>cPar</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name>mode</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>ZSTD_cpm_unknown</name></expr>:</case>
    <case>case <expr><name>ZSTD_cpm_noAttachDict</name></expr>:</case>
        <comment type="block">/* If we don't know the source size, don't make any
         * assumptions about it. We will already have selected
         * smaller parameters if a dictionary is in use.
         */</comment>
        <break>break;</break>
    <case>case <expr><name>ZSTD_cpm_createCDict</name></expr>:</case>
        <comment type="block">/* Assume a small source size when creating a dictionary
         * with an unknown source size.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>dictSize</name> <operator>&amp;&amp;</operator> <name>srcSize</name> <operator>==</operator> <name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>srcSize</name> <operator>=</operator> <name>minSrcSize</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <break>break;</break>
    <case>case <expr><name>ZSTD_cpm_attachDict</name></expr>:</case>
        <comment type="block">/* Dictionary has its own dedicated parameters which have
         * already been selected. We are selecting parameters
         * for only the source.
         */</comment>
        <expr_stmt><expr><name>dictSize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <break>break;</break>
    <default>default:</default>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>

    <comment type="block">/* resize windowLog if input is small enough, to use less memory */</comment>
    <if_stmt><if>if <condition>( <expr><operator>(</operator><name>srcSize</name> <operator>&lt;</operator> <name>maxWindowResize</name><operator>)</operator>
      <operator>&amp;&amp;</operator> <operator>(</operator><name>dictSize</name> <operator>&lt;</operator> <name>maxWindowResize</name><operator>)</operator></expr> )</condition>  <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>tSize</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>srcSize</name> <operator>+</operator> <name>dictSize</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>static</specifier> <name>U32</name> <specifier>const</specifier></type> <name>hashSizeMin</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>ZSTD_HASHLOG_MIN</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>srcLog</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>tSize</name> <operator>&lt;</operator> <name>hashSizeMin</name><operator>)</operator></expr> ?</condition><then> <expr><name>ZSTD_HASHLOG_MIN</name></expr> </then><else>:
                            <expr><call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><name>tSize</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>cPar</name><operator>.</operator><name>windowLog</name></name> <operator>&gt;</operator> <name>srcLog</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>cPar</name><operator>.</operator><name>windowLog</name></name> <operator>=</operator> <name>srcLog</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>srcSize</name> <operator>!=</operator> <name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>dictAndWindowLog</name> <init>= <expr><call><name>ZSTD_dictAndWindowLog</name><argument_list>(<argument><expr><name><name>cPar</name><operator>.</operator><name>windowLog</name></name></expr></argument>, <argument><expr><operator>(</operator><name>U64</name><operator>)</operator><name>srcSize</name></expr></argument>, <argument><expr><operator>(</operator><name>U64</name><operator>)</operator><name>dictSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>cycleLog</name> <init>= <expr><call><name>ZSTD_cycleLog</name><argument_list>(<argument><expr><name><name>cPar</name><operator>.</operator><name>chainLog</name></name></expr></argument>, <argument><expr><name><name>cPar</name><operator>.</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>cPar</name><operator>.</operator><name>hashLog</name></name> <operator>&gt;</operator> <name>dictAndWindowLog</name><operator>+</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>cPar</name><operator>.</operator><name>hashLog</name></name> <operator>=</operator> <name>dictAndWindowLog</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>cycleLog</name> <operator>&gt;</operator> <name>dictAndWindowLog</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>cPar</name><operator>.</operator><name>chainLog</name></name> <operator>-=</operator> <operator>(</operator><name>cycleLog</name> <operator>-</operator> <name>dictAndWindowLog</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cPar</name><operator>.</operator><name>windowLog</name></name> <operator>&lt;</operator> <name>ZSTD_WINDOWLOG_ABSOLUTEMIN</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>cPar</name><operator>.</operator><name>windowLog</name></name> <operator>=</operator> <name>ZSTD_WINDOWLOG_ABSOLUTEMIN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* minimum wlog required for valid frame header */</comment>

    <if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>ZSTD_cpm_createCDict</name> <operator>&amp;&amp;</operator> <call><name>ZSTD_CDictIndicesAreTagged</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cPar</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>maxShortCacheHashLog</name> <init>= <expr><literal type="number">32</literal> <operator>-</operator> <name>ZSTD_SHORT_CACHE_TAG_BITS</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>cPar</name><operator>.</operator><name>hashLog</name></name> <operator>&gt;</operator> <name>maxShortCacheHashLog</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>cPar</name><operator>.</operator><name>hashLog</name></name> <operator>=</operator> <name>maxShortCacheHashLog</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>cPar</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ZSTD_compressionParameters</name></type>
<name>ZSTD_adjustCParams</name><parameter_list>(<parameter><decl><type><name>ZSTD_compressionParameters</name></type> <name>cPar</name></decl></parameter>,
                   <parameter><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>srcSize</name></decl></parameter>,
                   <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>cPar</name> <operator>=</operator> <call><name>ZSTD_clampCParams</name><argument_list>(<argument><expr><name>cPar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* resulting cPar is necessarily valid (all parameters within range) */</comment>
    <if_stmt><if>if <condition>(<expr><name>srcSize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>srcSize</name> <operator>=</operator> <name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><call><name>ZSTD_adjustCParams_internal</name><argument_list>(<argument><expr><name>cPar</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>, <argument><expr><name>ZSTD_cpm_unknown</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>ZSTD_compressionParameters</name></type> <name>ZSTD_getCParams_internal</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>compressionLevel</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>srcSizeHint</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>, <parameter><decl><type><name>ZSTD_cParamMode_e</name></type> <name>mode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ZSTD_parameters</name></type> <name>ZSTD_getParams_internal</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>compressionLevel</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>srcSizeHint</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>, <parameter><decl><type><name>ZSTD_cParamMode_e</name></type> <name>mode</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_overrideCParams</name><parameter_list>(
              <parameter><decl><type><name>ZSTD_compressionParameters</name><modifier>*</modifier></type> <name>cParams</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>ZSTD_compressionParameters</name><modifier>*</modifier></type> <name>overrides</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>overrides</name><operator>-&gt;</operator><name>windowLog</name></name></expr>)</condition><block type="pseudo"><block_content>    <expr_stmt><expr><name><name>cParams</name><operator>-&gt;</operator><name>windowLog</name></name>    <operator>=</operator> <name><name>overrides</name><operator>-&gt;</operator><name>windowLog</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>overrides</name><operator>-&gt;</operator><name>hashLog</name></name></expr>)</condition><block type="pseudo"><block_content>      <expr_stmt><expr><name><name>cParams</name><operator>-&gt;</operator><name>hashLog</name></name>      <operator>=</operator> <name><name>overrides</name><operator>-&gt;</operator><name>hashLog</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>overrides</name><operator>-&gt;</operator><name>chainLog</name></name></expr>)</condition><block type="pseudo"><block_content>     <expr_stmt><expr><name><name>cParams</name><operator>-&gt;</operator><name>chainLog</name></name>     <operator>=</operator> <name><name>overrides</name><operator>-&gt;</operator><name>chainLog</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>overrides</name><operator>-&gt;</operator><name>searchLog</name></name></expr>)</condition><block type="pseudo"><block_content>    <expr_stmt><expr><name><name>cParams</name><operator>-&gt;</operator><name>searchLog</name></name>    <operator>=</operator> <name><name>overrides</name><operator>-&gt;</operator><name>searchLog</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>overrides</name><operator>-&gt;</operator><name>minMatch</name></name></expr>)</condition><block type="pseudo"><block_content>     <expr_stmt><expr><name><name>cParams</name><operator>-&gt;</operator><name>minMatch</name></name>     <operator>=</operator> <name><name>overrides</name><operator>-&gt;</operator><name>minMatch</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>overrides</name><operator>-&gt;</operator><name>targetLength</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>cParams</name><operator>-&gt;</operator><name>targetLength</name></name> <operator>=</operator> <name><name>overrides</name><operator>-&gt;</operator><name>targetLength</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>overrides</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition><block type="pseudo"><block_content>     <expr_stmt><expr><name><name>cParams</name><operator>-&gt;</operator><name>strategy</name></name>     <operator>=</operator> <name><name>overrides</name><operator>-&gt;</operator><name>strategy</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>ZSTD_compressionParameters</name></type> <name>ZSTD_getCParamsFromCCtxParams</name><parameter_list>(
        <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>CCtxParams</name></decl></parameter>, <parameter><decl><type><name>U64</name></type> <name>srcSizeHint</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>, <parameter><decl><type><name>ZSTD_cParamMode_e</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_compressionParameters</name></type> <name>cParams</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>srcSizeHint</name> <operator>==</operator> <name>ZSTD_CONTENTSIZE_UNKNOWN</name> <operator>&amp;&amp;</operator> <name><name>CCtxParams</name><operator>-&gt;</operator><name>srcSizeHint</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>srcSizeHint</name> <operator>=</operator> <name><name>CCtxParams</name><operator>-&gt;</operator><name>srcSizeHint</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>cParams</name> <operator>=</operator> <call><name>ZSTD_getCParams_internal</name><argument_list>(<argument><expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>compressionLevel</name></name></expr></argument>, <argument><expr><name>srcSizeHint</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>CCtxParams</name><operator>-&gt;</operator><name>ldmParams</name><operator>.</operator><name>enableLdm</name></name> <operator>==</operator> <name>ZSTD_ps_enable</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>cParams</name><operator>.</operator><name>windowLog</name></name> <operator>=</operator> <name>ZSTD_LDM_DEFAULT_WINDOW_LOG</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>ZSTD_overrideCParams</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cParams</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>CCtxParams</name><operator>-&gt;</operator><name>cParams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ZSTD_checkCParams</name><argument_list>(<argument><expr><name>cParams</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* srcSizeHint == 0 means 0 */</comment>
    <return>return <expr><call><name>ZSTD_adjustCParams_internal</name><argument_list>(<argument><expr><name>cParams</name></expr></argument>, <argument><expr><name>srcSizeHint</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>ZSTD_sizeof_matchState</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ZSTD_compressionParameters</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cParams</name></decl></parameter>,
                       <parameter><decl><type><specifier>const</specifier> <name>ZSTD_paramSwitch_e</name></type> <name>useRowMatchFinder</name></decl></parameter>,
                       <parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name>enableDedicatedDictSearch</name></decl></parameter>,
                       <parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name>forCCtx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* chain table size should be 0 for fast or row-hash strategies */</comment>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>chainSize</name> <init>= <expr><ternary><condition><expr><call><name>ZSTD_allocateChainTable</name><argument_list>(<argument><expr><name><name>cParams</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>, <argument><expr><name>useRowMatchFinder</name></expr></argument>, <argument><expr><name>enableDedicatedDictSearch</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>forCCtx</name></expr></argument>)</argument_list></call></expr>
                                ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>cParams</name><operator>-&gt;</operator><name>chainLog</name></name><operator>)</operator></expr>
                                </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>hSize</name> <init>= <expr><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name><name>cParams</name><operator>-&gt;</operator><name>hashLog</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>    <specifier>const</specifier></type> <name>hashLog3</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>forCCtx</name> <operator>&amp;&amp;</operator> <name><name>cParams</name><operator>-&gt;</operator><name>minMatch</name></name><operator>==</operator><literal type="number">3</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name>MIN</name><argument_list>(<argument><expr><name>ZSTD_HASHLOG3_MAX</name></expr></argument>, <argument><expr><name><name>cParams</name><operator>-&gt;</operator><name>windowLog</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>h3Size</name> <init>= <expr><ternary><condition><expr><name>hashLog3</name></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>hashLog3</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <comment type="block">/* We don't use ZSTD_cwksp_alloc_size() here because the tables aren't
     * surrounded by redzones in ASAN. */</comment>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>tableSpace</name> <init>= <expr><name>chainSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>U32</name></expr></argument>)</argument_list></sizeof>
                            <operator>+</operator> <name>hSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>U32</name></expr></argument>)</argument_list></sizeof>
                            <operator>+</operator> <name>h3Size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>U32</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>optPotentialSpace</name> <init>=
        <expr><call><name>ZSTD_cwksp_aligned_alloc_size</name><argument_list>(<argument><expr><operator>(</operator><name>MaxML</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>U32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call>
      <operator>+</operator> <call><name>ZSTD_cwksp_aligned_alloc_size</name><argument_list>(<argument><expr><operator>(</operator><name>MaxLL</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>U32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call>
      <operator>+</operator> <call><name>ZSTD_cwksp_aligned_alloc_size</name><argument_list>(<argument><expr><operator>(</operator><name>MaxOff</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>U32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call>
      <operator>+</operator> <call><name>ZSTD_cwksp_aligned_alloc_size</name><argument_list>(<argument><expr><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>Litbits</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>U32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call>
      <operator>+</operator> <call><name>ZSTD_cwksp_aligned_alloc_size</name><argument_list>(<argument><expr><operator>(</operator><name>ZSTD_OPT_NUM</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_match_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call>
      <operator>+</operator> <call><name>ZSTD_cwksp_aligned_alloc_size</name><argument_list>(<argument><expr><operator>(</operator><name>ZSTD_OPT_NUM</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_optimal_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>lazyAdditionalSpace</name> <init>= <expr><ternary><condition><expr><call><name>ZSTD_rowMatchFinderUsed</name><argument_list>(<argument><expr><name><name>cParams</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>, <argument><expr><name>useRowMatchFinder</name></expr></argument>)</argument_list></call></expr>
                                            ?</condition><then> <expr><call><name>ZSTD_cwksp_aligned_alloc_size</name><argument_list>(<argument><expr><name>hSize</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>U16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>
                                            </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>optSpace</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>forCCtx</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>cParams</name><operator>-&gt;</operator><name>strategy</name></name> <operator>&gt;=</operator> <name>ZSTD_btopt</name><operator>)</operator><operator>)</operator></expr>
                                ?</condition><then> <expr><name>optPotentialSpace</name></expr>
                                </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>slackSpace</name> <init>= <expr><call><name>ZSTD_cwksp_slack_space_required</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* tables are guaranteed to be sized in multiples of 64 bytes (or 16 uint32_t) */</comment>
    <expr_stmt><expr><call><name>ZSTD_STATIC_ASSERT</name><argument_list>(<argument><expr><name>ZSTD_HASHLOG_MIN</name> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <name>ZSTD_WINDOWLOG_MIN</name> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <name>ZSTD_CHAINLOG_MIN</name> <operator>&gt;=</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>useRowMatchFinder</name> <operator>!=</operator> <name>ZSTD_ps_auto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"chainSize: %u - hSize: %u - h3Size: %u"</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>chainSize</name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>hSize</name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>h3Size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>tableSpace</name> <operator>+</operator> <name>optSpace</name> <operator>+</operator> <name>slackSpace</name> <operator>+</operator> <name>lazyAdditionalSpace</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_estimateCCtxSize_usingCCtxParams_internal</name><parameter_list>(
        <parameter><decl><type><specifier>const</specifier> <name>ZSTD_compressionParameters</name><modifier>*</modifier></type> <name>cParams</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>ldmParams_t</name><modifier>*</modifier></type> <name>ldmParams</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>isStatic</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>ZSTD_paramSwitch_e</name></type> <name>useRowMatchFinder</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>buffInSize</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>buffOutSize</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>U64</name></type> <name>pledgedSrcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>windowSize</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator> <call><name>BOUNDED</name><argument_list>(<argument><expr><literal type="number">1ULL</literal></expr></argument>, <argument><expr><literal type="number">1ULL</literal> <operator>&lt;&lt;</operator> <name><name>cParams</name><operator>-&gt;</operator><name>windowLog</name></name></expr></argument>, <argument><expr><name>pledgedSrcSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>blockSize</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name>ZSTD_BLOCKSIZE_MAX</name></expr></argument>, <argument><expr><name>windowSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>    <specifier>const</specifier></type> <name>divider</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>cParams</name><operator>-&gt;</operator><name>minMatch</name></name><operator>==</operator><literal type="number">3</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">3</literal></expr> </then><else>: <expr><literal type="number">4</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>maxNbSeq</name> <init>= <expr><name>blockSize</name> <operator>/</operator> <name>divider</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>tokenSpace</name> <init>= <expr><call><name>ZSTD_cwksp_alloc_size</name><argument_list>(<argument><expr><name>WILDCOPY_OVERLENGTH</name> <operator>+</operator> <name>blockSize</name></expr></argument>)</argument_list></call>
                            <operator>+</operator> <call><name>ZSTD_cwksp_aligned_alloc_size</name><argument_list>(<argument><expr><name>maxNbSeq</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>seqDef</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call>
                            <operator>+</operator> <literal type="number">3</literal> <operator>*</operator> <call><name>ZSTD_cwksp_alloc_size</name><argument_list>(<argument><expr><name>maxNbSeq</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BYTE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>entropySpace</name> <init>= <expr><call><name>ZSTD_cwksp_alloc_size</name><argument_list>(<argument><expr><name>ENTROPY_WORKSPACE_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>blockStateSpace</name> <init>= <expr><literal type="number">2</literal> <operator>*</operator> <call><name>ZSTD_cwksp_alloc_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_compressedBlockState_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>matchStateSize</name> <init>= <expr><call><name>ZSTD_sizeof_matchState</name><argument_list>(<argument><expr><name>cParams</name></expr></argument>, <argument><expr><name>useRowMatchFinder</name></expr></argument>, <comment type="block">/* enableDedicatedDictSearch */</comment> <argument><expr><literal type="number">0</literal></expr></argument>, <comment type="block">/* forCCtx */</comment> <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>ldmSpace</name> <init>= <expr><call><name>ZSTD_ldm_getTableSize</name><argument_list>(<argument><expr><operator>*</operator><name>ldmParams</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>maxNbLdmSeq</name> <init>= <expr><call><name>ZSTD_ldm_getMaxNbSeq</name><argument_list>(<argument><expr><operator>*</operator><name>ldmParams</name></expr></argument>, <argument><expr><name>blockSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>ldmSeqSpace</name> <init>= <expr><ternary><condition><expr><name><name>ldmParams</name><operator>-&gt;</operator><name>enableLdm</name></name> <operator>==</operator> <name>ZSTD_ps_enable</name></expr> ?</condition><then>
        <expr><call><name>ZSTD_cwksp_aligned_alloc_size</name><argument_list>(<argument><expr><name>maxNbLdmSeq</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>rawSeq</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>


    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>bufferSpace</name> <init>= <expr><call><name>ZSTD_cwksp_alloc_size</name><argument_list>(<argument><expr><name>buffInSize</name></expr></argument>)</argument_list></call>
                             <operator>+</operator> <call><name>ZSTD_cwksp_alloc_size</name><argument_list>(<argument><expr><name>buffOutSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>cctxSpace</name> <init>= <expr><ternary><condition><expr><name>isStatic</name></expr> ?</condition><then> <expr><call><name>ZSTD_cwksp_alloc_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_CCtx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>neededSpace</name> <init>=
        <expr><name>cctxSpace</name> <operator>+</operator>
        <name>entropySpace</name> <operator>+</operator>
        <name>blockStateSpace</name> <operator>+</operator>
        <name>ldmSpace</name> <operator>+</operator>
        <name>ldmSeqSpace</name> <operator>+</operator>
        <name>matchStateSize</name> <operator>+</operator>
        <name>tokenSpace</name> <operator>+</operator>
        <name>bufferSpace</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"estimate workspace : %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>neededSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>neededSpace</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_estimateCCtxSize_usingCCtxParams</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_compressionParameters</name> <specifier>const</specifier></type> <name>cParams</name> <init>=
                <expr><call><name>ZSTD_getCParamsFromCCtxParams</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ZSTD_cpm_noAttachDict</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_paramSwitch_e</name> <specifier>const</specifier></type> <name>useRowMatchFinder</name> <init>= <expr><call><name>ZSTD_resolveRowMatchFinderMode</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>useRowMatchFinder</name></name></expr></argument>,
                                                                               <argument><expr><operator>&amp;</operator><name>cParams</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>nbWorkers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>GENERIC</name></expr></argument>, <argument><expr><literal type="string">"Estimate CCtx size is supported for single-threaded compression only."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* estimateCCtxSize is for one-shot compression. So no buffers should
     * be needed. However, we still allocate two 0-sized buffers, which can
     * take space under ASAN. */</comment>
    <return>return <expr><call><name>ZSTD_estimateCCtxSize_usingCCtxParams_internal</name><argument_list>(
        <argument><expr><operator>&amp;</operator><name>cParams</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>params</name><operator>-&gt;</operator><name>ldmParams</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>useRowMatchFinder</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_estimateCCtxSize_usingCParams</name><parameter_list>(<parameter><decl><type><name>ZSTD_compressionParameters</name></type> <name>cParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_CCtx_params</name></type> <name>initialParams</name> <init>= <expr><call><name>ZSTD_makeCCtxParamsFromCParams</name><argument_list>(<argument><expr><name>cParams</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ZSTD_rowMatchFinderSupported</name><argument_list>(<argument><expr><name><name>cParams</name><operator>.</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Pick bigger of not using and using row-based matchfinder for greedy and lazy strategies */</comment>
        <decl_stmt><decl><type><name>size_t</name></type> <name>noRowCCtxSize</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>rowCCtxSize</name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>initialParams</name><operator>.</operator><name>useRowMatchFinder</name></name> <operator>=</operator> <name>ZSTD_ps_disable</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>noRowCCtxSize</name> <operator>=</operator> <call><name>ZSTD_estimateCCtxSize_usingCCtxParams</name><argument_list>(<argument><expr><operator>&amp;</operator><name>initialParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>initialParams</name><operator>.</operator><name>useRowMatchFinder</name></name> <operator>=</operator> <name>ZSTD_ps_enable</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rowCCtxSize</name> <operator>=</operator> <call><name>ZSTD_estimateCCtxSize_usingCCtxParams</name><argument_list>(<argument><expr><operator>&amp;</operator><name>initialParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>MAX</name><argument_list>(<argument><expr><name>noRowCCtxSize</name></expr></argument>, <argument><expr><name>rowCCtxSize</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><call><name>ZSTD_estimateCCtxSize_usingCCtxParams</name><argument_list>(<argument><expr><operator>&amp;</operator><name>initialParams</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_estimateCCtxSize_internal</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>compressionLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>tier</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>largestSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>long</name> <name>long</name></type> <name><name>srcSizeTiers</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">16</literal> <name>KB</name></expr>, <expr><literal type="number">128</literal> <name>KB</name></expr>, <expr><literal type="number">256</literal> <name>KB</name></expr>, <expr><name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr>}</block></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init>;</init> <condition><expr><name>tier</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><operator>++</operator><name>tier</name></expr></incr>)</control> <block>{<block_content>
        <comment type="block">/* Choose the set of cParams for a given level across all srcSizes that give the largest cctxSize */</comment>
        <decl_stmt><decl><type><name>ZSTD_compressionParameters</name> <specifier>const</specifier></type> <name>cParams</name> <init>= <expr><call><name>ZSTD_getCParams_internal</name><argument_list>(<argument><expr><name>compressionLevel</name></expr></argument>, <argument><expr><name><name>srcSizeTiers</name><index>[<expr><name>tier</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ZSTD_cpm_noAttachDict</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>largestSize</name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><call><name>ZSTD_estimateCCtxSize_usingCParams</name><argument_list>(<argument><expr><name>cParams</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>largestSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>largestSize</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_estimateCCtxSize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>compressionLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>memBudget</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>level</name><operator>=</operator><call><name>MIN</name><argument_list>(<argument><expr><name>compressionLevel</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>level</name><operator>&lt;=</operator><name>compressionLevel</name></expr>;</condition> <incr><expr><name>level</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <comment type="block">/* Ensure monotonically increasing memory usage as compression level increases */</comment>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>newMB</name> <init>= <expr><call><name>ZSTD_estimateCCtxSize_internal</name><argument_list>(<argument><expr><name>level</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>newMB</name> <operator>&gt;</operator> <name>memBudget</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>memBudget</name> <operator>=</operator> <name>newMB</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>memBudget</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_estimateCStreamSize_usingCCtxParams</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>nbWorkers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>GENERIC</name></expr></argument>, <argument><expr><literal type="string">"Estimate CCtx size is supported for single-threaded compression only."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>ZSTD_compressionParameters</name> <specifier>const</specifier></type> <name>cParams</name> <init>=
                <expr><call><name>ZSTD_getCParamsFromCCtxParams</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ZSTD_cpm_noAttachDict</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>blockSize</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name>ZSTD_BLOCKSIZE_MAX</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>cParams</name><operator>.</operator><name>windowLog</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>inBuffSize</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>inBufferMode</name></name> <operator>==</operator> <name>ZSTD_bm_buffered</name><operator>)</operator></expr>
                ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>cParams</name><operator>.</operator><name>windowLog</name></name><operator>)</operator> <operator>+</operator> <name>blockSize</name></expr>
                </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>outBuffSize</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>outBufferMode</name></name> <operator>==</operator> <name>ZSTD_bm_buffered</name><operator>)</operator></expr>
                ?</condition><then> <expr><call><name>ZSTD_compressBound</name><argument_list>(<argument><expr><name>blockSize</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>
                </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ZSTD_paramSwitch_e</name> <specifier>const</specifier></type> <name>useRowMatchFinder</name> <init>= <expr><call><name>ZSTD_resolveRowMatchFinderMode</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>useRowMatchFinder</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>params</name><operator>-&gt;</operator><name>cParams</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <return>return <expr><call><name>ZSTD_estimateCCtxSize_usingCCtxParams_internal</name><argument_list>(
            <argument><expr><operator>&amp;</operator><name>cParams</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>params</name><operator>-&gt;</operator><name>ldmParams</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>useRowMatchFinder</name></expr></argument>, <argument><expr><name>inBuffSize</name></expr></argument>, <argument><expr><name>outBuffSize</name></expr></argument>,
            <argument><expr><name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_estimateCStreamSize_usingCParams</name><parameter_list>(<parameter><decl><type><name>ZSTD_compressionParameters</name></type> <name>cParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_CCtx_params</name></type> <name>initialParams</name> <init>= <expr><call><name>ZSTD_makeCCtxParamsFromCParams</name><argument_list>(<argument><expr><name>cParams</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ZSTD_rowMatchFinderSupported</name><argument_list>(<argument><expr><name><name>cParams</name><operator>.</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Pick bigger of not using and using row-based matchfinder for greedy and lazy strategies */</comment>
        <decl_stmt><decl><type><name>size_t</name></type> <name>noRowCCtxSize</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>rowCCtxSize</name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>initialParams</name><operator>.</operator><name>useRowMatchFinder</name></name> <operator>=</operator> <name>ZSTD_ps_disable</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>noRowCCtxSize</name> <operator>=</operator> <call><name>ZSTD_estimateCStreamSize_usingCCtxParams</name><argument_list>(<argument><expr><operator>&amp;</operator><name>initialParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>initialParams</name><operator>.</operator><name>useRowMatchFinder</name></name> <operator>=</operator> <name>ZSTD_ps_enable</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rowCCtxSize</name> <operator>=</operator> <call><name>ZSTD_estimateCStreamSize_usingCCtxParams</name><argument_list>(<argument><expr><operator>&amp;</operator><name>initialParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>MAX</name><argument_list>(<argument><expr><name>noRowCCtxSize</name></expr></argument>, <argument><expr><name>rowCCtxSize</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><call><name>ZSTD_estimateCStreamSize_usingCCtxParams</name><argument_list>(<argument><expr><operator>&amp;</operator><name>initialParams</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_estimateCStreamSize_internal</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>compressionLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_compressionParameters</name> <specifier>const</specifier></type> <name>cParams</name> <init>= <expr><call><name>ZSTD_getCParams_internal</name><argument_list>(<argument><expr><name>compressionLevel</name></expr></argument>, <argument><expr><name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ZSTD_cpm_noAttachDict</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>ZSTD_estimateCStreamSize_usingCParams</name><argument_list>(<argument><expr><name>cParams</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_estimateCStreamSize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>compressionLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>memBudget</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>level</name><operator>=</operator><call><name>MIN</name><argument_list>(<argument><expr><name>compressionLevel</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>level</name><operator>&lt;=</operator><name>compressionLevel</name></expr>;</condition> <incr><expr><name>level</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>newMB</name> <init>= <expr><call><name>ZSTD_estimateCStreamSize_internal</name><argument_list>(<argument><expr><name>level</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>newMB</name> <operator>&gt;</operator> <name>memBudget</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>memBudget</name> <operator>=</operator> <name>newMB</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>memBudget</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ZSTD_getFrameProgression():
 * tells how much data has been consumed (input) and produced (output) for current frame.
 * able to count progression inside worker threads (non-blocking mode).
 */</comment>
<function><type><name>ZSTD_frameProgression</name></type> <name>ZSTD_getFrameProgression</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ZSTD_MULTITHREAD</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>nbWorkers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>ZSTDMT_getFrameProgression</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>mtctx</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>   <decl_stmt><decl><type><name>ZSTD_frameProgression</name></type> <name>fp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>buffered</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>cctx</name><operator>-&gt;</operator><name>inBuff</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>:
                                <expr><name><name>cctx</name><operator>-&gt;</operator><name>inBuffPos</name></name> <operator>-</operator> <name><name>cctx</name><operator>-&gt;</operator><name>inToCompress</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>buffered</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>inBuffPos</name></name> <operator>&gt;=</operator> <name><name>cctx</name><operator>-&gt;</operator><name>inToCompress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>buffered</name> <operator>&lt;=</operator> <name>ZSTD_BLOCKSIZE_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>fp</name><operator>.</operator><name>ingested</name></name> <operator>=</operator> <name><name>cctx</name><operator>-&gt;</operator><name>consumedSrcSize</name></name> <operator>+</operator> <name>buffered</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>fp</name><operator>.</operator><name>consumed</name></name> <operator>=</operator> <name><name>cctx</name><operator>-&gt;</operator><name>consumedSrcSize</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>fp</name><operator>.</operator><name>produced</name></name> <operator>=</operator> <name><name>cctx</name><operator>-&gt;</operator><name>producedCSize</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>fp</name><operator>.</operator><name>flushed</name></name>  <operator>=</operator> <name><name>cctx</name><operator>-&gt;</operator><name>producedCSize</name></name></expr>;</expr_stmt>   <comment type="block">/* simplified; some data might still be left within streaming output buffer */</comment>
        <expr_stmt><expr><name><name>fp</name><operator>.</operator><name>currentJobID</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>fp</name><operator>.</operator><name>nbActiveWorkers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>fp</name></expr>;</return>
</block_content>}</block>   </block_content>}</block></function>

<comment type="block" format="doxygen">/*! ZSTD_toFlushNow()
 *  Only useful for multithreading scenarios currently (nbWorkers &gt;= 1).
 */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_toFlushNow</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ZSTD_MULTITHREAD</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>nbWorkers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>ZSTDMT_toFlushNow</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>mtctx</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>cctx</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* over-simplification; could also check if context is currently running in streaming mode, and in which case, report how many bytes are left to be flushed within output buffer */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_assertEqualCParams</name><parameter_list>(<parameter><decl><type><name>ZSTD_compressionParameters</name></type> <name>cParams1</name></decl></parameter>,
                                    <parameter><decl><type><name>ZSTD_compressionParameters</name></type> <name>cParams2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>cParams1</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>cParams2</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cParams1</name><operator>.</operator><name>windowLog</name></name>    <operator>==</operator> <name><name>cParams2</name><operator>.</operator><name>windowLog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cParams1</name><operator>.</operator><name>chainLog</name></name>     <operator>==</operator> <name><name>cParams2</name><operator>.</operator><name>chainLog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cParams1</name><operator>.</operator><name>hashLog</name></name>      <operator>==</operator> <name><name>cParams2</name><operator>.</operator><name>hashLog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cParams1</name><operator>.</operator><name>searchLog</name></name>    <operator>==</operator> <name><name>cParams2</name><operator>.</operator><name>searchLog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cParams1</name><operator>.</operator><name>minMatch</name></name>     <operator>==</operator> <name><name>cParams2</name><operator>.</operator><name>minMatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cParams1</name><operator>.</operator><name>targetLength</name></name> <operator>==</operator> <name><name>cParams2</name><operator>.</operator><name>targetLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cParams1</name><operator>.</operator><name>strategy</name></name>     <operator>==</operator> <name><name>cParams2</name><operator>.</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>ZSTD_reset_compressedBlockState</name><parameter_list>(<parameter><decl><type><name>ZSTD_compressedBlockState_t</name><modifier>*</modifier></type> <name>bs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ZSTD_REP_NUM</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>bs</name><operator>-&gt;</operator><name>rep</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>repStartValue</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><name><name>bs</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>huf</name><operator>.</operator><name>repeatMode</name></name> <operator>=</operator> <name>HUF_repeat_none</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bs</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>fse</name><operator>.</operator><name>offcode_repeatMode</name></name> <operator>=</operator> <name>FSE_repeat_none</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bs</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>fse</name><operator>.</operator><name>matchlength_repeatMode</name></name> <operator>=</operator> <name>FSE_repeat_none</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bs</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>fse</name><operator>.</operator><name>litlength_repeatMode</name></name> <operator>=</operator> <name>FSE_repeat_none</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! ZSTD_invalidateMatchState()
 *  Invalidate all the matches in the match finder tables.
 *  Requires nextSrc and base to be set (can be NULL).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_invalidateMatchState</name><parameter_list>(<parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>ZSTD_window_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ms</name><operator>-&gt;</operator><name>window</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name> <operator>=</operator> <name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictLimit</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>loadedDictEnd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>litLengthSum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* force reset of btopt stats */</comment>
    <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>dictMatchState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Controls, for this matchState reset, whether the tables need to be cleared /
 * prepared for the coming compression (ZSTDcrp_makeClean), or whether the
 * tables can be left unclean (ZSTDcrp_leaveDirty), because we know that a
 * subsequent operation will overwrite the table space anyways (e.g., copying
 * the matchState contents in from a CDict).
 */</comment>
<typedef>typedef <type><enum>enum <block>{
    <decl><name>ZSTDcrp_makeClean</name></decl>,
    <decl><name>ZSTDcrp_leaveDirty</name></decl>
}</block></enum></type> <name>ZSTD_compResetPolicy_e</name>;</typedef>

<comment type="block" format="doxygen">/**
 * Controls, for this matchState reset, whether indexing can continue where it
 * left off (ZSTDirp_continue), or whether it needs to be restarted from zero
 * (ZSTDirp_reset).
 */</comment>
<typedef>typedef <type><enum>enum <block>{
    <decl><name>ZSTDirp_continue</name></decl>,
    <decl><name>ZSTDirp_reset</name></decl>
}</block></enum></type> <name>ZSTD_indexResetPolicy_e</name>;</typedef>

<typedef>typedef <type><enum>enum <block>{
    <decl><name>ZSTD_resetTarget_CDict</name></decl>,
    <decl><name>ZSTD_resetTarget_CCtx</name></decl>
}</block></enum></type> <name>ZSTD_resetTarget_e</name>;</typedef>


<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>ZSTD_reset_matchState</name><parameter_list>(<parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>,
                      <parameter><decl><type><name>ZSTD_cwksp</name><modifier>*</modifier></type> <name>ws</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>ZSTD_compressionParameters</name><modifier>*</modifier></type> <name>cParams</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>ZSTD_paramSwitch_e</name></type> <name>useRowMatchFinder</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>ZSTD_compResetPolicy_e</name></type> <name>crp</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>ZSTD_indexResetPolicy_e</name></type> <name>forceResetIndex</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>ZSTD_resetTarget_e</name></type> <name>forWho</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* disable chain table allocation for fast or row-based strategies */</comment>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>chainSize</name> <init>= <expr><ternary><condition><expr><call><name>ZSTD_allocateChainTable</name><argument_list>(<argument><expr><name><name>cParams</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>, <argument><expr><name>useRowMatchFinder</name></expr></argument>,
                                                     <argument><expr><name><name>ms</name><operator>-&gt;</operator><name>dedicatedDictSearch</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>forWho</name> <operator>==</operator> <name>ZSTD_resetTarget_CDict</name><operator>)</operator></expr></argument>)</argument_list></call></expr>
                                ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>cParams</name><operator>-&gt;</operator><name>chainLog</name></name><operator>)</operator></expr>
                                </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>hSize</name> <init>= <expr><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name><name>cParams</name><operator>-&gt;</operator><name>hashLog</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>    <specifier>const</specifier></type> <name>hashLog3</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>forWho</name> <operator>==</operator> <name>ZSTD_resetTarget_CCtx</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>cParams</name><operator>-&gt;</operator><name>minMatch</name></name><operator>==</operator><literal type="number">3</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name>MIN</name><argument_list>(<argument><expr><name>ZSTD_HASHLOG3_MAX</name></expr></argument>, <argument><expr><name><name>cParams</name><operator>-&gt;</operator><name>windowLog</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>h3Size</name> <init>= <expr><ternary><condition><expr><name>hashLog3</name></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>hashLog3</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"reset indices : %u"</literal></expr></argument>, <argument><expr><name>forceResetIndex</name> <operator>==</operator> <name>ZSTDirp_reset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>useRowMatchFinder</name> <operator>!=</operator> <name>ZSTD_ps_auto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>forceResetIndex</name> <operator>==</operator> <name>ZSTDirp_reset</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>ZSTD_window_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ms</name><operator>-&gt;</operator><name>window</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_cwksp_mark_tables_dirty</name><argument_list>(<argument><expr><name>ws</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>hashLog3</name></name> <operator>=</operator> <name>hashLog3</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ZSTD_invalidateMatchState</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ZSTD_cwksp_reserve_failed</name><argument_list>(<argument><expr><name>ws</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* check that allocation hasn't already failed */</comment>

    <expr_stmt><expr><call><name>ZSTD_cwksp_clear_tables</name><argument_list>(<argument><expr><name>ws</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"reserving table space"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* table Space */</comment>
    <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>hashTable</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>*</operator><operator>)</operator><call><name>ZSTD_cwksp_reserve_table</name><argument_list>(<argument><expr><name>ws</name></expr></argument>, <argument><expr><name>hSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>U32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>chainTable</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>*</operator><operator>)</operator><call><name>ZSTD_cwksp_reserve_table</name><argument_list>(<argument><expr><name>ws</name></expr></argument>, <argument><expr><name>chainSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>U32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>hashTable3</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>*</operator><operator>)</operator><call><name>ZSTD_cwksp_reserve_table</name><argument_list>(<argument><expr><name>ws</name></expr></argument>, <argument><expr><name>h3Size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>U32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><call><name>ZSTD_cwksp_reserve_failed</name><argument_list>(<argument><expr><name>ws</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>memory_allocation</name></expr></argument>,
                    <argument><expr><literal type="string">"failed a workspace allocation in ZSTD_reset_matchState"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"reset table : %u"</literal></expr></argument>, <argument><expr><name>crp</name><operator>!=</operator><name>ZSTDcrp_leaveDirty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>crp</name><operator>!=</operator><name>ZSTDcrp_leaveDirty</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* reset tables only */</comment>
        <expr_stmt><expr><call><name>ZSTD_cwksp_clean_tables</name><argument_list>(<argument><expr><name>ws</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* opt parser space */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>forWho</name> <operator>==</operator> <name>ZSTD_resetTarget_CCtx</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>cParams</name><operator>-&gt;</operator><name>strategy</name></name> <operator>&gt;=</operator> <name>ZSTD_btopt</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"reserving optimal parser space"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>litFreq</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>*</operator><operator>)</operator><call><name>ZSTD_cwksp_reserve_aligned</name><argument_list>(<argument><expr><name>ws</name></expr></argument>, <argument><expr><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>Litbits</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>unsigned</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>litLengthFreq</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>*</operator><operator>)</operator><call><name>ZSTD_cwksp_reserve_aligned</name><argument_list>(<argument><expr><name>ws</name></expr></argument>, <argument><expr><operator>(</operator><name>MaxLL</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>unsigned</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>matchLengthFreq</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>*</operator><operator>)</operator><call><name>ZSTD_cwksp_reserve_aligned</name><argument_list>(<argument><expr><name>ws</name></expr></argument>, <argument><expr><operator>(</operator><name>MaxML</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>unsigned</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>offCodeFreq</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>*</operator><operator>)</operator><call><name>ZSTD_cwksp_reserve_aligned</name><argument_list>(<argument><expr><name>ws</name></expr></argument>, <argument><expr><operator>(</operator><name>MaxOff</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>unsigned</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>matchTable</name></name> <operator>=</operator> <operator>(</operator><name>ZSTD_match_t</name><operator>*</operator><operator>)</operator><call><name>ZSTD_cwksp_reserve_aligned</name><argument_list>(<argument><expr><name>ws</name></expr></argument>, <argument><expr><operator>(</operator><name>ZSTD_OPT_NUM</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_match_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>priceTable</name></name> <operator>=</operator> <operator>(</operator><name>ZSTD_optimal_t</name><operator>*</operator><operator>)</operator><call><name>ZSTD_cwksp_reserve_aligned</name><argument_list>(<argument><expr><name>ws</name></expr></argument>, <argument><expr><operator>(</operator><name>ZSTD_OPT_NUM</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_optimal_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>ZSTD_rowMatchFinderUsed</name><argument_list>(<argument><expr><name><name>cParams</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>, <argument><expr><name>useRowMatchFinder</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <block>{<block_content>   <comment type="block">/* Row match finder needs an additional table of hashes ("tags") */</comment>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>tagTableSize</name> <init>= <expr><name>hSize</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>U16</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>tagTable</name></name> <operator>=</operator> <operator>(</operator><name>U16</name><operator>*</operator><operator>)</operator><call><name>ZSTD_cwksp_reserve_aligned</name><argument_list>(<argument><expr><name>ws</name></expr></argument>, <argument><expr><name>tagTableSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>ms</name><operator>-&gt;</operator><name>tagTable</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>tagTable</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tagTableSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block>
        <block>{<block_content>   <comment type="block">/* Switch to 32-entry rows if searchLog is 5 (or more) */</comment>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>rowLog</name> <init>= <expr><call><name>BOUNDED</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name><name>cParams</name><operator>-&gt;</operator><name>searchLog</name></name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cParams</name><operator>-&gt;</operator><name>hashLog</name></name> <operator>&gt;=</operator> <name>rowLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>rowHashLog</name></name> <operator>=</operator> <name><name>cParams</name><operator>-&gt;</operator><name>hashLog</name></name> <operator>-</operator> <name>rowLog</name></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>cParams</name></name> <operator>=</operator> <operator>*</operator><name>cParams</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><call><name>ZSTD_cwksp_reserve_failed</name><argument_list>(<argument><expr><name>ws</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>memory_allocation</name></expr></argument>,
                    <argument><expr><literal type="string">"failed a workspace allocation in ZSTD_reset_matchState"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ZSTD_indexTooCloseToMax() :
 * minor optimization : prefer memset() rather than reduceIndex()
 * which is measurably slow in some circumstances (reported for Visual Studio).
 * Works when re-using a context for a lot of smallish inputs :
 * if all inputs are smaller than ZSTD_INDEXOVERFLOW_MARGIN,
 * memset() will be triggered before reduceIndex().
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZSTD_INDEXOVERFLOW_MARGIN</name></cpp:macro> <cpp:value>(16 MB)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ZSTD_indexTooCloseToMax</name><parameter_list>(<parameter><decl><type><name>ZSTD_window_t</name></type> <name>w</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>w</name><operator>.</operator><name>nextSrc</name></name> <operator>-</operator> <name><name>w</name><operator>.</operator><name>base</name></name><operator>)</operator> <operator>&gt;</operator> <operator>(</operator><name>ZSTD_CURRENT_MAX</name> <operator>-</operator> <name>ZSTD_INDEXOVERFLOW_MARGIN</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** ZSTD_dictTooBig():
 * When dictionaries are larger than ZSTD_CHUNKSIZE_MAX they can't be loaded in
 * one go generically. So we ensure that in that case we reset the tables to zero,
 * so that we can load as much of the dictionary as possible.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ZSTD_dictTooBig</name><parameter_list>(<parameter><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>loadedDictSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>loadedDictSize</name> <operator>&gt;</operator> <name>ZSTD_CHUNKSIZE_MAX</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! ZSTD_resetCCtx_internal() :
 * @param loadedDictSize The size of the dictionary to be loaded
 * into the context, if any. If no dictionary is used, or the
 * dictionary is being attached / copied, then pass 0.
 * note : `params` are assumed fully validated at this stage.
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_resetCCtx_internal</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>zc</name></decl></parameter>,
                                      <parameter><decl><type><name>ZSTD_CCtx_params</name> <specifier>const</specifier><modifier>*</modifier></type> <name>params</name></decl></parameter>,
                                      <parameter><decl><type><name>U64</name> <specifier>const</specifier></type> <name>pledgedSrcSize</name></decl></parameter>,
                                      <parameter><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>loadedDictSize</name></decl></parameter>,
                                      <parameter><decl><type><name>ZSTD_compResetPolicy_e</name> <specifier>const</specifier></type> <name>crp</name></decl></parameter>,
                                      <parameter><decl><type><name>ZSTD_buffered_policy_e</name> <specifier>const</specifier></type> <name>zbuff</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_cwksp</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ws</name> <init>= <expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>workspace</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_resetCCtx_internal: pledgedSrcSize=%u, wlog=%u, useRowMatchFinder=%d useBlockSplitter=%d"</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>pledgedSrcSize</name></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>windowLog</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>params</name><operator>-&gt;</operator><name>useRowMatchFinder</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>params</name><operator>-&gt;</operator><name>useBlockSplitter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ZSTD_isError</name><argument_list>(<argument><expr><call><name>ZSTD_checkCParams</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>cParams</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>isFirstBlock</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/* Set applied params early so we can modify them for LDM,
     * and point params at the applied params.
     */</comment>
    <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>appliedParams</name></name> <operator>=</operator> <operator>*</operator><name>params</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>params</name> <operator>=</operator> <operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>appliedParams</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>useRowMatchFinder</name></name> <operator>!=</operator> <name>ZSTD_ps_auto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>useBlockSplitter</name></name> <operator>!=</operator> <name>ZSTD_ps_auto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>ldmParams</name><operator>.</operator><name>enableLdm</name></name> <operator>!=</operator> <name>ZSTD_ps_auto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>ldmParams</name><operator>.</operator><name>enableLdm</name></name> <operator>==</operator> <name>ZSTD_ps_enable</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Adjust long distance matching parameters */</comment>
        <expr_stmt><expr><call><name>ZSTD_ldm_adjustParameters</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>ldmParams</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>params</name><operator>-&gt;</operator><name>cParams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>ldmParams</name><operator>.</operator><name>hashLog</name></name> <operator>&gt;=</operator> <name><name>params</name><operator>-&gt;</operator><name>ldmParams</name><operator>.</operator><name>bucketSizeLog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>ldmParams</name><operator>.</operator><name>hashRateLog</name></name> <operator>&lt;</operator> <literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>windowSize</name> <init>= <expr><call><name>MAX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><call><name>MIN</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>U64</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>params</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>windowLog</name></name><operator>)</operator></expr></argument>, <argument><expr><name>pledgedSrcSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>blockSize</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name>ZSTD_BLOCKSIZE_MAX</name></expr></argument>, <argument><expr><name>windowSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name>    <specifier>const</specifier></type> <name>divider</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>minMatch</name></name><operator>==</operator><literal type="number">3</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">3</literal></expr> </then><else>: <expr><literal type="number">4</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>maxNbSeq</name> <init>= <expr><name>blockSize</name> <operator>/</operator> <name>divider</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>buffOutSize</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>zbuff</name> <operator>==</operator> <name>ZSTDb_buffered</name> <operator>&amp;&amp;</operator> <name><name>params</name><operator>-&gt;</operator><name>outBufferMode</name></name> <operator>==</operator> <name>ZSTD_bm_buffered</name><operator>)</operator></expr>
                ?</condition><then> <expr><call><name>ZSTD_compressBound</name><argument_list>(<argument><expr><name>blockSize</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>
                </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>buffInSize</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>zbuff</name> <operator>==</operator> <name>ZSTDb_buffered</name> <operator>&amp;&amp;</operator> <name><name>params</name><operator>-&gt;</operator><name>inBufferMode</name></name> <operator>==</operator> <name>ZSTD_bm_buffered</name><operator>)</operator></expr>
                ?</condition><then> <expr><name>windowSize</name> <operator>+</operator> <name>blockSize</name></expr>
                </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>maxNbLdmSeq</name> <init>= <expr><call><name>ZSTD_ldm_getMaxNbSeq</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>ldmParams</name></name></expr></argument>, <argument><expr><name>blockSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>indexTooClose</name> <init>= <expr><call><name>ZSTD_indexTooCloseToMax</name><argument_list>(<argument><expr><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name><operator>.</operator><name>window</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>dictTooBig</name> <init>= <expr><call><name>ZSTD_dictTooBig</name><argument_list>(<argument><expr><name>loadedDictSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ZSTD_indexResetPolicy_e</name></type> <name>needsIndexReset</name> <init>=
            <expr><ternary><condition><expr><operator>(</operator><name>indexTooClose</name> <operator>||</operator> <name>dictTooBig</name> <operator>||</operator> <operator>!</operator><name><name>zc</name><operator>-&gt;</operator><name>initialized</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>ZSTDirp_reset</name></expr> </then><else>: <expr><name>ZSTDirp_continue</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>neededSpace</name> <init>=
            <expr><call><name>ZSTD_estimateCCtxSize_usingCCtxParams_internal</name><argument_list>(
                <argument><expr><operator>&amp;</operator><name><name>params</name><operator>-&gt;</operator><name>cParams</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>params</name><operator>-&gt;</operator><name>ldmParams</name></name></expr></argument>, <argument><expr><name><name>zc</name><operator>-&gt;</operator><name>staticSize</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>useRowMatchFinder</name></name></expr></argument>,
                <argument><expr><name>buffInSize</name></expr></argument>, <argument><expr><name>buffOutSize</name></expr></argument>, <argument><expr><name>pledgedSrcSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>resizeWorkspace</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>neededSpace</name></expr></argument>, <argument><expr><literal type="string">"cctx size estimate failed!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>zc</name><operator>-&gt;</operator><name>staticSize</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ZSTD_cwksp_bump_oversized_duration</name><argument_list>(<argument><expr><name>ws</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <block>{<block_content>   <comment type="block">/* Check if workspace is large enough, alloc a new one if needed */</comment>
            <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>workspaceTooSmall</name> <init>= <expr><call><name>ZSTD_cwksp_sizeof</name><argument_list>(<argument><expr><name>ws</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>neededSpace</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>workspaceWasteful</name> <init>= <expr><call><name>ZSTD_cwksp_check_wasteful</name><argument_list>(<argument><expr><name>ws</name></expr></argument>, <argument><expr><name>neededSpace</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>resizeWorkspace</name> <operator>=</operator> <name>workspaceTooSmall</name> <operator>||</operator> <name>workspaceWasteful</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"Need %zu B workspace"</literal></expr></argument>, <argument><expr><name>neededSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"windowSize: %zu - blockSize: %zu"</literal></expr></argument>, <argument><expr><name>windowSize</name></expr></argument>, <argument><expr><name>blockSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>resizeWorkspace</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"Resize workspaceSize from %zuKB to %zuKB"</literal></expr></argument>,
                            <argument><expr><call><name>ZSTD_cwksp_sizeof</name><argument_list>(<argument><expr><name>ws</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">10</literal></expr></argument>,
                            <argument><expr><name>neededSpace</name> <operator>&gt;&gt;</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>zc</name><operator>-&gt;</operator><name>staticSize</name></name></expr></argument>, <argument><expr><name>memory_allocation</name></expr></argument>, <argument><expr><literal type="string">"static cctx : no resize"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>needsIndexReset</name> <operator>=</operator> <name>ZSTDirp_reset</name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>ZSTD_cwksp_free</name><argument_list>(<argument><expr><name>ws</name></expr></argument>, <argument><expr><name><name>zc</name><operator>-&gt;</operator><name>customMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_cwksp_create</name><argument_list>(<argument><expr><name>ws</name></expr></argument>, <argument><expr><name>neededSpace</name></expr></argument>, <argument><expr><name><name>zc</name><operator>-&gt;</operator><name>customMem</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"reserving object space"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* Statically sized space.
                 * entropyWorkspace never moves,
                 * though prev/next block swap places */</comment>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>ZSTD_cwksp_check_available</name><argument_list>(<argument><expr><name>ws</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_compressedBlockState_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name></name> <operator>=</operator> <operator>(</operator><name>ZSTD_compressedBlockState_t</name><operator>*</operator><operator>)</operator> <call><name>ZSTD_cwksp_reserve_object</name><argument_list>(<argument><expr><name>ws</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_compressedBlockState_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name></name> <operator>==</operator> <name>NULL</name></expr></argument>, <argument><expr><name>memory_allocation</name></expr></argument>, <argument><expr><literal type="string">"couldn't allocate prevCBlock"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>nextCBlock</name></name> <operator>=</operator> <operator>(</operator><name>ZSTD_compressedBlockState_t</name><operator>*</operator><operator>)</operator> <call><name>ZSTD_cwksp_reserve_object</name><argument_list>(<argument><expr><name>ws</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_compressedBlockState_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>nextCBlock</name></name> <operator>==</operator> <name>NULL</name></expr></argument>, <argument><expr><name>memory_allocation</name></expr></argument>, <argument><expr><literal type="string">"couldn't allocate nextCBlock"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>entropyWorkspace</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>*</operator><operator>)</operator> <call><name>ZSTD_cwksp_reserve_object</name><argument_list>(<argument><expr><name>ws</name></expr></argument>, <argument><expr><name>ENTROPY_WORKSPACE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>zc</name><operator>-&gt;</operator><name>entropyWorkspace</name></name> <operator>==</operator> <name>NULL</name></expr></argument>, <argument><expr><name>memory_allocation</name></expr></argument>, <argument><expr><literal type="string">"couldn't allocate entropyWorkspace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>   </block_content>}</block>

        <expr_stmt><expr><call><name>ZSTD_cwksp_clear</name><argument_list>(<argument><expr><name>ws</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* init params */</comment>
        <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name><operator>.</operator><name>cParams</name></name> <operator>=</operator> <name><name>params</name><operator>-&gt;</operator><name>cParams</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name><operator>.</operator><name>prefetchCDictTables</name></name> <operator>=</operator> <name><name>params</name><operator>-&gt;</operator><name>prefetchCDictTables</name></name> <operator>==</operator> <name>ZSTD_ps_enable</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>pledgedSrcSizePlusOne</name></name> <operator>=</operator> <name>pledgedSrcSize</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>consumedSrcSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>producedCSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>pledgedSrcSize</name> <operator>==</operator> <name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>fParams</name><operator>.</operator><name>contentSizeFlag</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"pledged content size : %u ; flag : %u"</literal></expr></argument>,
            <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>pledgedSrcSize</name></expr></argument>, <argument><expr><name><name>zc</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>fParams</name><operator>.</operator><name>contentSizeFlag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>blockSize</name></name> <operator>=</operator> <name>blockSize</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>XXH64_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>xxhState</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>stage</name></name> <operator>=</operator> <name>ZSTDcs_init</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>dictID</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>dictContentSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ZSTD_reset_compressedBlockState</name><argument_list>(<argument><expr><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* ZSTD_wildcopy() is used to copy into the literals buffer,
         * so we have to oversize the buffer by WILDCOPY_OVERLENGTH bytes.
         */</comment>
        <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>seqStore</name><operator>.</operator><name>litStart</name></name> <operator>=</operator> <call><name>ZSTD_cwksp_reserve_buffer</name><argument_list>(<argument><expr><name>ws</name></expr></argument>, <argument><expr><name>blockSize</name> <operator>+</operator> <name>WILDCOPY_OVERLENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>seqStore</name><operator>.</operator><name>maxNbLit</name></name> <operator>=</operator> <name>blockSize</name></expr>;</expr_stmt>

        <comment type="block">/* buffers */</comment>
        <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>bufferedPolicy</name></name> <operator>=</operator> <name>zbuff</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>inBuffSize</name></name> <operator>=</operator> <name>buffInSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>inBuff</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>ZSTD_cwksp_reserve_buffer</name><argument_list>(<argument><expr><name>ws</name></expr></argument>, <argument><expr><name>buffInSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>outBuffSize</name></name> <operator>=</operator> <name>buffOutSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>outBuff</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>ZSTD_cwksp_reserve_buffer</name><argument_list>(<argument><expr><name>ws</name></expr></argument>, <argument><expr><name>buffOutSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* ldm bucketOffsets table */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>ldmParams</name><operator>.</operator><name>enableLdm</name></name> <operator>==</operator> <name>ZSTD_ps_enable</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* TODO: avoid memset? */</comment>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>numBuckets</name> <init>=
                  <expr><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>ldmParams</name><operator>.</operator><name>hashLog</name></name> <operator>-</operator>
                                  <name><name>params</name><operator>-&gt;</operator><name>ldmParams</name><operator>.</operator><name>bucketSizeLog</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>ldmState</name><operator>.</operator><name>bucketOffsets</name></name> <operator>=</operator> <call><name>ZSTD_cwksp_reserve_buffer</name><argument_list>(<argument><expr><name>ws</name></expr></argument>, <argument><expr><name>numBuckets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><name><name>zc</name><operator>-&gt;</operator><name>ldmState</name><operator>.</operator><name>bucketOffsets</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>numBuckets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* sequences storage */</comment>
        <expr_stmt><expr><call><name>ZSTD_referenceExternalSequences</name><argument_list>(<argument><expr><name>zc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>seqStore</name><operator>.</operator><name>maxNbSeq</name></name> <operator>=</operator> <name>maxNbSeq</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>seqStore</name><operator>.</operator><name>llCode</name></name> <operator>=</operator> <call><name>ZSTD_cwksp_reserve_buffer</name><argument_list>(<argument><expr><name>ws</name></expr></argument>, <argument><expr><name>maxNbSeq</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BYTE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>seqStore</name><operator>.</operator><name>mlCode</name></name> <operator>=</operator> <call><name>ZSTD_cwksp_reserve_buffer</name><argument_list>(<argument><expr><name>ws</name></expr></argument>, <argument><expr><name>maxNbSeq</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BYTE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>seqStore</name><operator>.</operator><name>ofCode</name></name> <operator>=</operator> <call><name>ZSTD_cwksp_reserve_buffer</name><argument_list>(<argument><expr><name>ws</name></expr></argument>, <argument><expr><name>maxNbSeq</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BYTE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>seqStore</name><operator>.</operator><name>sequencesStart</name></name> <operator>=</operator> <operator>(</operator><name>seqDef</name><operator>*</operator><operator>)</operator><call><name>ZSTD_cwksp_reserve_aligned</name><argument_list>(<argument><expr><name>ws</name></expr></argument>, <argument><expr><name>maxNbSeq</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>seqDef</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_reset_matchState</name><argument_list>(
            <argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name></name></expr></argument>,
            <argument><expr><name>ws</name></expr></argument>,
            <argument><expr><operator>&amp;</operator><name><name>params</name><operator>-&gt;</operator><name>cParams</name></name></expr></argument>,
            <argument><expr><name><name>params</name><operator>-&gt;</operator><name>useRowMatchFinder</name></name></expr></argument>,
            <argument><expr><name>crp</name></expr></argument>,
            <argument><expr><name>needsIndexReset</name></expr></argument>,
            <argument><expr><name>ZSTD_resetTarget_CCtx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* ldm hash table */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>ldmParams</name><operator>.</operator><name>enableLdm</name></name> <operator>==</operator> <name>ZSTD_ps_enable</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* TODO: avoid memset? */</comment>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>ldmHSize</name> <init>= <expr><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name><name>params</name><operator>-&gt;</operator><name>ldmParams</name><operator>.</operator><name>hashLog</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>ldmState</name><operator>.</operator><name>hashTable</name></name> <operator>=</operator> <operator>(</operator><name>ldmEntry_t</name><operator>*</operator><operator>)</operator><call><name>ZSTD_cwksp_reserve_aligned</name><argument_list>(<argument><expr><name>ws</name></expr></argument>, <argument><expr><name>ldmHSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ldmEntry_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><name><name>zc</name><operator>-&gt;</operator><name>ldmState</name><operator>.</operator><name>hashTable</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ldmHSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ldmEntry_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>ldmSequences</name></name> <operator>=</operator> <operator>(</operator><name>rawSeq</name><operator>*</operator><operator>)</operator><call><name>ZSTD_cwksp_reserve_aligned</name><argument_list>(<argument><expr><name>ws</name></expr></argument>, <argument><expr><name>maxNbLdmSeq</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>rawSeq</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>maxNbLdmSequences</name></name> <operator>=</operator> <name>maxNbLdmSeq</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>ZSTD_window_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>ldmState</name><operator>.</operator><name>window</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>ldmState</name><operator>.</operator><name>loadedDictEnd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"wksp: finished allocating, %zd bytes remain available"</literal></expr></argument>, <argument><expr><call><name>ZSTD_cwksp_available_space</name><argument_list>(<argument><expr><name>ws</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>ZSTD_cwksp_estimated_space_within_bounds</name><argument_list>(<argument><expr><name>ws</name></expr></argument>, <argument><expr><name>neededSpace</name></expr></argument>, <argument><expr><name>resizeWorkspace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>initialized</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/* ZSTD_invalidateRepCodes() :
 * ensures next compression will not use repcodes from previous block.
 * Note : only works with regular variant;
 *        do not use with extDict variant ! */</comment>
<function><type><name>void</name></type> <name>ZSTD_invalidateRepCodes</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>ZSTD_REP_NUM</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name><operator>-&gt;</operator><name>rep</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ZSTD_window_hasExtDict</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name><operator>.</operator><name>window</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* These are the approximate sizes for each strategy past which copying the
 * dictionary tables into the working context is faster than using them
 * in-place.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name><name>attachDictSizeCutoffs</name><index>[<expr><name>ZSTD_STRATEGY_MAX</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{
    <expr><literal type="number">8</literal> <name>KB</name></expr>,  <comment type="block">/* unused */</comment>
    <expr><literal type="number">8</literal> <name>KB</name></expr>,  <comment type="block">/* ZSTD_fast */</comment>
    <expr><literal type="number">16</literal> <name>KB</name></expr>, <comment type="block">/* ZSTD_dfast */</comment>
    <expr><literal type="number">32</literal> <name>KB</name></expr>, <comment type="block">/* ZSTD_greedy */</comment>
    <expr><literal type="number">32</literal> <name>KB</name></expr>, <comment type="block">/* ZSTD_lazy */</comment>
    <expr><literal type="number">32</literal> <name>KB</name></expr>, <comment type="block">/* ZSTD_lazy2 */</comment>
    <expr><literal type="number">32</literal> <name>KB</name></expr>, <comment type="block">/* ZSTD_btlazy2 */</comment>
    <expr><literal type="number">32</literal> <name>KB</name></expr>, <comment type="block">/* ZSTD_btopt */</comment>
    <expr><literal type="number">8</literal> <name>KB</name></expr>,  <comment type="block">/* ZSTD_btultra */</comment>
    <expr><literal type="number">8</literal> <name>KB</name></expr>   <comment type="block">/* ZSTD_btultra2 */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ZSTD_shouldAttachDict</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ZSTD_CDict</name><modifier>*</modifier></type> <name>cdict</name></decl></parameter>,
                                 <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>params</name></decl></parameter>,
                                 <parameter><decl><type><name>U64</name></type> <name>pledgedSrcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>cutoff</name> <init>= <expr><name><name>attachDictSizeCutoffs</name><index>[<expr><name><name>cdict</name><operator>-&gt;</operator><name>matchState</name><operator>.</operator><name>cParams</name><operator>.</operator><name>strategy</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>dedicatedDictSearch</name> <init>= <expr><name><name>cdict</name><operator>-&gt;</operator><name>matchState</name><operator>.</operator><name>dedicatedDictSearch</name></name></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>dedicatedDictSearch</name>
        <operator>||</operator> <operator>(</operator> <operator>(</operator> <name>pledgedSrcSize</name> <operator>&lt;=</operator> <name>cutoff</name>
            <operator>||</operator> <name>pledgedSrcSize</name> <operator>==</operator> <name>ZSTD_CONTENTSIZE_UNKNOWN</name>
            <operator>||</operator> <name><name>params</name><operator>-&gt;</operator><name>attachDictPref</name></name> <operator>==</operator> <name>ZSTD_dictForceAttach</name> <operator>)</operator>
          <operator>&amp;&amp;</operator> <name><name>params</name><operator>-&gt;</operator><name>attachDictPref</name></name> <operator>!=</operator> <name>ZSTD_dictForceCopy</name>
          <operator>&amp;&amp;</operator> <operator>!</operator><name><name>params</name><operator>-&gt;</operator><name>forceWindow</name></name> <operator>)</operator></expr>;</return> <comment type="block">/* dictMatchState isn't correctly
                                      * handled in _enforceMaxDist */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>ZSTD_resetCCtx_byAttachingCDict</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CDict</name><modifier>*</modifier></type> <name>cdict</name></decl></parameter>,
                        <parameter><decl><type><name>ZSTD_CCtx_params</name></type> <name>params</name></decl></parameter>,
                        <parameter><decl><type><name>U64</name></type> <name>pledgedSrcSize</name></decl></parameter>,
                        <parameter><decl><type><name>ZSTD_buffered_policy_e</name></type> <name>zbuff</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_resetCCtx_byAttachingCDict() pledgedSrcSize=%llu"</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator><name>pledgedSrcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ZSTD_compressionParameters</name></type> <name>adjusted_cdict_cParams</name> <init>= <expr><name><name>cdict</name><operator>-&gt;</operator><name>matchState</name><operator>.</operator><name>cParams</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>windowLog</name> <init>= <expr><name><name>params</name><operator>.</operator><name>cParams</name><operator>.</operator><name>windowLog</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>windowLog</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Resize working context table params for input only, since the dict
         * has its own tables. */</comment>
        <comment type="block">/* pledgedSrcSize == 0 means 0! */</comment>

        <if_stmt><if>if <condition>(<expr><name><name>cdict</name><operator>-&gt;</operator><name>matchState</name><operator>.</operator><name>dedicatedDictSearch</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>ZSTD_dedicatedDictSearch_revertCParams</name><argument_list>(<argument><expr><operator>&amp;</operator><name>adjusted_cdict_cParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>params</name><operator>.</operator><name>cParams</name></name> <operator>=</operator> <call><name>ZSTD_adjustCParams_internal</name><argument_list>(<argument><expr><name>adjusted_cdict_cParams</name></expr></argument>, <argument><expr><name>pledgedSrcSize</name></expr></argument>,
                                                     <argument><expr><name><name>cdict</name><operator>-&gt;</operator><name>dictContentSize</name></name></expr></argument>, <argument><expr><name>ZSTD_cpm_attachDict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>params</name><operator>.</operator><name>cParams</name><operator>.</operator><name>windowLog</name></name> <operator>=</operator> <name>windowLog</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>params</name><operator>.</operator><name>useRowMatchFinder</name></name> <operator>=</operator> <name><name>cdict</name><operator>-&gt;</operator><name>useRowMatchFinder</name></name></expr>;</expr_stmt>    <comment type="block">/* cdict overrides */</comment>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_resetCCtx_internal</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><name>pledgedSrcSize</name></expr></argument>,
                                                 <comment type="block">/* loadedDictSize */</comment> <argument><expr><literal type="number">0</literal></expr></argument>,
                                                 <argument><expr><name>ZSTDcrp_makeClean</name></expr></argument>, <argument><expr><name>zbuff</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>cParams</name><operator>.</operator><name>strategy</name></name> <operator>==</operator> <name><name>adjusted_cdict_cParams</name><operator>.</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <block>{<block_content>   <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>cdictEnd</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator> <name><name>cdict</name><operator>-&gt;</operator><name>matchState</name><operator>.</operator><name>window</name><operator>.</operator><name>nextSrc</name></name>
                                  <operator>-</operator> <name><name>cdict</name><operator>-&gt;</operator><name>matchState</name><operator>.</operator><name>window</name><operator>.</operator><name>base</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>cdictLen</name> <init>= <expr><name>cdictEnd</name> <operator>-</operator> <name><name>cdict</name><operator>-&gt;</operator><name>matchState</name><operator>.</operator><name>window</name><operator>.</operator><name>dictLimit</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>cdictLen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* don't even attach dictionaries with no contents */</comment>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"skipping attaching empty dictionary"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"attaching dictionary into context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name><operator>.</operator><name>dictMatchState</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>cdict</name><operator>-&gt;</operator><name>matchState</name></name></expr>;</expr_stmt>

            <comment type="block">/* prep working match state so dict matches never have negative indices
             * when they are translated to the working context's index space. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name><operator>.</operator><name>window</name><operator>.</operator><name>dictLimit</name></name> <operator>&lt;</operator> <name>cdictEnd</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name><operator>.</operator><name>window</name><operator>.</operator><name>nextSrc</name></name> <operator>=</operator>
                    <name><name>cctx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name><operator>.</operator><name>window</name><operator>.</operator><name>base</name></name> <operator>+</operator> <name>cdictEnd</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ZSTD_window_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name><operator>.</operator><name>window</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* loadedDictEnd is expressed within the referential of the active context */</comment>
            <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name><operator>.</operator><name>loadedDictEnd</name></name> <operator>=</operator> <name><name>cctx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name><operator>.</operator><name>window</name><operator>.</operator><name>dictLimit</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>   </block_content>}</block>

    <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>dictID</name></name> <operator>=</operator> <name><name>cdict</name><operator>-&gt;</operator><name>dictID</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>dictContentSize</name></name> <operator>=</operator> <name><name>cdict</name><operator>-&gt;</operator><name>dictContentSize</name></name></expr>;</expr_stmt>

    <comment type="block">/* copy block state */</comment>
    <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cdict</name><operator>-&gt;</operator><name>cBlockState</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>cdict</name><operator>-&gt;</operator><name>cBlockState</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_copyCDictTableIntoCCtx</name><parameter_list>(<parameter><decl><type><name>U32</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>tableSize</name></decl></parameter>,
                                        <parameter><decl><type><name>ZSTD_compressionParameters</name> <specifier>const</specifier><modifier>*</modifier></type> <name>cParams</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>ZSTD_CDictIndicesAreTagged</name><argument_list>(<argument><expr><name>cParams</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
        <comment type="block">/* Remove tags from the CDict table if they are present.
         * See docs on "short cache" in zstd_compress_internal.h for context. */</comment>
        <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>tableSize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>taggedIndex</name> <init>= <expr><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>index</name> <init>= <expr><name>taggedIndex</name> <operator>&gt;&gt;</operator> <name>ZSTD_SHORT_CACHE_TAG_BITS</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>dst</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>tableSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>U32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_resetCCtx_byCopyingCDict</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>,
                            <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CDict</name><modifier>*</modifier></type> <name>cdict</name></decl></parameter>,
                            <parameter><decl><type><name>ZSTD_CCtx_params</name></type> <name>params</name></decl></parameter>,
                            <parameter><decl><type><name>U64</name></type> <name>pledgedSrcSize</name></decl></parameter>,
                            <parameter><decl><type><name>ZSTD_buffered_policy_e</name></type> <name>zbuff</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_compressionParameters</name> <modifier>*</modifier></type><name>cdict_cParams</name> <init>= <expr><operator>&amp;</operator><name><name>cdict</name><operator>-&gt;</operator><name>matchState</name><operator>.</operator><name>cParams</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>cdict</name><operator>-&gt;</operator><name>matchState</name><operator>.</operator><name>dedicatedDictSearch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_resetCCtx_byCopyingCDict() pledgedSrcSize=%llu"</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator><name>pledgedSrcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <block>{<block_content>   <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>windowLog</name> <init>= <expr><name><name>params</name><operator>.</operator><name>cParams</name><operator>.</operator><name>windowLog</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>windowLog</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Copy only compression parameters related to tables. */</comment>
        <expr_stmt><expr><name><name>params</name><operator>.</operator><name>cParams</name></name> <operator>=</operator> <operator>*</operator><name>cdict_cParams</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>params</name><operator>.</operator><name>cParams</name><operator>.</operator><name>windowLog</name></name> <operator>=</operator> <name>windowLog</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>params</name><operator>.</operator><name>useRowMatchFinder</name></name> <operator>=</operator> <name><name>cdict</name><operator>-&gt;</operator><name>useRowMatchFinder</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_resetCCtx_internal</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><name>pledgedSrcSize</name></expr></argument>,
                                                 <comment type="block">/* loadedDictSize */</comment> <argument><expr><literal type="number">0</literal></expr></argument>,
                                                 <argument><expr><name>ZSTDcrp_leaveDirty</name></expr></argument>, <argument><expr><name>zbuff</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>cParams</name><operator>.</operator><name>strategy</name></name> <operator>==</operator> <name><name>cdict_cParams</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>cParams</name><operator>.</operator><name>hashLog</name></name> <operator>==</operator> <name><name>cdict_cParams</name><operator>-&gt;</operator><name>hashLog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>cParams</name><operator>.</operator><name>chainLog</name></name> <operator>==</operator> <name><name>cdict_cParams</name><operator>-&gt;</operator><name>chainLog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>ZSTD_cwksp_mark_tables_dirty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>params</name><operator>.</operator><name>useRowMatchFinder</name></name> <operator>!=</operator> <name>ZSTD_ps_auto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* copy tables */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>chainSize</name> <init>= <expr><ternary><condition><expr><call><name>ZSTD_allocateChainTable</name><argument_list>(<argument><expr><name><name>cdict_cParams</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>, <argument><expr><name><name>cdict</name><operator>-&gt;</operator><name>useRowMatchFinder</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* DDS guaranteed disabled */</comment>)</argument_list></call></expr>
                                                            ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>cdict_cParams</name><operator>-&gt;</operator><name>chainLog</name></name><operator>)</operator></expr>
                                                            </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>hSize</name> <init>=  <expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>cdict_cParams</name><operator>-&gt;</operator><name>hashLog</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>ZSTD_copyCDictTableIntoCCtx</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name><operator>.</operator><name>hashTable</name></name></expr></argument>,
                                <argument><expr><name><name>cdict</name><operator>-&gt;</operator><name>matchState</name><operator>.</operator><name>hashTable</name></name></expr></argument>,
                                <argument><expr><name>hSize</name></expr></argument>, <argument><expr><name>cdict_cParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Do not copy cdict's chainTable if cctx has parameters such that it would not use chainTable */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>ZSTD_allocateChainTable</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>cParams</name><operator>.</operator><name>strategy</name></name></expr></argument>, <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>useRowMatchFinder</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* forDDSDict */</comment>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>ZSTD_copyCDictTableIntoCCtx</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name><operator>.</operator><name>chainTable</name></name></expr></argument>,
                                    <argument><expr><name><name>cdict</name><operator>-&gt;</operator><name>matchState</name><operator>.</operator><name>chainTable</name></name></expr></argument>,
                                    <argument><expr><name>chainSize</name></expr></argument>, <argument><expr><name>cdict_cParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* copy tag table */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>ZSTD_rowMatchFinderUsed</name><argument_list>(<argument><expr><name><name>cdict_cParams</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>, <argument><expr><name><name>cdict</name><operator>-&gt;</operator><name>useRowMatchFinder</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>tagTableSize</name> <init>= <expr><name>hSize</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>U16</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name><operator>.</operator><name>tagTable</name></name></expr></argument>,
                <argument><expr><name><name>cdict</name><operator>-&gt;</operator><name>matchState</name><operator>.</operator><name>tagTable</name></name></expr></argument>,
                <argument><expr><name>tagTableSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/* Zero the hashTable3, since the cdict never fills it */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>h3log</name> <init>= <expr><name><name>cctx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name><operator>.</operator><name>hashLog3</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>h3Size</name> <init>= <expr><ternary><condition><expr><name>h3log</name></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>h3log</name><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cdict</name><operator>-&gt;</operator><name>matchState</name><operator>.</operator><name>hashLog3</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name><operator>.</operator><name>hashTable3</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>h3Size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>U32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>ZSTD_cwksp_mark_tables_clean</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* copy dictionary offsets */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>ZSTD_matchState_t</name> <specifier>const</specifier><modifier>*</modifier></type> <name>srcMatchState</name> <init>= <expr><operator>&amp;</operator><name><name>cdict</name><operator>-&gt;</operator><name>matchState</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>dstMatchState</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>dstMatchState</name><operator>-&gt;</operator><name>window</name></name>       <operator>=</operator> <name><name>srcMatchState</name><operator>-&gt;</operator><name>window</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dstMatchState</name><operator>-&gt;</operator><name>nextToUpdate</name></name> <operator>=</operator> <name><name>srcMatchState</name><operator>-&gt;</operator><name>nextToUpdate</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dstMatchState</name><operator>-&gt;</operator><name>loadedDictEnd</name></name><operator>=</operator> <name><name>srcMatchState</name><operator>-&gt;</operator><name>loadedDictEnd</name></name></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>dictID</name></name> <operator>=</operator> <name><name>cdict</name><operator>-&gt;</operator><name>dictID</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>dictContentSize</name></name> <operator>=</operator> <name><name>cdict</name><operator>-&gt;</operator><name>dictContentSize</name></name></expr>;</expr_stmt>

    <comment type="block">/* copy block state */</comment>
    <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cdict</name><operator>-&gt;</operator><name>cBlockState</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>cdict</name><operator>-&gt;</operator><name>cBlockState</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* We have a choice between copying the dictionary context into the working
 * context, or referencing the dictionary context from the working context
 * in-place. We decide here which strategy to use. */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_resetCCtx_usingCDict</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>,
                            <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CDict</name><modifier>*</modifier></type> <name>cdict</name></decl></parameter>,
                            <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>params</name></decl></parameter>,
                            <parameter><decl><type><name>U64</name></type> <name>pledgedSrcSize</name></decl></parameter>,
                            <parameter><decl><type><name>ZSTD_buffered_policy_e</name></type> <name>zbuff</name></decl></parameter>)</parameter_list>
<block>{<block_content>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_resetCCtx_usingCDict (pledgedSrcSize=%u)"</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>pledgedSrcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>ZSTD_shouldAttachDict</name><argument_list>(<argument><expr><name>cdict</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>pledgedSrcSize</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>ZSTD_resetCCtx_byAttachingCDict</name><argument_list>(
            <argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>cdict</name></expr></argument>, <argument><expr><operator>*</operator><name>params</name></expr></argument>, <argument><expr><name>pledgedSrcSize</name></expr></argument>, <argument><expr><name>zbuff</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><call><name>ZSTD_resetCCtx_byCopyingCDict</name><argument_list>(
            <argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>cdict</name></expr></argument>, <argument><expr><operator>*</operator><name>params</name></expr></argument>, <argument><expr><name>pledgedSrcSize</name></expr></argument>, <argument><expr><name>zbuff</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! ZSTD_copyCCtx_internal() :
 *  Duplicate an existing context `srcCCtx` into another one `dstCCtx`.
 *  Only works during stage ZSTDcs_init (i.e. after creation, but before first call to ZSTD_compressContinue()).
 *  The "context", in this case, refers to the hash and chain tables,
 *  entropy tables, and dictionary references.
 * `windowLog` value is enforced if != 0, otherwise value is copied from srcCCtx.
 * @return : 0, or an error code */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_copyCCtx_internal</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>dstCCtx</name></decl></parameter>,
                            <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>srcCCtx</name></decl></parameter>,
                            <parameter><decl><type><name>ZSTD_frameParameters</name></type> <name>fParams</name></decl></parameter>,
                            <parameter><decl><type><name>U64</name></type> <name>pledgedSrcSize</name></decl></parameter>,
                            <parameter><decl><type><name>ZSTD_buffered_policy_e</name></type> <name>zbuff</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>srcCCtx</name><operator>-&gt;</operator><name>stage</name></name><operator>!=</operator><name>ZSTDcs_init</name></expr></argument>, <argument><expr><name>stage_wrong</name></expr></argument>,
                    <argument><expr><literal type="string">"Can't copy a ctx that's not in init stage."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_copyCCtx_internal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dstCCtx</name><operator>-&gt;</operator><name>customMem</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>srcCCtx</name><operator>-&gt;</operator><name>customMem</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_customMem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>ZSTD_CCtx_params</name></type> <name>params</name> <init>= <expr><name><name>dstCCtx</name><operator>-&gt;</operator><name>requestedParams</name></name></expr></init></decl>;</decl_stmt>
        <comment type="block">/* Copy only compression parameters related to tables. */</comment>
        <expr_stmt><expr><name><name>params</name><operator>.</operator><name>cParams</name></name> <operator>=</operator> <name><name>srcCCtx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>cParams</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>srcCCtx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>useRowMatchFinder</name></name> <operator>!=</operator> <name>ZSTD_ps_auto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>srcCCtx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>useBlockSplitter</name></name> <operator>!=</operator> <name>ZSTD_ps_auto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>srcCCtx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>ldmParams</name><operator>.</operator><name>enableLdm</name></name> <operator>!=</operator> <name>ZSTD_ps_auto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>params</name><operator>.</operator><name>useRowMatchFinder</name></name> <operator>=</operator> <name><name>srcCCtx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>useRowMatchFinder</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>params</name><operator>.</operator><name>useBlockSplitter</name></name> <operator>=</operator> <name><name>srcCCtx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>useBlockSplitter</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>params</name><operator>.</operator><name>ldmParams</name></name> <operator>=</operator> <name><name>srcCCtx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>ldmParams</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>params</name><operator>.</operator><name>fParams</name></name> <operator>=</operator> <name>fParams</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_resetCCtx_internal</name><argument_list>(<argument><expr><name>dstCCtx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><name>pledgedSrcSize</name></expr></argument>,
                                <comment type="block">/* loadedDictSize */</comment> <argument><expr><literal type="number">0</literal></expr></argument>,
                                <argument><expr><name>ZSTDcrp_leaveDirty</name></expr></argument>, <argument><expr><name>zbuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dstCCtx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>cParams</name><operator>.</operator><name>windowLog</name></name> <operator>==</operator> <name><name>srcCCtx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>cParams</name><operator>.</operator><name>windowLog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dstCCtx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>cParams</name><operator>.</operator><name>strategy</name></name> <operator>==</operator> <name><name>srcCCtx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>cParams</name><operator>.</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dstCCtx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>cParams</name><operator>.</operator><name>hashLog</name></name> <operator>==</operator> <name><name>srcCCtx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>cParams</name><operator>.</operator><name>hashLog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dstCCtx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>cParams</name><operator>.</operator><name>chainLog</name></name> <operator>==</operator> <name><name>srcCCtx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>cParams</name><operator>.</operator><name>chainLog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dstCCtx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name><operator>.</operator><name>hashLog3</name></name> <operator>==</operator> <name><name>srcCCtx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name><operator>.</operator><name>hashLog3</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>ZSTD_cwksp_mark_tables_dirty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dstCCtx</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* copy tables */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>chainSize</name> <init>= <expr><ternary><condition><expr><call><name>ZSTD_allocateChainTable</name><argument_list>(<argument><expr><name><name>srcCCtx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>cParams</name><operator>.</operator><name>strategy</name></name></expr></argument>,
                                                         <argument><expr><name><name>srcCCtx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>useRowMatchFinder</name></name></expr></argument>,
                                                         <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* forDDSDict */</comment>)</argument_list></call></expr>
                                    ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>srcCCtx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>cParams</name><operator>.</operator><name>chainLog</name></name><operator>)</operator></expr>
                                    </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>hSize</name> <init>=  <expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>srcCCtx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>cParams</name><operator>.</operator><name>hashLog</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>h3log</name> <init>= <expr><name><name>srcCCtx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name><operator>.</operator><name>hashLog3</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>h3Size</name> <init>= <expr><ternary><condition><expr><name>h3log</name></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>h3log</name><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name><name>dstCCtx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name><operator>.</operator><name>hashTable</name></name></expr></argument>,
               <argument><expr><name><name>srcCCtx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name><operator>.</operator><name>hashTable</name></name></expr></argument>,
               <argument><expr><name>hSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>U32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name><name>dstCCtx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name><operator>.</operator><name>chainTable</name></name></expr></argument>,
               <argument><expr><name><name>srcCCtx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name><operator>.</operator><name>chainTable</name></name></expr></argument>,
               <argument><expr><name>chainSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>U32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name><name>dstCCtx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name><operator>.</operator><name>hashTable3</name></name></expr></argument>,
               <argument><expr><name><name>srcCCtx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name><operator>.</operator><name>hashTable3</name></name></expr></argument>,
               <argument><expr><name>h3Size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>U32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>ZSTD_cwksp_mark_tables_clean</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dstCCtx</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* copy dictionary offsets */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>srcMatchState</name> <init>= <expr><operator>&amp;</operator><name><name>srcCCtx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>dstMatchState</name> <init>= <expr><operator>&amp;</operator><name><name>dstCCtx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>dstMatchState</name><operator>-&gt;</operator><name>window</name></name>       <operator>=</operator> <name><name>srcMatchState</name><operator>-&gt;</operator><name>window</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dstMatchState</name><operator>-&gt;</operator><name>nextToUpdate</name></name> <operator>=</operator> <name><name>srcMatchState</name><operator>-&gt;</operator><name>nextToUpdate</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dstMatchState</name><operator>-&gt;</operator><name>loadedDictEnd</name></name><operator>=</operator> <name><name>srcMatchState</name><operator>-&gt;</operator><name>loadedDictEnd</name></name></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><name><name>dstCCtx</name><operator>-&gt;</operator><name>dictID</name></name> <operator>=</operator> <name><name>srcCCtx</name><operator>-&gt;</operator><name>dictID</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dstCCtx</name><operator>-&gt;</operator><name>dictContentSize</name></name> <operator>=</operator> <name><name>srcCCtx</name><operator>-&gt;</operator><name>dictContentSize</name></name></expr>;</expr_stmt>

    <comment type="block">/* copy block state */</comment>
    <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name><name>dstCCtx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name></name></expr></argument>, <argument><expr><name><name>srcCCtx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>srcCCtx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! ZSTD_copyCCtx() :
 *  Duplicate an existing context `srcCCtx` into another one `dstCCtx`.
 *  Only works during stage ZSTDcs_init (i.e. after creation, but before first call to ZSTD_compressContinue()).
 *  pledgedSrcSize==0 means "unknown".
*   @return : 0, or an error code */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_copyCCtx</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>dstCCtx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>srcCCtx</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>pledgedSrcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_frameParameters</name></type> <name>fParams</name> <init>= <expr><block>{ <expr><literal type="number">1</literal></expr> <comment type="block">/*content*/</comment>, <expr><literal type="number">0</literal></expr> <comment type="block">/*checksum*/</comment>, <expr><literal type="number">0</literal></expr> <comment type="block">/*noDictID*/</comment> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_buffered_policy_e</name> <specifier>const</specifier></type> <name>zbuff</name> <init>= <expr><name><name>srcCCtx</name><operator>-&gt;</operator><name>bufferedPolicy</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ZSTD_STATIC_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>ZSTDb_buffered</name><operator>==</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>pledgedSrcSize</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pledgedSrcSize</name> <operator>=</operator> <name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>fParams</name><operator>.</operator><name>contentSizeFlag</name></name> <operator>=</operator> <operator>(</operator><name>pledgedSrcSize</name> <operator>!=</operator> <name>ZSTD_CONTENTSIZE_UNKNOWN</name><operator>)</operator></expr>;</expr_stmt>

    <return>return <expr><call><name>ZSTD_copyCCtx_internal</name><argument_list>(<argument><expr><name>dstCCtx</name></expr></argument>, <argument><expr><name>srcCCtx</name></expr></argument>,
                                <argument><expr><name>fParams</name></expr></argument>, <argument><expr><name>pledgedSrcSize</name></expr></argument>,
                                <argument><expr><name>zbuff</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZSTD_ROWSIZE</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<comment type="block" format="doxygen">/*! ZSTD_reduceTable() :
 *  reduce table indexes by `reducerValue`, or squash to zero.
 *  PreserveMark preserves "unsorted mark" for btlazy2 strategy.
 *  It must be set to a clear 0/1 value, to remove branch during inlining.
 *  Presume table size is a multiple of ZSTD_ROWSIZE
 *  to help auto-vectorization */</comment>
<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>void</name></type>
<name>ZSTD_reduceTable_internal</name> <parameter_list>(<parameter><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>table</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>reducerValue</name></decl></parameter>, <parameter><decl><type><name>int</name> <specifier>const</specifier></type> <name>preserveMark</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>nbRows</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name>size</name> <operator>/</operator> <name>ZSTD_ROWSIZE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cellNb</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rowNb</name></decl>;</decl_stmt>
    <comment type="block">/* Protect special index values &lt; ZSTD_WINDOW_START_INDEX. */</comment>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>reducerThreshold</name> <init>= <expr><name>reducerValue</name> <operator>+</operator> <name>ZSTD_WINDOW_START_INDEX</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>size</name> <operator>&amp;</operator> <operator>(</operator><name>ZSTD_ROWSIZE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* multiple of ZSTD_ROWSIZE */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size</name> <operator>&lt;</operator> <operator>(</operator><literal type="number">1U</literal><operator>&lt;&lt;</operator><literal type="number">31</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* can be casted to int */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ZSTD_MEMORY_SANITIZER</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name> <argument_list>(<argument><expr><name>ZSTD_MSAN_DONT_POISON_WORKSPACE</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="block">/* To validate that the table re-use logic is sound, and that we don't
     * access table space that we haven't cleaned, we re-"poison" the table
     * space every time we mark it dirty.
     *
     * This function however is intended to operate on those dirty tables and
     * re-clean them. So when this function is used correctly, we can unpoison
     * the memory it operated on. This introduces a blind spot though, since
     * if we now try to operate on __actually__ poisoned memory, we will not
     * detect that. */</comment>
    <expr_stmt><expr><call><name>__msan_unpoison</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>U32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <for>for <control>(<init><expr><name>rowNb</name><operator>=</operator><literal type="number">0</literal></expr> ;</init> <condition><expr><name>rowNb</name> <operator>&lt;</operator> <name>nbRows</name></expr> ;</condition> <incr><expr><name>rowNb</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>column</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>column</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>column</name><operator>&lt;</operator><name>ZSTD_ROWSIZE</name></expr>;</condition> <incr><expr><name>column</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>U32</name></type> <name>newVal</name></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>preserveMark</name> <operator>&amp;&amp;</operator> <name><name>table</name><index>[<expr><name>cellNb</name></expr>]</index></name> <operator>==</operator> <name>ZSTD_DUBT_UNSORTED_MARK</name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* This write is pointless, but is required(?) for the compiler
                 * to auto-vectorize the loop. */</comment>
                <expr_stmt><expr><name>newVal</name> <operator>=</operator> <name>ZSTD_DUBT_UNSORTED_MARK</name></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>table</name><index>[<expr><name>cellNb</name></expr>]</index></name> <operator>&lt;</operator> <name>reducerThreshold</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>newVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>newVal</name> <operator>=</operator> <name><name>table</name><index>[<expr><name>cellNb</name></expr>]</index></name> <operator>-</operator> <name>reducerValue</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name><name>table</name><index>[<expr><name>cellNb</name></expr>]</index></name> <operator>=</operator> <name>newVal</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>cellNb</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>   </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_reduceTable</name><parameter_list>(<parameter><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>table</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>reducerValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>ZSTD_reduceTable_internal</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>reducerValue</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_reduceTable_btlazy2</name><parameter_list>(<parameter><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>table</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>reducerValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>ZSTD_reduceTable_internal</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>reducerValue</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! ZSTD_reduceIndex() :
*   rescale all indexes to avoid future overflow (indexes are U32) */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_reduceIndex</name> <parameter_list>(<parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>, <parameter><decl><type><name>ZSTD_CCtx_params</name> <specifier>const</specifier><modifier>*</modifier></type> <name>params</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name>reducerValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>hSize</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>params</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>hashLog</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ZSTD_reduceTable</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>hashTable</name></name></expr></argument>, <argument><expr><name>hSize</name></expr></argument>, <argument><expr><name>reducerValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <if_stmt><if>if <condition>(<expr><call><name>ZSTD_allocateChainTable</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>strategy</name></name></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>useRowMatchFinder</name></name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>ms</name><operator>-&gt;</operator><name>dedicatedDictSearch</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>chainSize</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>params</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>chainLog</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>strategy</name></name> <operator>==</operator> <name>ZSTD_btlazy2</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ZSTD_reduceTable_btlazy2</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>chainTable</name></name></expr></argument>, <argument><expr><name>chainSize</name></expr></argument>, <argument><expr><name>reducerValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ZSTD_reduceTable</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>chainTable</name></name></expr></argument>, <argument><expr><name>chainSize</name></expr></argument>, <argument><expr><name>reducerValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>ms</name><operator>-&gt;</operator><name>hashLog3</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>h3Size</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>ms</name><operator>-&gt;</operator><name>hashLog3</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ZSTD_reduceTable</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>hashTable3</name></name></expr></argument>, <argument><expr><name>h3Size</name></expr></argument>, <argument><expr><name>reducerValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*-*******************************************************
*  Block entropic compression
*********************************************************/</comment>

<comment type="block">/* See doc/zstd_compression_format.md for detailed format description */</comment>

<function><type><name>void</name></type> <name>ZSTD_seqToCodes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>seqStore_t</name><modifier>*</modifier></type> <name>seqStorePtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>seqDef</name><modifier>*</modifier> <specifier>const</specifier></type> <name>sequences</name> <init>= <expr><name><name>seqStorePtr</name><operator>-&gt;</operator><name>sequencesStart</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>llCodeTable</name> <init>= <expr><name><name>seqStorePtr</name><operator>-&gt;</operator><name>llCode</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ofCodeTable</name> <init>= <expr><name><name>seqStorePtr</name><operator>-&gt;</operator><name>ofCode</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>mlCodeTable</name> <init>= <expr><name><name>seqStorePtr</name><operator>-&gt;</operator><name>mlCode</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>nbSeq</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name><name>seqStorePtr</name><operator>-&gt;</operator><name>sequences</name></name> <operator>-</operator> <name><name>seqStorePtr</name><operator>-&gt;</operator><name>sequencesStart</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>u</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nbSeq</name> <operator>&lt;=</operator> <name><name>seqStorePtr</name><operator>-&gt;</operator><name>maxNbSeq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>u</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>u</name><operator>&lt;</operator><name>nbSeq</name></expr>;</condition> <incr><expr><name>u</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>llv</name> <init>= <expr><name><name>sequences</name><index>[<expr><name>u</name></expr>]</index></name><operator>.</operator><name>litLength</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>mlv</name> <init>= <expr><name><name>sequences</name><index>[<expr><name>u</name></expr>]</index></name><operator>.</operator><name>mlBase</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>llCodeTable</name><index>[<expr><name>u</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><call><name>ZSTD_LLcode</name><argument_list>(<argument><expr><name>llv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ofCodeTable</name><index>[<expr><name>u</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><name><name>sequences</name><index>[<expr><name>u</name></expr>]</index></name><operator>.</operator><name>offBase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mlCodeTable</name><index>[<expr><name>u</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><call><name>ZSTD_MLcode</name><argument_list>(<argument><expr><name>mlv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name><name>seqStorePtr</name><operator>-&gt;</operator><name>longLengthType</name></name><operator>==</operator><name>ZSTD_llt_literalLength</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>llCodeTable</name><index>[<expr><name><name>seqStorePtr</name><operator>-&gt;</operator><name>longLengthPos</name></name></expr>]</index></name> <operator>=</operator> <name>MaxLL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>seqStorePtr</name><operator>-&gt;</operator><name>longLengthType</name></name><operator>==</operator><name>ZSTD_llt_matchLength</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>mlCodeTable</name><index>[<expr><name><name>seqStorePtr</name><operator>-&gt;</operator><name>longLengthPos</name></name></expr>]</index></name> <operator>=</operator> <name>MaxML</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ZSTD_useTargetCBlockSize():
 * Returns if target compressed block size param is being used.
 * If used, compression will do best effort to make a compressed block size to be around targetCBlockSize.
 * Returns 1 if true, 0 otherwise. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ZSTD_useTargetCBlockSize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>cctxParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_useTargetCBlockSize (targetCBlockSize=%zu)"</literal></expr></argument>, <argument><expr><name><name>cctxParams</name><operator>-&gt;</operator><name>targetCBlockSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name><name>cctxParams</name><operator>-&gt;</operator><name>targetCBlockSize</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ZSTD_blockSplitterEnabled():
 * Returns if block splitting param is being used
 * If used, compression will do best effort to split a block in order to improve compression ratio.
 * At the time this function is called, the parameter must be finalized.
 * Returns 1 if true, 0 otherwise. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ZSTD_blockSplitterEnabled</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>cctxParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_blockSplitterEnabled (useBlockSplitter=%d)"</literal></expr></argument>, <argument><expr><name><name>cctxParams</name><operator>-&gt;</operator><name>useBlockSplitter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cctxParams</name><operator>-&gt;</operator><name>useBlockSplitter</name></name> <operator>!=</operator> <name>ZSTD_ps_auto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name><name>cctxParams</name><operator>-&gt;</operator><name>useBlockSplitter</name></name> <operator>==</operator> <name>ZSTD_ps_enable</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Type returned by ZSTD_buildSequencesStatistics containing finalized symbol encoding types
 * and size of the sequences statistics
 */</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>U32</name></type> <name>LLtype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>Offtype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>MLtype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>lastCountSize</name></decl>;</decl_stmt> <comment type="block">/* Accounts for bug in 1.3.4. More detail in ZSTD_entropyCompressSeqStore_internal() */</comment>
}</block></struct></type> <name>ZSTD_symbolEncodingTypeStats_t</name>;</typedef>

<comment type="block">/* ZSTD_buildSequencesStatistics():
 * Returns a ZSTD_symbolEncodingTypeStats_t, or a zstd error code in the `size` field.
 * Modifies `nextEntropy` to have the appropriate values as a side effect.
 * nbSeq must be greater than 0.
 *
 * entropyWkspSize must be of size at least ENTROPY_WORKSPACE_SIZE - (MaxSeq + 1)*sizeof(U32)
 */</comment>
<function><type><specifier>static</specifier> <name>ZSTD_symbolEncodingTypeStats_t</name></type>
<name>ZSTD_buildSequencesStatistics</name><parameter_list>(<parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStorePtr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nbSeq</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>ZSTD_fseCTables_t</name><modifier>*</modifier></type> <name>prevEntropy</name></decl></parameter>, <parameter><decl><type><name>ZSTD_fseCTables_t</name><modifier>*</modifier></type> <name>nextEntropy</name></decl></parameter>,
                              <parameter><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dstEnd</name></decl></parameter>,
                              <parameter><decl><type><name>ZSTD_strategy</name></type> <name>strategy</name></decl></parameter>, <parameter><decl><type><name>unsigned</name><modifier>*</modifier></type> <name>countWorkspace</name></decl></parameter>,
                              <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>entropyWorkspace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>entropyWkspSize</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ostart</name> <init>= <expr><name>dst</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend</name> <init>= <expr><name>dstEnd</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><name>ostart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FSE_CTable</name><modifier>*</modifier></type> <name>CTable_LitLength</name> <init>= <expr><name><name>nextEntropy</name><operator>-&gt;</operator><name>litlengthCTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FSE_CTable</name><modifier>*</modifier></type> <name>CTable_OffsetBits</name> <init>= <expr><name><name>nextEntropy</name><operator>-&gt;</operator><name>offcodeCTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FSE_CTable</name><modifier>*</modifier></type> <name>CTable_MatchLength</name> <init>= <expr><name><name>nextEntropy</name><operator>-&gt;</operator><name>matchlengthCTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ofCodeTable</name> <init>= <expr><name><name>seqStorePtr</name><operator>-&gt;</operator><name>ofCode</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>llCodeTable</name> <init>= <expr><name><name>seqStorePtr</name><operator>-&gt;</operator><name>llCode</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>mlCodeTable</name> <init>= <expr><name><name>seqStorePtr</name><operator>-&gt;</operator><name>mlCode</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_symbolEncodingTypeStats_t</name></type> <name>stats</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>stats</name><operator>.</operator><name>lastCountSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <comment type="block">/* convert length/distances into codes */</comment>
    <expr_stmt><expr><call><name>ZSTD_seqToCodes</name><argument_list>(<argument><expr><name>seqStorePtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name> <operator>&lt;=</operator> <name>oend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nbSeq</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* ZSTD_selectEncodingType() divides by nbSeq */</comment>
    <comment type="block">/* build CTable for Literal Lengths */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>unsigned</name></type> <name>max</name> <init>= <expr><name>MaxLL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>mostFrequent</name> <init>= <expr><call><name>HIST_countFast_wksp</name><argument_list>(<argument><expr><name>countWorkspace</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>max</name></expr></argument>, <argument><expr><name>llCodeTable</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>entropyWorkspace</name></expr></argument>, <argument><expr><name>entropyWkspSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>   <comment type="block">/* can't fail */</comment>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Building LL table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nextEntropy</name><operator>-&gt;</operator><name>litlength_repeatMode</name></name> <operator>=</operator> <name><name>prevEntropy</name><operator>-&gt;</operator><name>litlength_repeatMode</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stats</name><operator>.</operator><name>LLtype</name></name> <operator>=</operator> <call><name>ZSTD_selectEncodingType</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nextEntropy</name><operator>-&gt;</operator><name>litlength_repeatMode</name></name></expr></argument>,
                                        <argument><expr><name>countWorkspace</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name>mostFrequent</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>,
                                        <argument><expr><name>LLFSELog</name></expr></argument>, <argument><expr><name><name>prevEntropy</name><operator>-&gt;</operator><name>litlengthCTable</name></name></expr></argument>,
                                        <argument><expr><name>LL_defaultNorm</name></expr></argument>, <argument><expr><name>LL_defaultNormLog</name></expr></argument>,
                                        <argument><expr><name>ZSTD_defaultAllowed</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>set_basic</name> <operator>&lt;</operator> <name>set_compressed</name> <operator>&amp;&amp;</operator> <name>set_rle</name> <operator>&lt;</operator> <name>set_compressed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>stats</name><operator>.</operator><name>LLtype</name></name> <operator>&lt;</operator> <name>set_compressed</name> <operator>&amp;&amp;</operator> <name><name>nextEntropy</name><operator>-&gt;</operator><name>litlength_repeatMode</name></name> <operator>!=</operator> <name>FSE_repeat_none</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* We don't copy tables */</comment>
        <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>countSize</name> <init>= <expr><call><name>ZSTD_buildCTable</name><argument_list>(
                <argument><expr><name>op</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name> <operator>-</operator> <name>op</name><operator>)</operator></expr></argument>,
                <argument><expr><name>CTable_LitLength</name></expr></argument>, <argument><expr><name>LLFSELog</name></expr></argument>, <argument><expr><operator>(</operator><name>symbolEncodingType_e</name><operator>)</operator><name><name>stats</name><operator>.</operator><name>LLtype</name></name></expr></argument>,
                <argument><expr><name>countWorkspace</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name>llCodeTable</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>,
                <argument><expr><name>LL_defaultNorm</name></expr></argument>, <argument><expr><name>LL_defaultNormLog</name></expr></argument>, <argument><expr><name>MaxLL</name></expr></argument>,
                <argument><expr><name><name>prevEntropy</name><operator>-&gt;</operator><name>litlengthCTable</name></name></expr></argument>,
                <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>prevEntropy</name><operator>-&gt;</operator><name>litlengthCTable</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
                <argument><expr><name>entropyWorkspace</name></expr></argument>, <argument><expr><name>entropyWkspSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>countSize</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_buildCTable for LitLens failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>stats</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>countSize</name></expr>;</expr_stmt>
                <return>return <expr><name>stats</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>stats</name><operator>.</operator><name>LLtype</name></name> <operator>==</operator> <name>set_compressed</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>stats</name><operator>.</operator><name>lastCountSize</name></name> <operator>=</operator> <name>countSize</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>countSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name> <operator>&lt;=</operator> <name>oend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>   </block_content>}</block>
    <comment type="block">/* build CTable for Offsets */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>unsigned</name></type> <name>max</name> <init>= <expr><name>MaxOff</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>mostFrequent</name> <init>= <expr><call><name>HIST_countFast_wksp</name><argument_list>(
            <argument><expr><name>countWorkspace</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>max</name></expr></argument>, <argument><expr><name>ofCodeTable</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>entropyWorkspace</name></expr></argument>, <argument><expr><name>entropyWkspSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* can't fail */</comment>
        <comment type="block">/* We can only use the basic table if max &lt;= DefaultMaxOff, otherwise the offsets are too large */</comment>
        <decl_stmt><decl><type><name>ZSTD_defaultPolicy_e</name> <specifier>const</specifier></type> <name>defaultPolicy</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>max</name> <operator>&lt;=</operator> <name>DefaultMaxOff</name><operator>)</operator></expr> ?</condition><then> <expr><name>ZSTD_defaultAllowed</name></expr> </then><else>: <expr><name>ZSTD_defaultDisallowed</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Building OF table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nextEntropy</name><operator>-&gt;</operator><name>offcode_repeatMode</name></name> <operator>=</operator> <name><name>prevEntropy</name><operator>-&gt;</operator><name>offcode_repeatMode</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stats</name><operator>.</operator><name>Offtype</name></name> <operator>=</operator> <call><name>ZSTD_selectEncodingType</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nextEntropy</name><operator>-&gt;</operator><name>offcode_repeatMode</name></name></expr></argument>,
                                        <argument><expr><name>countWorkspace</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name>mostFrequent</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>,
                                        <argument><expr><name>OffFSELog</name></expr></argument>, <argument><expr><name><name>prevEntropy</name><operator>-&gt;</operator><name>offcodeCTable</name></name></expr></argument>,
                                        <argument><expr><name>OF_defaultNorm</name></expr></argument>, <argument><expr><name>OF_defaultNormLog</name></expr></argument>,
                                        <argument><expr><name>defaultPolicy</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>stats</name><operator>.</operator><name>Offtype</name></name> <operator>&lt;</operator> <name>set_compressed</name> <operator>&amp;&amp;</operator> <name><name>nextEntropy</name><operator>-&gt;</operator><name>offcode_repeatMode</name></name> <operator>!=</operator> <name>FSE_repeat_none</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* We don't copy tables */</comment>
        <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>countSize</name> <init>= <expr><call><name>ZSTD_buildCTable</name><argument_list>(
                <argument><expr><name>op</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name> <operator>-</operator> <name>op</name><operator>)</operator></expr></argument>,
                <argument><expr><name>CTable_OffsetBits</name></expr></argument>, <argument><expr><name>OffFSELog</name></expr></argument>, <argument><expr><operator>(</operator><name>symbolEncodingType_e</name><operator>)</operator><name><name>stats</name><operator>.</operator><name>Offtype</name></name></expr></argument>,
                <argument><expr><name>countWorkspace</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name>ofCodeTable</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>,
                <argument><expr><name>OF_defaultNorm</name></expr></argument>, <argument><expr><name>OF_defaultNormLog</name></expr></argument>, <argument><expr><name>DefaultMaxOff</name></expr></argument>,
                <argument><expr><name><name>prevEntropy</name><operator>-&gt;</operator><name>offcodeCTable</name></name></expr></argument>,
                <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>prevEntropy</name><operator>-&gt;</operator><name>offcodeCTable</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
                <argument><expr><name>entropyWorkspace</name></expr></argument>, <argument><expr><name>entropyWkspSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>countSize</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_buildCTable for Offsets failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>stats</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>countSize</name></expr>;</expr_stmt>
                <return>return <expr><name>stats</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>stats</name><operator>.</operator><name>Offtype</name></name> <operator>==</operator> <name>set_compressed</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>stats</name><operator>.</operator><name>lastCountSize</name></name> <operator>=</operator> <name>countSize</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>countSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name> <operator>&lt;=</operator> <name>oend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>   </block_content>}</block>
    <comment type="block">/* build CTable for MatchLengths */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>unsigned</name></type> <name>max</name> <init>= <expr><name>MaxML</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>mostFrequent</name> <init>= <expr><call><name>HIST_countFast_wksp</name><argument_list>(
            <argument><expr><name>countWorkspace</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>max</name></expr></argument>, <argument><expr><name>mlCodeTable</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>entropyWorkspace</name></expr></argument>, <argument><expr><name>entropyWkspSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>   <comment type="block">/* can't fail */</comment>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Building ML table (remaining space : %i)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>oend</name><operator>-</operator><name>op</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nextEntropy</name><operator>-&gt;</operator><name>matchlength_repeatMode</name></name> <operator>=</operator> <name><name>prevEntropy</name><operator>-&gt;</operator><name>matchlength_repeatMode</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stats</name><operator>.</operator><name>MLtype</name></name> <operator>=</operator> <call><name>ZSTD_selectEncodingType</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nextEntropy</name><operator>-&gt;</operator><name>matchlength_repeatMode</name></name></expr></argument>,
                                        <argument><expr><name>countWorkspace</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name>mostFrequent</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>,
                                        <argument><expr><name>MLFSELog</name></expr></argument>, <argument><expr><name><name>prevEntropy</name><operator>-&gt;</operator><name>matchlengthCTable</name></name></expr></argument>,
                                        <argument><expr><name>ML_defaultNorm</name></expr></argument>, <argument><expr><name>ML_defaultNormLog</name></expr></argument>,
                                        <argument><expr><name>ZSTD_defaultAllowed</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>stats</name><operator>.</operator><name>MLtype</name></name> <operator>&lt;</operator> <name>set_compressed</name> <operator>&amp;&amp;</operator> <name><name>nextEntropy</name><operator>-&gt;</operator><name>matchlength_repeatMode</name></name> <operator>!=</operator> <name>FSE_repeat_none</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* We don't copy tables */</comment>
        <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>countSize</name> <init>= <expr><call><name>ZSTD_buildCTable</name><argument_list>(
                <argument><expr><name>op</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name> <operator>-</operator> <name>op</name><operator>)</operator></expr></argument>,
                <argument><expr><name>CTable_MatchLength</name></expr></argument>, <argument><expr><name>MLFSELog</name></expr></argument>, <argument><expr><operator>(</operator><name>symbolEncodingType_e</name><operator>)</operator><name><name>stats</name><operator>.</operator><name>MLtype</name></name></expr></argument>,
                <argument><expr><name>countWorkspace</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name>mlCodeTable</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>,
                <argument><expr><name>ML_defaultNorm</name></expr></argument>, <argument><expr><name>ML_defaultNormLog</name></expr></argument>, <argument><expr><name>MaxML</name></expr></argument>,
                <argument><expr><name><name>prevEntropy</name><operator>-&gt;</operator><name>matchlengthCTable</name></name></expr></argument>,
                <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>prevEntropy</name><operator>-&gt;</operator><name>matchlengthCTable</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
                <argument><expr><name>entropyWorkspace</name></expr></argument>, <argument><expr><name>entropyWkspSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>countSize</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_buildCTable for MatchLengths failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>stats</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>countSize</name></expr>;</expr_stmt>
                <return>return <expr><name>stats</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>stats</name><operator>.</operator><name>MLtype</name></name> <operator>==</operator> <name>set_compressed</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>stats</name><operator>.</operator><name>lastCountSize</name></name> <operator>=</operator> <name>countSize</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>countSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name> <operator>&lt;=</operator> <name>oend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>   </block_content>}</block>
    <expr_stmt><expr><name><name>stats</name><operator>.</operator><name>size</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>op</name><operator>-</operator><name>ostart</name><operator>)</operator></expr>;</expr_stmt>
    <return>return <expr><name>stats</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ZSTD_entropyCompressSeqStore_internal():
 * compresses both literals and sequences
 * Returns compressed size of block, or a zstd error.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUSPECT_UNCOMPRESSIBLE_LITERAL_RATIO</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define>
<function><type><name>MEM_STATIC</name> <name>size_t</name></type>
<name>ZSTD_entropyCompressSeqStore_internal</name><parameter_list>(<parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStorePtr</name></decl></parameter>,
                          <parameter><decl><type><specifier>const</specifier> <name>ZSTD_entropyCTables_t</name><modifier>*</modifier></type> <name>prevEntropy</name></decl></parameter>,
                                <parameter><decl><type><name>ZSTD_entropyCTables_t</name><modifier>*</modifier></type> <name>nextEntropy</name></decl></parameter>,
                          <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>cctxParams</name></decl></parameter>,
                                <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                                <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>entropyWorkspace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>entropyWkspSize</name></decl></parameter>,
                          <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>bmi2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>longOffsets</name> <init>= <expr><name><name>cctxParams</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>windowLog</name></name> <operator>&gt;</operator> <name>STREAM_ACCUMULATOR_MIN</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_strategy</name> <specifier>const</specifier></type> <name>strategy</name> <init>= <expr><name><name>cctxParams</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>strategy</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name><modifier>*</modifier></type> <name>count</name> <init>= <expr><operator>(</operator><name>unsigned</name><operator>*</operator><operator>)</operator><name>entropyWorkspace</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FSE_CTable</name><modifier>*</modifier></type> <name>CTable_LitLength</name> <init>= <expr><name><name>nextEntropy</name><operator>-&gt;</operator><name>fse</name><operator>.</operator><name>litlengthCTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FSE_CTable</name><modifier>*</modifier></type> <name>CTable_OffsetBits</name> <init>= <expr><name><name>nextEntropy</name><operator>-&gt;</operator><name>fse</name><operator>.</operator><name>offcodeCTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FSE_CTable</name><modifier>*</modifier></type> <name>CTable_MatchLength</name> <init>= <expr><name><name>nextEntropy</name><operator>-&gt;</operator><name>fse</name><operator>.</operator><name>matchlengthCTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>seqDef</name><modifier>*</modifier> <specifier>const</specifier></type> <name>sequences</name> <init>= <expr><name><name>seqStorePtr</name><operator>-&gt;</operator><name>sequencesStart</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>nbSeq</name> <init>= <expr><name><name>seqStorePtr</name><operator>-&gt;</operator><name>sequences</name></name> <operator>-</operator> <name><name>seqStorePtr</name><operator>-&gt;</operator><name>sequencesStart</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ofCodeTable</name> <init>= <expr><name><name>seqStorePtr</name><operator>-&gt;</operator><name>ofCode</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>llCodeTable</name> <init>= <expr><name><name>seqStorePtr</name><operator>-&gt;</operator><name>llCode</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>mlCodeTable</name> <init>= <expr><name><name>seqStorePtr</name><operator>-&gt;</operator><name>mlCode</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ostart</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend</name> <init>= <expr><name>ostart</name> <operator>+</operator> <name>dstCapacity</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><name>ostart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>lastCountSize</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>entropyWorkspace</name> <operator>=</operator> <name>count</name> <operator>+</operator> <operator>(</operator><name>MaxSeq</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>entropyWkspSize</name> <operator>-=</operator> <operator>(</operator><name>MaxSeq</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>count</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_entropyCompressSeqStore_internal (nbSeq=%zu, dstCapacity=%zu)"</literal></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_STATIC_ASSERT</name><argument_list>(<argument><expr><name>HUF_WORKSPACE_SIZE</name> <operator>&gt;=</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><call><name>MAX</name><argument_list>(<argument><expr><name>MLFSELog</name></expr></argument>,<argument><expr><name>LLFSELog</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>entropyWkspSize</name> <operator>&gt;=</operator> <name>HUF_WORKSPACE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Compress literals */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>literals</name> <init>= <expr><name><name>seqStorePtr</name><operator>-&gt;</operator><name>litStart</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>numSequences</name> <init>= <expr><name><name>seqStorePtr</name><operator>-&gt;</operator><name>sequences</name></name> <operator>-</operator> <name><name>seqStorePtr</name><operator>-&gt;</operator><name>sequencesStart</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>numLiterals</name> <init>= <expr><name><name>seqStorePtr</name><operator>-&gt;</operator><name>lit</name></name> <operator>-</operator> <name><name>seqStorePtr</name><operator>-&gt;</operator><name>litStart</name></name></expr></init></decl>;</decl_stmt>
        <comment type="block">/* Base suspicion of uncompressibility on ratio of literals to sequences */</comment>
        <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>suspectUncompressible</name> <init>= <expr><operator>(</operator><name>numSequences</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>numLiterals</name> <operator>/</operator> <name>numSequences</name> <operator>&gt;=</operator> <name>SUSPECT_UNCOMPRESSIBLE_LITERAL_RATIO</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>litSize</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>seqStorePtr</name><operator>-&gt;</operator><name>lit</name></name> <operator>-</operator> <name>literals</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>cSize</name> <init>= <expr><call><name>ZSTD_compressLiterals</name><argument_list>(
                                    <argument><expr><operator>&amp;</operator><name><name>prevEntropy</name><operator>-&gt;</operator><name>huf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nextEntropy</name><operator>-&gt;</operator><name>huf</name></name></expr></argument>,
                                    <argument><expr><name><name>cctxParams</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>strategy</name></name></expr></argument>,
                                    <argument><expr><call><name>ZSTD_literalsCompressionIsDisabled</name><argument_list>(<argument><expr><name>cctxParams</name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><name>op</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>,
                                    <argument><expr><name>literals</name></expr></argument>, <argument><expr><name>litSize</name></expr></argument>,
                                    <argument><expr><name>entropyWorkspace</name></expr></argument>, <argument><expr><name>entropyWkspSize</name></expr></argument>,
                                    <argument><expr><name>bmi2</name></expr></argument>, <argument><expr><name>suspectUncompressible</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressLiterals failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>cSize</name> <operator>&lt;=</operator> <name>dstCapacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>cSize</name></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* Sequences Header */</comment>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><operator>(</operator><name>oend</name><operator>-</operator><name>op</name><operator>)</operator> <operator>&lt;</operator> <literal type="number">3</literal> <comment type="block">/*max nbSeq Size*/</comment> <operator>+</operator> <literal type="number">1</literal></expr></argument> <comment type="block">/*seqHead*/</comment>,
                    <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">"Can't fit seq hdr in output buf!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nbSeq</name> <operator>&lt;</operator> <literal type="number">128</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>op</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><name>nbSeq</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>nbSeq</name> <operator>&lt;</operator> <name>LONGNBSEQ</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><operator>(</operator><operator>(</operator><name>nbSeq</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator> <operator>+</operator> <literal type="number">0x80</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>op</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><name>nbSeq</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name><operator>+=</operator><literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>=</operator><literal type="number">0xFF</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MEM_writeLE16</name><argument_list>(<argument><expr><name>op</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>U16</name><operator>)</operator><operator>(</operator><name>nbSeq</name> <operator>-</operator> <name>LONGNBSEQ</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name><operator>+=</operator><literal type="number">3</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name> <operator>&lt;=</operator> <name>oend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nbSeq</name><operator>==</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Copy the old tables over as if we repeated them */</comment>
        <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nextEntropy</name><operator>-&gt;</operator><name>fse</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>prevEntropy</name><operator>-&gt;</operator><name>fse</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>prevEntropy</name><operator>-&gt;</operator><name>fse</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>op</name> <operator>-</operator> <name>ostart</name><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>seqHead</name> <init>= <expr><name>op</name><operator>++</operator></expr></init></decl>;</decl_stmt>
        <comment type="block">/* build stats for sequences */</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_symbolEncodingTypeStats_t</name></type> <name>stats</name> <init>=
                <expr><call><name>ZSTD_buildSequencesStatistics</name><argument_list>(<argument><expr><name>seqStorePtr</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>,
                                             <argument><expr><operator>&amp;</operator><name><name>prevEntropy</name><operator>-&gt;</operator><name>fse</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nextEntropy</name><operator>-&gt;</operator><name>fse</name></name></expr></argument>,
                                              <argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>,
                                              <argument><expr><name>strategy</name></expr></argument>, <argument><expr><name>count</name></expr></argument>,
                                              <argument><expr><name>entropyWorkspace</name></expr></argument>, <argument><expr><name>entropyWkspSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name><name>stats</name><operator>.</operator><name>size</name></name></expr></argument>, <argument><expr><literal type="string">"ZSTD_buildSequencesStatistics failed!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>seqHead</name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>stats</name><operator>.</operator><name>LLtype</name></name><operator>&lt;&lt;</operator><literal type="number">6</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>stats</name><operator>.</operator><name>Offtype</name></name><operator>&lt;&lt;</operator><literal type="number">4</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>stats</name><operator>.</operator><name>MLtype</name></name><operator>&lt;&lt;</operator><literal type="number">2</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>lastCountSize</name> <operator>=</operator> <name><name>stats</name><operator>.</operator><name>lastCountSize</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> <operator>+=</operator> <name><name>stats</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
    </block_content>}</block>

    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>bitstreamSize</name> <init>= <expr><call><name>ZSTD_encodeSequences</name><argument_list>(
                                        <argument><expr><name>op</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name> <operator>-</operator> <name>op</name><operator>)</operator></expr></argument>,
                                        <argument><expr><name>CTable_MatchLength</name></expr></argument>, <argument><expr><name>mlCodeTable</name></expr></argument>,
                                        <argument><expr><name>CTable_OffsetBits</name></expr></argument>, <argument><expr><name>ofCodeTable</name></expr></argument>,
                                        <argument><expr><name>CTable_LitLength</name></expr></argument>, <argument><expr><name>llCodeTable</name></expr></argument>,
                                        <argument><expr><name>sequences</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>,
                                        <argument><expr><name>longOffsets</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>bitstreamSize</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_encodeSequences failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>bitstreamSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name> <operator>&lt;=</operator> <name>oend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* zstd versions &lt;= 1.3.4 mistakenly report corruption when
         * FSE_readNCount() receives a buffer &lt; 4 bytes.
         * Fixed by https://github.com/facebook/zstd/pull/1146.
         * This can happen when the last set_compressed table present is 2
         * bytes and the bitstream is only one byte.
         * In this exceedingly rare case, we will simply emit an uncompressed
         * block, since it isn't worth optimizing.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>lastCountSize</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>lastCountSize</name> <operator>+</operator> <name>bitstreamSize</name><operator>)</operator> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* lastCountSize &gt;= 2 &amp;&amp; bitstreamSize &gt; 0 ==&gt; lastCountSize == 3 */</comment>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lastCountSize</name> <operator>+</operator> <name>bitstreamSize</name> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Avoiding bug in zstd decoder in versions &lt;= 1.3.4 by "</literal>
                        <literal type="string">"emitting an uncompressed block."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"compressed block size : %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name>op</name> <operator>-</operator> <name>ostart</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>op</name> <operator>-</operator> <name>ostart</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>MEM_STATIC</name> <name>size_t</name></type>
<name>ZSTD_entropyCompressSeqStore</name><parameter_list>(<parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStorePtr</name></decl></parameter>,
                       <parameter><decl><type><specifier>const</specifier> <name>ZSTD_entropyCTables_t</name><modifier>*</modifier></type> <name>prevEntropy</name></decl></parameter>,
                             <parameter><decl><type><name>ZSTD_entropyCTables_t</name><modifier>*</modifier></type> <name>nextEntropy</name></decl></parameter>,
                       <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>cctxParams</name></decl></parameter>,
                             <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                             <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                             <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>entropyWorkspace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>entropyWkspSize</name></decl></parameter>,
                             <parameter><decl><type><name>int</name></type> <name>bmi2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>cSize</name> <init>= <expr><call><name>ZSTD_entropyCompressSeqStore_internal</name><argument_list>(
                            <argument><expr><name>seqStorePtr</name></expr></argument>, <argument><expr><name>prevEntropy</name></expr></argument>, <argument><expr><name>nextEntropy</name></expr></argument>, <argument><expr><name>cctxParams</name></expr></argument>,
                            <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>,
                            <argument><expr><name>entropyWorkspace</name></expr></argument>, <argument><expr><name>entropyWkspSize</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>cSize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* When srcSize &lt;= dstCapacity, there is enough space to write a raw uncompressed block.
     * Since we ran out of space, block must be not compressible, so fall back to raw uncompressed block.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>cSize</name> <operator>==</operator> <call><name>ERROR</name><argument_list>(<argument><expr><name>dstSize_tooSmall</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>srcSize</name> <operator>&lt;=</operator> <name>dstCapacity</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"not enough dstCapacity (%zu) for ZSTD_entropyCompressSeqStore_internal()=&gt; do not compress block"</literal></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* block not compressed */</comment>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_entropyCompressSeqStore_internal failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check compressibility */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>maxCSize</name> <init>= <expr><name>srcSize</name> <operator>-</operator> <call><name>ZSTD_minGain</name><argument_list>(<argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name><name>cctxParams</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>cSize</name> <operator>&gt;=</operator> <name>maxCSize</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* block not compressed */</comment>
    </block_content>}</block>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_entropyCompressSeqStore() cSize: %zu"</literal></expr></argument>, <argument><expr><name>cSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>cSize</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ZSTD_selectBlockCompressor() :
 * Not static, but internal use only (used by long distance matcher)
 * assumption : strat is a valid strategy */</comment>
<function><type><name>ZSTD_blockCompressor</name></type> <name>ZSTD_selectBlockCompressor</name><parameter_list>(<parameter><decl><type><name>ZSTD_strategy</name></type> <name>strat</name></decl></parameter>, <parameter><decl><type><name>ZSTD_paramSwitch_e</name></type> <name>useRowMatchFinder</name></decl></parameter>, <parameter><decl><type><name>ZSTD_dictMode_e</name></type> <name>dictMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ZSTD_blockCompressor</name></type> <name><name>blockCompressor</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><name>ZSTD_STRATEGY_MAX</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{
        <expr><block>{ <expr><name>ZSTD_compressBlock_fast</name></expr>  <comment type="block">/* default for 0 */</comment>,
          <expr><name>ZSTD_compressBlock_fast</name></expr>,
          <expr><name>ZSTD_compressBlock_doubleFast</name></expr>,
          <expr><name>ZSTD_compressBlock_greedy</name></expr>,
          <expr><name>ZSTD_compressBlock_lazy</name></expr>,
          <expr><name>ZSTD_compressBlock_lazy2</name></expr>,
          <expr><name>ZSTD_compressBlock_btlazy2</name></expr>,
          <expr><name>ZSTD_compressBlock_btopt</name></expr>,
          <expr><name>ZSTD_compressBlock_btultra</name></expr>,
          <expr><name>ZSTD_compressBlock_btultra2</name></expr> }</block></expr>,
        <expr><block>{ <expr><name>ZSTD_compressBlock_fast_extDict</name></expr>  <comment type="block">/* default for 0 */</comment>,
          <expr><name>ZSTD_compressBlock_fast_extDict</name></expr>,
          <expr><name>ZSTD_compressBlock_doubleFast_extDict</name></expr>,
          <expr><name>ZSTD_compressBlock_greedy_extDict</name></expr>,
          <expr><name>ZSTD_compressBlock_lazy_extDict</name></expr>,
          <expr><name>ZSTD_compressBlock_lazy2_extDict</name></expr>,
          <expr><name>ZSTD_compressBlock_btlazy2_extDict</name></expr>,
          <expr><name>ZSTD_compressBlock_btopt_extDict</name></expr>,
          <expr><name>ZSTD_compressBlock_btultra_extDict</name></expr>,
          <expr><name>ZSTD_compressBlock_btultra_extDict</name></expr> }</block></expr>,
        <expr><block>{ <expr><name>ZSTD_compressBlock_fast_dictMatchState</name></expr>  <comment type="block">/* default for 0 */</comment>,
          <expr><name>ZSTD_compressBlock_fast_dictMatchState</name></expr>,
          <expr><name>ZSTD_compressBlock_doubleFast_dictMatchState</name></expr>,
          <expr><name>ZSTD_compressBlock_greedy_dictMatchState</name></expr>,
          <expr><name>ZSTD_compressBlock_lazy_dictMatchState</name></expr>,
          <expr><name>ZSTD_compressBlock_lazy2_dictMatchState</name></expr>,
          <expr><name>ZSTD_compressBlock_btlazy2_dictMatchState</name></expr>,
          <expr><name>ZSTD_compressBlock_btopt_dictMatchState</name></expr>,
          <expr><name>ZSTD_compressBlock_btultra_dictMatchState</name></expr>,
          <expr><name>ZSTD_compressBlock_btultra_dictMatchState</name></expr> }</block></expr>,
        <expr><block>{ <expr><name>NULL</name></expr>  <comment type="block">/* default for 0 */</comment>,
          <expr><name>NULL</name></expr>,
          <expr><name>NULL</name></expr>,
          <expr><name>ZSTD_compressBlock_greedy_dedicatedDictSearch</name></expr>,
          <expr><name>ZSTD_compressBlock_lazy_dedicatedDictSearch</name></expr>,
          <expr><name>ZSTD_compressBlock_lazy2_dedicatedDictSearch</name></expr>,
          <expr><name>NULL</name></expr>,
          <expr><name>NULL</name></expr>,
          <expr><name>NULL</name></expr>,
          <expr><name>NULL</name></expr> }</block></expr>
    }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_blockCompressor</name></type> <name>selectedCompressor</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ZSTD_STATIC_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>ZSTD_fast</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>ZSTD_cParam_withinBounds</name><argument_list>(<argument><expr><name>ZSTD_c_strategy</name></expr></argument>, <argument><expr><name>strat</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"Selected block compressor: dictMode=%d strat=%d rowMatchfinder=%d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>dictMode</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>strat</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>useRowMatchFinder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ZSTD_rowMatchFinderUsed</name><argument_list>(<argument><expr><name>strat</name></expr></argument>, <argument><expr><name>useRowMatchFinder</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ZSTD_blockCompressor</name></type> <name><name>rowBasedBlockCompressors</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{
            <expr><block>{ <expr><name>ZSTD_compressBlock_greedy_row</name></expr>,
            <expr><name>ZSTD_compressBlock_lazy_row</name></expr>,
            <expr><name>ZSTD_compressBlock_lazy2_row</name></expr> }</block></expr>,
            <expr><block>{ <expr><name>ZSTD_compressBlock_greedy_extDict_row</name></expr>,
            <expr><name>ZSTD_compressBlock_lazy_extDict_row</name></expr>,
            <expr><name>ZSTD_compressBlock_lazy2_extDict_row</name></expr> }</block></expr>,
            <expr><block>{ <expr><name>ZSTD_compressBlock_greedy_dictMatchState_row</name></expr>,
            <expr><name>ZSTD_compressBlock_lazy_dictMatchState_row</name></expr>,
            <expr><name>ZSTD_compressBlock_lazy2_dictMatchState_row</name></expr> }</block></expr>,
            <expr><block>{ <expr><name>ZSTD_compressBlock_greedy_dedicatedDictSearch_row</name></expr>,
            <expr><name>ZSTD_compressBlock_lazy_dedicatedDictSearch_row</name></expr>,
            <expr><name>ZSTD_compressBlock_lazy2_dedicatedDictSearch_row</name></expr> }</block></expr>
        }</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"Selecting a row-based matchfinder"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>useRowMatchFinder</name> <operator>!=</operator> <name>ZSTD_ps_auto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>selectedCompressor</name> <operator>=</operator> <name><name>rowBasedBlockCompressors</name><index>[<expr><operator>(</operator><name>int</name><operator>)</operator><name>dictMode</name></expr>]</index><index>[<expr><operator>(</operator><name>int</name><operator>)</operator><name>strat</name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><name>ZSTD_greedy</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>selectedCompressor</name> <operator>=</operator> <name><name>blockCompressor</name><index>[<expr><operator>(</operator><name>int</name><operator>)</operator><name>dictMode</name></expr>]</index><index>[<expr><operator>(</operator><name>int</name><operator>)</operator><name>strat</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>selectedCompressor</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>selectedCompressor</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_storeLastLiterals</name><parameter_list>(<parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStorePtr</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>anchor</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>lastLLSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name><name>seqStorePtr</name><operator>-&gt;</operator><name>lit</name></name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>lastLLSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>seqStorePtr</name><operator>-&gt;</operator><name>lit</name></name> <operator>+=</operator> <name>lastLLSize</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>ZSTD_resetSeqStore</name><parameter_list>(<parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>ssPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>ssPtr</name><operator>-&gt;</operator><name>lit</name></name> <operator>=</operator> <name><name>ssPtr</name><operator>-&gt;</operator><name>litStart</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ssPtr</name><operator>-&gt;</operator><name>sequences</name></name> <operator>=</operator> <name><name>ssPtr</name><operator>-&gt;</operator><name>sequencesStart</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ssPtr</name><operator>-&gt;</operator><name>longLengthType</name></name> <operator>=</operator> <name>ZSTD_llt_none</name></expr>;</expr_stmt>
</block_content>}</block></function>

<typedef>typedef <type><enum>enum <block>{ <decl><name>ZSTDbss_compress</name></decl>, <decl><name>ZSTDbss_noCompress</name></decl> }</block></enum></type> <name>ZSTD_buildSeqStore_e</name>;</typedef>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_buildSeqStore</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>zc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ms</name> <init>= <expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_buildSeqStore (srcSize=%zu)"</literal></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>srcSize</name> <operator>&lt;=</operator> <name>ZSTD_BLOCKSIZE_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Assert that we have correctly flushed the ctx params into the ms's copy */</comment>
    <expr_stmt><expr><call><name>ZSTD_assertEqualCParams</name><argument_list>(<argument><expr><name><name>zc</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>cParams</name></name></expr></argument>, <argument><expr><name><name>ms</name><operator>-&gt;</operator><name>cParams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* TODO: See 3090. We reduced MIN_CBLOCK_SIZE from 3 to 2 so to compensate we are adding
     * additional 1. We need to revisit and change this logic to be more consistent */</comment>
    <if_stmt><if>if <condition>(<expr><name>srcSize</name> <operator>&lt;</operator> <name>MIN_CBLOCK_SIZE</name><operator>+</operator><name>ZSTD_blockHeaderSize</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>zc</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>cParams</name><operator>.</operator><name>strategy</name></name> <operator>&gt;=</operator> <name>ZSTD_btopt</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>ZSTD_ldm_skipRawSeqStoreBytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>externSeqStore</name></name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>ZSTD_ldm_skipSequences</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>externSeqStore</name></name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name><name>zc</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>cParams</name><operator>.</operator><name>minMatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><name>ZSTDbss_noCompress</name></expr>;</return> <comment type="block">/* don't even attempt compression below a certain srcSize */</comment>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>ZSTD_resetSeqStore</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>zc</name><operator>-&gt;</operator><name>seqStore</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* required for optimal parser to read stats from dictionary */</comment>
    <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>symbolCosts</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name><operator>-&gt;</operator><name>entropy</name></name></expr>;</expr_stmt>
    <comment type="block">/* tell the optimal parser how we expect to compress literals */</comment>
    <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>literalCompressionMode</name></name> <operator>=</operator> <name><name>zc</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>literalCompressionMode</name></name></expr>;</expr_stmt>
    <comment type="block">/* a gap between an attached dict and the current window is not safe,
     * they must remain adjacent,
     * and when that stops being the case, the dict must be unset */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>dictMatchState</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>ms</name><operator>-&gt;</operator><name>loadedDictEnd</name></name> <operator>==</operator> <name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictLimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* limited update after a very long match */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>base</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>istart</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>curr</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>istart</name><operator>-</operator><name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>ptrdiff_t</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>istart</name> <operator>-</operator> <name>base</name> <operator>&lt;</operator> <operator>(</operator><name>ptrdiff_t</name><operator>)</operator><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>   <comment type="block">/* ensure no overflow */</comment>
        <if_stmt><if>if <condition>(<expr><name>curr</name> <operator>&gt;</operator> <name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name> <operator>+</operator> <literal type="number">384</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name> <operator>=</operator> <name>curr</name> <operator>-</operator> <call><name>MIN</name><argument_list>(<argument><expr><literal type="number">192</literal></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>curr</name> <operator>-</operator> <name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name> <operator>-</operator> <literal type="number">384</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/* select and store sequences */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>ZSTD_dictMode_e</name> <specifier>const</specifier></type> <name>dictMode</name> <init>= <expr><call><name>ZSTD_matchState_dictMode</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>lastLLSize</name></decl>;</decl_stmt>
        <block>{<block_content>   <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ZSTD_REP_NUM</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>nextCBlock</name><operator>-&gt;</operator><name>rep</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name><operator>-&gt;</operator><name>rep</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
        </block_content>}</block>
        <if_stmt><if>if <condition>(<expr><name><name>zc</name><operator>-&gt;</operator><name>externSeqStore</name><operator>.</operator><name>pos</name></name> <operator>&lt;</operator> <name><name>zc</name><operator>-&gt;</operator><name>externSeqStore</name><operator>.</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>zc</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>ldmParams</name><operator>.</operator><name>enableLdm</name></name> <operator>==</operator> <name>ZSTD_ps_disable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Updates ldmSeqStore.pos */</comment>
            <expr_stmt><expr><name>lastLLSize</name> <operator>=</operator>
                <call><name>ZSTD_ldm_blockCompress</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>externSeqStore</name></name></expr></argument>,
                                       <argument><expr><name>ms</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>seqStore</name></name></expr></argument>,
                                       <argument><expr><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>nextCBlock</name><operator>-&gt;</operator><name>rep</name></name></expr></argument>,
                                       <argument><expr><name><name>zc</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>useRowMatchFinder</name></name></expr></argument>,
                                       <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>zc</name><operator>-&gt;</operator><name>externSeqStore</name><operator>.</operator><name>pos</name></name> <operator>&lt;=</operator> <name><name>zc</name><operator>-&gt;</operator><name>externSeqStore</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zc</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>ldmParams</name><operator>.</operator><name>enableLdm</name></name> <operator>==</operator> <name>ZSTD_ps_enable</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>rawSeqStore_t</name></type> <name>ldmSeqStore</name> <init>= <expr><name>kNullRawSeqStore</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>ldmSeqStore</name><operator>.</operator><name>seq</name></name> <operator>=</operator> <name><name>zc</name><operator>-&gt;</operator><name>ldmSequences</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ldmSeqStore</name><operator>.</operator><name>capacity</name></name> <operator>=</operator> <name><name>zc</name><operator>-&gt;</operator><name>maxNbLdmSequences</name></name></expr>;</expr_stmt>
            <comment type="block">/* Updates ldmSeqStore.size */</comment>
            <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_ldm_generateSequences</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>ldmState</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ldmSeqStore</name></expr></argument>,
                                               <argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>ldmParams</name></name></expr></argument>,
                                               <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Updates ldmSeqStore.pos */</comment>
            <expr_stmt><expr><name>lastLLSize</name> <operator>=</operator>
                <call><name>ZSTD_ldm_blockCompress</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ldmSeqStore</name></expr></argument>,
                                       <argument><expr><name>ms</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>seqStore</name></name></expr></argument>,
                                       <argument><expr><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>nextCBlock</name><operator>-&gt;</operator><name>rep</name></name></expr></argument>,
                                       <argument><expr><name><name>zc</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>useRowMatchFinder</name></name></expr></argument>,
                                       <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ldmSeqStore</name><operator>.</operator><name>pos</name></name> <operator>==</operator> <name><name>ldmSeqStore</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>   <comment type="block">/* not long range mode */</comment>
            <decl_stmt><decl><type><name>ZSTD_blockCompressor</name> <specifier>const</specifier></type> <name>blockCompressor</name> <init>= <expr><call><name>ZSTD_selectBlockCompressor</name><argument_list>(<argument><expr><name><name>zc</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>cParams</name><operator>.</operator><name>strategy</name></name></expr></argument>,
                                                                                    <argument><expr><name><name>zc</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>useRowMatchFinder</name></name></expr></argument>,
                                                                                    <argument><expr><name>dictMode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>ldmSeqStore</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>lastLLSize</name> <operator>=</operator> <call><name>blockCompressor</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>seqStore</name></name></expr></argument>, <argument><expr><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>nextCBlock</name><operator>-&gt;</operator><name>rep</name></name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <block>{<block_content>   <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>lastLiterals</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <name>srcSize</name> <operator>-</operator> <name>lastLLSize</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ZSTD_storeLastLiterals</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>seqStore</name></name></expr></argument>, <argument><expr><name>lastLiterals</name></expr></argument>, <argument><expr><name>lastLLSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>   </block_content>}</block>
    <return>return <expr><name>ZSTDbss_compress</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_copyBlockSequences</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>zc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name> <init>= <expr><call><name>ZSTD_getSeqStore</name><argument_list>(<argument><expr><name>zc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>seqDef</name><modifier>*</modifier></type> <name>seqStoreSeqs</name> <init>= <expr><name><name>seqStore</name><operator>-&gt;</operator><name>sequencesStart</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>seqStoreSeqSize</name> <init>= <expr><name><name>seqStore</name><operator>-&gt;</operator><name>sequences</name></name> <operator>-</operator> <name>seqStoreSeqs</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>seqStoreLiteralsSize</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>seqStore</name><operator>-&gt;</operator><name>lit</name></name> <operator>-</operator> <name><name>seqStore</name><operator>-&gt;</operator><name>litStart</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>literalsRead</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>lastLLSize</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>ZSTD_Sequence</name><modifier>*</modifier></type> <name>outSeqs</name> <init>= <expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>seqCollector</name><operator>.</operator><name>seqStart</name><index>[<expr><name><name>zc</name><operator>-&gt;</operator><name>seqCollector</name><operator>.</operator><name>seqIndex</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>repcodes_t</name></type> <name>updatedRepcodes</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>zc</name><operator>-&gt;</operator><name>seqCollector</name><operator>.</operator><name>seqIndex</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>zc</name><operator>-&gt;</operator><name>seqCollector</name><operator>.</operator><name>maxSequences</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Ensure we have enough space for last literals "sequence" */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>zc</name><operator>-&gt;</operator><name>seqCollector</name><operator>.</operator><name>maxSequences</name></name> <operator>&gt;=</operator> <name>seqStoreSeqSize</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name><name>updatedRepcodes</name><operator>.</operator><name>rep</name></name></expr></argument>, <argument><expr><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name><operator>-&gt;</operator><name>rep</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repcodes_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>seqStoreSeqSize</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name></type> <name>rawOffset</name> <init>= <expr><name><name>seqStoreSeqs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offBase</name> <operator>-</operator> <name>ZSTD_REP_NUM</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>outSeqs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>litLength</name> <operator>=</operator> <name><name>seqStoreSeqs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>litLength</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>outSeqs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>matchLength</name> <operator>=</operator> <name><name>seqStoreSeqs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mlBase</name> <operator>+</operator> <name>MINMATCH</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>outSeqs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rep</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name><name>seqStore</name><operator>-&gt;</operator><name>longLengthPos</name></name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>seqStore</name><operator>-&gt;</operator><name>longLengthType</name></name> <operator>==</operator> <name>ZSTD_llt_literalLength</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>outSeqs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>litLength</name> <operator>+=</operator> <literal type="number">0x10000</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>seqStore</name><operator>-&gt;</operator><name>longLengthType</name></name> <operator>==</operator> <name>ZSTD_llt_matchLength</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>outSeqs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>matchLength</name> <operator>+=</operator> <literal type="number">0x10000</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>seqStoreSeqs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offBase</name> <operator>&lt;=</operator> <name>ZSTD_REP_NUM</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Derive the correct offset corresponding to a repcode */</comment>
            <expr_stmt><expr><name><name>outSeqs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rep</name> <operator>=</operator> <name><name>seqStoreSeqs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offBase</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>outSeqs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>litLength</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>rawOffset</name> <operator>=</operator> <name><name>updatedRepcodes</name><operator>.</operator><name>rep</name><index>[<expr><name><name>outSeqs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rep</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>outSeqs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rep</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>rawOffset</name> <operator>=</operator> <name><name>updatedRepcodes</name><operator>.</operator><name>rep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><name>rawOffset</name> <operator>=</operator> <name><name>updatedRepcodes</name><operator>.</operator><name>rep</name><index>[<expr><name><name>outSeqs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rep</name></expr>]</index></name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>outSeqs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <name>rawOffset</name></expr>;</expr_stmt>
        <comment type="block">/* seqStoreSeqs[i].offset == offCode+1, and ZSTD_updateRep() expects offCode
           so we provide seqStoreSeqs[i].offset - 1 */</comment>
        <expr_stmt><expr><call><name>ZSTD_updateRep</name><argument_list>(<argument><expr><name><name>updatedRepcodes</name><operator>.</operator><name>rep</name></name></expr></argument>,
                       <argument><expr><name><name>seqStoreSeqs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offBase</name></expr></argument>,
                       <argument><expr><name><name>seqStoreSeqs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>litLength</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>literalsRead</name> <operator>+=</operator> <name><name>outSeqs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>litLength</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <comment type="block">/* Insert last literals (if any exist) in the block as a sequence with ml == off == 0.
     * If there are no last literals, then we'll emit (of: 0, ml: 0, ll: 0), which is a marker
     * for the block boundary, according to the API.
     */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>seqStoreLiteralsSize</name> <operator>&gt;=</operator> <name>literalsRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lastLLSize</name> <operator>=</operator> <name>seqStoreLiteralsSize</name> <operator>-</operator> <name>literalsRead</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>outSeqs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>litLength</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>lastLLSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>outSeqs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>matchLength</name> <operator>=</operator> <name><name>outSeqs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <name><name>outSeqs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rep</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>seqStoreSeqSize</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>seqCollector</name><operator>.</operator><name>seqIndex</name></name> <operator>+=</operator> <name>seqStoreSeqSize</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_generateSequences</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>zc</name></decl></parameter>, <parameter><decl><type><name>ZSTD_Sequence</name><modifier>*</modifier></type> <name>outSeqs</name></decl></parameter>,
                              <parameter><decl><type><name>size_t</name></type> <name>outSeqsSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>dstCapacity</name> <init>= <expr><call><name>ZSTD_compressBound</name><argument_list>(<argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name> <init>= <expr><call><name>ZSTD_customMalloc</name><argument_list>(<argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>ZSTD_defaultCMem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SeqCollector</name></type> <name>seqCollector</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>dst</name> <operator>==</operator> <name>NULL</name></expr></argument>, <argument><expr><name>memory_allocation</name></expr></argument>, <argument><expr><literal type="string">"NULL pointer!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>seqCollector</name><operator>.</operator><name>collectSequences</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>seqCollector</name><operator>.</operator><name>seqStart</name></name> <operator>=</operator> <name>outSeqs</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>seqCollector</name><operator>.</operator><name>seqIndex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>seqCollector</name><operator>.</operator><name>maxSequences</name></name> <operator>=</operator> <name>outSeqsSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>seqCollector</name></name> <operator>=</operator> <name>seqCollector</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ZSTD_compress2</name><argument_list>(<argument><expr><name>zc</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_customFree</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>ZSTD_defaultCMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>zc</name><operator>-&gt;</operator><name>seqCollector</name><operator>.</operator><name>seqIndex</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_mergeBlockDelimiters</name><parameter_list>(<parameter><decl><type><name>ZSTD_Sequence</name><modifier>*</modifier></type> <name>sequences</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>seqsSize</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>in</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>out</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init>;</init> <condition><expr><name>in</name> <operator>&lt;</operator> <name>seqsSize</name></expr>;</condition> <incr><expr><operator>++</operator><name>in</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>sequences</name><index>[<expr><name>in</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>sequences</name><index>[<expr><name>in</name></expr>]</index></name><operator>.</operator><name>matchLength</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>in</name> <operator>!=</operator> <name>seqsSize</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>sequences</name><index>[<expr><name>in</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>litLength</name> <operator>+=</operator> <name><name>sequences</name><index>[<expr><name>in</name></expr>]</index></name><operator>.</operator><name>litLength</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>sequences</name><index>[<expr><name>out</name></expr>]</index></name> <operator>=</operator> <name><name>sequences</name><index>[<expr><name>in</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>++</operator><name>out</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>out</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Unrolled loop to read four size_ts of input at a time. Returns 1 if is RLE, 0 if not. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ZSTD_isRLE</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><name>src</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name></type> <name>value</name> <init>= <expr><name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>valueST</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>U64</name><operator>)</operator><name>value</name> <operator>*</operator> <literal type="number">0x0101010101010101ULL</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>unrollSize</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>unrollMask</name> <init>= <expr><name>unrollSize</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>prefixLength</name> <init>= <expr><name>length</name> <operator>&amp;</operator> <name>unrollMask</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>u</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>length</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Check if prefix is RLE first before using unrolled loop */</comment>
    <if_stmt><if>if <condition>(<expr><name>prefixLength</name> <operator>&amp;&amp;</operator> <call><name>ZSTD_count</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>ip</name><operator>+</operator><name>prefixLength</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>prefixLength</name><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>prefixLength</name></expr>;</init> <condition><expr><name>i</name> <operator>!=</operator> <name>length</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>unrollSize</name></expr></incr>)</control> <block>{<block_content>
        <for>for <control>(<init><expr><name>u</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>u</name> <operator>&lt;</operator> <name>unrollSize</name></expr>;</condition> <incr><expr><name>u</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>MEM_readST</name><argument_list>(<argument><expr><name>ip</name> <operator>+</operator> <name>i</name> <operator>+</operator> <name>u</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>valueST</name></expr>)</condition> <block>{<block_content>
                <return>return <expr><literal type="number">0</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Returns true if the given block may be RLE.
 * This is just a heuristic based on the compressibility.
 * It may return both false positives and false negatives.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ZSTD_maybeRLE</name><parameter_list>(<parameter><decl><type><name>seqStore_t</name> <specifier>const</specifier><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>nbSeqs</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>seqStore</name><operator>-&gt;</operator><name>sequences</name></name> <operator>-</operator> <name><name>seqStore</name><operator>-&gt;</operator><name>sequencesStart</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>nbLits</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>seqStore</name><operator>-&gt;</operator><name>lit</name></name> <operator>-</operator> <name><name>seqStore</name><operator>-&gt;</operator><name>litStart</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

    <return>return <expr><name>nbSeqs</name> <operator>&lt;</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <name>nbLits</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_blockState_confirmRepcodesAndEntropyTables</name><parameter_list>(<parameter><decl><type><name>ZSTD_blockState_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>bs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_compressedBlockState_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>tmp</name> <init>= <expr><name><name>bs</name><operator>-&gt;</operator><name>prevCBlock</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>bs</name><operator>-&gt;</operator><name>prevCBlock</name></name> <operator>=</operator> <name><name>bs</name><operator>-&gt;</operator><name>nextCBlock</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bs</name><operator>-&gt;</operator><name>nextCBlock</name></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Writes the block header */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>writeBlockHeader</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cSize</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>blockSize</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>lastBlock</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>cBlockHeader</name> <init>= <expr><ternary><condition><expr><name>cSize</name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then>
                        <expr><name>lastBlock</name> <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><name>bt_rle</name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">1</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>blockSize</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr> </then><else>:
                        <expr><name>lastBlock</name> <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><name>bt_compressed</name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">1</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>cSize</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>MEM_writeLE24</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>cBlockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"writeBlockHeader: cSize: %zu blockSize: %zu lastBlock: %u"</literal></expr></argument>, <argument><expr><name>cSize</name></expr></argument>, <argument><expr><name>blockSize</name></expr></argument>, <argument><expr><name>lastBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** ZSTD_buildBlockEntropyStats_literals() :
 *  Builds entropy for the literals.
 *  Stores literals block type (raw, rle, compressed, repeat) and
 *  huffman description table to hufMetadata.
 *  Requires ENTROPY_WORKSPACE_SIZE workspace
 *  @return : size of huffman description table or error code */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_buildBlockEntropyStats_literals</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier> <specifier>const</specifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                                            <parameter><decl><type><specifier>const</specifier> <name>ZSTD_hufCTables_t</name><modifier>*</modifier></type> <name>prevHuf</name></decl></parameter>,
                                                  <parameter><decl><type><name>ZSTD_hufCTables_t</name><modifier>*</modifier></type> <name>nextHuf</name></decl></parameter>,
                                                  <parameter><decl><type><name>ZSTD_hufCTablesMetadata_t</name><modifier>*</modifier></type> <name>hufMetadata</name></decl></parameter>,
                                                  <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>literalsCompressionIsDisabled</name></decl></parameter>,
                                                  <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workspace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>wkspStart</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>workspace</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>wkspEnd</name> <init>= <expr><name>wkspStart</name> <operator>+</operator> <name>wkspSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>countWkspStart</name> <init>= <expr><name>wkspStart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name><modifier>*</modifier> <specifier>const</specifier></type> <name>countWksp</name> <init>= <expr><operator>(</operator><name>unsigned</name><operator>*</operator><operator>)</operator><name>workspace</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>countWkspSize</name> <init>= <expr><operator>(</operator><name>HUF_SYMBOLVALUE_MAX</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>unsigned</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>nodeWksp</name> <init>= <expr><name>countWkspStart</name> <operator>+</operator> <name>countWkspSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>nodeWkspSize</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>wkspEnd</name> <operator>-</operator> <name>nodeWksp</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>maxSymbolValue</name> <init>= <expr><name>HUF_SYMBOLVALUE_MAX</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>huffLog</name> <init>= <expr><name>LitHufLog</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HUF_repeat</name></type> <name>repeat</name> <init>= <expr><name><name>prevHuf</name><operator>-&gt;</operator><name>repeatMode</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_buildBlockEntropyStats_literals (srcSize=%zu)"</literal></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Prepare nextEntropy assuming reusing the existing table */</comment>
    <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>nextHuf</name></expr></argument>, <argument><expr><name>prevHuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>prevHuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>literalsCompressionIsDisabled</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"set_basic - disabled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hufMetadata</name><operator>-&gt;</operator><name>hType</name></name> <operator>=</operator> <name>set_basic</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* small ? don't even attempt compression (speed opt) */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPRESS_LITERALS_SIZE_MIN</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPRESS_LITERALS_SIZE_MIN</name></cpp:macro> <cpp:value>63</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>minLitSize</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>prevHuf</name><operator>-&gt;</operator><name>repeatMode</name></name> <operator>==</operator> <name>HUF_repeat_valid</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">6</literal></expr> </then><else>: <expr><name>COMPRESS_LITERALS_SIZE_MIN</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>srcSize</name> <operator>&lt;=</operator> <name>minLitSize</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"set_basic - too small"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hufMetadata</name><operator>-&gt;</operator><name>hType</name></name> <operator>=</operator> <name>set_basic</name></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/* Scan input and build symbol stats */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>largest</name> <init>= <expr><call><name>HIST_count_wksp</name> <argument_list>(<argument><expr><name>countWksp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>maxSymbolValue</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>largest</name></expr></argument>, <argument><expr><literal type="string">"HIST_count_wksp failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>largest</name> <operator>==</operator> <name>srcSize</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"set_rle"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hufMetadata</name><operator>-&gt;</operator><name>hType</name></name> <operator>=</operator> <name>set_rle</name></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>largest</name> <operator>&lt;=</operator> <operator>(</operator><name>srcSize</name> <operator>&gt;&gt;</operator> <literal type="number">7</literal><operator>)</operator><operator>+</operator><literal type="number">4</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"set_basic - no gain"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hufMetadata</name><operator>-&gt;</operator><name>hType</name></name> <operator>=</operator> <name>set_basic</name></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/* Validate the previous Huffman table */</comment>
    <if_stmt><if>if <condition>(<expr><name>repeat</name> <operator>==</operator> <name>HUF_repeat_check</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>HUF_validateCTable</name><argument_list>(<argument><expr><operator>(</operator><name>HUF_CElt</name> <specifier>const</specifier><operator>*</operator><operator>)</operator><name><name>prevHuf</name><operator>-&gt;</operator><name>CTable</name></name></expr></argument>, <argument><expr><name>countWksp</name></expr></argument>, <argument><expr><name>maxSymbolValue</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>repeat</name> <operator>=</operator> <name>HUF_repeat_none</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Build Huffman Tree */</comment>
    <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><name><name>nextHuf</name><operator>-&gt;</operator><name>CTable</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>nextHuf</name><operator>-&gt;</operator><name>CTable</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>huffLog</name> <operator>=</operator> <call><name>HUF_optimalTableLog</name><argument_list>(<argument><expr><name>huffLog</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>maxSymbolValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>huffLog</name> <operator>&lt;=</operator> <name>LitHufLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>maxBits</name> <init>= <expr><call><name>HUF_buildCTable_wksp</name><argument_list>(<argument><expr><operator>(</operator><name>HUF_CElt</name><operator>*</operator><operator>)</operator><name><name>nextHuf</name><operator>-&gt;</operator><name>CTable</name></name></expr></argument>, <argument><expr><name>countWksp</name></expr></argument>,
                                                    <argument><expr><name>maxSymbolValue</name></expr></argument>, <argument><expr><name>huffLog</name></expr></argument>,
                                                    <argument><expr><name>nodeWksp</name></expr></argument>, <argument><expr><name>nodeWkspSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>maxBits</name></expr></argument>, <argument><expr><literal type="string">"HUF_buildCTable_wksp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>huffLog</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>maxBits</name></expr>;</expr_stmt>
        <block>{<block_content>   <comment type="block">/* Build and write the CTable */</comment>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>newCSize</name> <init>= <expr><call><name>HUF_estimateCompressedSize</name><argument_list>(
                    <argument><expr><operator>(</operator><name>HUF_CElt</name><operator>*</operator><operator>)</operator><name><name>nextHuf</name><operator>-&gt;</operator><name>CTable</name></name></expr></argument>, <argument><expr><name>countWksp</name></expr></argument>, <argument><expr><name>maxSymbolValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>hSize</name> <init>= <expr><call><name>HUF_writeCTable_wksp</name><argument_list>(
                    <argument><expr><name><name>hufMetadata</name><operator>-&gt;</operator><name>hufDesBuffer</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>hufMetadata</name><operator>-&gt;</operator><name>hufDesBuffer</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
                    <argument><expr><operator>(</operator><name>HUF_CElt</name><operator>*</operator><operator>)</operator><name><name>nextHuf</name><operator>-&gt;</operator><name>CTable</name></name></expr></argument>, <argument><expr><name>maxSymbolValue</name></expr></argument>, <argument><expr><name>huffLog</name></expr></argument>,
                    <argument><expr><name>nodeWksp</name></expr></argument>, <argument><expr><name>nodeWkspSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <comment type="block">/* Check against repeating the previous CTable */</comment>
            <if_stmt><if>if <condition>(<expr><name>repeat</name> <operator>!=</operator> <name>HUF_repeat_none</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>oldCSize</name> <init>= <expr><call><name>HUF_estimateCompressedSize</name><argument_list>(
                        <argument><expr><operator>(</operator><name>HUF_CElt</name> <specifier>const</specifier><operator>*</operator><operator>)</operator><name><name>prevHuf</name><operator>-&gt;</operator><name>CTable</name></name></expr></argument>, <argument><expr><name>countWksp</name></expr></argument>, <argument><expr><name>maxSymbolValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>oldCSize</name> <operator>&lt;</operator> <name>srcSize</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>oldCSize</name> <operator>&lt;=</operator> <name>hSize</name> <operator>+</operator> <name>newCSize</name> <operator>||</operator> <name>hSize</name> <operator>+</operator> <literal type="number">12</literal> <operator>&gt;=</operator> <name>srcSize</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"set_repeat - smaller"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>nextHuf</name></expr></argument>, <argument><expr><name>prevHuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>prevHuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>hufMetadata</name><operator>-&gt;</operator><name>hType</name></name> <operator>=</operator> <name>set_repeat</name></expr>;</expr_stmt>
                    <return>return <expr><literal type="number">0</literal></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>newCSize</name> <operator>+</operator> <name>hSize</name> <operator>&gt;=</operator> <name>srcSize</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"set_basic - no gains"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>nextHuf</name></expr></argument>, <argument><expr><name>prevHuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>prevHuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>hufMetadata</name><operator>-&gt;</operator><name>hType</name></name> <operator>=</operator> <name>set_basic</name></expr>;</expr_stmt>
                <return>return <expr><literal type="number">0</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"set_compressed (hSize=%u)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>hSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hufMetadata</name><operator>-&gt;</operator><name>hType</name></name> <operator>=</operator> <name>set_compressed</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>nextHuf</name><operator>-&gt;</operator><name>repeatMode</name></name> <operator>=</operator> <name>HUF_repeat_check</name></expr>;</expr_stmt>
            <return>return <expr><name>hSize</name></expr>;</return>
        </block_content>}</block>
    </block_content>}</block>
</block_content>}</block></function>


<comment type="block">/* ZSTD_buildDummySequencesStatistics():
 * Returns a ZSTD_symbolEncodingTypeStats_t with all encoding types as set_basic,
 * and updates nextEntropy to the appropriate repeatMode.
 */</comment>
<function><type><specifier>static</specifier> <name>ZSTD_symbolEncodingTypeStats_t</name></type>
<name>ZSTD_buildDummySequencesStatistics</name><parameter_list>(<parameter><decl><type><name>ZSTD_fseCTables_t</name><modifier>*</modifier></type> <name>nextEntropy</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_symbolEncodingTypeStats_t</name></type> <name>stats</name> <init>= <expr><block>{<expr><name>set_basic</name></expr>, <expr><name>set_basic</name></expr>, <expr><name>set_basic</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>nextEntropy</name><operator>-&gt;</operator><name>litlength_repeatMode</name></name> <operator>=</operator> <name>FSE_repeat_none</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nextEntropy</name><operator>-&gt;</operator><name>offcode_repeatMode</name></name> <operator>=</operator> <name>FSE_repeat_none</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nextEntropy</name><operator>-&gt;</operator><name>matchlength_repeatMode</name></name> <operator>=</operator> <name>FSE_repeat_none</name></expr>;</expr_stmt>
    <return>return <expr><name>stats</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** ZSTD_buildBlockEntropyStats_sequences() :
 *  Builds entropy for the sequences.
 *  Stores symbol compression modes and fse table to fseMetadata.
 *  Requires ENTROPY_WORKSPACE_SIZE wksp.
 *  @return : size of fse tables or error code */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_buildBlockEntropyStats_sequences</name><parameter_list>(<parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStorePtr</name></decl></parameter>,
                                              <parameter><decl><type><specifier>const</specifier> <name>ZSTD_fseCTables_t</name><modifier>*</modifier></type> <name>prevEntropy</name></decl></parameter>,
                                                    <parameter><decl><type><name>ZSTD_fseCTables_t</name><modifier>*</modifier></type> <name>nextEntropy</name></decl></parameter>,
                                              <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>cctxParams</name></decl></parameter>,
                                                    <parameter><decl><type><name>ZSTD_fseCTablesMetadata_t</name><modifier>*</modifier></type> <name>fseMetadata</name></decl></parameter>,
                                                    <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workspace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_strategy</name> <specifier>const</specifier></type> <name>strategy</name> <init>= <expr><name><name>cctxParams</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>strategy</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>nbSeq</name> <init>= <expr><name><name>seqStorePtr</name><operator>-&gt;</operator><name>sequences</name></name> <operator>-</operator> <name><name>seqStorePtr</name><operator>-&gt;</operator><name>sequencesStart</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ostart</name> <init>= <expr><name><name>fseMetadata</name><operator>-&gt;</operator><name>fseTablesBuffer</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend</name> <init>= <expr><name>ostart</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>fseMetadata</name><operator>-&gt;</operator><name>fseTablesBuffer</name></name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><name>ostart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name><modifier>*</modifier></type> <name>countWorkspace</name> <init>= <expr><operator>(</operator><name>unsigned</name><operator>*</operator><operator>)</operator><name>workspace</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name><modifier>*</modifier></type> <name>entropyWorkspace</name> <init>= <expr><name>countWorkspace</name> <operator>+</operator> <operator>(</operator><name>MaxSeq</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>entropyWorkspaceSize</name> <init>= <expr><name>wkspSize</name> <operator>-</operator> <operator>(</operator><name>MaxSeq</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>countWorkspace</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_symbolEncodingTypeStats_t</name></type> <name>stats</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_buildBlockEntropyStats_sequences (nbSeq=%zu)"</literal></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>stats</name> <operator>=</operator> <ternary><condition><expr><name>nbSeq</name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>ZSTD_buildSequencesStatistics</name><argument_list>(<argument><expr><name>seqStorePtr</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>,
                                          <argument><expr><name>prevEntropy</name></expr></argument>, <argument><expr><name>nextEntropy</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>,
                                          <argument><expr><name>strategy</name></expr></argument>, <argument><expr><name>countWorkspace</name></expr></argument>,
                                          <argument><expr><name>entropyWorkspace</name></expr></argument>, <argument><expr><name>entropyWorkspaceSize</name></expr></argument>)</argument_list></call></expr>
                       </then><else>: <expr><call><name>ZSTD_buildDummySequencesStatistics</name><argument_list>(<argument><expr><name>nextEntropy</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name><name>stats</name><operator>.</operator><name>size</name></name></expr></argument>, <argument><expr><literal type="string">"ZSTD_buildSequencesStatistics failed!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fseMetadata</name><operator>-&gt;</operator><name>llType</name></name> <operator>=</operator> <operator>(</operator><name>symbolEncodingType_e</name><operator>)</operator> <name><name>stats</name><operator>.</operator><name>LLtype</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fseMetadata</name><operator>-&gt;</operator><name>ofType</name></name> <operator>=</operator> <operator>(</operator><name>symbolEncodingType_e</name><operator>)</operator> <name><name>stats</name><operator>.</operator><name>Offtype</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fseMetadata</name><operator>-&gt;</operator><name>mlType</name></name> <operator>=</operator> <operator>(</operator><name>symbolEncodingType_e</name><operator>)</operator> <name><name>stats</name><operator>.</operator><name>MLtype</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fseMetadata</name><operator>-&gt;</operator><name>lastCountSize</name></name> <operator>=</operator> <name><name>stats</name><operator>.</operator><name>lastCountSize</name></name></expr>;</expr_stmt>
    <return>return <expr><name><name>stats</name><operator>.</operator><name>size</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/** ZSTD_buildBlockEntropyStats() :
 *  Builds entropy for the block.
 *  Requires workspace size ENTROPY_WORKSPACE_SIZE
 *
 *  @return : 0 on success or error code
 */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_buildBlockEntropyStats</name><parameter_list>(<parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStorePtr</name></decl></parameter>,
                             <parameter><decl><type><specifier>const</specifier> <name>ZSTD_entropyCTables_t</name><modifier>*</modifier></type> <name>prevEntropy</name></decl></parameter>,
                                   <parameter><decl><type><name>ZSTD_entropyCTables_t</name><modifier>*</modifier></type> <name>nextEntropy</name></decl></parameter>,
                             <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>cctxParams</name></decl></parameter>,
                                   <parameter><decl><type><name>ZSTD_entropyCTablesMetadata_t</name><modifier>*</modifier></type> <name>entropyMetadata</name></decl></parameter>,
                                   <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workspace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>litSize</name> <init>= <expr><name><name>seqStorePtr</name><operator>-&gt;</operator><name>lit</name></name> <operator>-</operator> <name><name>seqStorePtr</name><operator>-&gt;</operator><name>litStart</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>entropyMetadata</name><operator>-&gt;</operator><name>hufMetadata</name><operator>.</operator><name>hufDesSize</name></name> <operator>=</operator>
        <call><name>ZSTD_buildBlockEntropyStats_literals</name><argument_list>(<argument><expr><name><name>seqStorePtr</name><operator>-&gt;</operator><name>litStart</name></name></expr></argument>, <argument><expr><name>litSize</name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name><name>prevEntropy</name><operator>-&gt;</operator><name>huf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nextEntropy</name><operator>-&gt;</operator><name>huf</name></name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name><name>entropyMetadata</name><operator>-&gt;</operator><name>hufMetadata</name></name></expr></argument>,
                                            <argument><expr><call><name>ZSTD_literalsCompressionIsDisabled</name><argument_list>(<argument><expr><name>cctxParams</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name><name>entropyMetadata</name><operator>-&gt;</operator><name>hufMetadata</name><operator>.</operator><name>hufDesSize</name></name></expr></argument>, <argument><expr><literal type="string">"ZSTD_buildBlockEntropyStats_literals failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entropyMetadata</name><operator>-&gt;</operator><name>fseMetadata</name><operator>.</operator><name>fseTablesSize</name></name> <operator>=</operator>
        <call><name>ZSTD_buildBlockEntropyStats_sequences</name><argument_list>(<argument><expr><name>seqStorePtr</name></expr></argument>,
                                              <argument><expr><operator>&amp;</operator><name><name>prevEntropy</name><operator>-&gt;</operator><name>fse</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nextEntropy</name><operator>-&gt;</operator><name>fse</name></name></expr></argument>,
                                              <argument><expr><name>cctxParams</name></expr></argument>,
                                              <argument><expr><operator>&amp;</operator><name><name>entropyMetadata</name><operator>-&gt;</operator><name>fseMetadata</name></name></expr></argument>,
                                              <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name><name>entropyMetadata</name><operator>-&gt;</operator><name>fseMetadata</name><operator>.</operator><name>fseTablesSize</name></name></expr></argument>, <argument><expr><literal type="string">"ZSTD_buildBlockEntropyStats_sequences failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Returns the size estimate for the literals section (header + content) of a block */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_estimateBlockSize_literal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>literals</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>litSize</name></decl></parameter>,
                                                <parameter><decl><type><specifier>const</specifier> <name>ZSTD_hufCTables_t</name><modifier>*</modifier></type> <name>huf</name></decl></parameter>,
                                                <parameter><decl><type><specifier>const</specifier> <name>ZSTD_hufCTablesMetadata_t</name><modifier>*</modifier></type> <name>hufMetadata</name></decl></parameter>,
                                                <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workspace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>,
                                                <parameter><decl><type><name>int</name></type> <name>writeEntropy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name><modifier>*</modifier> <specifier>const</specifier></type> <name>countWksp</name> <init>= <expr><operator>(</operator><name>unsigned</name><operator>*</operator><operator>)</operator><name>workspace</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>maxSymbolValue</name> <init>= <expr><name>HUF_SYMBOLVALUE_MAX</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>literalSectionHeaderSize</name> <init>= <expr><literal type="number">3</literal> <operator>+</operator> <operator>(</operator><name>litSize</name> <operator>&gt;=</operator> <literal type="number">1</literal> <name>KB</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>litSize</name> <operator>&gt;=</operator> <literal type="number">16</literal> <name>KB</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>singleStream</name> <init>= <expr><name>litSize</name> <operator>&lt;</operator> <literal type="number">256</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hufMetadata</name><operator>-&gt;</operator><name>hType</name></name> <operator>==</operator> <name>set_basic</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>litSize</name></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>hufMetadata</name><operator>-&gt;</operator><name>hType</name></name> <operator>==</operator> <name>set_rle</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>hufMetadata</name><operator>-&gt;</operator><name>hType</name></name> <operator>==</operator> <name>set_compressed</name> <operator>||</operator> <name><name>hufMetadata</name><operator>-&gt;</operator><name>hType</name></name> <operator>==</operator> <name>set_repeat</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>largest</name> <init>= <expr><call><name>HIST_count_wksp</name> <argument_list>(<argument><expr><name>countWksp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>maxSymbolValue</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>literals</name></expr></argument>, <argument><expr><name>litSize</name></expr></argument>, <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>largest</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>litSize</name></expr>;</return></block_content></block></if></if_stmt>
        <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name></type> <name>cLitSizeEstimate</name> <init>= <expr><call><name>HUF_estimateCompressedSize</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>HUF_CElt</name><operator>*</operator><operator>)</operator><name><name>huf</name><operator>-&gt;</operator><name>CTable</name></name></expr></argument>, <argument><expr><name>countWksp</name></expr></argument>, <argument><expr><name>maxSymbolValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>writeEntropy</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cLitSizeEstimate</name> <operator>+=</operator> <name><name>hufMetadata</name><operator>-&gt;</operator><name>hufDesSize</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>singleStream</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cLitSizeEstimate</name> <operator>+=</operator> <literal type="number">6</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* multi-stream huffman uses 6-byte jump table */</comment>
            <return>return <expr><name>cLitSizeEstimate</name> <operator>+</operator> <name>literalSectionHeaderSize</name></expr>;</return>
    </block_content>}</block>   </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* impossible */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Returns the size estimate for the FSE-compressed symbols (of, ml, ll) of a block */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_estimateBlockSize_symbolType</name><parameter_list>(<parameter><decl><type><name>symbolEncodingType_e</name></type> <name>type</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>codeTable</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nbSeq</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>maxCode</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>FSE_CTable</name><modifier>*</modifier></type> <name>fseCTable</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>U8</name><modifier>*</modifier></type> <name>additionalBits</name></decl></parameter>,
                        <parameter><decl><type><name>short</name> <specifier>const</specifier><modifier>*</modifier></type> <name>defaultNorm</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>defaultNormLog</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>defaultMax</name></decl></parameter>,
                        <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workspace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name><modifier>*</modifier> <specifier>const</specifier></type> <name>countWksp</name> <init>= <expr><operator>(</operator><name>unsigned</name><operator>*</operator><operator>)</operator><name>workspace</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ctp</name> <init>= <expr><name>codeTable</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ctStart</name> <init>= <expr><name>ctp</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ctEnd</name> <init>= <expr><name>ctStart</name> <operator>+</operator> <name>nbSeq</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>cSymbolTypeSizeEstimateInBits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>max</name> <init>= <expr><name>maxCode</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>HIST_countFast_wksp</name><argument_list>(<argument><expr><name>countWksp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>max</name></expr></argument>, <argument><expr><name>codeTable</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* can't fail */</comment>
    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>set_basic</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* We selected this encoding type, so it must be valid. */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>max</name> <operator>&lt;=</operator> <name>defaultMax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>defaultMax</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>cSymbolTypeSizeEstimateInBits</name> <operator>=</operator> <call><name>ZSTD_crossEntropyCost</name><argument_list>(<argument><expr><name>defaultNorm</name></expr></argument>, <argument><expr><name>defaultNormLog</name></expr></argument>, <argument><expr><name>countWksp</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>set_rle</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>cSymbolTypeSizeEstimateInBits</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>set_compressed</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>set_repeat</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>cSymbolTypeSizeEstimateInBits</name> <operator>=</operator> <call><name>ZSTD_fseBitCost</name><argument_list>(<argument><expr><name>fseCTable</name></expr></argument>, <argument><expr><name>countWksp</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>cSymbolTypeSizeEstimateInBits</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>nbSeq</name> <operator>*</operator> <literal type="number">10</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <while>while <condition>(<expr><name>ctp</name> <operator>&lt;</operator> <name>ctEnd</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>additionalBits</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cSymbolTypeSizeEstimateInBits</name> <operator>+=</operator> <name><name>additionalBits</name><index>[<expr><operator>*</operator><name>ctp</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>cSymbolTypeSizeEstimateInBits</name> <operator>+=</operator> <operator>*</operator><name>ctp</name></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="block">/* for offset, offset code is also the number of additional bits */</comment>
        <expr_stmt><expr><name>ctp</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>cSymbolTypeSizeEstimateInBits</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Returns the size estimate for the sequences section (header + content) of a block */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_estimateBlockSize_sequences</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ofCodeTable</name></decl></parameter>,
                                                  <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>llCodeTable</name></decl></parameter>,
                                                  <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>mlCodeTable</name></decl></parameter>,
                                                  <parameter><decl><type><name>size_t</name></type> <name>nbSeq</name></decl></parameter>,
                                                  <parameter><decl><type><specifier>const</specifier> <name>ZSTD_fseCTables_t</name><modifier>*</modifier></type> <name>fseTables</name></decl></parameter>,
                                                  <parameter><decl><type><specifier>const</specifier> <name>ZSTD_fseCTablesMetadata_t</name><modifier>*</modifier></type> <name>fseMetadata</name></decl></parameter>,
                                                  <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workspace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>,
                                                  <parameter><decl><type><name>int</name></type> <name>writeEntropy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>sequencesSectionHeaderSize</name> <init>= <expr><literal type="number">1</literal> <comment type="block">/* seqHead */</comment> <operator>+</operator> <literal type="number">1</literal> <comment type="block">/* min seqSize size */</comment> <operator>+</operator> <operator>(</operator><name>nbSeq</name> <operator>&gt;=</operator> <literal type="number">128</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>nbSeq</name> <operator>&gt;=</operator> <name>LONGNBSEQ</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>cSeqSizeEstimate</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>cSeqSizeEstimate</name> <operator>+=</operator> <call><name>ZSTD_estimateBlockSize_symbolType</name><argument_list>(<argument><expr><name><name>fseMetadata</name><operator>-&gt;</operator><name>ofType</name></name></expr></argument>, <argument><expr><name>ofCodeTable</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>MaxOff</name></expr></argument>,
                                         <argument><expr><name><name>fseTables</name><operator>-&gt;</operator><name>offcodeCTable</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                         <argument><expr><name>OF_defaultNorm</name></expr></argument>, <argument><expr><name>OF_defaultNormLog</name></expr></argument>, <argument><expr><name>DefaultMaxOff</name></expr></argument>,
                                         <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cSeqSizeEstimate</name> <operator>+=</operator> <call><name>ZSTD_estimateBlockSize_symbolType</name><argument_list>(<argument><expr><name><name>fseMetadata</name><operator>-&gt;</operator><name>llType</name></name></expr></argument>, <argument><expr><name>llCodeTable</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>MaxLL</name></expr></argument>,
                                         <argument><expr><name><name>fseTables</name><operator>-&gt;</operator><name>litlengthCTable</name></name></expr></argument>, <argument><expr><name>LL_bits</name></expr></argument>,
                                         <argument><expr><name>LL_defaultNorm</name></expr></argument>, <argument><expr><name>LL_defaultNormLog</name></expr></argument>, <argument><expr><name>MaxLL</name></expr></argument>,
                                         <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cSeqSizeEstimate</name> <operator>+=</operator> <call><name>ZSTD_estimateBlockSize_symbolType</name><argument_list>(<argument><expr><name><name>fseMetadata</name><operator>-&gt;</operator><name>mlType</name></name></expr></argument>, <argument><expr><name>mlCodeTable</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>MaxML</name></expr></argument>,
                                         <argument><expr><name><name>fseTables</name><operator>-&gt;</operator><name>matchlengthCTable</name></name></expr></argument>, <argument><expr><name>ML_bits</name></expr></argument>,
                                         <argument><expr><name>ML_defaultNorm</name></expr></argument>, <argument><expr><name>ML_defaultNormLog</name></expr></argument>, <argument><expr><name>MaxML</name></expr></argument>,
                                         <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>writeEntropy</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cSeqSizeEstimate</name> <operator>+=</operator> <name><name>fseMetadata</name><operator>-&gt;</operator><name>fseTablesSize</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>cSeqSizeEstimate</name> <operator>+</operator> <name>sequencesSectionHeaderSize</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Returns the size estimate for a given stream of literals, of, ll, ml */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_estimateBlockSize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>literals</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>litSize</name></decl></parameter>,
                                     <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ofCodeTable</name></decl></parameter>,
                                     <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>llCodeTable</name></decl></parameter>,
                                     <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>mlCodeTable</name></decl></parameter>,
                                     <parameter><decl><type><name>size_t</name></type> <name>nbSeq</name></decl></parameter>,
                                     <parameter><decl><type><specifier>const</specifier> <name>ZSTD_entropyCTables_t</name><modifier>*</modifier></type> <name>entropy</name></decl></parameter>,
                                     <parameter><decl><type><specifier>const</specifier> <name>ZSTD_entropyCTablesMetadata_t</name><modifier>*</modifier></type> <name>entropyMetadata</name></decl></parameter>,
                                     <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workspace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>,
                                     <parameter><decl><type><name>int</name></type> <name>writeLitEntropy</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>writeSeqEntropy</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>literalsSize</name> <init>= <expr><call><name>ZSTD_estimateBlockSize_literal</name><argument_list>(<argument><expr><name>literals</name></expr></argument>, <argument><expr><name>litSize</name></expr></argument>,
                                                         <argument><expr><operator>&amp;</operator><name><name>entropy</name><operator>-&gt;</operator><name>huf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entropyMetadata</name><operator>-&gt;</operator><name>hufMetadata</name></name></expr></argument>,
                                                         <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>, <argument><expr><name>writeLitEntropy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>seqSize</name> <init>= <expr><call><name>ZSTD_estimateBlockSize_sequences</name><argument_list>(<argument><expr><name>ofCodeTable</name></expr></argument>, <argument><expr><name>llCodeTable</name></expr></argument>, <argument><expr><name>mlCodeTable</name></expr></argument>,
                                                         <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entropy</name><operator>-&gt;</operator><name>fse</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entropyMetadata</name><operator>-&gt;</operator><name>fseMetadata</name></name></expr></argument>,
                                                         <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>, <argument><expr><name>writeSeqEntropy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>seqSize</name> <operator>+</operator> <name>literalsSize</name> <operator>+</operator> <name>ZSTD_blockHeaderSize</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Builds entropy statistics and uses them for blocksize estimation.
 *
 * Returns the estimated compressed size of the seqStore, or a zstd error.
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_buildEntropyStatisticsAndEstimateSubBlockSize</name><parameter_list>(<parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>zc</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_entropyCTablesMetadata_t</name><modifier>*</modifier></type> <name>entropyMetadata</name> <init>= <expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>blockSplitCtx</name><operator>.</operator><name>entropyMetadata</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_buildEntropyStatisticsAndEstimateSubBlockSize()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_buildBlockEntropyStats</name><argument_list>(<argument><expr><name>seqStore</name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name><operator>-&gt;</operator><name>entropy</name></name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>nextCBlock</name><operator>-&gt;</operator><name>entropy</name></name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>appliedParams</name></name></expr></argument>,
                    <argument><expr><name>entropyMetadata</name></expr></argument>,
                    <argument><expr><name><name>zc</name><operator>-&gt;</operator><name>entropyWorkspace</name></name></expr></argument>, <argument><expr><name>ENTROPY_WORKSPACE_SIZE</name></expr></argument> <comment type="block">/* statically allocated in resetCCtx */</comment>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>ZSTD_estimateBlockSize</name><argument_list>(<argument><expr><name><name>seqStore</name><operator>-&gt;</operator><name>litStart</name></name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>seqStore</name><operator>-&gt;</operator><name>lit</name></name> <operator>-</operator> <name><name>seqStore</name><operator>-&gt;</operator><name>litStart</name></name><operator>)</operator></expr></argument>,
                    <argument><expr><name><name>seqStore</name><operator>-&gt;</operator><name>ofCode</name></name></expr></argument>, <argument><expr><name><name>seqStore</name><operator>-&gt;</operator><name>llCode</name></name></expr></argument>, <argument><expr><name><name>seqStore</name><operator>-&gt;</operator><name>mlCode</name></name></expr></argument>,
                    <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>seqStore</name><operator>-&gt;</operator><name>sequences</name></name> <operator>-</operator> <name><name>seqStore</name><operator>-&gt;</operator><name>sequencesStart</name></name><operator>)</operator></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>nextCBlock</name><operator>-&gt;</operator><name>entropy</name></name></expr></argument>, <argument><expr><name>entropyMetadata</name></expr></argument>, <argument><expr><name><name>zc</name><operator>-&gt;</operator><name>entropyWorkspace</name></name></expr></argument>, <argument><expr><name>ENTROPY_WORKSPACE_SIZE</name></expr></argument>,
                    <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>entropyMetadata</name><operator>-&gt;</operator><name>hufMetadata</name><operator>.</operator><name>hType</name></name> <operator>==</operator> <name>set_compressed</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Returns literals bytes represented in a seqStore */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_countSeqStoreLiteralsBytes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>seqStore_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>seqStore</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>literalsBytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>nbSeqs</name> <init>= <expr><name><name>seqStore</name><operator>-&gt;</operator><name>sequences</name></name> <operator>-</operator> <name><name>seqStore</name><operator>-&gt;</operator><name>sequencesStart</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nbSeqs</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>seqDef</name></type> <name>seq</name> <init>= <expr><name><name>seqStore</name><operator>-&gt;</operator><name>sequencesStart</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>literalsBytes</name> <operator>+=</operator> <name><name>seq</name><operator>.</operator><name>litLength</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name><name>seqStore</name><operator>-&gt;</operator><name>longLengthPos</name></name> <operator>&amp;&amp;</operator> <name><name>seqStore</name><operator>-&gt;</operator><name>longLengthType</name></name> <operator>==</operator> <name>ZSTD_llt_literalLength</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>literalsBytes</name> <operator>+=</operator> <literal type="number">0x10000</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>literalsBytes</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Returns match bytes represented in a seqStore */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_countSeqStoreMatchBytes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>seqStore_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>seqStore</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>matchBytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>nbSeqs</name> <init>= <expr><name><name>seqStore</name><operator>-&gt;</operator><name>sequences</name></name> <operator>-</operator> <name><name>seqStore</name><operator>-&gt;</operator><name>sequencesStart</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nbSeqs</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>seqDef</name></type> <name>seq</name> <init>= <expr><name><name>seqStore</name><operator>-&gt;</operator><name>sequencesStart</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>matchBytes</name> <operator>+=</operator> <name><name>seq</name><operator>.</operator><name>mlBase</name></name> <operator>+</operator> <name>MINMATCH</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name><name>seqStore</name><operator>-&gt;</operator><name>longLengthPos</name></name> <operator>&amp;&amp;</operator> <name><name>seqStore</name><operator>-&gt;</operator><name>longLengthType</name></name> <operator>==</operator> <name>ZSTD_llt_matchLength</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>matchBytes</name> <operator>+=</operator> <literal type="number">0x10000</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>matchBytes</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Derives the seqStore that is a chunk of the originalSeqStore from [startIdx, endIdx).
 * Stores the result in resultSeqStore.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_deriveSeqStoreChunk</name><parameter_list>(<parameter><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>resultSeqStore</name></decl></parameter>,
                               <parameter><decl><type><specifier>const</specifier> <name>seqStore_t</name><modifier>*</modifier></type> <name>originalSeqStore</name></decl></parameter>,
                                     <parameter><decl><type><name>size_t</name></type> <name>startIdx</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>endIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>resultSeqStore</name> <operator>=</operator> <operator>*</operator><name>originalSeqStore</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>startIdx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>resultSeqStore</name><operator>-&gt;</operator><name>sequences</name></name> <operator>=</operator> <name><name>originalSeqStore</name><operator>-&gt;</operator><name>sequencesStart</name></name> <operator>+</operator> <name>startIdx</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>resultSeqStore</name><operator>-&gt;</operator><name>litStart</name></name> <operator>+=</operator> <call><name>ZSTD_countSeqStoreLiteralsBytes</name><argument_list>(<argument><expr><name>resultSeqStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Move longLengthPos into the correct position if necessary */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>originalSeqStore</name><operator>-&gt;</operator><name>longLengthType</name></name> <operator>!=</operator> <name>ZSTD_llt_none</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>originalSeqStore</name><operator>-&gt;</operator><name>longLengthPos</name></name> <operator>&lt;</operator> <name>startIdx</name> <operator>||</operator> <name><name>originalSeqStore</name><operator>-&gt;</operator><name>longLengthPos</name></name> <operator>&gt;</operator> <name>endIdx</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>resultSeqStore</name><operator>-&gt;</operator><name>longLengthType</name></name> <operator>=</operator> <name>ZSTD_llt_none</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>resultSeqStore</name><operator>-&gt;</operator><name>longLengthPos</name></name> <operator>-=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>startIdx</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>resultSeqStore</name><operator>-&gt;</operator><name>sequencesStart</name></name> <operator>=</operator> <name><name>originalSeqStore</name><operator>-&gt;</operator><name>sequencesStart</name></name> <operator>+</operator> <name>startIdx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>resultSeqStore</name><operator>-&gt;</operator><name>sequences</name></name> <operator>=</operator> <name><name>originalSeqStore</name><operator>-&gt;</operator><name>sequencesStart</name></name> <operator>+</operator> <name>endIdx</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>endIdx</name> <operator>==</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>originalSeqStore</name><operator>-&gt;</operator><name>sequences</name></name> <operator>-</operator> <name><name>originalSeqStore</name><operator>-&gt;</operator><name>sequencesStart</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <comment type="block">/* This accounts for possible last literals if the derived chunk reaches the end of the block */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>resultSeqStore</name><operator>-&gt;</operator><name>lit</name></name> <operator>==</operator> <name><name>originalSeqStore</name><operator>-&gt;</operator><name>lit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>literalsBytes</name> <init>= <expr><call><name>ZSTD_countSeqStoreLiteralsBytes</name><argument_list>(<argument><expr><name>resultSeqStore</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>resultSeqStore</name><operator>-&gt;</operator><name>lit</name></name> <operator>=</operator> <name><name>resultSeqStore</name><operator>-&gt;</operator><name>litStart</name></name> <operator>+</operator> <name>literalsBytes</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>resultSeqStore</name><operator>-&gt;</operator><name>llCode</name></name> <operator>+=</operator> <name>startIdx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>resultSeqStore</name><operator>-&gt;</operator><name>mlCode</name></name> <operator>+=</operator> <name>startIdx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>resultSeqStore</name><operator>-&gt;</operator><name>ofCode</name></name> <operator>+=</operator> <name>startIdx</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Returns the raw offset represented by the combination of offBase, ll0, and repcode history.
 * offBase must represent a repcode in the numeric representation of ZSTD_storeSeq().
 */</comment>
<function><type><specifier>static</specifier> <name>U32</name></type>
<name>ZSTD_resolveRepcodeToRawOffset</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name>offBase</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name>ll0</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>adjustedRepCode</name> <init>= <expr><call><name>OFFBASE_TO_REPCODE</name><argument_list>(<argument><expr><name>offBase</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal> <operator>+</operator> <name>ll0</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* [ 0 - 3 ] */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>OFFBASE_IS_REPCODE</name><argument_list>(<argument><expr><name>offBase</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>adjustedRepCode</name> <operator>==</operator> <name>ZSTD_REP_NUM</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* litlength == 0 and offCode == 2 implies selection of first repcode - 1
         * This is only valid if it results in a valid offset value, aka &gt; 0.
         * Note : it may happen that `rep[0]==1` in exceptional circumstances.
         * In which case this function will return 0, which is an invalid offset.
         * It's not an issue though, since this value will be
         * compared and discarded within ZSTD_seqStore_resolveOffCodes().
         */</comment>
        <return>return <expr><name><name>rep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name><name>rep</name><index>[<expr><name>adjustedRepCode</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * ZSTD_seqStore_resolveOffCodes() reconciles any possible divergences in offset history that may arise
 * due to emission of RLE/raw blocks that disturb the offset history,
 * and replaces any repcodes within the seqStore that may be invalid.
 *
 * dRepcodes are updated as would be on the decompression side.
 * cRepcodes are updated exactly in accordance with the seqStore.
 *
 * Note : this function assumes seq-&gt;offBase respects the following numbering scheme :
 *        0 : invalid
 *        1-3 : repcode 1-3
 *        4+ : real_offset+3
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_seqStore_resolveOffCodes</name><parameter_list>(<parameter><decl><type><name>repcodes_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dRepcodes</name></decl></parameter>, <parameter><decl><type><name>repcodes_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cRepcodes</name></decl></parameter>,
                                          <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>seqStore</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>nbSeq</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>U32</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name>nbSeq</name></expr>;</condition> <incr><expr><operator>++</operator><name>idx</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>seqDef</name><modifier>*</modifier> <specifier>const</specifier></type> <name>seq</name> <init>= <expr><name><name>seqStore</name><operator>-&gt;</operator><name>sequencesStart</name></name> <operator>+</operator> <name>idx</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>ll0</name> <init>= <expr><operator>(</operator><name><name>seq</name><operator>-&gt;</operator><name>litLength</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>offBase</name> <init>= <expr><name><name>seq</name><operator>-&gt;</operator><name>offBase</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>seq</name><operator>-&gt;</operator><name>offBase</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>OFFBASE_IS_REPCODE</name><argument_list>(<argument><expr><name>offBase</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>dRawOffset</name> <init>= <expr><call><name>ZSTD_resolveRepcodeToRawOffset</name><argument_list>(<argument><expr><name><name>dRepcodes</name><operator>-&gt;</operator><name>rep</name></name></expr></argument>, <argument><expr><name>offBase</name></expr></argument>, <argument><expr><name>ll0</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>cRawOffset</name> <init>= <expr><call><name>ZSTD_resolveRepcodeToRawOffset</name><argument_list>(<argument><expr><name><name>cRepcodes</name><operator>-&gt;</operator><name>rep</name></name></expr></argument>, <argument><expr><name>offBase</name></expr></argument>, <argument><expr><name>ll0</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <comment type="block">/* Adjust simulated decompression repcode history if we come across a mismatch. Replace
             * the repcode with the offset it actually references, determined by the compression
             * repcode history.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>dRawOffset</name> <operator>!=</operator> <name>cRawOffset</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>seq</name><operator>-&gt;</operator><name>offBase</name></name> <operator>=</operator> <name>cRawOffset</name> <operator>+</operator> <name>ZSTD_REP_NUM</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Compression repcode history is always updated with values directly from the unmodified seqStore.
         * Decompression repcode history may use modified seq-&gt;offset value taken from compression repcode history.
         */</comment>
        <expr_stmt><expr><call><name>ZSTD_updateRep</name><argument_list>(<argument><expr><name><name>dRepcodes</name><operator>-&gt;</operator><name>rep</name></name></expr></argument>, <argument><expr><name><name>seq</name><operator>-&gt;</operator><name>offBase</name></name></expr></argument>, <argument><expr><name>ll0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_updateRep</name><argument_list>(<argument><expr><name><name>cRepcodes</name><operator>-&gt;</operator><name>rep</name></name></expr></argument>, <argument><expr><name>offBase</name></expr></argument>, <argument><expr><name>ll0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* ZSTD_compressSeqStore_singleBlock():
 * Compresses a seqStore into a block with a block header, into the buffer dst.
 *
 * Returns the total size of that block (including header) or a ZSTD error code.
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>ZSTD_compressSeqStore_singleBlock</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>zc</name></decl></parameter>, <parameter><decl><type><name>seqStore_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>seqStore</name></decl></parameter>,
                                  <parameter><decl><type><name>repcodes_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dRep</name></decl></parameter>, <parameter><decl><type><name>repcodes_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cRep</name></decl></parameter>,
                                  <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                                  <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                                  <parameter><decl><type><name>U32</name></type> <name>lastBlock</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>isPartition</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>rleMaxLength</name> <init>= <expr><literal type="number">25</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>cSize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>cSeqsSize</name></decl>;</decl_stmt>

    <comment type="block">/* In case of an RLE or raw block, the simulated decompression repcode history must be reset */</comment>
    <decl_stmt><decl><type><name>repcodes_t</name> <specifier>const</specifier></type> <name>dRepOriginal</name> <init>= <expr><operator>*</operator><name>dRep</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressSeqStore_singleBlock"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>isPartition</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ZSTD_seqStore_resolveOffCodes</name><argument_list>(<argument><expr><name>dRep</name></expr></argument>, <argument><expr><name>cRep</name></expr></argument>, <argument><expr><name>seqStore</name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name><name>seqStore</name><operator>-&gt;</operator><name>sequences</name></name> <operator>-</operator> <name><name>seqStore</name><operator>-&gt;</operator><name>sequencesStart</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>dstCapacity</name> <operator>&lt;</operator> <name>ZSTD_blockHeaderSize</name></expr></argument>, <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">"Block header doesn't fit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cSeqsSize</name> <operator>=</operator> <call><name>ZSTD_entropyCompressSeqStore</name><argument_list>(<argument><expr><name>seqStore</name></expr></argument>,
                <argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name><operator>-&gt;</operator><name>entropy</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>nextCBlock</name><operator>-&gt;</operator><name>entropy</name></name></expr></argument>,
                <argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>appliedParams</name></name></expr></argument>,
                <argument><expr><name>op</name> <operator>+</operator> <name>ZSTD_blockHeaderSize</name></expr></argument>, <argument><expr><name>dstCapacity</name> <operator>-</operator> <name>ZSTD_blockHeaderSize</name></expr></argument>,
                <argument><expr><name>srcSize</name></expr></argument>,
                <argument><expr><name><name>zc</name><operator>-&gt;</operator><name>entropyWorkspace</name></name></expr></argument>, <argument><expr><name>ENTROPY_WORKSPACE_SIZE</name></expr></argument> <comment type="block">/* statically allocated in resetCCtx */</comment>,
                <argument><expr><name><name>zc</name><operator>-&gt;</operator><name>bmi2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>cSeqsSize</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_entropyCompressSeqStore failed!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>zc</name><operator>-&gt;</operator><name>isFirstBlock</name></name> <operator>&amp;&amp;</operator>
        <name>cSeqsSize</name> <operator>&lt;</operator> <name>rleMaxLength</name> <operator>&amp;&amp;</operator>
        <call><name>ZSTD_isRLE</name><argument_list>(<argument><expr><operator>(</operator><name>BYTE</name> <specifier>const</specifier><operator>*</operator><operator>)</operator><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="block">/* We don't want to emit our first block as a RLE even if it qualifies because
        * doing so will cause the decoder (cli only) to throw a "should consume all input error."
        * This is only an issue for zstd &lt;= v1.4.3
        */</comment>
        <expr_stmt><expr><name>cSeqsSize</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>zc</name><operator>-&gt;</operator><name>seqCollector</name><operator>.</operator><name>collectSequences</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>ZSTD_copyBlockSequences</name><argument_list>(<argument><expr><name>zc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_blockState_confirmRepcodesAndEntropyTables</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>blockState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>cSeqsSize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>cSize</name> <operator>=</operator> <call><name>ZSTD_noCompressBlock</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>lastBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>, <argument><expr><literal type="string">"Nocompress block failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"Writing out nocompress block, size: %zu"</literal></expr></argument>, <argument><expr><name>cSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>dRep</name> <operator>=</operator> <name>dRepOriginal</name></expr>;</expr_stmt> <comment type="block">/* reset simulated decompression repcode history */</comment>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cSeqsSize</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>cSize</name> <operator>=</operator> <call><name>ZSTD_rleCompressBlock</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><operator>*</operator><name>ip</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>lastBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>, <argument><expr><literal type="string">"RLE compress block failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"Writing out RLE block, size: %zu"</literal></expr></argument>, <argument><expr><name>cSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>dRep</name> <operator>=</operator> <name>dRepOriginal</name></expr>;</expr_stmt> <comment type="block">/* reset simulated decompression repcode history */</comment>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>ZSTD_blockState_confirmRepcodesAndEntropyTables</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>blockState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>writeBlockHeader</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>cSeqsSize</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>lastBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cSize</name> <operator>=</operator> <name>ZSTD_blockHeaderSize</name> <operator>+</operator> <name>cSeqsSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"Writing out compressed block, size: %zu"</literal></expr></argument>, <argument><expr><name>cSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>fse</name><operator>.</operator><name>offcode_repeatMode</name></name> <operator>==</operator> <name>FSE_repeat_valid</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>fse</name><operator>.</operator><name>offcode_repeatMode</name></name> <operator>=</operator> <name>FSE_repeat_check</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>cSize</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Struct to keep track of where we are in our recursive calls. */</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier></type> <name>splitLocations</name></decl>;</decl_stmt>    <comment type="block">/* Array of split indices */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>idx</name></decl>;</decl_stmt>             <comment type="block">/* The current index within splitLocations being worked on */</comment>
}</block></struct></type> <name>seqStoreSplits</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_SEQUENCES_BLOCK_SPLITTING</name></cpp:macro> <cpp:value>300</cpp:value></cpp:define>

<comment type="block">/* Helper function to perform the recursive search for block splits.
 * Estimates the cost of seqStore prior to split, and estimates the cost of splitting the sequences in half.
 * If advantageous to split, then we recurse down the two sub-blocks. If not, or if an error occurred in estimation, then
 * we do not recurse.
 *
 * Note: The recursion depth is capped by a heuristic minimum number of sequences, defined by MIN_SEQUENCES_BLOCK_SPLITTING.
 * In theory, this means the absolute largest recursion depth is 10 == log2(maxNbSeqInBlock/MIN_SEQUENCES_BLOCK_SPLITTING).
 * In practice, recursion depth usually doesn't go beyond 4.
 *
 * Furthermore, the number of splits is capped by ZSTD_MAX_NB_BLOCK_SPLITS.
 * At ZSTD_MAX_NB_BLOCK_SPLITS == 196 with the current existing blockSize
 * maximum of 128 KB, this value is actually impossible to reach.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ZSTD_deriveBlockSplitsHelper</name><parameter_list>(<parameter><decl><type><name>seqStoreSplits</name><modifier>*</modifier></type> <name>splits</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>startIdx</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>endIdx</name></decl></parameter>,
                             <parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>zc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>seqStore_t</name><modifier>*</modifier></type> <name>origSeqStore</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>fullSeqStoreChunk</name> <init>= <expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>blockSplitCtx</name><operator>.</operator><name>fullSeqStoreChunk</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>firstHalfSeqStore</name> <init>= <expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>blockSplitCtx</name><operator>.</operator><name>firstHalfSeqStore</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>secondHalfSeqStore</name> <init>= <expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>blockSplitCtx</name><operator>.</operator><name>secondHalfSeqStore</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>estimatedOriginalSize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>estimatedFirstHalfSize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>estimatedSecondHalfSize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>midIdx</name> <init>= <expr><operator>(</operator><name>startIdx</name> <operator>+</operator> <name>endIdx</name><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>endIdx</name> <operator>-</operator> <name>startIdx</name> <operator>&lt;</operator> <name>MIN_SEQUENCES_BLOCK_SPLITTING</name> <operator>||</operator> <name><name>splits</name><operator>-&gt;</operator><name>idx</name></name> <operator>&gt;=</operator> <name>ZSTD_MAX_NB_BLOCK_SPLITS</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_deriveBlockSplitsHelper: Too few sequences"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_deriveBlockSplitsHelper: startIdx=%zu endIdx=%zu"</literal></expr></argument>, <argument><expr><name>startIdx</name></expr></argument>, <argument><expr><name>endIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_deriveSeqStoreChunk</name><argument_list>(<argument><expr><name>fullSeqStoreChunk</name></expr></argument>, <argument><expr><name>origSeqStore</name></expr></argument>, <argument><expr><name>startIdx</name></expr></argument>, <argument><expr><name>endIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_deriveSeqStoreChunk</name><argument_list>(<argument><expr><name>firstHalfSeqStore</name></expr></argument>, <argument><expr><name>origSeqStore</name></expr></argument>, <argument><expr><name>startIdx</name></expr></argument>, <argument><expr><name>midIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_deriveSeqStoreChunk</name><argument_list>(<argument><expr><name>secondHalfSeqStore</name></expr></argument>, <argument><expr><name>origSeqStore</name></expr></argument>, <argument><expr><name>midIdx</name></expr></argument>, <argument><expr><name>endIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>estimatedOriginalSize</name> <operator>=</operator> <call><name>ZSTD_buildEntropyStatisticsAndEstimateSubBlockSize</name><argument_list>(<argument><expr><name>fullSeqStoreChunk</name></expr></argument>, <argument><expr><name>zc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>estimatedFirstHalfSize</name> <operator>=</operator> <call><name>ZSTD_buildEntropyStatisticsAndEstimateSubBlockSize</name><argument_list>(<argument><expr><name>firstHalfSeqStore</name></expr></argument>, <argument><expr><name>zc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>estimatedSecondHalfSize</name> <operator>=</operator> <call><name>ZSTD_buildEntropyStatisticsAndEstimateSubBlockSize</name><argument_list>(<argument><expr><name>secondHalfSeqStore</name></expr></argument>, <argument><expr><name>zc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Estimated original block size: %zu -- First half split: %zu -- Second half split: %zu"</literal></expr></argument>,
             <argument><expr><name>estimatedOriginalSize</name></expr></argument>, <argument><expr><name>estimatedFirstHalfSize</name></expr></argument>, <argument><expr><name>estimatedSecondHalfSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>estimatedOriginalSize</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>estimatedFirstHalfSize</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>estimatedSecondHalfSize</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>estimatedFirstHalfSize</name> <operator>+</operator> <name>estimatedSecondHalfSize</name> <operator>&lt;</operator> <name>estimatedOriginalSize</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"split decided at seqNb:%zu"</literal></expr></argument>, <argument><expr><name>midIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_deriveBlockSplitsHelper</name><argument_list>(<argument><expr><name>splits</name></expr></argument>, <argument><expr><name>startIdx</name></expr></argument>, <argument><expr><name>midIdx</name></expr></argument>, <argument><expr><name>zc</name></expr></argument>, <argument><expr><name>origSeqStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>splits</name><operator>-&gt;</operator><name>splitLocations</name><index>[<expr><name><name>splits</name><operator>-&gt;</operator><name>idx</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>midIdx</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>splits</name><operator>-&gt;</operator><name>idx</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_deriveBlockSplitsHelper</name><argument_list>(<argument><expr><name>splits</name></expr></argument>, <argument><expr><name>midIdx</name></expr></argument>, <argument><expr><name>endIdx</name></expr></argument>, <argument><expr><name>zc</name></expr></argument>, <argument><expr><name>origSeqStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Base recursive function. Populates a table with intra-block partition indices that can improve compression ratio.
 *
 * Returns the number of splits made (which equals the size of the partition table - 1).
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_deriveBlockSplits</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>zc</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name><name>partitions</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>nbSeq</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>seqStoreSplits</name></type> <name>splits</name> <init>= <expr><block>{<expr><name>partitions</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>nbSeq</name> <operator>&lt;=</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_deriveBlockSplits: Too few sequences to split"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Refuse to try and split anything with less than 4 sequences */</comment>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>ZSTD_deriveBlockSplitsHelper</name><argument_list>(<argument><expr><operator>&amp;</operator><name>splits</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>zc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>seqStore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>splits</name><operator>.</operator><name>splitLocations</name><index>[<expr><name><name>splits</name><operator>.</operator><name>idx</name></name></expr>]</index></name> <operator>=</operator> <name>nbSeq</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_deriveBlockSplits: final nb partitions: %zu"</literal></expr></argument>, <argument><expr><name><name>splits</name><operator>.</operator><name>idx</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>splits</name><operator>.</operator><name>idx</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ZSTD_compressBlock_splitBlock():
 * Attempts to split a given block into multiple blocks to improve compression ratio.
 *
 * Returns combined size of all blocks (which includes headers), or a ZSTD error code.
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>ZSTD_compressBlock_splitBlock_internal</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>zc</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                                       <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>blockSize</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>lastBlock</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>nbSeq</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>cSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>srcBytesTotal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier></type> <name>partitions</name> <init>= <expr><name><name>zc</name><operator>-&gt;</operator><name>blockSplitCtx</name><operator>.</operator><name>partitions</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* size == ZSTD_MAX_NB_BLOCK_SPLITS */</comment>
    <decl_stmt><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>nextSeqStore</name> <init>= <expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>blockSplitCtx</name><operator>.</operator><name>nextSeqStore</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>seqStore_t</name><modifier>*</modifier></type> <name>currSeqStore</name> <init>= <expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>blockSplitCtx</name><operator>.</operator><name>currSeqStore</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>numSplits</name> <init>= <expr><call><name>ZSTD_deriveBlockSplits</name><argument_list>(<argument><expr><name>zc</name></expr></argument>, <argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* If a block is split and some partitions are emitted as RLE/uncompressed, then repcode history
     * may become invalid. In order to reconcile potentially invalid repcodes, we keep track of two
     * separate repcode histories that simulate repcode history on compression and decompression side,
     * and use the histories to determine whether we must replace a particular repcode with its raw offset.
     *
     * 1) cRep gets updated for each partition, regardless of whether the block was emitted as uncompressed
     *    or RLE. This allows us to retrieve the offset value that an invalid repcode references within
     *    a nocompress/RLE block.
     * 2) dRep gets updated only for compressed partitions, and when a repcode gets replaced, will use
     *    the replacement offset value rather than the original repcode to update the repcode history.
     *    dRep also will be the final repcode history sent to the next block.
     *
     * See ZSTD_seqStore_resolveOffCodes() for more details.
     */</comment>
    <decl_stmt><decl><type><name>repcodes_t</name></type> <name>dRep</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>repcodes_t</name></type> <name>cRep</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name><name>dRep</name><operator>.</operator><name>rep</name></name></expr></argument>, <argument><expr><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name><operator>-&gt;</operator><name>rep</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repcodes_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name><name>cRep</name><operator>.</operator><name>rep</name></name></expr></argument>, <argument><expr><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name><operator>-&gt;</operator><name>rep</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repcodes_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><name>nextSeqStore</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>seqStore_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressBlock_splitBlock_internal (dstCapacity=%u, dictLimit=%u, nextToUpdate=%u)"</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>dstCapacity</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name><operator>.</operator><name>window</name><operator>.</operator><name>dictLimit</name></name></expr></argument>,
                <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name><operator>.</operator><name>nextToUpdate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>numSplits</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>cSizeSingleBlock</name> <init>= <expr><call><name>ZSTD_compressSeqStore_singleBlock</name><argument_list>(<argument><expr><name>zc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>seqStore</name></name></expr></argument>,
                                                                   <argument><expr><operator>&amp;</operator><name>dRep</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cRep</name></expr></argument>,
                                                                    <argument><expr><name>op</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>,
                                                                    <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>blockSize</name></expr></argument>,
                                                                    <argument><expr><name>lastBlock</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* isPartition */</comment>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>cSizeSingleBlock</name></expr></argument>, <argument><expr><literal type="string">"Compressing single block from splitBlock_internal() failed!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressBlock_splitBlock_internal: No splits"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>cSizeSingleBlock</name> <operator>&lt;=</operator> <name>ZSTD_BLOCKSIZE_MAX</name> <operator>+</operator> <name>ZSTD_blockHeaderSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>cSizeSingleBlock</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ZSTD_deriveSeqStoreChunk</name><argument_list>(<argument><expr><name>currSeqStore</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>seqStore</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>partitions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>numSplits</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>cSizeChunk</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>lastPartition</name> <init>= <expr><operator>(</operator><name>i</name> <operator>==</operator> <name>numSplits</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name></type> <name>lastBlockEntireSrc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>size_t</name></type> <name>srcBytes</name> <init>= <expr><call><name>ZSTD_countSeqStoreLiteralsBytes</name><argument_list>(<argument><expr><name>currSeqStore</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>ZSTD_countSeqStoreMatchBytes</name><argument_list>(<argument><expr><name>currSeqStore</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>srcBytesTotal</name> <operator>+=</operator> <name>srcBytes</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>lastPartition</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* This is the final partition, need to account for possible last literals */</comment>
            <expr_stmt><expr><name>srcBytes</name> <operator>+=</operator> <name>blockSize</name> <operator>-</operator> <name>srcBytesTotal</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>lastBlockEntireSrc</name> <operator>=</operator> <name>lastBlock</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>ZSTD_deriveSeqStoreChunk</name><argument_list>(<argument><expr><name>nextSeqStore</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>seqStore</name></name></expr></argument>, <argument><expr><name><name>partitions</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>partitions</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>cSizeChunk</name> <operator>=</operator> <call><name>ZSTD_compressSeqStore_singleBlock</name><argument_list>(<argument><expr><name>zc</name></expr></argument>, <argument><expr><name>currSeqStore</name></expr></argument>,
                                                      <argument><expr><operator>&amp;</operator><name>dRep</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cRep</name></expr></argument>,
                                                       <argument><expr><name>op</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>,
                                                       <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>srcBytes</name></expr></argument>,
                                                       <argument><expr><name>lastBlockEntireSrc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> <comment type="block">/* isPartition */</comment>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Estimated size: %zu actual size: %zu"</literal></expr></argument>, <argument><expr><call><name>ZSTD_buildEntropyStatisticsAndEstimateSubBlockSize</name><argument_list>(<argument><expr><name>currSeqStore</name></expr></argument>, <argument><expr><name>zc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cSizeChunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>cSizeChunk</name></expr></argument>, <argument><expr><literal type="string">"Compressing chunk failed!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>srcBytes</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>cSizeChunk</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dstCapacity</name> <operator>-=</operator> <name>cSizeChunk</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>cSize</name> <operator>+=</operator> <name>cSizeChunk</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>currSeqStore</name> <operator>=</operator> <operator>*</operator><name>nextSeqStore</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>cSizeChunk</name> <operator>&lt;=</operator> <name>ZSTD_BLOCKSIZE_MAX</name> <operator>+</operator> <name>ZSTD_blockHeaderSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <comment type="block">/* cRep and dRep may have diverged during the compression. If so, we use the dRep repcodes
     * for the next block.
     */</comment>
    <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name><operator>-&gt;</operator><name>rep</name></name></expr></argument>, <argument><expr><name><name>dRep</name><operator>.</operator><name>rep</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repcodes_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>cSize</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>ZSTD_compressBlock_splitBlock</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>zc</name></decl></parameter>,
                              <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                              <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>lastBlock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>nbSeq</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>cSize</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressBlock_splitBlock"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>zc</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>useBlockSplitter</name></name> <operator>==</operator> <name>ZSTD_ps_enable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <block>{<block_content>   <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>bss</name> <init>= <expr><call><name>ZSTD_buildSeqStore</name><argument_list>(<argument><expr><name>zc</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>bss</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_buildSeqStore failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>bss</name> <operator>==</operator> <name>ZSTDbss_noCompress</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>fse</name><operator>.</operator><name>offcode_repeatMode</name></name> <operator>==</operator> <name>FSE_repeat_valid</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>fse</name><operator>.</operator><name>offcode_repeatMode</name></name> <operator>=</operator> <name>FSE_repeat_check</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>cSize</name> <operator>=</operator> <call><name>ZSTD_noCompressBlock</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>lastBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_noCompressBlock failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressBlock_splitBlock: Nocompress block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>cSize</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>nbSeq</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name><name>zc</name><operator>-&gt;</operator><name>seqStore</name><operator>.</operator><name>sequences</name></name> <operator>-</operator> <name><name>zc</name><operator>-&gt;</operator><name>seqStore</name><operator>.</operator><name>sequencesStart</name></name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name>cSize</name> <operator>=</operator> <call><name>ZSTD_compressBlock_splitBlock_internal</name><argument_list>(<argument><expr><name>zc</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>lastBlock</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>, <argument><expr><literal type="string">"Splitting blocks failed!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>cSize</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>ZSTD_compressBlock_internal</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>zc</name></decl></parameter>,
                            <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                            <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>frame</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* This is an estimated upper bound for the length of an rle block.
     * This isn't the actual upper bound.
     * Finding the real threshold needs further investigation.
     */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>rleMaxLength</name> <init>= <expr><literal type="number">25</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>cSize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressBlock_internal (dstCapacity=%u, dictLimit=%u, nextToUpdate=%u)"</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>dstCapacity</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name><operator>.</operator><name>window</name><operator>.</operator><name>dictLimit</name></name></expr></argument>,
                <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name><operator>.</operator><name>nextToUpdate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <block>{<block_content>   <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>bss</name> <init>= <expr><call><name>ZSTD_buildSeqStore</name><argument_list>(<argument><expr><name>zc</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>bss</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_buildSeqStore failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>bss</name> <operator>==</operator> <name>ZSTDbss_noCompress</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>cSize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <goto>goto <name>out</name>;</goto> </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <if_stmt><if>if <condition>(<expr><name><name>zc</name><operator>-&gt;</operator><name>seqCollector</name><operator>.</operator><name>collectSequences</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>ZSTD_copyBlockSequences</name><argument_list>(<argument><expr><name>zc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_blockState_confirmRepcodesAndEntropyTables</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>blockState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* encode sequences and literals */</comment>
    <expr_stmt><expr><name>cSize</name> <operator>=</operator> <call><name>ZSTD_entropyCompressSeqStore</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>seqStore</name></name></expr></argument>,
            <argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name><operator>-&gt;</operator><name>entropy</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>nextCBlock</name><operator>-&gt;</operator><name>entropy</name></name></expr></argument>,
            <argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>appliedParams</name></name></expr></argument>,
            <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>,
            <argument><expr><name>srcSize</name></expr></argument>,
            <argument><expr><name><name>zc</name><operator>-&gt;</operator><name>entropyWorkspace</name></name></expr></argument>, <argument><expr><name>ENTROPY_WORKSPACE_SIZE</name></expr></argument> <comment type="block">/* statically allocated in resetCCtx */</comment>,
            <argument><expr><name><name>zc</name><operator>-&gt;</operator><name>bmi2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>frame</name> <operator>&amp;&amp;</operator>
        <comment type="block">/* We don't want to emit our first block as a RLE even if it qualifies because
         * doing so will cause the decoder (cli only) to throw a "should consume all input error."
         * This is only an issue for zstd &lt;= v1.4.3
         */</comment>
        <operator>!</operator><name><name>zc</name><operator>-&gt;</operator><name>isFirstBlock</name></name> <operator>&amp;&amp;</operator>
        <name>cSize</name> <operator>&lt;</operator> <name>rleMaxLength</name> <operator>&amp;&amp;</operator>
        <call><name>ZSTD_isRLE</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>cSize</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

<label><name>out</name>:</label>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>cSize</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>ZSTD_blockState_confirmRepcodesAndEntropyTables</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>blockState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* We check that dictionaries have offset codes available for the first
     * block. After the first block, the offcode table might not have large
     * enough codes to represent the offsets in the data.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>fse</name><operator>.</operator><name>offcode_repeatMode</name></name> <operator>==</operator> <name>FSE_repeat_valid</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>fse</name><operator>.</operator><name>offcode_repeatMode</name></name> <operator>=</operator> <name>FSE_repeat_check</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>cSize</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_compressBlock_targetCBlockSize_body</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>zc</name></decl></parameter>,
                               <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                               <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                               <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>bss</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>lastBlock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"Attempting ZSTD_compressSuperBlock()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>bss</name> <operator>==</operator> <name>ZSTDbss_compress</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<comment type="block">/* We don't want to emit our first block as a RLE even if it qualifies because
            * doing so will cause the decoder (cli only) to throw a "should consume all input error."
            * This is only an issue for zstd &lt;= v1.4.3
            */</comment>
            <expr><operator>!</operator><name><name>zc</name><operator>-&gt;</operator><name>isFirstBlock</name></name> <operator>&amp;&amp;</operator>
            <call><name>ZSTD_maybeRLE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>seqStore</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>ZSTD_isRLE</name><argument_list>(<argument><expr><operator>(</operator><name>BYTE</name> <specifier>const</specifier><operator>*</operator><operator>)</operator><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><call><name>ZSTD_rleCompressBlock</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>BYTE</name> <specifier>const</specifier><operator>*</operator><operator>)</operator><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>lastBlock</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Attempt superblock compression.
         *
         * Note that compressed size of ZSTD_compressSuperBlock() is not bound by the
         * standard ZSTD_compressBound(). This is a problem, because even if we have
         * space now, taking an extra byte now could cause us to run out of space later
         * and violate ZSTD_compressBound().
         *
         * Define blockBound(blockSize) = blockSize + ZSTD_blockHeaderSize.
         *
         * In order to respect ZSTD_compressBound() we must attempt to emit a raw
         * uncompressed block in these cases:
         *   * cSize == 0: Return code for an uncompressed block.
         *   * cSize == dstSize_tooSmall: We may have expanded beyond blockBound(srcSize).
         *     ZSTD_noCompressBlock() will return dstSize_tooSmall if we are really out of
         *     output space.
         *   * cSize &gt;= blockBound(srcSize): We have expanded the block too much so
         *     emit an uncompressed block.
         */</comment>
        <block>{<block_content>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>cSize</name> <init>= <expr><call><name>ZSTD_compressSuperBlock</name><argument_list>(<argument><expr><name>zc</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>lastBlock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>cSize</name> <operator>!=</operator> <call><name>ERROR</name><argument_list>(<argument><expr><name>dstSize_tooSmall</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>maxCSize</name> <init>= <expr><name>srcSize</name> <operator>-</operator> <call><name>ZSTD_minGain</name><argument_list>(<argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name><name>zc</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>cParams</name><operator>.</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressSuperBlock failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>cSize</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>cSize</name> <operator>&lt;</operator> <name>maxCSize</name> <operator>+</operator> <name>ZSTD_blockHeaderSize</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>ZSTD_blockState_confirmRepcodesAndEntropyTables</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zc</name><operator>-&gt;</operator><name>blockState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>cSize</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"Resorting to ZSTD_noCompressBlock()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Superblock compression failed, attempt to emit a single no compress block.
     * The decoder will be able to stream this block since it is uncompressed.
     */</comment>
    <return>return <expr><call><name>ZSTD_noCompressBlock</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>lastBlock</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_compressBlock_targetCBlockSize</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>zc</name></decl></parameter>,
                               <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                               <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                               <parameter><decl><type><name>U32</name></type> <name>lastBlock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>cSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>bss</name> <init>= <expr><call><name>ZSTD_buildSeqStore</name><argument_list>(<argument><expr><name>zc</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressBlock_targetCBlockSize (dstCapacity=%u, dictLimit=%u, nextToUpdate=%u, srcSize=%zu)"</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>dstCapacity</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name><operator>.</operator><name>window</name><operator>.</operator><name>dictLimit</name></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name><operator>.</operator><name>nextToUpdate</name></name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>bss</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_buildSeqStore failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>cSize</name> <operator>=</operator> <call><name>ZSTD_compressBlock_targetCBlockSize_body</name><argument_list>(<argument><expr><name>zc</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>bss</name></expr></argument>, <argument><expr><name>lastBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressBlock_targetCBlockSize_body failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>fse</name><operator>.</operator><name>offcode_repeatMode</name></name> <operator>==</operator> <name>FSE_repeat_valid</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>zc</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>fse</name><operator>.</operator><name>offcode_repeatMode</name></name> <operator>=</operator> <name>FSE_repeat_check</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>cSize</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_overflowCorrectIfNeeded</name><parameter_list>(<parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>,
                                         <parameter><decl><type><name>ZSTD_cwksp</name><modifier>*</modifier></type> <name>ws</name></decl></parameter>,
                                         <parameter><decl><type><name>ZSTD_CCtx_params</name> <specifier>const</specifier><modifier>*</modifier></type> <name>params</name></decl></parameter>,
                                         <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>ip</name></decl></parameter>,
                                         <parameter><decl><type><name>void</name> <specifier>const</specifier><modifier>*</modifier></type> <name>iend</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>cycleLog</name> <init>= <expr><call><name>ZSTD_cycleLog</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>chainLog</name></name></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>maxDist</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>params</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>windowLog</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ZSTD_window_needOverflowCorrection</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>window</name></name></expr></argument>, <argument><expr><name>cycleLog</name></expr></argument>, <argument><expr><name>maxDist</name></expr></argument>, <argument><expr><name><name>ms</name><operator>-&gt;</operator><name>loadedDictEnd</name></name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>correction</name> <init>= <expr><call><name>ZSTD_window_correctOverflow</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ms</name><operator>-&gt;</operator><name>window</name></name></expr></argument>, <argument><expr><name>cycleLog</name></expr></argument>, <argument><expr><name>maxDist</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ZSTD_STATIC_ASSERT</name><argument_list>(<argument><expr><name>ZSTD_CHAINLOG_MAX</name> <operator>&lt;=</operator> <literal type="number">30</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_STATIC_ASSERT</name><argument_list>(<argument><expr><name>ZSTD_WINDOWLOG_MAX_32</name> <operator>&lt;=</operator> <literal type="number">30</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_STATIC_ASSERT</name><argument_list>(<argument><expr><name>ZSTD_WINDOWLOG_MAX</name> <operator>&lt;=</operator> <literal type="number">31</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_cwksp_mark_tables_dirty</name><argument_list>(<argument><expr><name>ws</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_reduceIndex</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>correction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_cwksp_mark_tables_clean</name><argument_list>(<argument><expr><name>ws</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name> <operator>&lt;</operator> <name>correction</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name> <operator>-=</operator> <name>correction</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <comment type="block">/* invalidate dictionaries on overflow correction */</comment>
        <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>loadedDictEnd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>dictMatchState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! ZSTD_compress_frameChunk() :
*   Compress a chunk of data into one or multiple blocks.
*   All blocks will be terminated, all input will be consumed.
*   Function will issue an error if there is not enough `dstCapacity` to hold the compressed content.
*   Frame is supposed already started (header already produced)
*   @return : compressed size, or an error code
*/</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_compress_frameChunk</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>,
                                     <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                               <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                                     <parameter><decl><type><name>U32</name></type> <name>lastFrameChunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>blockSize</name> <init>= <expr><name><name>cctx</name><operator>-&gt;</operator><name>blockSize</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>remaining</name> <init>= <expr><name>srcSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ostart</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><name>ostart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>maxDist</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>cParams</name><operator>.</operator><name>windowLog</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>cParams</name><operator>.</operator><name>windowLog</name></name> <operator>&lt;=</operator> <name>ZSTD_WINDOWLOG_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compress_frameChunk (blockSize=%u)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>blockSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>fParams</name><operator>.</operator><name>checksumFlag</name></name> <operator>&amp;&amp;</operator> <name>srcSize</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>XXH64_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>xxhState</name></name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <while>while <condition>(<expr><name>remaining</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ms</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>lastBlock</name> <init>= <expr><name>lastFrameChunk</name> <operator>&amp;</operator> <operator>(</operator><name>blockSize</name> <operator>&gt;=</operator> <name>remaining</name><operator>)</operator></expr></init></decl>;</decl_stmt>

        <comment type="block">/* TODO: See 3090. We reduced MIN_CBLOCK_SIZE from 3 to 2 so to compensate we are adding
         * additional 1. We need to revisit and change this logic to be more consistent */</comment>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>dstCapacity</name> <operator>&lt;</operator> <name>ZSTD_blockHeaderSize</name> <operator>+</operator> <name>MIN_CBLOCK_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
                        <argument><expr><name>dstSize_tooSmall</name></expr></argument>,
                        <argument><expr><literal type="string">"not enough space to store compressed block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>remaining</name> <operator>&lt;</operator> <name>blockSize</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>blockSize</name> <operator>=</operator> <name>remaining</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>ZSTD_overflowCorrectIfNeeded</name><argument_list>(
            <argument><expr><name>ms</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name></name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>ip</name> <operator>+</operator> <name>blockSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_checkDictValidity</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ms</name><operator>-&gt;</operator><name>window</name></name></expr></argument>, <argument><expr><name>ip</name> <operator>+</operator> <name>blockSize</name></expr></argument>, <argument><expr><name>maxDist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ms</name><operator>-&gt;</operator><name>loadedDictEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ms</name><operator>-&gt;</operator><name>dictMatchState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_window_enforceMaxDist</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ms</name><operator>-&gt;</operator><name>window</name></name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>maxDist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ms</name><operator>-&gt;</operator><name>loadedDictEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ms</name><operator>-&gt;</operator><name>dictMatchState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Ensure hash/chain table insertion resumes no sooner than lowlimit */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name> <operator>&lt;</operator> <name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>lowLimit</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name> <operator>=</operator> <name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>lowLimit</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name></type> <name>cSize</name></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>ZSTD_useTargetCBlockSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>cSize</name> <operator>=</operator> <call><name>ZSTD_compressBlock_targetCBlockSize</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>blockSize</name></expr></argument>, <argument><expr><name>lastBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressBlock_targetCBlockSize failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>cSize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>cSize</name> <operator>&lt;=</operator> <name>blockSize</name> <operator>+</operator> <name>ZSTD_blockHeaderSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ZSTD_blockSplitterEnabled</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>cSize</name> <operator>=</operator> <call><name>ZSTD_compressBlock_splitBlock</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>blockSize</name></expr></argument>, <argument><expr><name>lastBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressBlock_splitBlock failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>cSize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>cctx</name><operator>-&gt;</operator><name>seqCollector</name><operator>.</operator><name>collectSequences</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>cSize</name> <operator>=</operator> <call><name>ZSTD_compressBlock_internal</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>,
                                        <argument><expr><name>op</name><operator>+</operator><name>ZSTD_blockHeaderSize</name></expr></argument>, <argument><expr><name>dstCapacity</name><operator>-</operator><name>ZSTD_blockHeaderSize</name></expr></argument>,
                                        <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>blockSize</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> <comment type="block">/* frame */</comment>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressBlock_internal failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>cSize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* block is not compressible */</comment>
                    <expr_stmt><expr><name>cSize</name> <operator>=</operator> <call><name>ZSTD_noCompressBlock</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>blockSize</name></expr></argument>, <argument><expr><name>lastBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_noCompressBlock failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>cBlockHeader</name> <init>= <expr><ternary><condition><expr><name>cSize</name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then>
                        <expr><name>lastBlock</name> <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><name>bt_rle</name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">1</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>blockSize</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr> </then><else>:
                        <expr><name>lastBlock</name> <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><name>bt_compressed</name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">1</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>cSize</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>MEM_writeLE24</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>cBlockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>cSize</name> <operator>+=</operator> <name>ZSTD_blockHeaderSize</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></else></if_stmt>


            <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>blockSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>remaining</name> <operator>&gt;=</operator> <name>blockSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>remaining</name> <operator>-=</operator> <name>blockSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>cSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dstCapacity</name> <operator>&gt;=</operator> <name>cSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>dstCapacity</name> <operator>-=</operator> <name>cSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>isFirstBlock</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compress_frameChunk: adding a block of size %u"</literal></expr></argument>,
                        <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>cSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>   </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><name>lastFrameChunk</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>op</name><operator>&gt;</operator><name>ostart</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>stage</name></name> <operator>=</operator> <name>ZSTDcs_ending</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>op</name><operator>-</operator><name>ostart</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_writeFrameHeader</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                                    <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>params</name></decl></parameter>, <parameter><decl><type><name>U64</name></type> <name>pledgedSrcSize</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>dictID</name></decl></parameter>)</parameter_list>
<block>{<block_content>   <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>op</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>   <specifier>const</specifier></type> <name>dictIDSizeCodeLength</name> <init>= <expr><operator>(</operator><name>dictID</name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>dictID</name><operator>&gt;=</operator><literal type="number">256</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>dictID</name><operator>&gt;=</operator><literal type="number">65536</literal><operator>)</operator></expr></init></decl>;</decl_stmt>   <comment type="block">/* 0-3 */</comment>
    <decl_stmt><decl><type><name>U32</name>   <specifier>const</specifier></type> <name>dictIDSizeCode</name> <init>= <expr><ternary><condition><expr><name><name>params</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>noDictIDFlag</name></name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>dictIDSizeCodeLength</name></expr></else></ternary></expr></init></decl>;</decl_stmt>   <comment type="block">/* 0-3 */</comment>
    <decl_stmt><decl><type><name>U32</name>   <specifier>const</specifier></type> <name>checksumFlag</name> <init>= <expr><name><name>params</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>checksumFlag</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>   <specifier>const</specifier></type> <name>windowSize</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>params</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>windowLog</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>   <specifier>const</specifier></type> <name>singleSegment</name> <init>= <expr><name><name>params</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>contentSizeFlag</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>windowSize</name> <operator>&gt;=</operator> <name>pledgedSrcSize</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name>  <specifier>const</specifier></type> <name>windowLogByte</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>windowLog</name></name> <operator>-</operator> <name>ZSTD_WINDOWLOG_ABSOLUTEMIN</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name>   <specifier>const</specifier></type> <name>fcsCode</name> <init>= <expr><ternary><condition><expr><name><name>params</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>contentSizeFlag</name></name></expr> ?</condition><then>
                     <expr><operator>(</operator><name>pledgedSrcSize</name><operator>&gt;=</operator><literal type="number">256</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>pledgedSrcSize</name><operator>&gt;=</operator><literal type="number">65536</literal><operator>+</operator><literal type="number">256</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>pledgedSrcSize</name><operator>&gt;=</operator><literal type="number">0xFFFFFFFFU</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>  <comment type="block">/* 0-3 */</comment>
    <decl_stmt><decl><type><name>BYTE</name>  <specifier>const</specifier></type> <name>frameHeaderDescriptionByte</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>)</operator><operator>(</operator><name>dictIDSizeCode</name> <operator>+</operator> <operator>(</operator><name>checksumFlag</name><operator>&lt;&lt;</operator><literal type="number">2</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>singleSegment</name><operator>&lt;&lt;</operator><literal type="number">5</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>fcsCode</name><operator>&lt;&lt;</operator><literal type="number">6</literal><operator>)</operator> <operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>pos</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>contentSizeFlag</name></name> <operator>&amp;&amp;</operator> <name>pledgedSrcSize</name> <operator>==</operator> <name>ZSTD_CONTENTSIZE_UNKNOWN</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>dstCapacity</name> <operator>&lt;</operator> <name>ZSTD_FRAMEHEADERSIZE_MAX</name></expr></argument>, <argument><expr><name>dstSize_tooSmall</name></expr></argument>,
                    <argument><expr><literal type="string">"dst buf is too small to fit worst-case frame header size."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_writeFrameHeader : dictIDFlag : %u ; dictID : %u ; dictIDSizeCode : %u"</literal></expr></argument>,
                <argument><expr><operator>!</operator><name><name>params</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>noDictIDFlag</name></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>dictID</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>dictIDSizeCode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>ZSTD_f_zstd1</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>MEM_writeLE32</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>ZSTD_MAGICNUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pos</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>op</name><index>[<expr><name>pos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>frameHeaderDescriptionByte</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>singleSegment</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>op</name><index>[<expr><name>pos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>windowLogByte</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <switch>switch<condition>(<expr><name>dictIDSizeCode</name></expr>)</condition>
    <block>{<block_content>
        <default>default:</default>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* impossible */</comment>
            <expr_stmt><expr><name>ZSTD_FALLTHROUGH</name></expr>;</expr_stmt>
        <case>case <expr><literal type="number">0</literal></expr> :</case> <break>break;</break>
        <case>case <expr><literal type="number">1</literal></expr> :</case> <expr_stmt><expr><name><name>op</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><operator>(</operator><name>dictID</name><operator>)</operator></expr>;</expr_stmt> <expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt> <break>break;</break>
        <case>case <expr><literal type="number">2</literal></expr> :</case> <expr_stmt><expr><call><name>MEM_writeLE16</name><argument_list>(<argument><expr><name>op</name><operator>+</operator><name>pos</name></expr></argument>, <argument><expr><operator>(</operator><name>U16</name><operator>)</operator><name>dictID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>pos</name><operator>+=</operator><literal type="number">2</literal></expr>;</expr_stmt> <break>break;</break>
        <case>case <expr><literal type="number">3</literal></expr> :</case> <expr_stmt><expr><call><name>MEM_writeLE32</name><argument_list>(<argument><expr><name>op</name><operator>+</operator><name>pos</name></expr></argument>, <argument><expr><name>dictID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>pos</name><operator>+=</operator><literal type="number">4</literal></expr>;</expr_stmt> <break>break;</break>
    </block_content>}</block></switch>
    <switch>switch<condition>(<expr><name>fcsCode</name></expr>)</condition>
    <block>{<block_content>
        <default>default:</default>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* impossible */</comment>
            <expr_stmt><expr><name>ZSTD_FALLTHROUGH</name></expr>;</expr_stmt>
        <case>case <expr><literal type="number">0</literal></expr> :</case> <if_stmt><if>if <condition>(<expr><name>singleSegment</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>op</name><index>[<expr><name>pos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><operator>(</operator><name>pledgedSrcSize</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt> <break>break;</break>
        <case>case <expr><literal type="number">1</literal></expr> :</case> <expr_stmt><expr><call><name>MEM_writeLE16</name><argument_list>(<argument><expr><name>op</name><operator>+</operator><name>pos</name></expr></argument>, <argument><expr><operator>(</operator><name>U16</name><operator>)</operator><operator>(</operator><name>pledgedSrcSize</name><operator>-</operator><literal type="number">256</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>pos</name><operator>+=</operator><literal type="number">2</literal></expr>;</expr_stmt> <break>break;</break>
        <case>case <expr><literal type="number">2</literal></expr> :</case> <expr_stmt><expr><call><name>MEM_writeLE32</name><argument_list>(<argument><expr><name>op</name><operator>+</operator><name>pos</name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>pledgedSrcSize</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>pos</name><operator>+=</operator><literal type="number">4</literal></expr>;</expr_stmt> <break>break;</break>
        <case>case <expr><literal type="number">3</literal></expr> :</case> <expr_stmt><expr><call><name>MEM_writeLE64</name><argument_list>(<argument><expr><name>op</name><operator>+</operator><name>pos</name></expr></argument>, <argument><expr><operator>(</operator><name>U64</name><operator>)</operator><operator>(</operator><name>pledgedSrcSize</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>pos</name><operator>+=</operator><literal type="number">8</literal></expr>;</expr_stmt> <break>break;</break>
    </block_content>}</block></switch>
    <return>return <expr><name>pos</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ZSTD_writeSkippableFrame_advanced() :
 * Writes out a skippable frame with the specified magic number variant (16 are supported),
 * from ZSTD_MAGIC_SKIPPABLE_START to ZSTD_MAGIC_SKIPPABLE_START+15, and the desired source data.
 *
 * Returns the total number of bytes written, or a ZSTD error code.
 */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_writeSkippableFrame</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                                <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>magicVariant</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>dstCapacity</name> <operator>&lt;</operator> <name>srcSize</name> <operator>+</operator> <name>ZSTD_SKIPPABLEHEADERSIZE</name></expr></argument> <comment type="block">/* Skippable frame overhead */</comment>,
                    <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">"Not enough room for skippable frame"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>srcSize</name> <operator>&gt;</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><literal type="number">0xFFFFFFFF</literal></expr></argument>, <argument><expr><name>srcSize_wrong</name></expr></argument>, <argument><expr><literal type="string">"Src size too large for skippable frame"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>magicVariant</name> <operator>&gt;</operator> <literal type="number">15</literal></expr></argument>, <argument><expr><name>parameter_outOfBound</name></expr></argument>, <argument><expr><literal type="string">"Skippable frame magic number variant not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MEM_writeLE32</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ZSTD_MAGIC_SKIPPABLE_START</name> <operator>+</operator> <name>magicVariant</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MEM_writeLE32</name><argument_list>(<argument><expr><name>op</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>op</name><operator>+</operator><literal type="number">8</literal></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>srcSize</name> <operator>+</operator> <name>ZSTD_SKIPPABLEHEADERSIZE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ZSTD_writeLastEmptyBlock() :
 * output an empty Block with end-of-frame mark to complete a frame
 * @return : size of data written into `dst` (== ZSTD_blockHeaderSize (defined in zstd_internal.h))
 *           or an error code if `dstCapacity` is too small (&lt;ZSTD_blockHeaderSize)
 */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_writeLastEmptyBlock</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>dstCapacity</name> <operator>&lt;</operator> <name>ZSTD_blockHeaderSize</name></expr></argument>, <argument><expr><name>dstSize_tooSmall</name></expr></argument>,
                    <argument><expr><literal type="string">"dst buf is too small to write frame trailer empty block."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>cBlockHeader24</name> <init>= <expr><literal type="number">1</literal> <comment type="block">/*lastBlock*/</comment> <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><name>bt_raw</name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>  <comment type="block">/* 0 size */</comment>
        <expr_stmt><expr><call><name>MEM_writeLE24</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>cBlockHeader24</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ZSTD_blockHeaderSize</name></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_referenceExternalSequences</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>, <parameter><decl><type><name>rawSeq</name><modifier>*</modifier></type> <name>seq</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nbSeq</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>stage</name></name> <operator>!=</operator> <name>ZSTDcs_init</name></expr></argument>, <argument><expr><name>stage_wrong</name></expr></argument>,
                    <argument><expr><literal type="string">"wrong cctx stage"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>ldmParams</name><operator>.</operator><name>enableLdm</name></name> <operator>==</operator> <name>ZSTD_ps_enable</name></expr></argument>,
                    <argument><expr><name>parameter_unsupported</name></expr></argument>,
                    <argument><expr><literal type="string">"incompatible with ldm"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>externSeqStore</name><operator>.</operator><name>seq</name></name> <operator>=</operator> <name>seq</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>externSeqStore</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>nbSeq</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>externSeqStore</name><operator>.</operator><name>capacity</name></name> <operator>=</operator> <name>nbSeq</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>externSeqStore</name><operator>.</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>externSeqStore</name><operator>.</operator><name>posInSequence</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_compressContinue_internal</name> <parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>,
                              <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                               <parameter><decl><type><name>U32</name></type> <name>frame</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>lastFrameChunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ms</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>fhSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressContinue_internal, stage: %u, srcSize: %u"</literal></expr></argument>,
                <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>stage</name></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>stage</name></name><operator>==</operator><name>ZSTDcs_created</name></expr></argument>, <argument><expr><name>stage_wrong</name></expr></argument>,
                    <argument><expr><literal type="string">"missing init (ZSTD_compressBegin)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>frame</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>cctx</name><operator>-&gt;</operator><name>stage</name></name><operator>==</operator><name>ZSTDcs_init</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>fhSize</name> <operator>=</operator> <call><name>ZSTD_writeFrameHeader</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name></name></expr></argument>,
                                       <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>pledgedSrcSizePlusOne</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>dictID</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>fhSize</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_writeFrameHeader failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>fhSize</name> <operator>&lt;=</operator> <name>dstCapacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dstCapacity</name> <operator>-=</operator> <name>fhSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dst</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>dst</name> <operator>+</operator> <name>fhSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>stage</name></name> <operator>=</operator> <name>ZSTDcs_ongoing</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>srcSize</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>fhSize</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* do not generate an empty block if no input */</comment>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ZSTD_window_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ms</name><operator>-&gt;</operator><name>window</name></name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name><name>ms</name><operator>-&gt;</operator><name>forceNonContiguous</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>forceNonContiguous</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name> <operator>=</operator> <name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>dictLimit</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>ldmParams</name><operator>.</operator><name>enableLdm</name></name> <operator>==</operator> <name>ZSTD_ps_enable</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>ZSTD_window_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ldmState</name><operator>.</operator><name>window</name></name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <comment type="block">/* forceNonContiguous */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>frame</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* overflow check and correction for block mode */</comment>
        <expr_stmt><expr><call><name>ZSTD_overflowCorrectIfNeeded</name><argument_list>(
            <argument><expr><name>ms</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name></name></expr></argument>,
            <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>(</operator><name>BYTE</name> <specifier>const</specifier><operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressContinue_internal (blockSize=%u)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>cctx</name><operator>-&gt;</operator><name>blockSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>cSize</name> <init>= <expr><ternary><condition><expr><name>frame</name></expr> ?</condition><then>
                             <expr><call><name>ZSTD_compress_frameChunk</name> <argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>lastFrameChunk</name></expr></argument>)</argument_list></call></expr> </then><else>:
                             <expr><call><name>ZSTD_compressBlock_internal</name> <argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* frame */</comment>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>frame</name></expr> ?</condition><then> <expr><literal type="string">"ZSTD_compress_frameChunk failed"</literal></expr> </then><else>: <expr><literal type="string">"ZSTD_compressBlock_internal failed"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>consumedSrcSize</name></name> <operator>+=</operator> <name>srcSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>producedCSize</name></name> <operator>+=</operator> <operator>(</operator><name>cSize</name> <operator>+</operator> <name>fhSize</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>fParams</name><operator>.</operator><name>contentSizeFlag</name></name> <operator>&amp;&amp;</operator> <name><name>cctx</name><operator>-&gt;</operator><name>pledgedSrcSizePlusOne</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>pledgedSrcSizePlusOne</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* control src size */</comment>
            <expr_stmt><expr><call><name>ZSTD_STATIC_ASSERT</name><argument_list>(<argument><expr><name>ZSTD_CONTENTSIZE_UNKNOWN</name> <operator>==</operator> <operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(
                <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>consumedSrcSize</name></name><operator>+</operator><literal type="number">1</literal> <operator>&gt;</operator> <name><name>cctx</name><operator>-&gt;</operator><name>pledgedSrcSizePlusOne</name></name></expr></argument>,
                <argument><expr><name>srcSize_wrong</name></expr></argument>,
                <argument><expr><literal type="string">"error : pledgedSrcSize = %u, while realSrcSize &gt;= %u"</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>cctx</name><operator>-&gt;</operator><name>pledgedSrcSizePlusOne</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>cctx</name><operator>-&gt;</operator><name>consumedSrcSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>cSize</name> <operator>+</operator> <name>fhSize</name></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressContinue</name> <parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>,
                              <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressContinue (srcSize=%u)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>ZSTD_compressContinue_internal</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> <comment type="block">/* frame mode */</comment>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* last chunk */</comment>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>size_t</name></type> <name>ZSTD_getBlockSize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_compressionParameters</name> <specifier>const</specifier></type> <name>cParams</name> <init>= <expr><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>cParams</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ZSTD_checkCParams</name><argument_list>(<argument><expr><name>cParams</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>MIN</name> <argument_list>(<argument><expr><name>ZSTD_BLOCKSIZE_MAX</name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>cParams</name><operator>.</operator><name>windowLog</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressBlock</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressBlock: srcSize = %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content> <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>blockSizeMax</name> <init>= <expr><call><name>ZSTD_getBlockSize</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>srcSize</name> <operator>&gt;</operator> <name>blockSizeMax</name></expr></argument>, <argument><expr><name>srcSize_wrong</name></expr></argument>, <argument><expr><literal type="string">"input is larger than a block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block>

    <return>return <expr><call><name>ZSTD_compressContinue_internal</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* frame mode */</comment>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* last chunk */</comment>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! ZSTD_loadDictionaryContent() :
 *  @return : 0, or an error code
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_loadDictionaryContent</name><parameter_list>(<parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>,
                                         <parameter><decl><type><name>ldmState_t</name><modifier>*</modifier></type> <name>ls</name></decl></parameter>,
                                         <parameter><decl><type><name>ZSTD_cwksp</name><modifier>*</modifier></type> <name>ws</name></decl></parameter>,
                                         <parameter><decl><type><name>ZSTD_CCtx_params</name> <specifier>const</specifier><modifier>*</modifier></type> <name>params</name></decl></parameter>,
                                         <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                                         <parameter><decl><type><name>ZSTD_dictTableLoadMethod_e</name></type> <name>dtlm</name></decl></parameter>,
                                         <parameter><decl><type><name>ZSTD_tableFillPurpose_e</name></type> <name>tfp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator> <name>src</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name> <init>= <expr><name>ip</name> <operator>+</operator> <name>srcSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>loadLdmDict</name> <init>= <expr><name><name>params</name><operator>-&gt;</operator><name>ldmParams</name><operator>.</operator><name>enableLdm</name></name> <operator>==</operator> <name>ZSTD_ps_enable</name> <operator>&amp;&amp;</operator> <name>ls</name> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Assert that the ms params match the params we're being given */</comment>
    <expr_stmt><expr><call><name>ZSTD_assertEqualCParams</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>cParams</name></name></expr></argument>, <argument><expr><name><name>ms</name><operator>-&gt;</operator><name>cParams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <block>{<block_content>   <comment type="block">/* Ensure large dictionaries can't cause index overflow */</comment>

        <comment type="block">/* Allow the dictionary to set indices up to exactly ZSTD_CURRENT_MAX.
         * Dictionaries right at the edge will immediately trigger overflow
         * correction, but I don't want to insert extra constraints here.
         */</comment>
        <decl_stmt><decl><type><name>U32</name></type> <name>maxDictSize</name> <init>= <expr><name>ZSTD_CURRENT_MAX</name> <operator>-</operator> <name>ZSTD_WINDOW_START_INDEX</name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>CDictTaggedIndices</name> <init>= <expr><call><name>ZSTD_CDictIndicesAreTagged</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>params</name><operator>-&gt;</operator><name>cParams</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>CDictTaggedIndices</name> <operator>&amp;&amp;</operator> <name>tfp</name> <operator>==</operator> <name>ZSTD_tfp_forCDict</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Some dictionary matchfinders in zstd use "short cache",
             * which treats the lower ZSTD_SHORT_CACHE_TAG_BITS of each
             * CDict hashtable entry as a tag rather than as part of an index.
             * When short cache is used, we need to truncate the dictionary
             * so that its indices don't overlap with the tag. */</comment>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>shortCacheMaxDictSize</name> <init>= <expr><operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">32</literal> <operator>-</operator> <name>ZSTD_SHORT_CACHE_TAG_BITS</name><operator>)</operator><operator>)</operator> <operator>-</operator> <name>ZSTD_WINDOW_START_INDEX</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>maxDictSize</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>maxDictSize</name></expr></argument>, <argument><expr><name>shortCacheMaxDictSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>loadLdmDict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* If the dictionary is too large, only load the suffix of the dictionary. */</comment>
        <if_stmt><if>if <condition>(<expr><name>srcSize</name> <operator>&gt;</operator> <name>maxDictSize</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>ip</name> <operator>=</operator> <name>iend</name> <operator>-</operator> <name>maxDictSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>src</name> <operator>=</operator> <name>ip</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>srcSize</name> <operator>=</operator> <name>maxDictSize</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>   </block_content>}</block>

    <if_stmt><if>if <condition>(<expr><name>srcSize</name> <operator>&gt;</operator> <name>ZSTD_CHUNKSIZE_MAX</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* We must have cleared our windows when our source is this large. */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>ZSTD_window_isEmpty</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>window</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>loadLdmDict</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>ZSTD_window_isEmpty</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>window</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_loadDictionaryContent(): useRowMatchFinder=%d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>params</name><operator>-&gt;</operator><name>useRowMatchFinder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_window_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ms</name><operator>-&gt;</operator><name>window</name></name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <comment type="block">/* forceNonContiguous */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>loadedDictEnd</name></name> <operator>=</operator> <ternary><condition><expr><name><name>params</name><operator>-&gt;</operator><name>forceWindow</name></name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>iend</name> <operator>-</operator> <name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>forceNonContiguous</name></name> <operator>=</operator> <name><name>params</name><operator>-&gt;</operator><name>deterministicRefPrefix</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>loadLdmDict</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>ZSTD_window_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>window</name></name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <comment type="block">/* forceNonContiguous */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>loadedDictEnd</name></name> <operator>=</operator> <ternary><condition><expr><name><name>params</name><operator>-&gt;</operator><name>forceWindow</name></name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>iend</name> <operator>-</operator> <name><name>ls</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>srcSize</name> <operator>&lt;=</operator> <name>HASH_READ_SIZE</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>ZSTD_overflowCorrectIfNeeded</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>ws</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>loadLdmDict</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ZSTD_ldm_fillHashTable</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>params</name><operator>-&gt;</operator><name>ldmParams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <switch>switch<condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>strategy</name></name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>ZSTD_fast</name></expr>:</case>
        <expr_stmt><expr><call><name>ZSTD_fillHashTable</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>dtlm</name></expr></argument>, <argument><expr><name>tfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>ZSTD_dfast</name></expr>:</case>
        <expr_stmt><expr><call><name>ZSTD_fillDoubleHashTable</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>dtlm</name></expr></argument>, <argument><expr><name>tfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

    <case>case <expr><name>ZSTD_greedy</name></expr>:</case>
    <case>case <expr><name>ZSTD_lazy</name></expr>:</case>
    <case>case <expr><name>ZSTD_lazy2</name></expr>:</case>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>srcSize</name> <operator>&gt;=</operator> <name>HASH_READ_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>ms</name><operator>-&gt;</operator><name>dedicatedDictSearch</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>chainTable</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ZSTD_dedicatedDictSearch_lazy_loadDictionary</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>iend</name><operator>-</operator><name>HASH_READ_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>useRowMatchFinder</name></name> <operator>!=</operator> <name>ZSTD_ps_auto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>useRowMatchFinder</name></name> <operator>==</operator> <name>ZSTD_ps_enable</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>tagTableSize</name> <init>= <expr><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>params</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>hashLog</name></name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>U16</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>tagTable</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tagTableSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ZSTD_row_update</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>iend</name><operator>-</operator><name>HASH_READ_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"Using row-based hash table for lazy dict"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>ZSTD_insertAndFindFirstIndex</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>iend</name><operator>-</operator><name>HASH_READ_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"Using chain-based hash table for lazy dict"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>

    <case>case <expr><name>ZSTD_btlazy2</name></expr>:</case>   <comment type="block">/* we want the dictionary table fully sorted */</comment>
    <case>case <expr><name>ZSTD_btopt</name></expr>:</case>
    <case>case <expr><name>ZSTD_btultra</name></expr>:</case>
    <case>case <expr><name>ZSTD_btultra2</name></expr>:</case>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>srcSize</name> <operator>&gt;=</operator> <name>HASH_READ_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_updateTree</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>iend</name><operator>-</operator><name>HASH_READ_SIZE</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

    <default>default:</default>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* not possible : not a valid strategy id */</comment>
    </block_content>}</block></switch>

    <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>nextToUpdate</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>iend</name> <operator>-</operator> <name><name>ms</name><operator>-&gt;</operator><name>window</name><operator>.</operator><name>base</name></name><operator>)</operator></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Dictionaries that assign zero probability to symbols that show up causes problems
 * when FSE encoding. Mark dictionaries with zero probability symbols as FSE_repeat_check
 * and only dictionaries with 100% valid symbols can be assumed valid.
 */</comment>
<function><type><specifier>static</specifier> <name>FSE_repeat</name></type> <name>ZSTD_dictNCountRepeat</name><parameter_list>(<parameter><decl><type><name>short</name><modifier>*</modifier></type> <name>normalizedCounter</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>dictMaxSymbolValue</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>maxSymbolValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name></type> <name>s</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>dictMaxSymbolValue</name> <operator>&lt;</operator> <name>maxSymbolValue</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>FSE_repeat_check</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>s</name> <operator>&lt;=</operator> <name>maxSymbolValue</name></expr>;</condition> <incr><expr><operator>++</operator><name>s</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>normalizedCounter</name><index>[<expr><name>s</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>FSE_repeat_check</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>FSE_repeat_valid</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_loadCEntropy</name><parameter_list>(<parameter><decl><type><name>ZSTD_compressedBlockState_t</name><modifier>*</modifier></type> <name>bs</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workspace</name></decl></parameter>,
                         <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>short</name></type> <name><name>offcodeNCount</name><index>[<expr><name>MaxOff</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>offcodeMaxValue</name> <init>= <expr><name>MaxOff</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>dictPtr</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>dict</name></expr></init></decl>;</decl_stmt>    <comment type="block">/* skip magic num and dict ID */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictEnd</name> <init>= <expr><name>dictPtr</name> <operator>+</operator> <name>dictSize</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>dictPtr</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bs</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>huf</name><operator>.</operator><name>repeatMode</name></name> <operator>=</operator> <name>HUF_repeat_check</name></expr>;</expr_stmt>

    <block>{<block_content>   <decl_stmt><decl><type><name>unsigned</name></type> <name>maxSymbolValue</name> <init>= <expr><literal type="number">255</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name></type> <name>hasZeroWeights</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>hufHeaderSize</name> <init>= <expr><call><name>HUF_readCTable</name><argument_list>(<argument><expr><operator>(</operator><name>HUF_CElt</name><operator>*</operator><operator>)</operator><name><name>bs</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>huf</name><operator>.</operator><name>CTable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>maxSymbolValue</name></expr></argument>, <argument><expr><name>dictPtr</name></expr></argument>,
            <argument><expr><name>dictEnd</name><operator>-</operator><name>dictPtr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hasZeroWeights</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* We only set the loaded table as valid if it contains all non-zero
         * weights. Otherwise, we set it to check */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>hasZeroWeights</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>bs</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>huf</name><operator>.</operator><name>repeatMode</name></name> <operator>=</operator> <name>HUF_repeat_valid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><call><name>HUF_isError</name><argument_list>(<argument><expr><name>hufHeaderSize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dictionary_corrupted</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>maxSymbolValue</name> <operator>&lt;</operator> <literal type="number">255</literal></expr></argument>, <argument><expr><name>dictionary_corrupted</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dictPtr</name> <operator>+=</operator> <name>hufHeaderSize</name></expr>;</expr_stmt>
    </block_content>}</block>

    <block>{<block_content>   <decl_stmt><decl><type><name>unsigned</name></type> <name>offcodeLog</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>offcodeHeaderSize</name> <init>= <expr><call><name>FSE_readNCount</name><argument_list>(<argument><expr><name>offcodeNCount</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offcodeMaxValue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offcodeLog</name></expr></argument>, <argument><expr><name>dictPtr</name></expr></argument>, <argument><expr><name>dictEnd</name><operator>-</operator><name>dictPtr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><call><name>FSE_isError</name><argument_list>(<argument><expr><name>offcodeHeaderSize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dictionary_corrupted</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>offcodeLog</name> <operator>&gt;</operator> <name>OffFSELog</name></expr></argument>, <argument><expr><name>dictionary_corrupted</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* fill all offset symbols to avoid garbage at end of table */</comment>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><call><name>FSE_isError</name><argument_list>(<argument><expr><call><name>FSE_buildCTable_wksp</name><argument_list>(
                <argument><expr><name><name>bs</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>fse</name><operator>.</operator><name>offcodeCTable</name></name></expr></argument>,
                <argument><expr><name>offcodeNCount</name></expr></argument>, <argument><expr><name>MaxOff</name></expr></argument>, <argument><expr><name>offcodeLog</name></expr></argument>,
                <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>HUF_WORKSPACE_SIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><name>dictionary_corrupted</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Defer checking offcodeMaxValue because we need to know the size of the dictionary content */</comment>
        <expr_stmt><expr><name>dictPtr</name> <operator>+=</operator> <name>offcodeHeaderSize</name></expr>;</expr_stmt>
    </block_content>}</block>

    <block>{<block_content>   <decl_stmt><decl><type><name>short</name></type> <name><name>matchlengthNCount</name><index>[<expr><name>MaxML</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name></type> <name>matchlengthMaxValue</name> <init>= <expr><name>MaxML</name></expr></init></decl>, <decl><type ref="prev"/><name>matchlengthLog</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>matchlengthHeaderSize</name> <init>= <expr><call><name>FSE_readNCount</name><argument_list>(<argument><expr><name>matchlengthNCount</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>matchlengthMaxValue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>matchlengthLog</name></expr></argument>, <argument><expr><name>dictPtr</name></expr></argument>, <argument><expr><name>dictEnd</name><operator>-</operator><name>dictPtr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><call><name>FSE_isError</name><argument_list>(<argument><expr><name>matchlengthHeaderSize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dictionary_corrupted</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>matchlengthLog</name> <operator>&gt;</operator> <name>MLFSELog</name></expr></argument>, <argument><expr><name>dictionary_corrupted</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><call><name>FSE_isError</name><argument_list>(<argument><expr><call><name>FSE_buildCTable_wksp</name><argument_list>(
                <argument><expr><name><name>bs</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>fse</name><operator>.</operator><name>matchlengthCTable</name></name></expr></argument>,
                <argument><expr><name>matchlengthNCount</name></expr></argument>, <argument><expr><name>matchlengthMaxValue</name></expr></argument>, <argument><expr><name>matchlengthLog</name></expr></argument>,
                <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>HUF_WORKSPACE_SIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><name>dictionary_corrupted</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bs</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>fse</name><operator>.</operator><name>matchlength_repeatMode</name></name> <operator>=</operator> <call><name>ZSTD_dictNCountRepeat</name><argument_list>(<argument><expr><name>matchlengthNCount</name></expr></argument>, <argument><expr><name>matchlengthMaxValue</name></expr></argument>, <argument><expr><name>MaxML</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dictPtr</name> <operator>+=</operator> <name>matchlengthHeaderSize</name></expr>;</expr_stmt>
    </block_content>}</block>

    <block>{<block_content>   <decl_stmt><decl><type><name>short</name></type> <name><name>litlengthNCount</name><index>[<expr><name>MaxLL</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name></type> <name>litlengthMaxValue</name> <init>= <expr><name>MaxLL</name></expr></init></decl>, <decl><type ref="prev"/><name>litlengthLog</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>litlengthHeaderSize</name> <init>= <expr><call><name>FSE_readNCount</name><argument_list>(<argument><expr><name>litlengthNCount</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>litlengthMaxValue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>litlengthLog</name></expr></argument>, <argument><expr><name>dictPtr</name></expr></argument>, <argument><expr><name>dictEnd</name><operator>-</operator><name>dictPtr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><call><name>FSE_isError</name><argument_list>(<argument><expr><name>litlengthHeaderSize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dictionary_corrupted</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>litlengthLog</name> <operator>&gt;</operator> <name>LLFSELog</name></expr></argument>, <argument><expr><name>dictionary_corrupted</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><call><name>FSE_isError</name><argument_list>(<argument><expr><call><name>FSE_buildCTable_wksp</name><argument_list>(
                <argument><expr><name><name>bs</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>fse</name><operator>.</operator><name>litlengthCTable</name></name></expr></argument>,
                <argument><expr><name>litlengthNCount</name></expr></argument>, <argument><expr><name>litlengthMaxValue</name></expr></argument>, <argument><expr><name>litlengthLog</name></expr></argument>,
                <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>HUF_WORKSPACE_SIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><name>dictionary_corrupted</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bs</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>fse</name><operator>.</operator><name>litlength_repeatMode</name></name> <operator>=</operator> <call><name>ZSTD_dictNCountRepeat</name><argument_list>(<argument><expr><name>litlengthNCount</name></expr></argument>, <argument><expr><name>litlengthMaxValue</name></expr></argument>, <argument><expr><name>MaxLL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dictPtr</name> <operator>+=</operator> <name>litlengthHeaderSize</name></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>dictPtr</name><operator>+</operator><literal type="number">12</literal> <operator>&gt;</operator> <name>dictEnd</name></expr></argument>, <argument><expr><name>dictionary_corrupted</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bs</name><operator>-&gt;</operator><name>rep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>MEM_readLE32</name><argument_list>(<argument><expr><name>dictPtr</name><operator>+</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bs</name><operator>-&gt;</operator><name>rep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>MEM_readLE32</name><argument_list>(<argument><expr><name>dictPtr</name><operator>+</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bs</name><operator>-&gt;</operator><name>rep</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>MEM_readLE32</name><argument_list>(<argument><expr><name>dictPtr</name><operator>+</operator><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dictPtr</name> <operator>+=</operator> <literal type="number">12</literal></expr>;</expr_stmt>

    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>dictContentSize</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>dictEnd</name> <operator>-</operator> <name>dictPtr</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name></type> <name>offcodeMax</name> <init>= <expr><name>MaxOff</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>dictContentSize</name> <operator>&lt;=</operator> <operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>-</operator> <literal type="number">128</literal> <name>KB</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>maxOffset</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><name>dictContentSize</name> <operator>+</operator> <literal type="number">128</literal> <name>KB</name></expr></init></decl>;</decl_stmt> <comment type="block">/* The maximum offset that must be supported */</comment>
            <expr_stmt><expr><name>offcodeMax</name> <operator>=</operator> <call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><name>maxOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Calculate minimum offset code required to represent maxOffset */</comment>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* All offset values &lt;= dictContentSize + 128 KB must be representable for a valid table */</comment>
        <expr_stmt><expr><name><name>bs</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>fse</name><operator>.</operator><name>offcode_repeatMode</name></name> <operator>=</operator> <call><name>ZSTD_dictNCountRepeat</name><argument_list>(<argument><expr><name>offcodeNCount</name></expr></argument>, <argument><expr><name>offcodeMaxValue</name></expr></argument>, <argument><expr><call><name>MIN</name><argument_list>(<argument><expr><name>offcodeMax</name></expr></argument>, <argument><expr><name>MaxOff</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* All repCodes must be &lt;= dictContentSize and != 0 */</comment>
        <block>{<block_content>   <decl_stmt><decl><type><name>U32</name></type> <name>u</name></decl>;</decl_stmt>
            <for>for <control>(<init><expr><name>u</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>u</name><operator>&lt;</operator><literal type="number">3</literal></expr>;</condition> <incr><expr><name>u</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>bs</name><operator>-&gt;</operator><name>rep</name><index>[<expr><name>u</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>dictionary_corrupted</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>bs</name><operator>-&gt;</operator><name>rep</name><index>[<expr><name>u</name></expr>]</index></name> <operator>&gt;</operator> <name>dictContentSize</name></expr></argument>, <argument><expr><name>dictionary_corrupted</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>   </block_content>}</block>   </block_content>}</block>

    <return>return <expr><name>dictPtr</name> <operator>-</operator> <operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>dict</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Dictionary format :
 * See :
 * https://github.com/facebook/zstd/blob/release/doc/zstd_compression_format.md#dictionary-format
 */</comment>
<comment type="block" format="doxygen">/*! ZSTD_loadZstdDictionary() :
 * @return : dictID, or an error code
 *  assumptions : magic number supposed already checked
 *                dictSize supposed &gt;= 8
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_loadZstdDictionary</name><parameter_list>(<parameter><decl><type><name>ZSTD_compressedBlockState_t</name><modifier>*</modifier></type> <name>bs</name></decl></parameter>,
                                      <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>,
                                      <parameter><decl><type><name>ZSTD_cwksp</name><modifier>*</modifier></type> <name>ws</name></decl></parameter>,
                                      <parameter><decl><type><name>ZSTD_CCtx_params</name> <specifier>const</specifier><modifier>*</modifier></type> <name>params</name></decl></parameter>,
                                      <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>,
                                      <parameter><decl><type><name>ZSTD_dictTableLoadMethod_e</name></type> <name>dtlm</name></decl></parameter>,
                                      <parameter><decl><type><name>ZSTD_tableFillPurpose_e</name></type> <name>tfp</name></decl></parameter>,
                                      <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workspace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>dictPtr</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>dict</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictEnd</name> <init>= <expr><name>dictPtr</name> <operator>+</operator> <name>dictSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>dictID</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>eSize</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ZSTD_STATIC_ASSERT</name><argument_list>(<argument><expr><name>HUF_WORKSPACE_SIZE</name> <operator>&gt;=</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><call><name>MAX</name><argument_list>(<argument><expr><name>MLFSELog</name></expr></argument>,<argument><expr><name>LLFSELog</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dictSize</name> <operator>&gt;=</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>MEM_readLE32</name><argument_list>(<argument><expr><name>dictPtr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ZSTD_MAGIC_DICTIONARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>dictID</name> <operator>=</operator> <ternary><condition><expr><name><name>params</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>noDictIDFlag</name></name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>:  <expr><call><name>MEM_readLE32</name><argument_list>(<argument><expr><name>dictPtr</name> <operator>+</operator> <literal type="number">4</literal></expr></argument> <comment type="block">/* skip magic number */</comment> )</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>eSize</name> <operator>=</operator> <call><name>ZSTD_loadCEntropy</name><argument_list>(<argument><expr><name>bs</name></expr></argument>, <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>eSize</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_loadCEntropy failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dictPtr</name> <operator>+=</operator> <name>eSize</name></expr>;</expr_stmt>

    <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>dictContentSize</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>dictEnd</name> <operator>-</operator> <name>dictPtr</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_loadDictionaryContent</name><argument_list>(
            <argument><expr><name>ms</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ws</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>dictPtr</name></expr></argument>, <argument><expr><name>dictContentSize</name></expr></argument>, <argument><expr><name>dtlm</name></expr></argument>, <argument><expr><name>tfp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <return>return <expr><name>dictID</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** ZSTD_compress_insertDictionary() :
*   @return : dictID, or an error code */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>ZSTD_compress_insertDictionary</name><parameter_list>(<parameter><decl><type><name>ZSTD_compressedBlockState_t</name><modifier>*</modifier></type> <name>bs</name></decl></parameter>,
                               <parameter><decl><type><name>ZSTD_matchState_t</name><modifier>*</modifier></type> <name>ms</name></decl></parameter>,
                               <parameter><decl><type><name>ldmState_t</name><modifier>*</modifier></type> <name>ls</name></decl></parameter>,
                               <parameter><decl><type><name>ZSTD_cwksp</name><modifier>*</modifier></type> <name>ws</name></decl></parameter>,
                         <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>params</name></decl></parameter>,
                         <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>,
                               <parameter><decl><type><name>ZSTD_dictContentType_e</name></type> <name>dictContentType</name></decl></parameter>,
                               <parameter><decl><type><name>ZSTD_dictTableLoadMethod_e</name></type> <name>dtlm</name></decl></parameter>,
                               <parameter><decl><type><name>ZSTD_tableFillPurpose_e</name></type> <name>tfp</name></decl></parameter>,
                               <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workspace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compress_insertDictionary (dictSize=%u)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>dictSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>dict</name><operator>==</operator><name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>dictSize</name><operator>&lt;</operator><literal type="number">8</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>dictContentType</name> <operator>==</operator> <name>ZSTD_dct_fullDict</name></expr></argument>, <argument><expr><name>dictionary_wrong</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ZSTD_reset_compressedBlockState</name><argument_list>(<argument><expr><name>bs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* dict restricted modes */</comment>
    <if_stmt><if>if <condition>(<expr><name>dictContentType</name> <operator>==</operator> <name>ZSTD_dct_rawContent</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>ZSTD_loadDictionaryContent</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>ls</name></expr></argument>, <argument><expr><name>ws</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>, <argument><expr><name>dtlm</name></expr></argument>, <argument><expr><name>tfp</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>MEM_readLE32</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ZSTD_MAGIC_DICTIONARY</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>dictContentType</name> <operator>==</operator> <name>ZSTD_dct_auto</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"raw content dictionary detected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name>ZSTD_loadDictionaryContent</name><argument_list>(
                <argument><expr><name>ms</name></expr></argument>, <argument><expr><name>ls</name></expr></argument>, <argument><expr><name>ws</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>, <argument><expr><name>dtlm</name></expr></argument>, <argument><expr><name>tfp</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>dictContentType</name> <operator>==</operator> <name>ZSTD_dct_fullDict</name></expr></argument>, <argument><expr><name>dictionary_wrong</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* impossible */</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* dict as full zstd dictionary */</comment>
    <return>return <expr><call><name>ZSTD_loadZstdDictionary</name><argument_list>(
        <argument><expr><name>bs</name></expr></argument>, <argument><expr><name>ms</name></expr></argument>, <argument><expr><name>ws</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>, <argument><expr><name>dtlm</name></expr></argument>, <argument><expr><name>tfp</name></expr></argument>, <argument><expr><name>workspace</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZSTD_USE_CDICT_PARAMS_SRCSIZE_CUTOFF</name></cpp:macro> <cpp:value>(128 KB)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZSTD_USE_CDICT_PARAMS_DICTSIZE_MULTIPLIER</name></cpp:macro> <cpp:value>(6ULL)</cpp:value></cpp:define>

<comment type="block" format="doxygen">/*! ZSTD_compressBegin_internal() :
 * Assumption : either @dict OR @cdict (or none) is non-NULL, never both
 * @return : 0, or an error code */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_compressBegin_internal</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>,
                                    <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>,
                                    <parameter><decl><type><name>ZSTD_dictContentType_e</name></type> <name>dictContentType</name></decl></parameter>,
                                    <parameter><decl><type><name>ZSTD_dictTableLoadMethod_e</name></type> <name>dtlm</name></decl></parameter>,
                                    <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CDict</name><modifier>*</modifier></type> <name>cdict</name></decl></parameter>,
                                    <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>params</name></decl></parameter>, <parameter><decl><type><name>U64</name></type> <name>pledgedSrcSize</name></decl></parameter>,
                                    <parameter><decl><type><name>ZSTD_buffered_policy_e</name></type> <name>zbuff</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>dictContentSize</name> <init>= <expr><ternary><condition><expr><name>cdict</name></expr> ?</condition><then> <expr><name><name>cdict</name><operator>-&gt;</operator><name>dictContentSize</name></name></expr> </then><else>: <expr><name>dictSize</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ZSTD_TRACE</name></expr></cpp:if>
    <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>traceCtx</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>ZSTD_trace_compress_begin</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>ZSTD_trace_compress_begin</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressBegin_internal: wlog=%u"</literal></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>windowLog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* params are supposed to be fully validated at this point */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ZSTD_isError</name><argument_list>(<argument><expr><call><name>ZSTD_checkCParams</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>cParams</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><operator>(</operator><name>dict</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>cdict</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* either dict or cdict, not both */</comment>
    <if_stmt><if>if <condition>( <expr><operator>(</operator><name>cdict</name><operator>)</operator>
      <operator>&amp;&amp;</operator> <operator>(</operator><name><name>cdict</name><operator>-&gt;</operator><name>dictContentSize</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator>
      <operator>&amp;&amp;</operator> <operator>(</operator> <name>pledgedSrcSize</name> <operator>&lt;</operator> <name>ZSTD_USE_CDICT_PARAMS_SRCSIZE_CUTOFF</name>
        <operator>||</operator> <name>pledgedSrcSize</name> <operator>&lt;</operator> <name><name>cdict</name><operator>-&gt;</operator><name>dictContentSize</name></name> <operator>*</operator> <name>ZSTD_USE_CDICT_PARAMS_DICTSIZE_MULTIPLIER</name>
        <operator>||</operator> <name>pledgedSrcSize</name> <operator>==</operator> <name>ZSTD_CONTENTSIZE_UNKNOWN</name>
        <operator>||</operator> <name><name>cdict</name><operator>-&gt;</operator><name>compressionLevel</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator>
      <operator>&amp;&amp;</operator> <operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>attachDictPref</name></name> <operator>!=</operator> <name>ZSTD_dictForceLoad</name><operator>)</operator></expr> )</condition> <block>{<block_content>
        <return>return <expr><call><name>ZSTD_resetCCtx_usingCDict</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>cdict</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>pledgedSrcSize</name></expr></argument>, <argument><expr><name>zbuff</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_resetCCtx_internal</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>pledgedSrcSize</name></expr></argument>,
                                     <argument><expr><name>dictContentSize</name></expr></argument>,
                                     <argument><expr><name>ZSTDcrp_makeClean</name></expr></argument>, <argument><expr><name>zbuff</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>dictID</name> <init>= <expr><ternary><condition><expr><name>cdict</name></expr> ?</condition><then>
                <expr><call><name>ZSTD_compress_insertDictionary</name><argument_list>(
                        <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name></name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ldmState</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name></name></expr></argument>, <argument><expr><name><name>cdict</name><operator>-&gt;</operator><name>dictContent</name></name></expr></argument>,
                        <argument><expr><name><name>cdict</name><operator>-&gt;</operator><name>dictContentSize</name></name></expr></argument>, <argument><expr><name><name>cdict</name><operator>-&gt;</operator><name>dictContentType</name></name></expr></argument>, <argument><expr><name>dtlm</name></expr></argument>,
                        <argument><expr><name>ZSTD_tfp_forCCtx</name></expr></argument>, <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>entropyWorkspace</name></name></expr></argument>)</argument_list></call></expr>
              </then><else>: <expr><call><name>ZSTD_compress_insertDictionary</name><argument_list>(
                        <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>matchState</name></name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ldmState</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name></name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>,
                        <argument><expr><name>dictContentType</name></expr></argument>, <argument><expr><name>dtlm</name></expr></argument>, <argument><expr><name>ZSTD_tfp_forCCtx</name></expr></argument>, <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>entropyWorkspace</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>dictID</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_compress_insertDictionary failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dictID</name> <operator>&lt;=</operator> <name>UINT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>dictID</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>dictID</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>dictContentSize</name></name> <operator>=</operator> <name>dictContentSize</name></expr>;</expr_stmt>
    </block_content>}</block>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressBegin_advanced_internal</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>,
                                    <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>,
                                    <parameter><decl><type><name>ZSTD_dictContentType_e</name></type> <name>dictContentType</name></decl></parameter>,
                                    <parameter><decl><type><name>ZSTD_dictTableLoadMethod_e</name></type> <name>dtlm</name></decl></parameter>,
                                    <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CDict</name><modifier>*</modifier></type> <name>cdict</name></decl></parameter>,
                                    <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>params</name></decl></parameter>,
                                    <parameter><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>pledgedSrcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressBegin_advanced_internal: wlog=%u"</literal></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>cParams</name><operator>.</operator><name>windowLog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* compression parameters verification and optimization */</comment>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_checkCParams</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>cParams</name></name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>ZSTD_compressBegin_internal</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>,
                                       <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>, <argument><expr><name>dictContentType</name></expr></argument>, <argument><expr><name>dtlm</name></expr></argument>,
                                       <argument><expr><name>cdict</name></expr></argument>,
                                       <argument><expr><name>params</name></expr></argument>, <argument><expr><name>pledgedSrcSize</name></expr></argument>,
                                       <argument><expr><name>ZSTDb_not_buffered</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! ZSTD_compressBegin_advanced() :
*   @return : 0, or an error code */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_compressBegin_advanced</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>,
                             <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>,
                                   <parameter><decl><type><name>ZSTD_parameters</name></type> <name>params</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>pledgedSrcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_CCtx_params</name></type> <name>cctxParams</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ZSTD_CCtxParams_init_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cctxParams</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><name>ZSTD_NO_CLEVEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>ZSTD_compressBegin_advanced_internal</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>,
                                            <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>, <argument><expr><name>ZSTD_dct_auto</name></expr></argument>, <argument><expr><name>ZSTD_dtlm_fast</name></expr></argument>,
                                            <argument><expr><name>NULL</name></expr></argument> <comment type="block">/*cdict*/</comment>,
                                            <argument><expr><operator>&amp;</operator><name>cctxParams</name></expr></argument>, <argument><expr><name>pledgedSrcSize</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type>
<name>ZSTD_compressBegin_usingDict</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compressionLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_CCtx_params</name></type> <name>cctxParams</name></decl>;</decl_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>ZSTD_parameters</name> <specifier>const</specifier></type> <name>params</name> <init>= <expr><call><name>ZSTD_getParams_internal</name><argument_list>(<argument><expr><name>compressionLevel</name></expr></argument>, <argument><expr><name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>, <argument><expr><name>ZSTD_cpm_noAttachDict</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ZSTD_CCtxParams_init_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cctxParams</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>compressionLevel</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>ZSTD_CLEVEL_DEFAULT</name></expr> </then><else>: <expr><name>compressionLevel</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressBegin_usingDict (dictSize=%u)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>dictSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>ZSTD_compressBegin_internal</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>, <argument><expr><name>ZSTD_dct_auto</name></expr></argument>, <argument><expr><name>ZSTD_dtlm_fast</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                       <argument><expr><operator>&amp;</operator><name>cctxParams</name></expr></argument>, <argument><expr><name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr></argument>, <argument><expr><name>ZSTDb_not_buffered</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressBegin</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compressionLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBegin_usingDict</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>compressionLevel</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*! ZSTD_writeEpilogue() :
*   Ends a frame.
*   @return : nb of bytes written into dst (or an error code) */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_writeEpilogue</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ostart</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><name>ostart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>fhSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_writeEpilogue"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>stage</name></name> <operator>==</operator> <name>ZSTDcs_created</name></expr></argument>, <argument><expr><name>stage_wrong</name></expr></argument>, <argument><expr><literal type="string">"init missing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* special case : empty frame */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>stage</name></name> <operator>==</operator> <name>ZSTDcs_init</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>fhSize</name> <operator>=</operator> <call><name>ZSTD_writeFrameHeader</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>fhSize</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_writeFrameHeader failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dstCapacity</name> <operator>-=</operator> <name>fhSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>fhSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>stage</name></name> <operator>=</operator> <name>ZSTDcs_ongoing</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>stage</name></name> <operator>!=</operator> <name>ZSTDcs_ending</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* write one last empty block, make it the "last" block */</comment>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>cBlockHeader24</name> <init>= <expr><literal type="number">1</literal> <comment type="block">/* last block */</comment> <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><name>bt_raw</name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">1</literal><operator>)</operator> <operator>+</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>dstCapacity</name><operator>&lt;</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">"no room for epilogue"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MEM_writeLE32</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>cBlockHeader24</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>ZSTD_blockHeaderSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dstCapacity</name> <operator>-=</operator> <name>ZSTD_blockHeaderSize</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>fParams</name><operator>.</operator><name>checksumFlag</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>checksum</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator> <call><name>XXH64_digest</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>xxhState</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>dstCapacity</name><operator>&lt;</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">"no room for checksum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_writeEpilogue: write checksum : %08X"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>checksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MEM_writeLE32</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>checksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>stage</name></name> <operator>=</operator> <name>ZSTDcs_created</name></expr>;</expr_stmt>  <comment type="block">/* return to "created but no init" status */</comment>
    <return>return <expr><name>op</name><operator>-</operator><name>ostart</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>ZSTD_CCtx_trace</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>extraCSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ZSTD_TRACE</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>traceCtx</name></name> <operator>&amp;&amp;</operator> <name>ZSTD_trace_compress_end</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>streaming</name> <init>= <expr><name><name>cctx</name><operator>-&gt;</operator><name>inBuffSize</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>cctx</name><operator>-&gt;</operator><name>outBuffSize</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>nbWorkers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ZSTD_Trace</name></type> <name>trace</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trace</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>trace</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>trace</name><operator>.</operator><name>version</name></name> <operator>=</operator> <name>ZSTD_VERSION_NUMBER</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>trace</name><operator>.</operator><name>streaming</name></name> <operator>=</operator> <name>streaming</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>trace</name><operator>.</operator><name>dictionaryID</name></name> <operator>=</operator> <name><name>cctx</name><operator>-&gt;</operator><name>dictID</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>trace</name><operator>.</operator><name>dictionarySize</name></name> <operator>=</operator> <name><name>cctx</name><operator>-&gt;</operator><name>dictContentSize</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>trace</name><operator>.</operator><name>uncompressedSize</name></name> <operator>=</operator> <name><name>cctx</name><operator>-&gt;</operator><name>consumedSrcSize</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>trace</name><operator>.</operator><name>compressedSize</name></name> <operator>=</operator> <name><name>cctx</name><operator>-&gt;</operator><name>producedCSize</name></name> <operator>+</operator> <name>extraCSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>trace</name><operator>.</operator><name>params</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>trace</name><operator>.</operator><name>cctx</name></name> <operator>=</operator> <name>cctx</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_trace_compress_end</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>traceCtx</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>trace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>traceCtx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>cctx</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>extraCSize</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressEnd</name> <parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>,
                         <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                   <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>endResult</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>cSize</name> <init>= <expr><call><name>ZSTD_compressContinue_internal</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>,
                                <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>,
                                <argument><expr><literal type="number">1</literal></expr></argument> <comment type="block">/* frame mode */</comment>, <argument><expr><literal type="number">1</literal></expr></argument> <comment type="block">/* last chunk */</comment>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressContinue_internal failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>endResult</name> <operator>=</operator> <call><name>ZSTD_writeEpilogue</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>dst</name> <operator>+</operator> <name>cSize</name></expr></argument>, <argument><expr><name>dstCapacity</name><operator>-</operator><name>cSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>endResult</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_writeEpilogue failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>fParams</name><operator>.</operator><name>contentSizeFlag</name></name> <operator>&amp;&amp;</operator> <name><name>cctx</name><operator>-&gt;</operator><name>pledgedSrcSizePlusOne</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>pledgedSrcSizePlusOne</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* control src size */</comment>
        <expr_stmt><expr><call><name>ZSTD_STATIC_ASSERT</name><argument_list>(<argument><expr><name>ZSTD_CONTENTSIZE_UNKNOWN</name> <operator>==</operator> <operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"end of frame : controlling src size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(
            <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>pledgedSrcSizePlusOne</name></name> <operator>!=</operator> <name><name>cctx</name><operator>-&gt;</operator><name>consumedSrcSize</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>,
            <argument><expr><name>srcSize_wrong</name></expr></argument>,
             <argument><expr><literal type="string">"error : pledgedSrcSize = %u, while realSrcSize = %u"</literal></expr></argument>,
            <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>cctx</name><operator>-&gt;</operator><name>pledgedSrcSizePlusOne</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>,
            <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>cctx</name><operator>-&gt;</operator><name>consumedSrcSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>ZSTD_CCtx_trace</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>endResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>cSize</name> <operator>+</operator> <name>endResult</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compress_advanced</name> <parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>,
                               <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                         <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                         <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>,<parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>,
                               <parameter><decl><type><name>ZSTD_parameters</name></type> <name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compress_advanced"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_checkCParams</name><argument_list>(<argument><expr><name><name>params</name><operator>.</operator><name>cParams</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_CCtxParams_init_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>simpleApiParams</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><name>ZSTD_NO_CLEVEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>ZSTD_compress_advanced_internal</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>,
                                           <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>,
                                           <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>,
                                           <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>,
                                           <argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>simpleApiParams</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Internal */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_compress_advanced_internal</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>,
        <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>,<parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compress_advanced_internal (srcSize:%u)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_compressBegin_internal</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>,
                         <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>, <argument><expr><name>ZSTD_dct_auto</name></expr></argument>, <argument><expr><name>ZSTD_dtlm_fast</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                         <argument><expr><name>params</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>ZSTDb_not_buffered</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>ZSTD_compressEnd</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compress_usingDict</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>,
                               <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                         <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                         <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>,
                               <parameter><decl><type><name>int</name></type> <name>compressionLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ZSTD_parameters</name> <specifier>const</specifier></type> <name>params</name> <init>= <expr><call><name>ZSTD_getParams_internal</name><argument_list>(<argument><expr><name>compressionLevel</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><ternary><condition><expr><name>dict</name></expr> ?</condition><then> <expr><name>dictSize</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>, <argument><expr><name>ZSTD_cpm_noAttachDict</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>params</name><operator>.</operator><name>fParams</name><operator>.</operator><name>contentSizeFlag</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_CCtxParams_init_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>simpleApiParams</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>compressionLevel</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>ZSTD_CLEVEL_DEFAULT</name></expr></then><else>: <expr><name>compressionLevel</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compress_usingDict (srcSize=%u)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>ZSTD_compress_advanced_internal</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>simpleApiParams</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressCCtx</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>,
                         <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                   <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                         <parameter><decl><type><name>int</name></type> <name>compressionLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressCCtx (srcSize=%u)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>cctx</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>ZSTD_compress_usingDict</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>compressionLevel</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compress</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
               <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                     <parameter><decl><type><name>int</name></type> <name>compressionLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>result</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ZSTD_COMPRESS_HEAPMODE</name></expr></cpp:if>
    <decl_stmt><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name> <init>= <expr><call><name>ZSTD_createCCtx</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><operator>!</operator><name>cctx</name></expr></argument>, <argument><expr><name>memory_allocation</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_createCCtx failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ZSTD_compressCCtx</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>compressionLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_freeCCtx</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>ZSTD_CCtx</name></type> <name>ctxBody</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ZSTD_initCCtx</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctxBody</name></expr></argument>, <argument><expr><name>ZSTD_defaultCMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ZSTD_compressCCtx</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctxBody</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>compressionLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_freeCCtxContent</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctxBody</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* can't free ctxBody itself, as it's on stack; free only heap content */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* =====  Dictionary API  ===== */</comment>

<comment type="block" format="doxygen">/*! ZSTD_estimateCDictSize_advanced() :
 *  Estimate amount of memory that will be needed to create a dictionary with following arguments */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_estimateCDictSize_advanced</name><parameter_list>(
        <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>, <parameter><decl><type><name>ZSTD_compressionParameters</name></type> <name>cParams</name></decl></parameter>,
        <parameter><decl><type><name>ZSTD_dictLoadMethod_e</name></type> <name>dictLoadMethod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"sizeof(ZSTD_CDict) : %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_CDict</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>ZSTD_cwksp_alloc_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_CDict</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call>
         <operator>+</operator> <call><name>ZSTD_cwksp_alloc_size</name><argument_list>(<argument><expr><name>HUF_WORKSPACE_SIZE</name></expr></argument>)</argument_list></call>
         <comment type="block">/* enableDedicatedDictSearch == 1 ensures that CDict estimation will not be too small
          * in case we are using DDS with row-hash. */</comment>
         <operator>+</operator> <call><name>ZSTD_sizeof_matchState</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cParams</name></expr></argument>, <argument><expr><call><name>ZSTD_resolveRowMatchFinderMode</name><argument_list>(<argument><expr><name>ZSTD_ps_auto</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cParams</name></expr></argument>)</argument_list></call></expr></argument>,
                                  <comment type="block">/* enableDedicatedDictSearch */</comment> <argument><expr><literal type="number">1</literal></expr></argument>, <comment type="block">/* forCCtx */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call>
         <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>dictLoadMethod</name> <operator>==</operator> <name>ZSTD_dlm_byRef</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr>
            </then><else>: <expr><call><name>ZSTD_cwksp_alloc_size</name><argument_list>(<argument><expr><call><name>ZSTD_cwksp_align</name><argument_list>(<argument><expr><name>dictSize</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_estimateCDictSize</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compressionLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_compressionParameters</name> <specifier>const</specifier></type> <name>cParams</name> <init>= <expr><call><name>ZSTD_getCParams_internal</name><argument_list>(<argument><expr><name>compressionLevel</name></expr></argument>, <argument><expr><name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>, <argument><expr><name>ZSTD_cpm_createCDict</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>ZSTD_estimateCDictSize_advanced</name><argument_list>(<argument><expr><name>dictSize</name></expr></argument>, <argument><expr><name>cParams</name></expr></argument>, <argument><expr><name>ZSTD_dlm_byCopy</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_sizeof_CDict</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ZSTD_CDict</name><modifier>*</modifier></type> <name>cdict</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>cdict</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* support sizeof on NULL */</comment>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"sizeof(*cdict) : %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>cdict</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* cdict may be in the workspace */</comment>
    <return>return <expr><operator>(</operator><ternary><condition><expr><name><name>cdict</name><operator>-&gt;</operator><name>workspace</name><operator>.</operator><name>workspace</name></name> <operator>==</operator> <name>cdict</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>cdict</name></expr></argument>)</argument_list></sizeof></expr></else></ternary><operator>)</operator>
        <operator>+</operator> <call><name>ZSTD_cwksp_sizeof</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cdict</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_initCDict_internal</name><parameter_list>(
                    <parameter><decl><type><name>ZSTD_CDict</name><modifier>*</modifier></type> <name>cdict</name></decl></parameter>,
              <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dictBuffer</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>,
                    <parameter><decl><type><name>ZSTD_dictLoadMethod_e</name></type> <name>dictLoadMethod</name></decl></parameter>,
                    <parameter><decl><type><name>ZSTD_dictContentType_e</name></type> <name>dictContentType</name></decl></parameter>,
                    <parameter><decl><type><name>ZSTD_CCtx_params</name></type> <name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_initCDict_internal (dictContentType:%u)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>dictContentType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ZSTD_checkCParams</name><argument_list>(<argument><expr><name><name>params</name><operator>.</operator><name>cParams</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cdict</name><operator>-&gt;</operator><name>matchState</name><operator>.</operator><name>cParams</name></name> <operator>=</operator> <name><name>params</name><operator>.</operator><name>cParams</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cdict</name><operator>-&gt;</operator><name>matchState</name><operator>.</operator><name>dedicatedDictSearch</name></name> <operator>=</operator> <name><name>params</name><operator>.</operator><name>enableDedicatedDictSearch</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>dictLoadMethod</name> <operator>==</operator> <name>ZSTD_dlm_byRef</name><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>!</operator><name>dictBuffer</name><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>!</operator><name>dictSize</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>cdict</name><operator>-&gt;</operator><name>dictContent</name></name> <operator>=</operator> <name>dictBuffer</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
         <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>internalBuffer</name> <init>= <expr><call><name>ZSTD_cwksp_reserve_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cdict</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>, <argument><expr><call><name>ZSTD_cwksp_align</name><argument_list>(<argument><expr><name>dictSize</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><operator>!</operator><name>internalBuffer</name></expr></argument>, <argument><expr><name>memory_allocation</name></expr></argument>, <argument><expr><literal type="string">"NULL pointer!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cdict</name><operator>-&gt;</operator><name>dictContent</name></name> <operator>=</operator> <name>internalBuffer</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>internalBuffer</name></expr></argument>, <argument><expr><name>dictBuffer</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>cdict</name><operator>-&gt;</operator><name>dictContentSize</name></name> <operator>=</operator> <name>dictSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cdict</name><operator>-&gt;</operator><name>dictContentType</name></name> <operator>=</operator> <name>dictContentType</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>cdict</name><operator>-&gt;</operator><name>entropyWorkspace</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>*</operator><operator>)</operator><call><name>ZSTD_cwksp_reserve_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cdict</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>, <argument><expr><name>HUF_WORKSPACE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


    <comment type="block">/* Reset the state to no dictionary */</comment>
    <expr_stmt><expr><call><name>ZSTD_reset_compressedBlockState</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cdict</name><operator>-&gt;</operator><name>cBlockState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_reset_matchState</name><argument_list>(
        <argument><expr><operator>&amp;</operator><name><name>cdict</name><operator>-&gt;</operator><name>matchState</name></name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name><name>cdict</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name><name>params</name><operator>.</operator><name>cParams</name></name></expr></argument>,
        <argument><expr><name><name>params</name><operator>.</operator><name>useRowMatchFinder</name></name></expr></argument>,
        <argument><expr><name>ZSTDcrp_makeClean</name></expr></argument>,
        <argument><expr><name>ZSTDirp_reset</name></expr></argument>,
        <argument><expr><name>ZSTD_resetTarget_CDict</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* (Maybe) load the dictionary
     * Skips loading the dictionary if it is &lt; 8 bytes.
     */</comment>
    <block>{<block_content>   <expr_stmt><expr><name><name>params</name><operator>.</operator><name>compressionLevel</name></name> <operator>=</operator> <name>ZSTD_CLEVEL_DEFAULT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>params</name><operator>.</operator><name>fParams</name><operator>.</operator><name>contentSizeFlag</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>dictID</name> <init>= <expr><call><name>ZSTD_compress_insertDictionary</name><argument_list>(
                    <argument><expr><operator>&amp;</operator><name><name>cdict</name><operator>-&gt;</operator><name>cBlockState</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cdict</name><operator>-&gt;</operator><name>matchState</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cdict</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><name><name>cdict</name><operator>-&gt;</operator><name>dictContent</name></name></expr></argument>, <argument><expr><name><name>cdict</name><operator>-&gt;</operator><name>dictContentSize</name></name></expr></argument>,
                    <argument><expr><name>dictContentType</name></expr></argument>, <argument><expr><name>ZSTD_dtlm_full</name></expr></argument>, <argument><expr><name>ZSTD_tfp_forCDict</name></expr></argument>, <argument><expr><name><name>cdict</name><operator>-&gt;</operator><name>entropyWorkspace</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>dictID</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_compress_insertDictionary failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dictID</name> <operator>&lt;=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>U32</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cdict</name><operator>-&gt;</operator><name>dictID</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>dictID</name></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ZSTD_CDict</name><modifier>*</modifier></type> <name>ZSTD_createCDict_advanced_internal</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>,
                                      <parameter><decl><type><name>ZSTD_dictLoadMethod_e</name></type> <name>dictLoadMethod</name></decl></parameter>,
                                      <parameter><decl><type><name>ZSTD_compressionParameters</name></type> <name>cParams</name></decl></parameter>,
                                      <parameter><decl><type><name>ZSTD_paramSwitch_e</name></type> <name>useRowMatchFinder</name></decl></parameter>,
                                      <parameter><decl><type><name>U32</name></type> <name>enableDedicatedDictSearch</name></decl></parameter>,
                                      <parameter><decl><type><name>ZSTD_customMem</name></type> <name>customMem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name><name>customMem</name><operator>.</operator><name>customAlloc</name></name><operator>)</operator> <operator>^</operator> <operator>(</operator><operator>!</operator><name><name>customMem</name><operator>.</operator><name>customFree</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>workspaceSize</name> <init>=
            <expr><call><name>ZSTD_cwksp_alloc_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_CDict</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator>
            <call><name>ZSTD_cwksp_alloc_size</name><argument_list>(<argument><expr><name>HUF_WORKSPACE_SIZE</name></expr></argument>)</argument_list></call> <operator>+</operator>
            <call><name>ZSTD_sizeof_matchState</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cParams</name></expr></argument>, <argument><expr><name>useRowMatchFinder</name></expr></argument>, <argument><expr><name>enableDedicatedDictSearch</name></expr></argument>, <comment type="block">/* forCCtx */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>+</operator>
            <operator>(</operator><ternary><condition><expr><name>dictLoadMethod</name> <operator>==</operator> <name>ZSTD_dlm_byRef</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr>
             </then><else>: <expr><call><name>ZSTD_cwksp_alloc_size</name><argument_list>(<argument><expr><call><name>ZSTD_cwksp_align</name><argument_list>(<argument><expr><name>dictSize</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>void</name><modifier>*</modifier> <specifier>const</specifier></type> <name>workspace</name> <init>= <expr><call><name>ZSTD_customMalloc</name><argument_list>(<argument><expr><name>workspaceSize</name></expr></argument>, <argument><expr><name>customMem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ZSTD_cwksp</name></type> <name>ws</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ZSTD_CDict</name><modifier>*</modifier></type> <name>cdict</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>workspace</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>ZSTD_customFree</name><argument_list>(<argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>customMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>ZSTD_cwksp_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ws</name></expr></argument>, <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>workspaceSize</name></expr></argument>, <argument><expr><name>ZSTD_cwksp_dynamic_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>cdict</name> <operator>=</operator> <operator>(</operator><name>ZSTD_CDict</name><operator>*</operator><operator>)</operator><call><name>ZSTD_cwksp_reserve_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ws</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_CDict</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>cdict</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_cwksp_move</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cdict</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ws</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cdict</name><operator>-&gt;</operator><name>customMem</name></name> <operator>=</operator> <name>customMem</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cdict</name><operator>-&gt;</operator><name>compressionLevel</name></name> <operator>=</operator> <name>ZSTD_NO_CLEVEL</name></expr>;</expr_stmt> <comment type="block">/* signals advanced API usage */</comment>
        <expr_stmt><expr><name><name>cdict</name><operator>-&gt;</operator><name>useRowMatchFinder</name></name> <operator>=</operator> <name>useRowMatchFinder</name></expr>;</expr_stmt>
        <return>return <expr><name>cdict</name></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>

<function><type><name>ZSTD_CDict</name><modifier>*</modifier></type> <name>ZSTD_createCDict_advanced</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dictBuffer</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>,
                                      <parameter><decl><type><name>ZSTD_dictLoadMethod_e</name></type> <name>dictLoadMethod</name></decl></parameter>,
                                      <parameter><decl><type><name>ZSTD_dictContentType_e</name></type> <name>dictContentType</name></decl></parameter>,
                                      <parameter><decl><type><name>ZSTD_compressionParameters</name></type> <name>cParams</name></decl></parameter>,
                                      <parameter><decl><type><name>ZSTD_customMem</name></type> <name>customMem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_CCtx_params</name></type> <name>cctxParams</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cctxParams</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cctxParams</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_CCtxParams_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cctxParams</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctxParams</name><operator>.</operator><name>cParams</name></name> <operator>=</operator> <name>cParams</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctxParams</name><operator>.</operator><name>customMem</name></name> <operator>=</operator> <name>customMem</name></expr>;</expr_stmt>
    <return>return <expr><call><name>ZSTD_createCDict_advanced2</name><argument_list>(
        <argument><expr><name>dictBuffer</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>,
        <argument><expr><name>dictLoadMethod</name></expr></argument>, <argument><expr><name>dictContentType</name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name>cctxParams</name></expr></argument>, <argument><expr><name>customMem</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>ZSTD_CDict</name><modifier>*</modifier></type> <name>ZSTD_createCDict_advanced2</name><parameter_list>(
        <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>,
        <parameter><decl><type><name>ZSTD_dictLoadMethod_e</name></type> <name>dictLoadMethod</name></decl></parameter>,
        <parameter><decl><type><name>ZSTD_dictContentType_e</name></type> <name>dictContentType</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>originalCctxParams</name></decl></parameter>,
        <parameter><decl><type><name>ZSTD_customMem</name></type> <name>customMem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_CCtx_params</name></type> <name>cctxParams</name> <init>= <expr><operator>*</operator><name>originalCctxParams</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_compressionParameters</name></type> <name>cParams</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_CDict</name><modifier>*</modifier></type> <name>cdict</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_createCDict_advanced2, mode %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>dictContentType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>customMem</name><operator>.</operator><name>customAlloc</name></name> <operator>^</operator> <operator>!</operator><name><name>customMem</name><operator>.</operator><name>customFree</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cctxParams</name><operator>.</operator><name>enableDedicatedDictSearch</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>cParams</name> <operator>=</operator> <call><name>ZSTD_dedicatedDictSearch_getCParams</name><argument_list>(
            <argument><expr><name><name>cctxParams</name><operator>.</operator><name>compressionLevel</name></name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_overrideCParams</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cParams</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cctxParams</name><operator>.</operator><name>cParams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>cParams</name> <operator>=</operator> <call><name>ZSTD_getCParamsFromCCtxParams</name><argument_list>(
            <argument><expr><operator>&amp;</operator><name>cctxParams</name></expr></argument>, <argument><expr><name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>, <argument><expr><name>ZSTD_cpm_createCDict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ZSTD_dedicatedDictSearch_isSupported</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cParams</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Fall back to non-DDSS params */</comment>
        <expr_stmt><expr><name><name>cctxParams</name><operator>.</operator><name>enableDedicatedDictSearch</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>cParams</name> <operator>=</operator> <call><name>ZSTD_getCParamsFromCCtxParams</name><argument_list>(
            <argument><expr><operator>&amp;</operator><name>cctxParams</name></expr></argument>, <argument><expr><name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>, <argument><expr><name>ZSTD_cpm_createCDict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_createCDict_advanced2: DDS: %u"</literal></expr></argument>, <argument><expr><name><name>cctxParams</name><operator>.</operator><name>enableDedicatedDictSearch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctxParams</name><operator>.</operator><name>cParams</name></name> <operator>=</operator> <name>cParams</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctxParams</name><operator>.</operator><name>useRowMatchFinder</name></name> <operator>=</operator> <call><name>ZSTD_resolveRowMatchFinderMode</name><argument_list>(<argument><expr><name><name>cctxParams</name><operator>.</operator><name>useRowMatchFinder</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>cdict</name> <operator>=</operator> <call><name>ZSTD_createCDict_advanced_internal</name><argument_list>(<argument><expr><name>dictSize</name></expr></argument>,
                        <argument><expr><name>dictLoadMethod</name></expr></argument>, <argument><expr><name><name>cctxParams</name><operator>.</operator><name>cParams</name></name></expr></argument>,
                        <argument><expr><name><name>cctxParams</name><operator>.</operator><name>useRowMatchFinder</name></name></expr></argument>, <argument><expr><name><name>cctxParams</name><operator>.</operator><name>enableDedicatedDictSearch</name></name></expr></argument>,
                        <argument><expr><name>customMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>( <argument><expr><call><name>ZSTD_initCDict_internal</name><argument_list>(<argument><expr><name>cdict</name></expr></argument>,
                                    <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>,
                                    <argument><expr><name>dictLoadMethod</name></expr></argument>, <argument><expr><name>dictContentType</name></expr></argument>,
                                    <argument><expr><name>cctxParams</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>ZSTD_freeCDict</name><argument_list>(<argument><expr><name>cdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>cdict</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ZSTD_CDict</name><modifier>*</modifier></type> <name>ZSTD_createCDict</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compressionLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_compressionParameters</name></type> <name>cParams</name> <init>= <expr><call><name>ZSTD_getCParams_internal</name><argument_list>(<argument><expr><name>compressionLevel</name></expr></argument>, <argument><expr><name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>, <argument><expr><name>ZSTD_cpm_createCDict</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_CDict</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cdict</name> <init>= <expr><call><name>ZSTD_createCDict_advanced</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>,
                                                  <argument><expr><name>ZSTD_dlm_byCopy</name></expr></argument>, <argument><expr><name>ZSTD_dct_auto</name></expr></argument>,
                                                  <argument><expr><name>cParams</name></expr></argument>, <argument><expr><name>ZSTD_defaultCMem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>cdict</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>cdict</name><operator>-&gt;</operator><name>compressionLevel</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>compressionLevel</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>ZSTD_CLEVEL_DEFAULT</name></expr> </then><else>: <expr><name>compressionLevel</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>cdict</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ZSTD_CDict</name><modifier>*</modifier></type> <name>ZSTD_createCDict_byReference</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compressionLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_compressionParameters</name></type> <name>cParams</name> <init>= <expr><call><name>ZSTD_getCParams_internal</name><argument_list>(<argument><expr><name>compressionLevel</name></expr></argument>, <argument><expr><name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>, <argument><expr><name>ZSTD_cpm_createCDict</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_CDict</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cdict</name> <init>= <expr><call><name>ZSTD_createCDict_advanced</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>,
                                     <argument><expr><name>ZSTD_dlm_byRef</name></expr></argument>, <argument><expr><name>ZSTD_dct_auto</name></expr></argument>,
                                     <argument><expr><name>cParams</name></expr></argument>, <argument><expr><name>ZSTD_defaultCMem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>cdict</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>cdict</name><operator>-&gt;</operator><name>compressionLevel</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>compressionLevel</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>ZSTD_CLEVEL_DEFAULT</name></expr> </then><else>: <expr><name>compressionLevel</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>cdict</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_freeCDict</name><parameter_list>(<parameter><decl><type><name>ZSTD_CDict</name><modifier>*</modifier></type> <name>cdict</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>cdict</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* support free on NULL */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>ZSTD_customMem</name> <specifier>const</specifier></type> <name>cMem</name> <init>= <expr><name><name>cdict</name><operator>-&gt;</operator><name>customMem</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>cdictInWorkspace</name> <init>= <expr><call><name>ZSTD_cwksp_owns_buffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cdict</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>, <argument><expr><name>cdict</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ZSTD_cwksp_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cdict</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>, <argument><expr><name>cMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>cdictInWorkspace</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>ZSTD_customFree</name><argument_list>(<argument><expr><name>cdict</name></expr></argument>, <argument><expr><name>cMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! ZSTD_initStaticCDict_advanced() :
 *  Generate a digested dictionary in provided memory area.
 *  workspace: The memory area to emplace the dictionary into.
 *             Provided pointer must 8-bytes aligned.
 *             It must outlive dictionary usage.
 *  workspaceSize: Use ZSTD_estimateCDictSize()
 *                 to determine how large workspace must be.
 *  cParams : use ZSTD_getCParams() to transform a compression level
 *            into its relevants cParams.
 * @return : pointer to ZSTD_CDict*, or NULL if error (size too small)
 *  Note : there is no corresponding "free" function.
 *         Since workspace was allocated externally, it must be freed externally.
 */</comment>
<function><type><specifier>const</specifier> <name>ZSTD_CDict</name><modifier>*</modifier></type> <name>ZSTD_initStaticCDict</name><parameter_list>(
                                 <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>workspace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>workspaceSize</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>,
                                 <parameter><decl><type><name>ZSTD_dictLoadMethod_e</name></type> <name>dictLoadMethod</name></decl></parameter>,
                                 <parameter><decl><type><name>ZSTD_dictContentType_e</name></type> <name>dictContentType</name></decl></parameter>,
                                 <parameter><decl><type><name>ZSTD_compressionParameters</name></type> <name>cParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_paramSwitch_e</name> <specifier>const</specifier></type> <name>useRowMatchFinder</name> <init>= <expr><call><name>ZSTD_resolveRowMatchFinderMode</name><argument_list>(<argument><expr><name>ZSTD_ps_auto</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cParams</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/* enableDedicatedDictSearch == 1 ensures matchstate is not too small in case this CDict will be used for DDS + row hash */</comment>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>matchStateSize</name> <init>= <expr><call><name>ZSTD_sizeof_matchState</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cParams</name></expr></argument>, <argument><expr><name>useRowMatchFinder</name></expr></argument>, <comment type="block">/* enableDedicatedDictSearch */</comment> <argument><expr><literal type="number">1</literal></expr></argument>, <comment type="block">/* forCCtx */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>neededSize</name> <init>= <expr><call><name>ZSTD_cwksp_alloc_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_CDict</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call>
                            <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>dictLoadMethod</name> <operator>==</operator> <name>ZSTD_dlm_byRef</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr>
                               </then><else>: <expr><call><name>ZSTD_cwksp_alloc_size</name><argument_list>(<argument><expr><call><name>ZSTD_cwksp_align</name><argument_list>(<argument><expr><name>dictSize</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator>
                            <operator>+</operator> <call><name>ZSTD_cwksp_alloc_size</name><argument_list>(<argument><expr><name>HUF_WORKSPACE_SIZE</name></expr></argument>)</argument_list></call>
                            <operator>+</operator> <name>matchStateSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_CDict</name><modifier>*</modifier></type> <name>cdict</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_CCtx_params</name></type> <name>params</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><name>workspace</name> <operator>&amp;</operator> <literal type="number">7</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* 8-aligned */</comment>

    <block>{<block_content>
        <decl_stmt><decl><type><name>ZSTD_cwksp</name></type> <name>ws</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ZSTD_cwksp_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ws</name></expr></argument>, <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>workspaceSize</name></expr></argument>, <argument><expr><name>ZSTD_cwksp_static_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cdict</name> <operator>=</operator> <operator>(</operator><name>ZSTD_CDict</name><operator>*</operator><operator>)</operator><call><name>ZSTD_cwksp_reserve_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ws</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_CDict</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>cdict</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>ZSTD_cwksp_move</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cdict</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ws</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"(workspaceSize &lt; neededSize) : (%u &lt; %u) =&gt; %u"</literal></expr></argument>,
        <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>workspaceSize</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>neededSize</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name>workspaceSize</name> <operator>&lt;</operator> <name>neededSize</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>workspaceSize</name> <operator>&lt;</operator> <name>neededSize</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>ZSTD_CCtxParams_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>params</name><operator>.</operator><name>cParams</name></name> <operator>=</operator> <name>cParams</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>params</name><operator>.</operator><name>useRowMatchFinder</name></name> <operator>=</operator> <name>useRowMatchFinder</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cdict</name><operator>-&gt;</operator><name>useRowMatchFinder</name></name> <operator>=</operator> <name>useRowMatchFinder</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>( <argument><expr><call><name>ZSTD_initCDict_internal</name><argument_list>(<argument><expr><name>cdict</name></expr></argument>,
                                              <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>,
                                              <argument><expr><name>dictLoadMethod</name></expr></argument>, <argument><expr><name>dictContentType</name></expr></argument>,
                                              <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>cdict</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ZSTD_compressionParameters</name></type> <name>ZSTD_getCParamsFromCDict</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ZSTD_CDict</name><modifier>*</modifier></type> <name>cdict</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>cdict</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>cdict</name><operator>-&gt;</operator><name>matchState</name><operator>.</operator><name>cParams</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! ZSTD_getDictID_fromCDict() :
 *  Provides the dictID of the dictionary loaded into `cdict`.
 *  If @return == 0, the dictionary is not conformant to Zstandard specification, or empty.
 *  Non-conformant dictionaries can still be loaded, but as content-only dictionaries. */</comment>
<function><type><name>unsigned</name></type> <name>ZSTD_getDictID_fromCDict</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ZSTD_CDict</name><modifier>*</modifier></type> <name>cdict</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>cdict</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name><name>cdict</name><operator>-&gt;</operator><name>dictID</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ZSTD_compressBegin_usingCDict_internal() :
 * Implementation of various ZSTD_compressBegin_usingCDict* functions.
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_compressBegin_usingCDict_internal</name><parameter_list>(
    <parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CDict</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cdict</name></decl></parameter>,
    <parameter><decl><type><name>ZSTD_frameParameters</name> <specifier>const</specifier></type> <name>fParams</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name> <name>long</name> <specifier>const</specifier></type> <name>pledgedSrcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_CCtx_params</name></type> <name>cctxParams</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressBegin_usingCDict_internal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>cdict</name><operator>==</operator><name>NULL</name></expr></argument>, <argument><expr><name>dictionary_wrong</name></expr></argument>, <argument><expr><literal type="string">"NULL pointer!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Initialize the cctxParams from the cdict */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ZSTD_parameters</name></type> <name>params</name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>params</name><operator>.</operator><name>fParams</name></name> <operator>=</operator> <name>fParams</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>params</name><operator>.</operator><name>cParams</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator> <name>pledgedSrcSize</name> <operator>&lt;</operator> <name>ZSTD_USE_CDICT_PARAMS_SRCSIZE_CUTOFF</name>
                        <operator>||</operator> <name>pledgedSrcSize</name> <operator>&lt;</operator> <name><name>cdict</name><operator>-&gt;</operator><name>dictContentSize</name></name> <operator>*</operator> <name>ZSTD_USE_CDICT_PARAMS_DICTSIZE_MULTIPLIER</name>
                        <operator>||</operator> <name>pledgedSrcSize</name> <operator>==</operator> <name>ZSTD_CONTENTSIZE_UNKNOWN</name>
                        <operator>||</operator> <name><name>cdict</name><operator>-&gt;</operator><name>compressionLevel</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>)</operator></expr> ?</condition><then>
                <expr><call><name>ZSTD_getCParamsFromCDict</name><argument_list>(<argument><expr><name>cdict</name></expr></argument>)</argument_list></call></expr>
              </then><else>: <expr><call><name>ZSTD_getCParams</name><argument_list>(<argument><expr><name><name>cdict</name><operator>-&gt;</operator><name>compressionLevel</name></name></expr></argument>,
                                <argument><expr><name>pledgedSrcSize</name></expr></argument>,
                                <argument><expr><name><name>cdict</name><operator>-&gt;</operator><name>dictContentSize</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_CCtxParams_init_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cctxParams</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><name><name>cdict</name><operator>-&gt;</operator><name>compressionLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <comment type="block">/* Increase window log to fit the entire dictionary and source if the
     * source size is known. Limit the increase to 19, which is the
     * window log for compression level 1 with the largest source size.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>pledgedSrcSize</name> <operator>!=</operator> <name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>limitedSrcSize</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><call><name>MIN</name><argument_list>(<argument><expr><name>pledgedSrcSize</name></expr></argument>, <argument><expr><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <literal type="number">19</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>limitedSrcLog</name> <init>= <expr><ternary><condition><expr><name>limitedSrcSize</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><name>limitedSrcSize</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>cctxParams</name><operator>.</operator><name>cParams</name><operator>.</operator><name>windowLog</name></name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name><name>cctxParams</name><operator>.</operator><name>cParams</name><operator>.</operator><name>windowLog</name></name></expr></argument>, <argument><expr><name>limitedSrcLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name>ZSTD_compressBegin_internal</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>,
                                        <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ZSTD_dct_auto</name></expr></argument>, <argument><expr><name>ZSTD_dtlm_fast</name></expr></argument>,
                                        <argument><expr><name>cdict</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name>cctxParams</name></expr></argument>, <argument><expr><name>pledgedSrcSize</name></expr></argument>,
                                        <argument><expr><name>ZSTDb_not_buffered</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ZSTD_compressBegin_usingCDict_advanced() :
 * This function is DEPRECATED.
 * cdict must be != NULL */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_compressBegin_usingCDict_advanced</name><parameter_list>(
    <parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CDict</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cdict</name></decl></parameter>,
    <parameter><decl><type><name>ZSTD_frameParameters</name> <specifier>const</specifier></type> <name>fParams</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name> <name>long</name> <specifier>const</specifier></type> <name>pledgedSrcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBegin_usingCDict_internal</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>cdict</name></expr></argument>, <argument><expr><name>fParams</name></expr></argument>, <argument><expr><name>pledgedSrcSize</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ZSTD_compressBegin_usingCDict() :
 * cdict must be != NULL */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_compressBegin_usingCDict</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CDict</name><modifier>*</modifier></type> <name>cdict</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_frameParameters</name> <specifier>const</specifier></type> <name>fParams</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> <comment type="block">/*content*/</comment>, <expr><literal type="number">0</literal></expr> <comment type="block">/*checksum*/</comment>, <expr><literal type="number">0</literal></expr> <comment type="block">/*noDictID*/</comment> }</block></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>ZSTD_compressBegin_usingCDict_internal</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>cdict</name></expr></argument>, <argument><expr><name>fParams</name></expr></argument>, <argument><expr><name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! ZSTD_compress_usingCDict_internal():
 * Implementation of various ZSTD_compress_usingCDict* functions.
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_compress_usingCDict_internal</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>,
                                <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                                <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                                <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CDict</name><modifier>*</modifier></type> <name>cdict</name></decl></parameter>, <parameter><decl><type><name>ZSTD_frameParameters</name></type> <name>fParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_compressBegin_usingCDict_internal</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>cdict</name></expr></argument>, <argument><expr><name>fParams</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* will check if cdict != NULL */</comment>
    <return>return <expr><call><name>ZSTD_compressEnd</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! ZSTD_compress_usingCDict_advanced():
 * This function is DEPRECATED.
 */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_compress_usingCDict_advanced</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>,
                                <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                                <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                                <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CDict</name><modifier>*</modifier></type> <name>cdict</name></decl></parameter>, <parameter><decl><type><name>ZSTD_frameParameters</name></type> <name>fParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compress_usingCDict_internal</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>cdict</name></expr></argument>, <argument><expr><name>fParams</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! ZSTD_compress_usingCDict() :
 *  Compression using a digested Dictionary.
 *  Faster startup than ZSTD_compress_usingDict(), recommended when same dictionary is used multiple times.
 *  Note that compression parameters are decided at CDict creation time
 *  while frame parameters are hardcoded */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_compress_usingCDict</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>,
                                <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                                <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                                <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CDict</name><modifier>*</modifier></type> <name>cdict</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_frameParameters</name> <specifier>const</specifier></type> <name>fParams</name> <init>= <expr><block>{ <expr><literal type="number">1</literal></expr> <comment type="block">/*content*/</comment>, <expr><literal type="number">0</literal></expr> <comment type="block">/*checksum*/</comment>, <expr><literal type="number">0</literal></expr> <comment type="block">/*noDictID*/</comment> }</block></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>ZSTD_compress_usingCDict_internal</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>cdict</name></expr></argument>, <argument><expr><name>fParams</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<comment type="block">/* ******************************************************************
*  Streaming
********************************************************************/</comment>

<function><type><name>ZSTD_CStream</name><modifier>*</modifier></type> <name>ZSTD_createCStream</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_createCStream"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>ZSTD_createCStream_advanced</name><argument_list>(<argument><expr><name>ZSTD_defaultCMem</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>ZSTD_CStream</name><modifier>*</modifier></type> <name>ZSTD_initStaticCStream</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>workspace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>workspaceSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_initStaticCCtx</name><argument_list>(<argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>workspaceSize</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>ZSTD_CStream</name><modifier>*</modifier></type> <name>ZSTD_createCStream_advanced</name><parameter_list>(<parameter><decl><type><name>ZSTD_customMem</name></type> <name>customMem</name></decl></parameter>)</parameter_list>
<block>{<block_content>   <comment type="block">/* CStream and CCtx are now same object */</comment>
    <return>return <expr><call><name>ZSTD_createCCtx_advanced</name><argument_list>(<argument><expr><name>customMem</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_freeCStream</name><parameter_list>(<parameter><decl><type><name>ZSTD_CStream</name><modifier>*</modifier></type> <name>zcs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_freeCCtx</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>)</argument_list></call></expr>;</return>   <comment type="block">/* same object */</comment>
</block_content>}</block></function>



<comment type="block">/*======   Initialization   ======*/</comment>

<function><type><name>size_t</name></type> <name>ZSTD_CStreamInSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>  <block>{<block_content> <return>return <expr><name>ZSTD_BLOCKSIZE_MAX</name></expr>;</return> </block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_CStreamOutSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_compressBound</name><argument_list>(<argument><expr><name>ZSTD_BLOCKSIZE_MAX</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>ZSTD_blockHeaderSize</name> <operator>+</operator> <literal type="number">4</literal></expr> <comment type="block">/* 32-bits hash */</comment> ;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ZSTD_cParamMode_e</name></type> <name>ZSTD_getCParamMode</name><parameter_list>(<parameter><decl><type><name>ZSTD_CDict</name> <specifier>const</specifier><modifier>*</modifier></type> <name>cdict</name></decl></parameter>, <parameter><decl><type><name>ZSTD_CCtx_params</name> <specifier>const</specifier><modifier>*</modifier></type> <name>params</name></decl></parameter>, <parameter><decl><type><name>U64</name></type> <name>pledgedSrcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>cdict</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>ZSTD_shouldAttachDict</name><argument_list>(<argument><expr><name>cdict</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>pledgedSrcSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>ZSTD_cpm_attachDict</name></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>ZSTD_cpm_noAttachDict</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ZSTD_resetCStream():
 * pledgedSrcSize == 0 means "unknown" */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_resetCStream</name><parameter_list>(<parameter><decl><type><name>ZSTD_CStream</name><modifier>*</modifier></type> <name>zcs</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>pss</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* temporary : 0 interpreted as "unknown" during transition period.
     * Users willing to specify "unknown" **must** use ZSTD_CONTENTSIZE_UNKNOWN.
     * 0 will be interpreted as "empty" in the future.
     */</comment>
    <decl_stmt><decl><type><name>U64</name> <specifier>const</specifier></type> <name>pledgedSrcSize</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>pss</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr> </then><else>: <expr><name>pss</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_resetCStream: pledgedSrcSize = %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>pledgedSrcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_CCtx_reset</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>ZSTD_reset_session_only</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_CCtx_setPledgedSrcSize</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>pledgedSrcSize</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! ZSTD_initCStream_internal() :
 *  Note : for lib/compress only. Used by zstdmt_compress.c.
 *  Assumption 1 : params are valid
 *  Assumption 2 : either dict, or cdict, is defined, not both */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_initCStream_internal</name><parameter_list>(<parameter><decl><type><name>ZSTD_CStream</name><modifier>*</modifier></type> <name>zcs</name></decl></parameter>,
                    <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CDict</name><modifier>*</modifier></type> <name>cdict</name></decl></parameter>,
                    <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>params</name></decl></parameter>,
                    <parameter><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>pledgedSrcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_initCStream_internal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_CCtx_reset</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>ZSTD_reset_session_only</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_CCtx_setPledgedSrcSize</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>pledgedSrcSize</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ZSTD_isError</name><argument_list>(<argument><expr><call><name>ZSTD_checkCParams</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>cParams</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zcs</name><operator>-&gt;</operator><name>requestedParams</name></name> <operator>=</operator> <operator>*</operator><name>params</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><operator>(</operator><name>dict</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>cdict</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* either dict or cdict, not both */</comment>
    <if_stmt><if>if <condition>(<expr><name>dict</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_CCtx_loadDictionary</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* Dictionary is cleared if !cdict */</comment>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_CCtx_refCDict</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>cdict</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ZSTD_initCStream_usingCDict_advanced() :
 * same as ZSTD_initCStream_usingCDict(), with control over frame parameters */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_initCStream_usingCDict_advanced</name><parameter_list>(<parameter><decl><type><name>ZSTD_CStream</name><modifier>*</modifier></type> <name>zcs</name></decl></parameter>,
                                            <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CDict</name><modifier>*</modifier></type> <name>cdict</name></decl></parameter>,
                                            <parameter><decl><type><name>ZSTD_frameParameters</name></type> <name>fParams</name></decl></parameter>,
                                            <parameter><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>pledgedSrcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_initCStream_usingCDict_advanced"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_CCtx_reset</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>ZSTD_reset_session_only</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_CCtx_setPledgedSrcSize</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>pledgedSrcSize</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zcs</name><operator>-&gt;</operator><name>requestedParams</name><operator>.</operator><name>fParams</name></name> <operator>=</operator> <name>fParams</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_CCtx_refCDict</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>cdict</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* note : cdict must outlive compression session */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_initCStream_usingCDict</name><parameter_list>(<parameter><decl><type><name>ZSTD_CStream</name><modifier>*</modifier></type> <name>zcs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ZSTD_CDict</name><modifier>*</modifier></type> <name>cdict</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_initCStream_usingCDict"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_CCtx_reset</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>ZSTD_reset_session_only</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_CCtx_refCDict</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>cdict</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ZSTD_initCStream_advanced() :
 * pledgedSrcSize must be exact.
 * if srcSize is not known at init time, use value ZSTD_CONTENTSIZE_UNKNOWN.
 * dict is loaded with default parameters ZSTD_dct_auto and ZSTD_dlm_byCopy. */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_initCStream_advanced</name><parameter_list>(<parameter><decl><type><name>ZSTD_CStream</name><modifier>*</modifier></type> <name>zcs</name></decl></parameter>,
                                 <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>,
                                 <parameter><decl><type><name>ZSTD_parameters</name></type> <name>params</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>pss</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* for compatibility with older programs relying on this behavior.
     * Users should now specify ZSTD_CONTENTSIZE_UNKNOWN.
     * This line will be removed in the future.
     */</comment>
    <decl_stmt><decl><type><name>U64</name> <specifier>const</specifier></type> <name>pledgedSrcSize</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>pss</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>params</name><operator>.</operator><name>fParams</name><operator>.</operator><name>contentSizeFlag</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr> </then><else>: <expr><name>pss</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_initCStream_advanced"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_CCtx_reset</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>ZSTD_reset_session_only</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_CCtx_setPledgedSrcSize</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>pledgedSrcSize</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_checkCParams</name><argument_list>(<argument><expr><name><name>params</name><operator>.</operator><name>cParams</name></name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_CCtxParams_setZstdParams</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zcs</name><operator>-&gt;</operator><name>requestedParams</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_CCtx_loadDictionary</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_initCStream_usingDict</name><parameter_list>(<parameter><decl><type><name>ZSTD_CStream</name><modifier>*</modifier></type> <name>zcs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compressionLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_initCStream_usingDict"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_CCtx_reset</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>ZSTD_reset_session_only</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_CCtx_setParameter</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>ZSTD_c_compressionLevel</name></expr></argument>, <argument><expr><name>compressionLevel</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_CCtx_loadDictionary</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_initCStream_srcSize</name><parameter_list>(<parameter><decl><type><name>ZSTD_CStream</name><modifier>*</modifier></type> <name>zcs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compressionLevel</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>pss</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* temporary : 0 interpreted as "unknown" during transition period.
     * Users willing to specify "unknown" **must** use ZSTD_CONTENTSIZE_UNKNOWN.
     * 0 will be interpreted as "empty" in the future.
     */</comment>
    <decl_stmt><decl><type><name>U64</name> <specifier>const</specifier></type> <name>pledgedSrcSize</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>pss</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr> </then><else>: <expr><name>pss</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_initCStream_srcSize"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_CCtx_reset</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>ZSTD_reset_session_only</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_CCtx_refCDict</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_CCtx_setParameter</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>ZSTD_c_compressionLevel</name></expr></argument>, <argument><expr><name>compressionLevel</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_CCtx_setPledgedSrcSize</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>pledgedSrcSize</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_initCStream</name><parameter_list>(<parameter><decl><type><name>ZSTD_CStream</name><modifier>*</modifier></type> <name>zcs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compressionLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_initCStream"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_CCtx_reset</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>ZSTD_reset_session_only</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_CCtx_refCDict</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_CCtx_setParameter</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>ZSTD_c_compressionLevel</name></expr></argument>, <argument><expr><name>compressionLevel</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*======   Compression   ======*/</comment>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_nextInputSizeHint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>inBufferMode</name></name> <operator>==</operator> <name>ZSTD_bm_stable</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name><name>cctx</name><operator>-&gt;</operator><name>blockSize</name></name> <operator>-</operator> <name><name>cctx</name><operator>-&gt;</operator><name>stableIn_notConsumed</name></name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>inBufferMode</name></name> <operator>==</operator> <name>ZSTD_bm_buffered</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name></type> <name>hintInSize</name> <init>= <expr><name><name>cctx</name><operator>-&gt;</operator><name>inBuffTarget</name></name> <operator>-</operator> <name><name>cctx</name><operator>-&gt;</operator><name>inBuffPos</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>hintInSize</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>hintInSize</name> <operator>=</operator> <name><name>cctx</name><operator>-&gt;</operator><name>blockSize</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>hintInSize</name></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** ZSTD_compressStream_generic():
 *  internal function for all *compressStream*() variants
 * @return : hint size for next input to complete ongoing block */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_compressStream_generic</name><parameter_list>(<parameter><decl><type><name>ZSTD_CStream</name><modifier>*</modifier></type> <name>zcs</name></decl></parameter>,
                                          <parameter><decl><type><name>ZSTD_outBuffer</name><modifier>*</modifier></type> <name>output</name></decl></parameter>,
                                          <parameter><decl><type><name>ZSTD_inBuffer</name><modifier>*</modifier></type> <name>input</name></decl></parameter>,
                                          <parameter><decl><type><name>ZSTD_EndDirective</name> <specifier>const</specifier></type> <name>flushMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>istart</name> <init>= <expr><operator>(</operator><call><name>assert</name><argument_list>(<argument><expr><name>input</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call>, <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name><name>input</name><operator>-&gt;</operator><name>src</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>istart</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>istart</name> <operator>+</operator> <name><name>input</name><operator>-&gt;</operator><name>size</name></name></expr> </then><else>: <expr><name>istart</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>istart</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>istart</name> <operator>+</operator> <name><name>input</name><operator>-&gt;</operator><name>pos</name></name></expr> </then><else>: <expr><name>istart</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ostart</name> <init>= <expr><operator>(</operator><call><name>assert</name><argument_list>(<argument><expr><name>output</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call>, <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>output</name><operator>-&gt;</operator><name>dst</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>ostart</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>ostart</name> <operator>+</operator> <name><name>output</name><operator>-&gt;</operator><name>size</name></name></expr> </then><else>: <expr><name>ostart</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>ostart</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>ostart</name> <operator>+</operator> <name><name>output</name><operator>-&gt;</operator><name>pos</name></name></expr> </then><else>: <expr><name>ostart</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>someMoreWork</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* check expectations */</comment>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressStream_generic, flush=%i, srcSize = %zu"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>flushMode</name></expr></argument>, <argument><expr><name><name>input</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name><name>input</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>zcs</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>zcs</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>inBufferMode</name></name> <operator>==</operator> <name>ZSTD_bm_stable</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>input</name><operator>-&gt;</operator><name>pos</name></name> <operator>&gt;=</operator> <name><name>zcs</name><operator>-&gt;</operator><name>stableIn_notConsumed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>input</name><operator>-&gt;</operator><name>pos</name></name> <operator>-=</operator> <name><name>zcs</name><operator>-&gt;</operator><name>stableIn_notConsumed</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ip</name> <operator>-=</operator> <name><name>zcs</name><operator>-&gt;</operator><name>stableIn_notConsumed</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zcs</name><operator>-&gt;</operator><name>stableIn_notConsumed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>zcs</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>inBufferMode</name></name> <operator>==</operator> <name>ZSTD_bm_buffered</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>zcs</name><operator>-&gt;</operator><name>inBuff</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>zcs</name><operator>-&gt;</operator><name>inBuffSize</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>zcs</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>outBufferMode</name></name> <operator>==</operator> <name>ZSTD_bm_buffered</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>zcs</name><operator>-&gt;</operator><name>outBuff</name></name> <operator>!=</operator>  <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>zcs</name><operator>-&gt;</operator><name>outBuffSize</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>input</name><operator>-&gt;</operator><name>src</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>input</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>input</name><operator>-&gt;</operator><name>pos</name></name> <operator>&lt;=</operator> <name><name>input</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>output</name><operator>-&gt;</operator><name>dst</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>output</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>output</name><operator>-&gt;</operator><name>pos</name></name> <operator>&lt;=</operator> <name><name>output</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>flushMode</name> <operator>&lt;=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>ZSTD_e_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>someMoreWork</name></expr>)</condition> <block>{<block_content>
        <switch>switch<condition>(<expr><name><name>zcs</name><operator>-&gt;</operator><name>streamStage</name></name></expr>)</condition>
        <block>{<block_content>
        <case>case <expr><name>zcss_init</name></expr>:</case>
            <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr><name>init_missing</name></expr></argument>, <argument><expr><literal type="string">"call ZSTD_initCStream() first!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <case>case <expr><name>zcss_load</name></expr>:</case>
            <if_stmt><if>if <condition>( <expr><operator>(</operator><name>flushMode</name> <operator>==</operator> <name>ZSTD_e_end</name><operator>)</operator>
              <operator>&amp;&amp;</operator> <operator>(</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name><operator>-</operator><name>op</name><operator>)</operator> <operator>&gt;=</operator> <call><name>ZSTD_compressBound</name><argument_list>(<argument><expr><name>iend</name><operator>-</operator><name>ip</name></expr></argument>)</argument_list></call>     <comment type="block">/* Enough output space */</comment>
                <operator>||</operator> <name><name>zcs</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>outBufferMode</name></name> <operator>==</operator> <name>ZSTD_bm_stable</name><operator>)</operator>  <comment type="block">/* OR we are allowed to return dstSizeTooSmall */</comment>
              <operator>&amp;&amp;</operator> <operator>(</operator><name><name>zcs</name><operator>-&gt;</operator><name>inBuffPos</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> )</condition> <block>{<block_content>
                <comment type="block">/* shortcut to compression pass directly into output buffer */</comment>
                <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>cSize</name> <init>= <expr><call><name>ZSTD_compressEnd</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>,
                                                <argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name><operator>-</operator><name>op</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iend</name><operator>-</operator><name>ip</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressEnd : cSize=%u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>cSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressEnd failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>ip</name> <operator>=</operator> <name>iend</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>cSize</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>zcs</name><operator>-&gt;</operator><name>frameEnded</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ZSTD_CCtx_reset</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>ZSTD_reset_session_only</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>someMoreWork</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* complete loading into inBuffer in buffered mode */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>zcs</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>inBufferMode</name></name> <operator>==</operator> <name>ZSTD_bm_buffered</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>toLoad</name> <init>= <expr><name><name>zcs</name><operator>-&gt;</operator><name>inBuffTarget</name></name> <operator>-</operator> <name><name>zcs</name><operator>-&gt;</operator><name>inBuffPos</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>loaded</name> <init>= <expr><call><name>ZSTD_limitCopy</name><argument_list>(
                                        <argument><expr><name><name>zcs</name><operator>-&gt;</operator><name>inBuff</name></name> <operator>+</operator> <name><name>zcs</name><operator>-&gt;</operator><name>inBuffPos</name></name></expr></argument>, <argument><expr><name>toLoad</name></expr></argument>,
                                        <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iend</name><operator>-</operator><name>ip</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>zcs</name><operator>-&gt;</operator><name>inBuffPos</name></name> <operator>+=</operator> <name>loaded</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>ip</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>loaded</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>( <expr><operator>(</operator><name>flushMode</name> <operator>==</operator> <name>ZSTD_e_continue</name><operator>)</operator>
                  <operator>&amp;&amp;</operator> <operator>(</operator><name><name>zcs</name><operator>-&gt;</operator><name>inBuffPos</name></name> <operator>&lt;</operator> <name><name>zcs</name><operator>-&gt;</operator><name>inBuffTarget</name></name><operator>)</operator></expr> )</condition> <block>{<block_content>
                    <comment type="block">/* not enough input to fill full block : stop here */</comment>
                    <expr_stmt><expr><name>someMoreWork</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <break>break;</break>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>( <expr><operator>(</operator><name>flushMode</name> <operator>==</operator> <name>ZSTD_e_flush</name><operator>)</operator>
                  <operator>&amp;&amp;</operator> <operator>(</operator><name><name>zcs</name><operator>-&gt;</operator><name>inBuffPos</name></name> <operator>==</operator> <name><name>zcs</name><operator>-&gt;</operator><name>inToCompress</name></name><operator>)</operator></expr> )</condition> <block>{<block_content>
                    <comment type="block">/* empty */</comment>
                    <expr_stmt><expr><name>someMoreWork</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>zcs</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>inBufferMode</name></name> <operator>==</operator> <name>ZSTD_bm_stable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>( <expr><operator>(</operator><name>flushMode</name> <operator>==</operator> <name>ZSTD_e_continue</name><operator>)</operator>
                  <operator>&amp;&amp;</operator> <operator>(</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>iend</name> <operator>-</operator> <name>ip</name><operator>)</operator> <operator>&lt;</operator> <name><name>zcs</name><operator>-&gt;</operator><name>blockSize</name></name><operator>)</operator></expr> )</condition> <block>{<block_content>
                    <comment type="block">/* can't compress a full block : stop here */</comment>
                    <expr_stmt><expr><name><name>zcs</name><operator>-&gt;</operator><name>stableIn_notConsumed</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>iend</name> <operator>-</operator> <name>ip</name><operator>)</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name>ip</name> <operator>=</operator> <name>iend</name></expr>;</expr_stmt>  <comment type="block">/* pretend to have consumed input */</comment>
                    <expr_stmt><expr><name>someMoreWork</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <break>break;</break>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>( <expr><operator>(</operator><name>flushMode</name> <operator>==</operator> <name>ZSTD_e_flush</name><operator>)</operator>
                  <operator>&amp;&amp;</operator> <operator>(</operator><name>ip</name> <operator>==</operator> <name>iend</name><operator>)</operator></expr> )</condition> <block>{<block_content>
                    <comment type="block">/* empty */</comment>
                    <expr_stmt><expr><name>someMoreWork</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
            <comment type="block">/* compress current block (note : this stage cannot be stopped in the middle) */</comment>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"stream compression stage (flushMode==%u)"</literal></expr></argument>, <argument><expr><name>flushMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <block>{<block_content>   <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>inputBuffered</name> <init>= <expr><operator>(</operator><name><name>zcs</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>inBufferMode</name></name> <operator>==</operator> <name>ZSTD_bm_buffered</name><operator>)</operator></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>cDst</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>size_t</name></type> <name>cSize</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>size_t</name></type> <name>oSize</name> <init>= <expr><name>oend</name><operator>-</operator><name>op</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>iSize</name> <init>= <expr><ternary><condition><expr><name>inputBuffered</name></expr> ?</condition><then> <expr><name><name>zcs</name><operator>-&gt;</operator><name>inBuffPos</name></name> <operator>-</operator> <name><name>zcs</name><operator>-&gt;</operator><name>inToCompress</name></name></expr>
                                                   </then><else>: <expr><call><name>MIN</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>iend</name> <operator>-</operator> <name>ip</name><operator>)</operator></expr></argument>, <argument><expr><name><name>zcs</name><operator>-&gt;</operator><name>blockSize</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>oSize</name> <operator>&gt;=</operator> <call><name>ZSTD_compressBound</name><argument_list>(<argument><expr><name>iSize</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>zcs</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>outBufferMode</name></name> <operator>==</operator> <name>ZSTD_bm_stable</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>cDst</name> <operator>=</operator> <name>op</name></expr>;</expr_stmt></block_content></block></if>   <comment type="block">/* compress into output buffer, to skip flush stage */</comment>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>cDst</name> <operator>=</operator> <name><name>zcs</name><operator>-&gt;</operator><name>outBuff</name></name></expr><operator>,</operator> <expr><name>oSize</name> <operator>=</operator> <name><name>zcs</name><operator>-&gt;</operator><name>outBuffSize</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>inputBuffered</name></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>lastBlock</name> <init>= <expr><operator>(</operator><name>flushMode</name> <operator>==</operator> <name>ZSTD_e_end</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>ip</name><operator>==</operator><name>iend</name><operator>)</operator></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>cSize</name> <operator>=</operator> <ternary><condition><expr><name>lastBlock</name></expr> ?</condition><then>
                            <expr><call><name>ZSTD_compressEnd</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>cDst</name></expr></argument>, <argument><expr><name>oSize</name></expr></argument>,
                                        <argument><expr><name><name>zcs</name><operator>-&gt;</operator><name>inBuff</name></name> <operator>+</operator> <name><name>zcs</name><operator>-&gt;</operator><name>inToCompress</name></name></expr></argument>, <argument><expr><name>iSize</name></expr></argument>)</argument_list></call></expr> </then><else>:
                            <expr><call><name>ZSTD_compressContinue</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>cDst</name></expr></argument>, <argument><expr><name>oSize</name></expr></argument>,
                                        <argument><expr><name><name>zcs</name><operator>-&gt;</operator><name>inBuff</name></name> <operator>+</operator> <name><name>zcs</name><operator>-&gt;</operator><name>inToCompress</name></name></expr></argument>, <argument><expr><name>iSize</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>lastBlock</name></expr> ?</condition><then> <expr><literal type="string">"ZSTD_compressEnd failed"</literal></expr> </then><else>: <expr><literal type="string">"ZSTD_compressContinue failed"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>zcs</name><operator>-&gt;</operator><name>frameEnded</name></name> <operator>=</operator> <name>lastBlock</name></expr>;</expr_stmt>
                    <comment type="block">/* prepare next block */</comment>
                    <expr_stmt><expr><name><name>zcs</name><operator>-&gt;</operator><name>inBuffTarget</name></name> <operator>=</operator> <name><name>zcs</name><operator>-&gt;</operator><name>inBuffPos</name></name> <operator>+</operator> <name><name>zcs</name><operator>-&gt;</operator><name>blockSize</name></name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>zcs</name><operator>-&gt;</operator><name>inBuffTarget</name></name> <operator>&gt;</operator> <name><name>zcs</name><operator>-&gt;</operator><name>inBuffSize</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>zcs</name><operator>-&gt;</operator><name>inBuffPos</name></name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name><name>zcs</name><operator>-&gt;</operator><name>inBuffTarget</name></name> <operator>=</operator> <name><name>zcs</name><operator>-&gt;</operator><name>blockSize</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"inBuffTarget:%u / inBuffSize:%u"</literal></expr></argument>,
                            <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>zcs</name><operator>-&gt;</operator><name>inBuffTarget</name></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>zcs</name><operator>-&gt;</operator><name>inBuffSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>lastBlock</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>zcs</name><operator>-&gt;</operator><name>inBuffTarget</name></name> <operator>&lt;=</operator> <name><name>zcs</name><operator>-&gt;</operator><name>inBuffSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name><name>zcs</name><operator>-&gt;</operator><name>inToCompress</name></name> <operator>=</operator> <name><name>zcs</name><operator>-&gt;</operator><name>inBuffPos</name></name></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content> <comment type="block">/* !inputBuffered, hence ZSTD_bm_stable */</comment>
                    <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>lastBlock</name> <init>= <expr><operator>(</operator><name>flushMode</name> <operator>==</operator> <name>ZSTD_e_end</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>ip</name> <operator>+</operator> <name>iSize</name> <operator>==</operator> <name>iend</name><operator>)</operator></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>cSize</name> <operator>=</operator> <ternary><condition><expr><name>lastBlock</name></expr> ?</condition><then>
                            <expr><call><name>ZSTD_compressEnd</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>cDst</name></expr></argument>, <argument><expr><name>oSize</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iSize</name></expr></argument>)</argument_list></call></expr> </then><else>:
                            <expr><call><name>ZSTD_compressContinue</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>cDst</name></expr></argument>, <argument><expr><name>oSize</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iSize</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
                    <comment type="block">/* Consume the input prior to error checking to mirror buffered mode. */</comment>
                    <if_stmt><if>if <condition>(<expr><name>ip</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>iSize</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>lastBlock</name></expr> ?</condition><then> <expr><literal type="string">"ZSTD_compressEnd failed"</literal></expr> </then><else>: <expr><literal type="string">"ZSTD_compressContinue failed"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>zcs</name><operator>-&gt;</operator><name>frameEnded</name></name> <operator>=</operator> <name>lastBlock</name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>lastBlock</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ip</name> <operator>==</operator> <name>iend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></else></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>cDst</name> <operator>==</operator> <name>op</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* no need to flush */</comment>
                    <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>cSize</name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>zcs</name><operator>-&gt;</operator><name>frameEnded</name></name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Frame completed directly in outBuffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>someMoreWork</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>ZSTD_CCtx_reset</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>ZSTD_reset_session_only</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>zcs</name><operator>-&gt;</operator><name>outBuffContentSize</name></name> <operator>=</operator> <name>cSize</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>zcs</name><operator>-&gt;</operator><name>outBuffFlushedSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>zcs</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>=</operator> <name>zcss_flush</name></expr>;</expr_stmt> <comment type="block">/* pass-through to flush stage */</comment>
            </block_content>}</block>
	    <expr_stmt><expr><name>ZSTD_FALLTHROUGH</name></expr>;</expr_stmt>
        <case>case <expr><name>zcss_flush</name></expr>:</case>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"flush stage"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>zcs</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>outBufferMode</name></name> <operator>==</operator> <name>ZSTD_bm_buffered</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>toFlush</name> <init>= <expr><name><name>zcs</name><operator>-&gt;</operator><name>outBuffContentSize</name></name> <operator>-</operator> <name><name>zcs</name><operator>-&gt;</operator><name>outBuffFlushedSize</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>flushed</name> <init>= <expr><call><name>ZSTD_limitCopy</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name><operator>-</operator><name>op</name><operator>)</operator></expr></argument>,
                            <argument><expr><name><name>zcs</name><operator>-&gt;</operator><name>outBuff</name></name> <operator>+</operator> <name><name>zcs</name><operator>-&gt;</operator><name>outBuffFlushedSize</name></name></expr></argument>, <argument><expr><name>toFlush</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"toFlush: %u into %u ==&gt; flushed: %u"</literal></expr></argument>,
                            <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>toFlush</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name>oend</name><operator>-</operator><name>op</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>flushed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>flushed</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>flushed</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name><name>zcs</name><operator>-&gt;</operator><name>outBuffFlushedSize</name></name> <operator>+=</operator> <name>flushed</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>toFlush</name><operator>!=</operator><name>flushed</name></expr>)</condition> <block>{<block_content>
                    <comment type="block">/* flush not fully completed, presumably because dst is too small */</comment>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>oend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>someMoreWork</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>zcs</name><operator>-&gt;</operator><name>outBuffContentSize</name></name> <operator>=</operator> <name><name>zcs</name><operator>-&gt;</operator><name>outBuffFlushedSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>zcs</name><operator>-&gt;</operator><name>frameEnded</name></name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Frame completed on flush"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>someMoreWork</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ZSTD_CCtx_reset</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>ZSTD_reset_session_only</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>zcs</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>=</operator> <name>zcss_load</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <default>default:</default> <comment type="block">/* impossible */</comment>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
    </block_content>}</block></while>

    <expr_stmt><expr><name><name>input</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name>ip</name> <operator>-</operator> <name>istart</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>output</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name>op</name> <operator>-</operator> <name>ostart</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>zcs</name><operator>-&gt;</operator><name>frameEnded</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>ZSTD_nextInputSizeHint</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_nextInputSizeHint_MTorST</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ZSTD_MULTITHREAD</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>nbWorkers</name></name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>mtctx</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>ZSTDMT_nextInputSizeHint</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>mtctx</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><call><name>ZSTD_nextInputSizeHint</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressStream</name><parameter_list>(<parameter><decl><type><name>ZSTD_CStream</name><modifier>*</modifier></type> <name>zcs</name></decl></parameter>, <parameter><decl><type><name>ZSTD_outBuffer</name><modifier>*</modifier></type> <name>output</name></decl></parameter>, <parameter><decl><type><name>ZSTD_inBuffer</name><modifier>*</modifier></type> <name>input</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_compressStream2</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>ZSTD_e_continue</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>ZSTD_nextInputSizeHint_MTorST</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* After a compression call set the expected input/output buffer.
 * This is validated at the start of the next compression call.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ZSTD_setBufferExpectations</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ZSTD_outBuffer</name><modifier>*</modifier></type> <name>output</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ZSTD_inBuffer</name><modifier>*</modifier></type> <name>input</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_setBufferExpectations (for advanced stable in/out modes)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>inBufferMode</name></name> <operator>==</operator> <name>ZSTD_bm_stable</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>expectedInBuffer</name></name> <operator>=</operator> <operator>*</operator><name>input</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>outBufferMode</name></name> <operator>==</operator> <name>ZSTD_bm_stable</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>expectedOutBufferSize</name></name> <operator>=</operator> <name><name>output</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name><name>output</name><operator>-&gt;</operator><name>pos</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Validate that the input/output buffers match the expectations set by
 * ZSTD_setBufferExpectations.
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_checkBufferStability</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name> <specifier>const</specifier><modifier>*</modifier></type> <name>cctx</name></decl></parameter>,
                                        <parameter><decl><type><name>ZSTD_outBuffer</name> <specifier>const</specifier><modifier>*</modifier></type> <name>output</name></decl></parameter>,
                                        <parameter><decl><type><name>ZSTD_inBuffer</name> <specifier>const</specifier><modifier>*</modifier></type> <name>input</name></decl></parameter>,
                                        <parameter><decl><type><name>ZSTD_EndDirective</name></type> <name>endOp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>inBufferMode</name></name> <operator>==</operator> <name>ZSTD_bm_stable</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>ZSTD_inBuffer</name> <specifier>const</specifier></type> <name>expect</name> <init>= <expr><name><name>cctx</name><operator>-&gt;</operator><name>expectedInBuffer</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>expect</name><operator>.</operator><name>src</name></name> <operator>!=</operator> <name><name>input</name><operator>-&gt;</operator><name>src</name></name> <operator>||</operator> <name><name>expect</name><operator>.</operator><name>pos</name></name> <operator>!=</operator> <name><name>input</name><operator>-&gt;</operator><name>pos</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr><name>stabilityCondition_notRespected</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_c_stableInBuffer enabled but input differs!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>endOp</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>outBufferMode</name></name> <operator>==</operator> <name>ZSTD_bm_stable</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>outBufferSize</name> <init>= <expr><name><name>output</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name><name>output</name><operator>-&gt;</operator><name>pos</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>expectedOutBufferSize</name></name> <operator>!=</operator> <name>outBufferSize</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr><name>stabilityCondition_notRespected</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_c_stableOutBuffer enabled but output size differs!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_CCtx_init_compressStream2</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>,
                                             <parameter><decl><type><name>ZSTD_EndDirective</name></type> <name>endOp</name></decl></parameter>,
                                             <parameter><decl><type><name>size_t</name></type> <name>inSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_CCtx_params</name></type> <name>params</name> <init>= <expr><name><name>cctx</name><operator>-&gt;</operator><name>requestedParams</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_prefixDict</name> <specifier>const</specifier></type> <name>prefixDict</name> <init>= <expr><name><name>cctx</name><operator>-&gt;</operator><name>prefixDict</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_initLocalDict</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Init the local dict if present. */</comment>
    <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>prefixDict</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>prefixDict</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* single usage */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>prefixDict</name><operator>.</operator><name>dict</name></name><operator>==</operator><name>NULL</name> <operator>||</operator> <name><name>cctx</name><operator>-&gt;</operator><name>cdict</name></name><operator>==</operator><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* only one can be set */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>cdict</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>cctx</name><operator>-&gt;</operator><name>localDict</name><operator>.</operator><name>cdict</name></name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Let the cdict's compression level take priority over the requested params.
         * But do not take the cdict's compression level if the "cdict" is actually a localDict
         * generated from ZSTD_initLocalDict().
         */</comment>
        <expr_stmt><expr><name><name>params</name><operator>.</operator><name>compressionLevel</name></name> <operator>=</operator> <name><name>cctx</name><operator>-&gt;</operator><name>cdict</name><operator>-&gt;</operator><name>compressionLevel</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressStream2 : transparent init stage"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>endOp</name> <operator>==</operator> <name>ZSTD_e_end</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>pledgedSrcSizePlusOne</name></name> <operator>=</operator> <name>inSize</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* auto-determine pledgedSrcSize */</comment>

    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>dictSize</name> <init>= <expr><ternary><condition><expr><name><name>prefixDict</name><operator>.</operator><name>dict</name></name></expr>
                ?</condition><then> <expr><name><name>prefixDict</name><operator>.</operator><name>dictSize</name></name></expr>
                </then><else>: <expr><operator>(</operator><ternary><condition><expr><name><name>cctx</name><operator>-&gt;</operator><name>cdict</name></name></expr> ?</condition><then> <expr><name><name>cctx</name><operator>-&gt;</operator><name>cdict</name><operator>-&gt;</operator><name>dictContentSize</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ZSTD_cParamMode_e</name> <specifier>const</specifier></type> <name>mode</name> <init>= <expr><call><name>ZSTD_getCParamMode</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>cdict</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>pledgedSrcSizePlusOne</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>params</name><operator>.</operator><name>cParams</name></name> <operator>=</operator> <call><name>ZSTD_getCParamsFromCCtxParams</name><argument_list>(
                <argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>pledgedSrcSizePlusOne</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>,
                <argument><expr><name>dictSize</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name><name>params</name><operator>.</operator><name>useBlockSplitter</name></name> <operator>=</operator> <call><name>ZSTD_resolveBlockSplitterMode</name><argument_list>(<argument><expr><name><name>params</name><operator>.</operator><name>useBlockSplitter</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>params</name><operator>.</operator><name>cParams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>params</name><operator>.</operator><name>ldmParams</name><operator>.</operator><name>enableLdm</name></name> <operator>=</operator> <call><name>ZSTD_resolveEnableLdm</name><argument_list>(<argument><expr><name><name>params</name><operator>.</operator><name>ldmParams</name><operator>.</operator><name>enableLdm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>params</name><operator>.</operator><name>cParams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>params</name><operator>.</operator><name>useRowMatchFinder</name></name> <operator>=</operator> <call><name>ZSTD_resolveRowMatchFinderMode</name><argument_list>(<argument><expr><name><name>params</name><operator>.</operator><name>useRowMatchFinder</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>params</name><operator>.</operator><name>cParams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ZSTD_MULTITHREAD</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cctx</name><operator>-&gt;</operator><name>pledgedSrcSizePlusOne</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;=</operator> <name>ZSTDMT_JOBSIZE_MIN</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>params</name><operator>.</operator><name>nbWorkers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* do not invoke multi-threading when src size is too small */</comment>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>.</operator><name>nbWorkers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ZSTD_TRACE</name></expr></cpp:if>
        <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>traceCtx</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>ZSTD_trace_compress_begin</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>ZSTD_trace_compress_begin</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* mt context creation */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>mtctx</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressStream2: creating new mtctx for nbWorkers=%u"</literal></expr></argument>,
                        <argument><expr><name><name>params</name><operator>.</operator><name>nbWorkers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>mtctx</name></name> <operator>=</operator> <call><name>ZSTDMT_createCCtx_advanced</name><argument_list>(<argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>params</name><operator>.</operator><name>nbWorkers</name></name></expr></argument>, <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>customMem</name></name></expr></argument>, <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>mtctx</name></name> <operator>==</operator> <name>NULL</name></expr></argument>, <argument><expr><name>memory_allocation</name></expr></argument>, <argument><expr><literal type="string">"NULL pointer!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* mt compression */</comment>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"call ZSTDMT_initCStream_internal as nbWorkers=%u"</literal></expr></argument>, <argument><expr><name><name>params</name><operator>.</operator><name>nbWorkers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTDMT_initCStream_internal</name><argument_list>(
                    <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>mtctx</name></name></expr></argument>,
                    <argument><expr><name><name>prefixDict</name><operator>.</operator><name>dict</name></name></expr></argument>, <argument><expr><name><name>prefixDict</name><operator>.</operator><name>dictSize</name></name></expr></argument>, <argument><expr><name><name>prefixDict</name><operator>.</operator><name>dictContentType</name></name></expr></argument>,
                    <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>cdict</name></name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>pledgedSrcSizePlusOne</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>dictID</name></name> <operator>=</operator> <ternary><condition><expr><name><name>cctx</name><operator>-&gt;</operator><name>cdict</name></name></expr> ?</condition><then> <expr><name><name>cctx</name><operator>-&gt;</operator><name>cdict</name><operator>-&gt;</operator><name>dictID</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>dictContentSize</name></name> <operator>=</operator> <ternary><condition><expr><name><name>cctx</name><operator>-&gt;</operator><name>cdict</name></name></expr> ?</condition><then> <expr><name><name>cctx</name><operator>-&gt;</operator><name>cdict</name><operator>-&gt;</operator><name>dictContentSize</name></name></expr> </then><else>: <expr><name><name>prefixDict</name><operator>.</operator><name>dictSize</name></name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>consumedSrcSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>producedCSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>=</operator> <name>zcss_load</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name></name> <operator>=</operator> <name>params</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* ZSTD_MULTITHREAD */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>U64</name> <specifier>const</specifier></type> <name>pledgedSrcSize</name> <init>= <expr><name><name>cctx</name><operator>-&gt;</operator><name>pledgedSrcSizePlusOne</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ZSTD_isError</name><argument_list>(<argument><expr><call><name>ZSTD_checkCParams</name><argument_list>(<argument><expr><name><name>params</name><operator>.</operator><name>cParams</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_compressBegin_internal</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>,
                <argument><expr><name><name>prefixDict</name><operator>.</operator><name>dict</name></name></expr></argument>, <argument><expr><name><name>prefixDict</name><operator>.</operator><name>dictSize</name></name></expr></argument>, <argument><expr><name><name>prefixDict</name><operator>.</operator><name>dictContentType</name></name></expr></argument>, <argument><expr><name>ZSTD_dtlm_fast</name></expr></argument>,
                <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>cdict</name></name></expr></argument>,
                <argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><name>pledgedSrcSize</name></expr></argument>,
                <argument><expr><name>ZSTDb_buffered</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>nbWorkers</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>inToCompress</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>inBuffPos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>inBufferMode</name></name> <operator>==</operator> <name>ZSTD_bm_buffered</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* for small input: avoid automatic flush on reaching end of block, since
            * it would require to add a 3-bytes null block to end frame
            */</comment>
            <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>inBuffTarget</name></name> <operator>=</operator> <name><name>cctx</name><operator>-&gt;</operator><name>blockSize</name></name> <operator>+</operator> <operator>(</operator><name><name>cctx</name><operator>-&gt;</operator><name>blockSize</name></name> <operator>==</operator> <name>pledgedSrcSize</name><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>inBuffTarget</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>outBuffContentSize</name></name> <operator>=</operator> <name><name>cctx</name><operator>-&gt;</operator><name>outBuffFlushedSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>=</operator> <name>zcss_load</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>frameEnded</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* @return provides a minimum amount of data remaining to be flushed from internal buffers
 */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_compressStream2</name><parameter_list>( <parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>,
                             <parameter><decl><type><name>ZSTD_outBuffer</name><modifier>*</modifier></type> <name>output</name></decl></parameter>,
                             <parameter><decl><type><name>ZSTD_inBuffer</name><modifier>*</modifier></type> <name>input</name></decl></parameter>,
                             <parameter><decl><type><name>ZSTD_EndDirective</name></type> <name>endOp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressStream2, endOp=%u "</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>endOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* check conditions */</comment>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>output</name><operator>-&gt;</operator><name>pos</name></name> <operator>&gt;</operator> <name><name>output</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">"invalid output buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>input</name><operator>-&gt;</operator><name>pos</name></name>  <operator>&gt;</operator> <name><name>input</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>srcSize_wrong</name></expr></argument>, <argument><expr><literal type="string">"invalid input buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>endOp</name> <operator>&gt;</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>ZSTD_e_end</name></expr></argument>, <argument><expr><name>parameter_outOfBound</name></expr></argument>, <argument><expr><literal type="string">"invalid endDirective"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>cctx</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* transparent initialization stage */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>streamStage</name></name> <operator>==</operator> <name>zcss_init</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>inputSize</name> <init>= <expr><name><name>input</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name><name>input</name><operator>-&gt;</operator><name>pos</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* no obligation to start from pos==0 */</comment>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>totalInputSize</name> <init>= <expr><name>inputSize</name> <operator>+</operator> <name><name>cctx</name><operator>-&gt;</operator><name>stableIn_notConsumed</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>( <expr><operator>(</operator><name><name>cctx</name><operator>-&gt;</operator><name>requestedParams</name><operator>.</operator><name>inBufferMode</name></name> <operator>==</operator> <name>ZSTD_bm_stable</name><operator>)</operator> <comment type="block">/* input is presumed stable, across invocations */</comment>
          <operator>&amp;&amp;</operator> <operator>(</operator><name>endOp</name> <operator>==</operator> <name>ZSTD_e_continue</name><operator>)</operator>                             <comment type="block">/* no flush requested, more input to come */</comment>
          <operator>&amp;&amp;</operator> <operator>(</operator><name>totalInputSize</name> <operator>&lt;</operator> <name>ZSTD_BLOCKSIZE_MAX</name><operator>)</operator></expr> )</condition> <block>{<block_content>              <comment type="block">/* not even reached one block yet */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>stableIn_notConsumed</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* not the first time */</comment>
                <comment type="block">/* check stable source guarantees */</comment>
                <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>input</name><operator>-&gt;</operator><name>src</name></name> <operator>!=</operator> <name><name>cctx</name><operator>-&gt;</operator><name>expectedInBuffer</name><operator>.</operator><name>src</name></name></expr></argument>, <argument><expr><name>stabilityCondition_notRespected</name></expr></argument>, <argument><expr><literal type="string">"stableInBuffer condition not respected: wrong src pointer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>input</name><operator>-&gt;</operator><name>pos</name></name> <operator>!=</operator> <name><name>cctx</name><operator>-&gt;</operator><name>expectedInBuffer</name><operator>.</operator><name>size</name></name></expr></argument>, <argument><expr><name>stabilityCondition_notRespected</name></expr></argument>, <argument><expr><literal type="string">"stableInBuffer condition not respected: externally modified pos"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* pretend input was consumed, to give a sense forward progress */</comment>
            <expr_stmt><expr><name><name>input</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name><name>input</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
            <comment type="block">/* save stable inBuffer, for later control, and flush/end */</comment>
            <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>expectedInBuffer</name></name> <operator>=</operator> <operator>*</operator><name>input</name></expr>;</expr_stmt>
            <comment type="block">/* but actually input wasn't consumed, so keep track of position from where compression shall resume */</comment>
            <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>stableIn_notConsumed</name></name> <operator>+=</operator> <name>inputSize</name></expr>;</expr_stmt>
            <comment type="block">/* don't initialize yet, wait for the first block of flush() order, for better parameters adaptation */</comment>
            <return>return <expr><call><name>ZSTD_FRAMEHEADERSIZE_MIN</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>requestedParams</name><operator>.</operator><name>format</name></name></expr></argument>)</argument_list></call></expr>;</return>  <comment type="block">/* at least some header to produce */</comment>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_CCtx_init_compressStream2</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>endOp</name></expr></argument>, <argument><expr><name>totalInputSize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"compressStream2 initialization failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_setBufferExpectations</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* Set initial buffer expectations now that we've initialized */</comment>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* end of transparent initialization stage */</comment>

    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_checkBufferStability</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>endOp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"invalid buffers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* compression stage */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ZSTD_MULTITHREAD</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>nbWorkers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>flushMin</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>cParamsChanged</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>ZSTDMT_updateCParams_whileCompressing</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>mtctx</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>requestedParams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>cParamsChanged</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>stableIn_notConsumed</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>inBufferMode</name></name> <operator>==</operator> <name>ZSTD_bm_stable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* some early data was skipped - make it available for consumption */</comment>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>input</name><operator>-&gt;</operator><name>pos</name></name> <operator>&gt;=</operator> <name><name>cctx</name><operator>-&gt;</operator><name>stableIn_notConsumed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>input</name><operator>-&gt;</operator><name>pos</name></name> <operator>-=</operator> <name><name>cctx</name><operator>-&gt;</operator><name>stableIn_notConsumed</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>stableIn_notConsumed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>ipos</name> <init>= <expr><name><name>input</name><operator>-&gt;</operator><name>pos</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>opos</name> <init>= <expr><name><name>output</name><operator>-&gt;</operator><name>pos</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>flushMin</name> <operator>=</operator> <call><name>ZSTDMT_compressStream_generic</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>mtctx</name></name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>endOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>consumedSrcSize</name></name> <operator>+=</operator> <operator>(</operator><name>U64</name><operator>)</operator><operator>(</operator><name><name>input</name><operator>-&gt;</operator><name>pos</name></name> <operator>-</operator> <name>ipos</name><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>producedCSize</name></name> <operator>+=</operator> <operator>(</operator><name>U64</name><operator>)</operator><operator>(</operator><name><name>output</name><operator>-&gt;</operator><name>pos</name></name> <operator>-</operator> <name>opos</name><operator>)</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>( <expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>flushMin</name></expr></argument>)</argument_list></call>
              <operator>||</operator> <operator>(</operator><name>endOp</name> <operator>==</operator> <name>ZSTD_e_end</name> <operator>&amp;&amp;</operator> <name>flushMin</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> )</condition> <block>{<block_content> <comment type="block">/* compression completed */</comment>
                <if_stmt><if>if <condition>(<expr><name>flushMin</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ZSTD_CCtx_trace</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>ZSTD_CCtx_reset</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ZSTD_reset_session_only</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>flushMin</name></expr></argument>, <argument><expr><literal type="string">"ZSTDMT_compressStream_generic failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>endOp</name> <operator>==</operator> <name>ZSTD_e_continue</name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* We only require some progress with ZSTD_e_continue, not maximal progress.
                 * We're done if we've consumed or produced any bytes, or either buffer is
                 * full.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>input</name><operator>-&gt;</operator><name>pos</name></name> <operator>!=</operator> <name>ipos</name> <operator>||</operator> <name><name>output</name><operator>-&gt;</operator><name>pos</name></name> <operator>!=</operator> <name>opos</name> <operator>||</operator> <name><name>input</name><operator>-&gt;</operator><name>pos</name></name> <operator>==</operator> <name><name>input</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> <name><name>output</name><operator>-&gt;</operator><name>pos</name></name> <operator>==</operator> <name><name>output</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>endOp</name> <operator>==</operator> <name>ZSTD_e_flush</name> <operator>||</operator> <name>endOp</name> <operator>==</operator> <name>ZSTD_e_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* We require maximal progress. We're done when the flush is complete or the
                 * output buffer is full.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>flushMin</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>output</name><operator>-&gt;</operator><name>pos</name></name> <operator>==</operator> <name><name>output</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"completed ZSTD_compressStream2 delegating to ZSTDMT_compressStream_generic"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Either we don't require maximum forward progress, we've finished the
         * flush, or we are out of output space.
         */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>endOp</name> <operator>==</operator> <name>ZSTD_e_continue</name> <operator>||</operator> <name>flushMin</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>output</name><operator>-&gt;</operator><name>pos</name></name> <operator>==</operator> <name><name>output</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_setBufferExpectations</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>flushMin</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ZSTD_MULTITHREAD */</comment>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>( <argument><expr><call><name>ZSTD_compressStream_generic</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>endOp</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"completed ZSTD_compressStream2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_setBufferExpectations</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>cctx</name><operator>-&gt;</operator><name>outBuffContentSize</name></name> <operator>-</operator> <name><name>cctx</name><operator>-&gt;</operator><name>outBuffFlushedSize</name></name></expr>;</return> <comment type="block">/* remaining to flush */</comment>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressStream2_simpleArgs</name> <parameter_list>(
                            <parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>,
                            <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>dstPos</name></decl></parameter>,
                      <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>srcPos</name></decl></parameter>,
                            <parameter><decl><type><name>ZSTD_EndDirective</name></type> <name>endOp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_outBuffer</name></type> <name>output</name> <init>= <expr><block>{ <expr><name>dst</name></expr>, <expr><name>dstCapacity</name></expr>, <expr><operator>*</operator><name>dstPos</name></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_inBuffer</name></type>  <name>input</name>  <init>= <expr><block>{ <expr><name>src</name></expr>, <expr><name>srcSize</name></expr>, <expr><operator>*</operator><name>srcPos</name></expr> }</block></expr></init></decl>;</decl_stmt>
    <comment type="block">/* ZSTD_compressStream2() will check validity of dstPos and srcPos */</comment>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>cErr</name> <init>= <expr><call><name>ZSTD_compressStream2</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>input</name></expr></argument>, <argument><expr><name>endOp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><name>dstPos</name> <operator>=</operator> <name><name>output</name><operator>.</operator><name>pos</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>srcPos</name> <operator>=</operator> <name><name>input</name><operator>.</operator><name>pos</name></name></expr>;</expr_stmt>
    <return>return <expr><name>cErr</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compress2</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>,
                      <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                      <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_bufferMode_e</name> <specifier>const</specifier></type> <name>originalInBufferMode</name> <init>= <expr><name><name>cctx</name><operator>-&gt;</operator><name>requestedParams</name><operator>.</operator><name>inBufferMode</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_bufferMode_e</name> <specifier>const</specifier></type> <name>originalOutBufferMode</name> <init>= <expr><name><name>cctx</name><operator>-&gt;</operator><name>requestedParams</name><operator>.</operator><name>outBufferMode</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compress2 (srcSize=%u)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_CCtx_reset</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ZSTD_reset_session_only</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Enable stable input/output buffers. */</comment>
    <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>requestedParams</name><operator>.</operator><name>inBufferMode</name></name> <operator>=</operator> <name>ZSTD_bm_stable</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>requestedParams</name><operator>.</operator><name>outBufferMode</name></name> <operator>=</operator> <name>ZSTD_bm_stable</name></expr>;</expr_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name></type> <name>oPos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>iPos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>result</name> <init>= <expr><call><name>ZSTD_compressStream2_simpleArgs</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>,
                                        <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oPos</name></expr></argument>,
                                        <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPos</name></expr></argument>,
                                        <argument><expr><name>ZSTD_e_end</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="block">/* Reset to the original values. */</comment>
        <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>requestedParams</name><operator>.</operator><name>inBufferMode</name></name> <operator>=</operator> <name>originalInBufferMode</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>requestedParams</name><operator>.</operator><name>outBufferMode</name></name> <operator>=</operator> <name>originalOutBufferMode</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressStream2_simpleArgs failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* compression not completed, due to lack of output space */</comment>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>oPos</name> <operator>==</operator> <name>dstCapacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>iPos</name> <operator>==</operator> <name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* all input is expected consumed */</comment>
        <return>return <expr><name>oPos</name></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>U32</name></type> <name>idx</name></decl>;</decl_stmt>            <comment type="block">/* Index in array of ZSTD_Sequence */</comment>
    <decl_stmt><decl><type><name>U32</name></type> <name>posInSequence</name></decl>;</decl_stmt>  <comment type="block">/* Position within sequence at idx */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>posInSrc</name></decl>;</decl_stmt>    <comment type="block">/* Number of bytes given by sequences provided so far */</comment>
}</block></struct></type> <name>ZSTD_sequencePosition</name>;</typedef>

<comment type="block">/* ZSTD_validateSequence() :
 * @offCode : is presumed to follow format required by ZSTD_storeSeq()
 * @returns a ZSTD error code if sequence is not valid
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>ZSTD_validateSequence</name><parameter_list>(<parameter><decl><type><name>U32</name></type> <name>offCode</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>matchLength</name></decl></parameter>,
                      <parameter><decl><type><name>size_t</name></type> <name>posInSrc</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>windowLog</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>windowSize</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>windowLog</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* posInSrc represents the amount of data the decoder would decode up to this point.
     * As long as the amount of data decoded is less than or equal to window size, offsets may be
     * larger than the total length of output decoded in order to reference the dict, even larger than
     * window size. After output surpasses windowSize, we're limited to windowSize offsets again.
     */</comment>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>offsetBound</name> <init>= <expr><ternary><condition><expr><name>posInSrc</name> <operator>&gt;</operator> <name>windowSize</name></expr> ?</condition><then> <expr><operator>(</operator><name>size_t</name><operator>)</operator><name>windowSize</name></expr> </then><else>: <expr><name>posInSrc</name> <operator>+</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>dictSize</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>offCode</name> <operator>&gt;</operator> <call><name>OFFSET_TO_OFFBASE</name><argument_list>(<argument><expr><name>offsetBound</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">"Offset too large!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>matchLength</name> <operator>&lt;</operator> <name>MINMATCH</name></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">"Matchlength too small"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Returns an offset code, given a sequence's raw offset, the ongoing repcode array, and whether litLength == 0 */</comment>
<function><type><specifier>static</specifier> <name>U32</name></type> <name>ZSTD_finalizeOffBase</name><parameter_list>(<parameter><decl><type><name>U32</name></type> <name>rawOffset</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>U32</name></type> <name><name>rep</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>ll0</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name></type> <name>offBase</name> <init>= <expr><call><name>OFFSET_TO_OFFBASE</name><argument_list>(<argument><expr><name>rawOffset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ll0</name> <operator>&amp;&amp;</operator> <name>rawOffset</name> <operator>==</operator> <name><name>rep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>offBase</name> <operator>=</operator> <name>REPCODE1_TO_OFFBASE</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>rawOffset</name> <operator>==</operator> <name><name>rep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>offBase</name> <operator>=</operator> <call><name>REPCODE_TO_OFFBASE</name><argument_list>(<argument><expr><literal type="number">2</literal> <operator>-</operator> <name>ll0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>rawOffset</name> <operator>==</operator> <name><name>rep</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>offBase</name> <operator>=</operator> <call><name>REPCODE_TO_OFFBASE</name><argument_list>(<argument><expr><literal type="number">3</literal> <operator>-</operator> <name>ll0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ll0</name> <operator>&amp;&amp;</operator> <name>rawOffset</name> <operator>==</operator> <name><name>rep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>offBase</name> <operator>=</operator> <name>REPCODE3_TO_OFFBASE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>offBase</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Returns 0 on success, and a ZSTD_error otherwise. This function scans through an array of
 * ZSTD_Sequence, storing the sequences it finds, until it reaches a block delimiter.
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>ZSTD_copySequencesToSeqStoreExplicitBlockDelim</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>,
                                              <parameter><decl><type><name>ZSTD_sequencePosition</name><modifier>*</modifier></type> <name>seqPos</name></decl></parameter>,
                                        <parameter><decl><type><specifier>const</specifier> <name>ZSTD_Sequence</name><modifier>*</modifier> <specifier>const</specifier></type> <name>inSeqs</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>inSeqsSize</name></decl></parameter>,
                                        <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>blockSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name></type> <name>idx</name> <init>= <expr><name><name>seqPos</name><operator>-&gt;</operator><name>idx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>ip</name> <init>= <expr><operator>(</operator><name>BYTE</name> <specifier>const</specifier><operator>*</operator><operator>)</operator><operator>(</operator><name>src</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name> <init>= <expr><name>ip</name> <operator>+</operator> <name>blockSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>repcodes_t</name></type> <name>updatedRepcodes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>dictSize</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_copySequencesToSeqStoreExplicitBlockDelim (blockSize = %zu)"</literal></expr></argument>, <argument><expr><name>blockSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>cdict</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>dictSize</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name><name>cctx</name><operator>-&gt;</operator><name>cdict</name><operator>-&gt;</operator><name>dictContentSize</name></name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>prefixDict</name><operator>.</operator><name>dict</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>dictSize</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name><name>cctx</name><operator>-&gt;</operator><name>prefixDict</name><operator>.</operator><name>dictSize</name></name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>dictSize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name><name>updatedRepcodes</name><operator>.</operator><name>rep</name></name></expr></argument>, <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name><operator>-&gt;</operator><name>rep</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repcodes_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name>inSeqsSize</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>inSeqs</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>matchLength</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>inSeqs</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</condition> <incr><expr><operator>++</operator><name>idx</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>litLength</name> <init>= <expr><name><name>inSeqs</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>litLength</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>ll0</name> <init>= <expr><operator>(</operator><name>litLength</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>matchLength</name> <init>= <expr><name><name>inSeqs</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>matchLength</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>offBase</name> <init>= <expr><call><name>ZSTD_finalizeOffBase</name><argument_list>(<argument><expr><name><name>inSeqs</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>offset</name></expr></argument>, <argument><expr><name><name>updatedRepcodes</name><operator>.</operator><name>rep</name></name></expr></argument>, <argument><expr><name>ll0</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ZSTD_updateRep</name><argument_list>(<argument><expr><name><name>updatedRepcodes</name><operator>.</operator><name>rep</name></name></expr></argument>, <argument><expr><name>offBase</name></expr></argument>, <argument><expr><name>ll0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"Storing sequence: (of: %u, ml: %u, ll: %u)"</literal></expr></argument>, <argument><expr><name>offBase</name></expr></argument>, <argument><expr><name>matchLength</name></expr></argument>, <argument><expr><name>litLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>validateSequences</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>seqPos</name><operator>-&gt;</operator><name>posInSrc</name></name> <operator>+=</operator> <name>litLength</name> <operator>+</operator> <name>matchLength</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_validateSequence</name><argument_list>(<argument><expr><name>offBase</name></expr></argument>, <argument><expr><name>matchLength</name></expr></argument>, <argument><expr><name><name>seqPos</name><operator>-&gt;</operator><name>posInSrc</name></name></expr></argument>,
                                                <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>cParams</name><operator>.</operator><name>windowLog</name></name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>)</argument_list></call></expr></argument>,
                                                <argument><expr><literal type="string">"Sequence validation failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>idx</name> <operator>-</operator> <name><name>seqPos</name><operator>-&gt;</operator><name>idx</name></name> <operator>&gt;</operator> <name><name>cctx</name><operator>-&gt;</operator><name>seqStore</name><operator>.</operator><name>maxNbSeq</name></name></expr></argument>, <argument><expr><name>memory_allocation</name></expr></argument>,
                        <argument><expr><literal type="string">"Not enough memory allocated. Try adjusting ZSTD_c_minMatch."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_storeSeq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>seqStore</name></name></expr></argument>, <argument><expr><name>litLength</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>offBase</name></expr></argument>, <argument><expr><name>matchLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>matchLength</name> <operator>+</operator> <name>litLength</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>nextCBlock</name><operator>-&gt;</operator><name>rep</name></name></expr></argument>, <argument><expr><name><name>updatedRepcodes</name><operator>.</operator><name>rep</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repcodes_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>inSeqs</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>litLength</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"Storing last literals of size: %u"</literal></expr></argument>, <argument><expr><name><name>inSeqs</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>litLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_storeLastLiterals</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>seqStore</name></name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name><name>inSeqs</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>litLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name><name>inSeqs</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>litLength</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>seqPos</name><operator>-&gt;</operator><name>posInSrc</name></name> <operator>+=</operator> <name><name>inSeqs</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>litLength</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>ip</name> <operator>!=</operator> <name>iend</name></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">"Blocksize doesn't agree with block delimiter!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>seqPos</name><operator>-&gt;</operator><name>idx</name></name> <operator>=</operator> <name>idx</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Returns the number of bytes to move the current read position back by.
 * Only non-zero if we ended up splitting a sequence.
 * Otherwise, it may return a ZSTD error if something went wrong.
 *
 * This function will attempt to scan through blockSize bytes
 * represented by the sequences in @inSeqs,
 * storing any (partial) sequences.
 *
 * Occasionally, we may want to change the actual number of bytes we consumed from inSeqs to
 * avoid splitting a match, or to avoid splitting a match such that it would produce a match
 * smaller than MINMATCH. In this case, we return the number of bytes that we didn't read from this block.
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>ZSTD_copySequencesToSeqStoreNoBlockDelim</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>, <parameter><decl><type><name>ZSTD_sequencePosition</name><modifier>*</modifier></type> <name>seqPos</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>ZSTD_Sequence</name><modifier>*</modifier> <specifier>const</specifier></type> <name>inSeqs</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>inSeqsSize</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>blockSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name></type> <name>idx</name> <init>= <expr><name><name>seqPos</name><operator>-&gt;</operator><name>idx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>startPosInSequence</name> <init>= <expr><name><name>seqPos</name><operator>-&gt;</operator><name>posInSequence</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>endPosInSequence</name> <init>= <expr><name><name>seqPos</name><operator>-&gt;</operator><name>posInSequence</name></name> <operator>+</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>blockSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>dictSize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>ip</name> <init>= <expr><operator>(</operator><name>BYTE</name> <specifier>const</specifier><operator>*</operator><operator>)</operator><operator>(</operator><name>src</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>iend</name> <init>= <expr><name>ip</name> <operator>+</operator> <name>blockSize</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* May be adjusted if we decide to process fewer than blockSize bytes */</comment>
    <decl_stmt><decl><type><name>repcodes_t</name></type> <name>updatedRepcodes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>bytesAdjustment</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>finalMatchSplit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>cdict</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>dictSize</name> <operator>=</operator> <name><name>cctx</name><operator>-&gt;</operator><name>cdict</name><operator>-&gt;</operator><name>dictContentSize</name></name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>prefixDict</name><operator>.</operator><name>dict</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>dictSize</name> <operator>=</operator> <name><name>cctx</name><operator>-&gt;</operator><name>prefixDict</name><operator>.</operator><name>dictSize</name></name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>dictSize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_copySequencesToSeqStoreNoBlockDelim: idx: %u PIS: %u blockSize: %zu"</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>startPosInSequence</name></expr></argument>, <argument><expr><name>blockSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Start seq: idx: %u (of: %u ml: %u ll: %u)"</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name><name>inSeqs</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>offset</name></expr></argument>, <argument><expr><name><name>inSeqs</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>matchLength</name></expr></argument>, <argument><expr><name><name>inSeqs</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>litLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name><name>updatedRepcodes</name><operator>.</operator><name>rep</name></name></expr></argument>, <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name><operator>-&gt;</operator><name>rep</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repcodes_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>endPosInSequence</name> <operator>&amp;&amp;</operator> <name>idx</name> <operator>&lt;</operator> <name>inSeqsSize</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>finalMatchSplit</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_Sequence</name></type> <name>currSeq</name> <init>= <expr><name><name>inSeqs</name><index>[<expr><name>idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name></type> <name>litLength</name> <init>= <expr><name><name>currSeq</name><operator>.</operator><name>litLength</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name></type> <name>matchLength</name> <init>= <expr><name><name>currSeq</name><operator>.</operator><name>matchLength</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>rawOffset</name> <init>= <expr><name><name>currSeq</name><operator>.</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name></type> <name>offBase</name></decl>;</decl_stmt>

        <comment type="block">/* Modify the sequence depending on where endPosInSequence lies */</comment>
        <if_stmt><if>if <condition>(<expr><name>endPosInSequence</name> <operator>&gt;=</operator> <name><name>currSeq</name><operator>.</operator><name>litLength</name></name> <operator>+</operator> <name><name>currSeq</name><operator>.</operator><name>matchLength</name></name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>startPosInSequence</name> <operator>&gt;=</operator> <name>litLength</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>startPosInSequence</name> <operator>-=</operator> <name>litLength</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>litLength</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>matchLength</name> <operator>-=</operator> <name>startPosInSequence</name></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>litLength</name> <operator>-=</operator> <name>startPosInSequence</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <comment type="block">/* Move to the next sequence */</comment>
            <expr_stmt><expr><name>endPosInSequence</name> <operator>-=</operator> <name><name>currSeq</name><operator>.</operator><name>litLength</name></name> <operator>+</operator> <name><name>currSeq</name><operator>.</operator><name>matchLength</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>startPosInSequence</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* This is the final (partial) sequence we're adding from inSeqs, and endPosInSequence
               does not reach the end of the match. So, we have to split the sequence */</comment>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"Require a split: diff: %u, idx: %u PIS: %u"</literal></expr></argument>,
                     <argument><expr><name><name>currSeq</name><operator>.</operator><name>litLength</name></name> <operator>+</operator> <name><name>currSeq</name><operator>.</operator><name>matchLength</name></name> <operator>-</operator> <name>endPosInSequence</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>endPosInSequence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>endPosInSequence</name> <operator>&gt;</operator> <name>litLength</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>U32</name></type> <name>firstHalfMatchLength</name></decl>;</decl_stmt>
                <expr_stmt><expr><name>litLength</name> <operator>=</operator> <ternary><condition><expr><name>startPosInSequence</name> <operator>&gt;=</operator> <name>litLength</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>litLength</name> <operator>-</operator> <name>startPosInSequence</name></expr></else></ternary></expr>;</expr_stmt>
                <expr_stmt><expr><name>firstHalfMatchLength</name> <operator>=</operator> <name>endPosInSequence</name> <operator>-</operator> <name>startPosInSequence</name> <operator>-</operator> <name>litLength</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>matchLength</name> <operator>&gt;</operator> <name>blockSize</name> <operator>&amp;&amp;</operator> <name>firstHalfMatchLength</name> <operator>&gt;=</operator> <name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>cParams</name><operator>.</operator><name>minMatch</name></name></expr>)</condition> <block>{<block_content>
                    <comment type="block">/* Only ever split the match if it is larger than the block size */</comment>
                    <decl_stmt><decl><type><name>U32</name></type> <name>secondHalfMatchLength</name> <init>= <expr><name><name>currSeq</name><operator>.</operator><name>matchLength</name></name> <operator>+</operator> <name><name>currSeq</name><operator>.</operator><name>litLength</name></name> <operator>-</operator> <name>endPosInSequence</name></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>secondHalfMatchLength</name> <operator>&lt;</operator> <name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>cParams</name><operator>.</operator><name>minMatch</name></name></expr>)</condition> <block>{<block_content>
                        <comment type="block">/* Move the endPosInSequence backward so that it creates match of minMatch length */</comment>
                        <expr_stmt><expr><name>endPosInSequence</name> <operator>-=</operator> <name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>cParams</name><operator>.</operator><name>minMatch</name></name> <operator>-</operator> <name>secondHalfMatchLength</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>bytesAdjustment</name> <operator>=</operator> <name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>cParams</name><operator>.</operator><name>minMatch</name></name> <operator>-</operator> <name>secondHalfMatchLength</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>firstHalfMatchLength</name> <operator>-=</operator> <name>bytesAdjustment</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name>matchLength</name> <operator>=</operator> <name>firstHalfMatchLength</name></expr>;</expr_stmt>
                    <comment type="block">/* Flag that we split the last match - after storing the sequence, exit the loop,
                       but keep the value of endPosInSequence */</comment>
                    <expr_stmt><expr><name>finalMatchSplit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <comment type="block">/* Move the position in sequence backwards so that we don't split match, and break to store
                     * the last literals. We use the original currSeq.litLength as a marker for where endPosInSequence
                     * should go. We prefer to do this whenever it is not necessary to split the match, or if doing so
                     * would cause the first half of the match to be too small
                     */</comment>
                    <expr_stmt><expr><name>bytesAdjustment</name> <operator>=</operator> <name>endPosInSequence</name> <operator>-</operator> <name><name>currSeq</name><operator>.</operator><name>litLength</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>endPosInSequence</name> <operator>=</operator> <name><name>currSeq</name><operator>.</operator><name>litLength</name></name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <comment type="block">/* This sequence ends inside the literals, break to store the last literals */</comment>
                <break>break;</break>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
        <comment type="block">/* Check if this offset can be represented with a repcode */</comment>
        <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>ll0</name> <init>= <expr><operator>(</operator><name>litLength</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>offBase</name> <operator>=</operator> <call><name>ZSTD_finalizeOffBase</name><argument_list>(<argument><expr><name>rawOffset</name></expr></argument>, <argument><expr><name><name>updatedRepcodes</name><operator>.</operator><name>rep</name></name></expr></argument>, <argument><expr><name>ll0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ZSTD_updateRep</name><argument_list>(<argument><expr><name><name>updatedRepcodes</name><operator>.</operator><name>rep</name></name></expr></argument>, <argument><expr><name>offBase</name></expr></argument>, <argument><expr><name>ll0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>validateSequences</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>seqPos</name><operator>-&gt;</operator><name>posInSrc</name></name> <operator>+=</operator> <name>litLength</name> <operator>+</operator> <name>matchLength</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_validateSequence</name><argument_list>(<argument><expr><name>offBase</name></expr></argument>, <argument><expr><name>matchLength</name></expr></argument>, <argument><expr><name><name>seqPos</name><operator>-&gt;</operator><name>posInSrc</name></name></expr></argument>,
                                                   <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>cParams</name><operator>.</operator><name>windowLog</name></name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>)</argument_list></call></expr></argument>,
                                                   <argument><expr><literal type="string">"Sequence validation failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"Storing sequence: (of: %u, ml: %u, ll: %u)"</literal></expr></argument>, <argument><expr><name>offBase</name></expr></argument>, <argument><expr><name>matchLength</name></expr></argument>, <argument><expr><name>litLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>idx</name> <operator>-</operator> <name><name>seqPos</name><operator>-&gt;</operator><name>idx</name></name> <operator>&gt;</operator> <name><name>cctx</name><operator>-&gt;</operator><name>seqStore</name><operator>.</operator><name>maxNbSeq</name></name></expr></argument>, <argument><expr><name>memory_allocation</name></expr></argument>,
                        <argument><expr><literal type="string">"Not enough memory allocated. Try adjusting ZSTD_c_minMatch."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_storeSeq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>seqStore</name></name></expr></argument>, <argument><expr><name>litLength</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>offBase</name></expr></argument>, <argument><expr><name>matchLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>matchLength</name> <operator>+</operator> <name>litLength</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Ending seq: idx: %u (of: %u ml: %u ll: %u)"</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name><name>inSeqs</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>offset</name></expr></argument>, <argument><expr><name><name>inSeqs</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>matchLength</name></expr></argument>, <argument><expr><name><name>inSeqs</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>litLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>idx</name> <operator>==</operator> <name>inSeqsSize</name> <operator>||</operator> <name>endPosInSequence</name> <operator>&lt;=</operator> <name><name>inSeqs</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>litLength</name> <operator>+</operator> <name><name>inSeqs</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>matchLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>seqPos</name><operator>-&gt;</operator><name>idx</name></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>seqPos</name><operator>-&gt;</operator><name>posInSequence</name></name> <operator>=</operator> <name>endPosInSequence</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>nextCBlock</name><operator>-&gt;</operator><name>rep</name></name></expr></argument>, <argument><expr><name><name>updatedRepcodes</name><operator>.</operator><name>rep</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repcodes_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>iend</name> <operator>-=</operator> <name>bytesAdjustment</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ip</name> <operator>!=</operator> <name>iend</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Store any last literals */</comment>
        <decl_stmt><decl><type><name>U32</name></type> <name>lastLLSize</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>iend</name> <operator>-</operator> <name>ip</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ip</name> <operator>&lt;=</operator> <name>iend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"Storing last literals of size: %u"</literal></expr></argument>, <argument><expr><name>lastLLSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_storeLastLiterals</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>seqStore</name></name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>lastLLSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>seqPos</name><operator>-&gt;</operator><name>posInSrc</name></name> <operator>+=</operator> <name>lastLLSize</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>bytesAdjustment</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <function_decl><type><name>size_t</name></type> (<modifier>*</modifier><name>ZSTD_sequenceCopier</name>) <parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>, <parameter><decl><type><name>ZSTD_sequencePosition</name><modifier>*</modifier></type> <name>seqPos</name></decl></parameter>,
                                       <parameter><decl><type><specifier>const</specifier> <name>ZSTD_Sequence</name><modifier>*</modifier> <specifier>const</specifier></type> <name>inSeqs</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>inSeqsSize</name></decl></parameter>,
                                       <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>blockSize</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<function><type><specifier>static</specifier> <name>ZSTD_sequenceCopier</name></type> <name>ZSTD_selectSequenceCopier</name><parameter_list>(<parameter><decl><type><name>ZSTD_sequenceFormat_e</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_sequenceCopier</name></type> <name>sequenceCopier</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>ZSTD_cParam_withinBounds</name><argument_list>(<argument><expr><name>ZSTD_c_blockDelimiters</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>ZSTD_sf_explicitBlockDelimiters</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>ZSTD_copySequencesToSeqStoreExplicitBlockDelim</name></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>mode</name> <operator>==</operator> <name>ZSTD_sf_noBlockDelimiters</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>ZSTD_copySequencesToSeqStoreNoBlockDelim</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>sequenceCopier</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>sequenceCopier</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Discover the size of next block by searching for the delimiter.
 * Note that a block delimiter **must** exist in this mode,
 * otherwise it's an input error.
 * The block size retrieved will be later compared to ensure it remains within bounds */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>blockSize_explicitDelimiter</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ZSTD_Sequence</name><modifier>*</modifier></type> <name>inSeqs</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>inSeqsSize</name></decl></parameter>, <parameter><decl><type><name>ZSTD_sequencePosition</name></type> <name>seqPos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>end</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>blockSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>spos</name> <init>= <expr><name><name>seqPos</name><operator>.</operator><name>idx</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"blockSize_explicitDelimiter : seq %zu / %zu"</literal></expr></argument>, <argument><expr><name>spos</name></expr></argument>, <argument><expr><name>inSeqsSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>spos</name> <operator>&lt;=</operator> <name>inSeqsSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>spos</name> <operator>&lt;</operator> <name>inSeqsSize</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>end</name> <operator>=</operator> <operator>(</operator><name><name>inSeqs</name><index>[<expr><name>spos</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>blockSize</name> <operator>+=</operator> <name><name>inSeqs</name><index>[<expr><name>spos</name></expr>]</index></name><operator>.</operator><name>litLength</name> <operator>+</operator> <name><name>inSeqs</name><index>[<expr><name>spos</name></expr>]</index></name><operator>.</operator><name>matchLength</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>end</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>inSeqs</name><index>[<expr><name>spos</name></expr>]</index></name><operator>.</operator><name>matchLength</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">"delimiter format error : both matchlength and offset must be == 0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>spos</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>end</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">"Reached end of sequences without finding a block delimiter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>blockSize</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* More a "target" block size */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>blockSize_noDelimiter</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>blockSize</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>remaining</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>lastBlock</name> <init>= <expr><operator>(</operator><name>remaining</name> <operator>&lt;=</operator> <name>blockSize</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <return>return <expr><ternary><condition><expr><name>lastBlock</name></expr> ?</condition><then> <expr><name>remaining</name></expr> </then><else>: <expr><name>blockSize</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>determine_blockSize</name><parameter_list>(<parameter><decl><type><name>ZSTD_sequenceFormat_e</name></type> <name>mode</name></decl></parameter>,
                           <parameter><decl><type><name>size_t</name></type> <name>blockSize</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>remaining</name></decl></parameter>,
                     <parameter><decl><type><specifier>const</specifier> <name>ZSTD_Sequence</name><modifier>*</modifier></type> <name>inSeqs</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>inSeqsSize</name></decl></parameter>, <parameter><decl><type><name>ZSTD_sequencePosition</name></type> <name>seqPos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"determine_blockSize : remainingSize = %zu"</literal></expr></argument>, <argument><expr><name>remaining</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>ZSTD_sf_noBlockDelimiters</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>blockSize_noDelimiter</name><argument_list>(<argument><expr><name>blockSize</name></expr></argument>, <argument><expr><name>remaining</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>explicitBlockSize</name> <init>= <expr><call><name>blockSize_explicitDelimiter</name><argument_list>(<argument><expr><name>inSeqs</name></expr></argument>, <argument><expr><name>inSeqsSize</name></expr></argument>, <argument><expr><name>seqPos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>explicitBlockSize</name></expr></argument>, <argument><expr><literal type="string">"Error while determining block size with explicit delimiters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>explicitBlockSize</name> <operator>&gt;</operator> <name>blockSize</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">"sequences incorrectly define a too large block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>explicitBlockSize</name> <operator>&gt;</operator> <name>remaining</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr><name>srcSize_wrong</name></expr></argument>, <argument><expr><literal type="string">"sequences define a frame longer than source"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>explicitBlockSize</name></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/* Compress, block-by-block, all of the sequences given.
 *
 * Returns the cumulative size of all compressed blocks (including their headers),
 * otherwise a ZSTD error.
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>ZSTD_compressSequences_internal</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>,
                                <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                          <parameter><decl><type><specifier>const</specifier> <name>ZSTD_Sequence</name><modifier>*</modifier></type> <name>inSeqs</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>inSeqsSize</name></decl></parameter>,
                          <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>cSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>remaining</name> <init>= <expr><name>srcSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_sequencePosition</name></type> <name>seqPos</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>ip</name> <init>= <expr><operator>(</operator><name>BYTE</name> <specifier>const</specifier><operator>*</operator><operator>)</operator><name>src</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_sequenceCopier</name> <specifier>const</specifier></type> <name>sequenceCopier</name> <init>= <expr><call><name>ZSTD_selectSequenceCopier</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>blockDelimiters</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressSequences_internal srcSize: %zu, inSeqsSize: %zu"</literal></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>inSeqsSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Special case: empty frame */</comment>
    <if_stmt><if>if <condition>(<expr><name>remaining</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>cBlockHeader24</name> <init>= <expr><literal type="number">1</literal> <comment type="block">/* last block */</comment> <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><name>bt_raw</name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>dstCapacity</name><operator>&lt;</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">"No room for empty frame block header"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MEM_writeLE32</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>cBlockHeader24</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>ZSTD_blockHeaderSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dstCapacity</name> <operator>-=</operator> <name>ZSTD_blockHeaderSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>cSize</name> <operator>+=</operator> <name>ZSTD_blockHeaderSize</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <while>while <condition>(<expr><name>remaining</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>compressedSeqsSize</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>cBlockSize</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>additionalByteAdjustment</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>blockSize</name> <init>= <expr><call><name>determine_blockSize</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>blockDelimiters</name></name></expr></argument>,
                                        <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>blockSize</name></name></expr></argument>, <argument><expr><name>remaining</name></expr></argument>,
                                        <argument><expr><name>inSeqs</name></expr></argument>, <argument><expr><name>inSeqsSize</name></expr></argument>, <argument><expr><name>seqPos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>lastBlock</name> <init>= <expr><operator>(</operator><name>blockSize</name> <operator>==</operator> <name>remaining</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>blockSize</name></expr></argument>, <argument><expr><literal type="string">"Error while trying to determine block size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>blockSize</name> <operator>&lt;=</operator> <name>remaining</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_resetSeqStore</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>seqStore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Working on new block. Blocksize: %zu (total:%zu)"</literal></expr></argument>, <argument><expr><name>blockSize</name></expr></argument>, <argument><expr><operator>(</operator><name>ip</name> <operator>-</operator> <operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name><operator>)</operator> <operator>+</operator> <name>blockSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>additionalByteAdjustment</name> <operator>=</operator> <call><name>sequenceCopier</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seqPos</name></expr></argument>, <argument><expr><name>inSeqs</name></expr></argument>, <argument><expr><name>inSeqsSize</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>blockSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>additionalByteAdjustment</name></expr></argument>, <argument><expr><literal type="string">"Bad sequence copy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>blockSize</name> <operator>-=</operator> <name>additionalByteAdjustment</name></expr>;</expr_stmt>

        <comment type="block">/* If blocks are too small, emit as a nocompress block */</comment>
        <comment type="block">/* TODO: See 3090. We reduced MIN_CBLOCK_SIZE from 3 to 2 so to compensate we are adding
         * additional 1. We need to revisit and change this logic to be more consistent */</comment>
        <if_stmt><if>if <condition>(<expr><name>blockSize</name> <operator>&lt;</operator> <name>MIN_CBLOCK_SIZE</name><operator>+</operator><name>ZSTD_blockHeaderSize</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>cBlockSize</name> <operator>=</operator> <call><name>ZSTD_noCompressBlock</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>blockSize</name></expr></argument>, <argument><expr><name>lastBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>cBlockSize</name></expr></argument>, <argument><expr><literal type="string">"Nocompress block failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Block too small, writing out nocompress block: cSize: %zu"</literal></expr></argument>, <argument><expr><name>cBlockSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>cSize</name> <operator>+=</operator> <name>cBlockSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>blockSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>cBlockSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>remaining</name> <operator>-=</operator> <name>blockSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>dstCapacity</name> <operator>-=</operator> <name>cBlockSize</name></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>dstCapacity</name> <operator>&lt;</operator> <name>ZSTD_blockHeaderSize</name></expr></argument>, <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">"not enough dstCapacity to write a new compressed block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>compressedSeqsSize</name> <operator>=</operator> <call><name>ZSTD_entropyCompressSeqStore</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>seqStore</name></name></expr></argument>,
                                <argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name><operator>-&gt;</operator><name>entropy</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>nextCBlock</name><operator>-&gt;</operator><name>entropy</name></name></expr></argument>,
                                <argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name></name></expr></argument>,
                                <argument><expr><name>op</name> <operator>+</operator> <name>ZSTD_blockHeaderSize</name></expr></argument> <comment type="block">/* Leave space for block header */</comment>, <argument><expr><name>dstCapacity</name> <operator>-</operator> <name>ZSTD_blockHeaderSize</name></expr></argument>,
                                <argument><expr><name>blockSize</name></expr></argument>,
                                <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>entropyWorkspace</name></name></expr></argument>, <argument><expr><name>ENTROPY_WORKSPACE_SIZE</name></expr></argument> <comment type="block">/* statically allocated in resetCCtx */</comment>,
                                <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>bmi2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>compressedSeqsSize</name></expr></argument>, <argument><expr><literal type="string">"Compressing sequences of block failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Compressed sequences size: %zu"</literal></expr></argument>, <argument><expr><name>compressedSeqsSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cctx</name><operator>-&gt;</operator><name>isFirstBlock</name></name> <operator>&amp;&amp;</operator>
            <call><name>ZSTD_maybeRLE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>seqStore</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>ZSTD_isRLE</name><argument_list>(<argument><expr><operator>(</operator><name>BYTE</name> <specifier>const</specifier><operator>*</operator><operator>)</operator><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="block">/* We don't want to emit our first block as a RLE even if it qualifies because
            * doing so will cause the decoder (cli only) to throw a "should consume all input error."
            * This is only an issue for zstd &lt;= v1.4.3
            */</comment>
            <expr_stmt><expr><name>compressedSeqsSize</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>compressedSeqsSize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* ZSTD_noCompressBlock writes the block header as well */</comment>
            <expr_stmt><expr><name>cBlockSize</name> <operator>=</operator> <call><name>ZSTD_noCompressBlock</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>blockSize</name></expr></argument>, <argument><expr><name>lastBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>cBlockSize</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_noCompressBlock failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Writing out nocompress block, size: %zu"</literal></expr></argument>, <argument><expr><name>cBlockSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>compressedSeqsSize</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>cBlockSize</name> <operator>=</operator> <call><name>ZSTD_rleCompressBlock</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><operator>*</operator><name>ip</name></expr></argument>, <argument><expr><name>blockSize</name></expr></argument>, <argument><expr><name>lastBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>cBlockSize</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_rleCompressBlock failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Writing out RLE block, size: %zu"</literal></expr></argument>, <argument><expr><name>cBlockSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <decl_stmt><decl><type><name>U32</name></type> <name>cBlockHeader</name></decl>;</decl_stmt>
            <comment type="block">/* Error checking and repcodes update */</comment>
            <expr_stmt><expr><call><name>ZSTD_blockState_confirmRepcodesAndEntropyTables</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>blockState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>fse</name><operator>.</operator><name>offcode_repeatMode</name></name> <operator>==</operator> <name>FSE_repeat_valid</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>blockState</name><operator>.</operator><name>prevCBlock</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>fse</name><operator>.</operator><name>offcode_repeatMode</name></name> <operator>=</operator> <name>FSE_repeat_check</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* Write block header into beginning of block*/</comment>
            <expr_stmt><expr><name>cBlockHeader</name> <operator>=</operator> <name>lastBlock</name> <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><name>bt_compressed</name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">1</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>compressedSeqsSize</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MEM_writeLE24</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>cBlockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>cBlockSize</name> <operator>=</operator> <name>ZSTD_blockHeaderSize</name> <operator>+</operator> <name>compressedSeqsSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Writing out compressed block, size: %zu"</literal></expr></argument>, <argument><expr><name>cBlockSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>cSize</name> <operator>+=</operator> <name>cBlockSize</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>lastBlock</name></expr>)</condition> <block>{<block_content>
            <break>break;</break>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>blockSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>cBlockSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>remaining</name> <operator>-=</operator> <name>blockSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>dstCapacity</name> <operator>-=</operator> <name>cBlockSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>isFirstBlock</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"cSize running total: %zu (remaining dstCapacity=%zu)"</literal></expr></argument>, <argument><expr><name>cSize</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"cSize final total: %zu"</literal></expr></argument>, <argument><expr><name>cSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>cSize</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_compressSequences</name><parameter_list>(<parameter><decl><type><name>ZSTD_CCtx</name><modifier>*</modifier></type> <name>cctx</name></decl></parameter>,
                              <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                              <parameter><decl><type><specifier>const</specifier> <name>ZSTD_Sequence</name><modifier>*</modifier></type> <name>inSeqs</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>inSeqsSize</name></decl></parameter>,
                              <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>cSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>compressedBlocksSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>frameHeaderSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Transparent initialization stage, same as compressStream2() */</comment>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_compressSequences (dstCapacity=%zu)"</literal></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>cctx</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><call><name>ZSTD_CCtx_init_compressStream2</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ZSTD_e_end</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"CCtx initialization failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Begin writing output, starting with frame header */</comment>
    <expr_stmt><expr><name>frameHeaderSize</name> <operator>=</operator> <call><name>ZSTD_writeFrameHeader</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name></name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>dictID</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>frameHeaderSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>dstCapacity</name> <operator>-=</operator> <name>frameHeaderSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cSize</name> <operator>+=</operator> <name>frameHeaderSize</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>fParams</name><operator>.</operator><name>checksumFlag</name></name> <operator>&amp;&amp;</operator> <name>srcSize</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>XXH64_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>xxhState</name></name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* cSize includes block header size and compressed sequences size */</comment>
    <expr_stmt><expr><name>compressedBlocksSize</name> <operator>=</operator> <call><name>ZSTD_compressSequences_internal</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>,
                                                           <argument><expr><name>op</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>,
                                                           <argument><expr><name>inSeqs</name></expr></argument>, <argument><expr><name>inSeqsSize</name></expr></argument>,
                                                           <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>compressedBlocksSize</name></expr></argument>, <argument><expr><literal type="string">"Compressing blocks failed!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cSize</name> <operator>+=</operator> <name>compressedBlocksSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>dstCapacity</name> <operator>-=</operator> <name>compressedBlocksSize</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>fParams</name><operator>.</operator><name>checksumFlag</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>checksum</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator> <call><name>XXH64_digest</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>xxhState</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>dstCapacity</name><operator>&lt;</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">"no room for checksum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"Write checksum : %08X"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>checksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MEM_writeLE32</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>dst</name> <operator>+</operator> <name>cSize</name></expr></argument>, <argument><expr><name>checksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cSize</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"Final compressed size: %zu"</literal></expr></argument>, <argument><expr><name>cSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>cSize</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*======   Finalize   ======*/</comment>

<function><type><specifier>static</specifier> <name>ZSTD_inBuffer</name></type> <name>inBuffer_forEndFlush</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ZSTD_CStream</name><modifier>*</modifier></type> <name>zcs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_inBuffer</name></type> <name>nullInput</name> <init>= <expr><block>{ <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>stableInput</name> <init>= <expr><operator>(</operator><name><name>zcs</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>inBufferMode</name></name> <operator>==</operator> <name>ZSTD_bm_stable</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <return>return <expr><ternary><condition><expr><name>stableInput</name></expr> ?</condition><then> <expr><name><name>zcs</name><operator>-&gt;</operator><name>expectedInBuffer</name></name></expr> </then><else>: <expr><name>nullInput</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! ZSTD_flushStream() :
 * @return : amount of data remaining to flush */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_flushStream</name><parameter_list>(<parameter><decl><type><name>ZSTD_CStream</name><modifier>*</modifier></type> <name>zcs</name></decl></parameter>, <parameter><decl><type><name>ZSTD_outBuffer</name><modifier>*</modifier></type> <name>output</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_inBuffer</name></type> <name>input</name> <init>= <expr><call><name>inBuffer_forEndFlush</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>input</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name><name>input</name><operator>.</operator><name>pos</name></name></expr>;</expr_stmt> <comment type="block">/* do not ingest more input during flush */</comment>
    <return>return <expr><call><name>ZSTD_compressStream2</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>input</name></expr></argument>, <argument><expr><name>ZSTD_e_flush</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>size_t</name></type> <name>ZSTD_endStream</name><parameter_list>(<parameter><decl><type><name>ZSTD_CStream</name><modifier>*</modifier></type> <name>zcs</name></decl></parameter>, <parameter><decl><type><name>ZSTD_outBuffer</name><modifier>*</modifier></type> <name>output</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_inBuffer</name></type> <name>input</name> <init>= <expr><call><name>inBuffer_forEndFlush</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>remainingToFlush</name> <init>= <expr><call><name>ZSTD_compressStream2</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>input</name></expr></argument>, <argument><expr><name>ZSTD_e_end</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>FORWARD_IF_ERROR</name><argument_list>(<argument><expr><name>remainingToFlush</name></expr></argument> , <argument><expr><literal type="string">"ZSTD_compressStream2(,,ZSTD_e_end) failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>zcs</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>nbWorkers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>remainingToFlush</name></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* minimal estimation */</comment>
    <comment type="block">/* single thread mode : attempt to calculate remaining to flush more precisely */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>lastBlockSize</name> <init>= <expr><ternary><condition><expr><name><name>zcs</name><operator>-&gt;</operator><name>frameEnded</name></name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>ZSTD_BLOCKHEADERSIZE</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>checksumSize</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><ternary><condition><expr><name><name>zcs</name><operator>-&gt;</operator><name>frameEnded</name></name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>zcs</name><operator>-&gt;</operator><name>appliedParams</name><operator>.</operator><name>fParams</name><operator>.</operator><name>checksumFlag</name></name> <operator>*</operator> <literal type="number">4</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>toFlush</name> <init>= <expr><name>remainingToFlush</name> <operator>+</operator> <name>lastBlockSize</name> <operator>+</operator> <name>checksumSize</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_endStream : remaining to flush : %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>toFlush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>toFlush</name></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*-=====  Pre-defined compression levels  =====-*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clevels.h"</cpp:file></cpp:include>

<function><type><name>int</name></type> <name>ZSTD_maxCLevel</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>ZSTD_MAX_CLEVEL</name></expr>;</return> </block_content>}</block></function>
<function><type><name>int</name></type> <name>ZSTD_minCLevel</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>-</operator><name>ZSTD_TARGETLENGTH_MAX</name></expr>;</return> </block_content>}</block></function>
<function><type><name>int</name></type> <name>ZSTD_defaultCLevel</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>ZSTD_CLEVEL_DEFAULT</name></expr>;</return> </block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ZSTD_compressionParameters</name></type> <name>ZSTD_dedicatedDictSearch_getCParams</name><parameter_list>(<parameter><decl><type><name>int</name> <specifier>const</specifier></type> <name>compressionLevel</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>dictSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_compressionParameters</name></type> <name>cParams</name> <init>= <expr><call><name>ZSTD_getCParams_internal</name><argument_list>(<argument><expr><name>compressionLevel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>, <argument><expr><name>ZSTD_cpm_createCDict</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><name><name>cParams</name><operator>.</operator><name>strategy</name></name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>ZSTD_fast</name></expr>:</case>
        <case>case <expr><name>ZSTD_dfast</name></expr>:</case>
            <break>break;</break>
        <case>case <expr><name>ZSTD_greedy</name></expr>:</case>
        <case>case <expr><name>ZSTD_lazy</name></expr>:</case>
        <case>case <expr><name>ZSTD_lazy2</name></expr>:</case>
            <expr_stmt><expr><name><name>cParams</name><operator>.</operator><name>hashLog</name></name> <operator>+=</operator> <name>ZSTD_LAZY_DDSS_BUCKET_LOG</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>ZSTD_btlazy2</name></expr>:</case>
        <case>case <expr><name>ZSTD_btopt</name></expr>:</case>
        <case>case <expr><name>ZSTD_btultra</name></expr>:</case>
        <case>case <expr><name>ZSTD_btultra2</name></expr>:</case>
            <break>break;</break>
    </block_content>}</block></switch>
    <return>return <expr><name>cParams</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ZSTD_dedicatedDictSearch_isSupported</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_compressionParameters</name> <specifier>const</specifier><modifier>*</modifier></type> <name>cParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><name><name>cParams</name><operator>-&gt;</operator><name>strategy</name></name> <operator>&gt;=</operator> <name>ZSTD_greedy</name><operator>)</operator>
        <operator>&amp;&amp;</operator> <operator>(</operator><name><name>cParams</name><operator>-&gt;</operator><name>strategy</name></name> <operator>&lt;=</operator> <name>ZSTD_lazy2</name><operator>)</operator>
        <operator>&amp;&amp;</operator> <operator>(</operator><name><name>cParams</name><operator>-&gt;</operator><name>hashLog</name></name> <operator>&gt;</operator> <name><name>cParams</name><operator>-&gt;</operator><name>chainLog</name></name><operator>)</operator>
        <operator>&amp;&amp;</operator> <operator>(</operator><name><name>cParams</name><operator>-&gt;</operator><name>chainLog</name></name> <operator>&lt;=</operator> <literal type="number">24</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Reverses the adjustment applied to cparams when enabling dedicated dict
 * search. This is used to recover the params set to be used in the working
 * context. (Otherwise, those tables would also grow.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_dedicatedDictSearch_revertCParams</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_compressionParameters</name><modifier>*</modifier></type> <name>cParams</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <switch>switch <condition>(<expr><name><name>cParams</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>ZSTD_fast</name></expr>:</case>
        <case>case <expr><name>ZSTD_dfast</name></expr>:</case>
            <break>break;</break>
        <case>case <expr><name>ZSTD_greedy</name></expr>:</case>
        <case>case <expr><name>ZSTD_lazy</name></expr>:</case>
        <case>case <expr><name>ZSTD_lazy2</name></expr>:</case>
            <expr_stmt><expr><name><name>cParams</name><operator>-&gt;</operator><name>hashLog</name></name> <operator>-=</operator> <name>ZSTD_LAZY_DDSS_BUCKET_LOG</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>cParams</name><operator>-&gt;</operator><name>hashLog</name></name> <operator>&lt;</operator> <name>ZSTD_HASHLOG_MIN</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>cParams</name><operator>-&gt;</operator><name>hashLog</name></name> <operator>=</operator> <name>ZSTD_HASHLOG_MIN</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>ZSTD_btlazy2</name></expr>:</case>
        <case>case <expr><name>ZSTD_btopt</name></expr>:</case>
        <case>case <expr><name>ZSTD_btultra</name></expr>:</case>
        <case>case <expr><name>ZSTD_btultra2</name></expr>:</case>
            <break>break;</break>
    </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>U64</name></type> <name>ZSTD_getCParamRowSize</name><parameter_list>(<parameter><decl><type><name>U64</name></type> <name>srcSizeHint</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>, <parameter><decl><type><name>ZSTD_cParamMode_e</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch <condition>(<expr><name>mode</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>ZSTD_cpm_unknown</name></expr>:</case>
    <case>case <expr><name>ZSTD_cpm_noAttachDict</name></expr>:</case>
    <case>case <expr><name>ZSTD_cpm_createCDict</name></expr>:</case>
        <break>break;</break>
    <case>case <expr><name>ZSTD_cpm_attachDict</name></expr>:</case>
        <expr_stmt><expr><name>dictSize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <break>break;</break>
    <default>default:</default>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
    <block>{<block_content>   <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>unknown</name> <init>= <expr><name>srcSizeHint</name> <operator>==</operator> <name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>addedSize</name> <init>= <expr><ternary><condition><expr><name>unknown</name> <operator>&amp;&amp;</operator> <name>dictSize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">500</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <return>return <expr><ternary><condition><expr><name>unknown</name> <operator>&amp;&amp;</operator> <name>dictSize</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr> </then><else>: <expr><name>srcSizeHint</name><operator>+</operator><name>dictSize</name><operator>+</operator><name>addedSize</name></expr></else></ternary></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! ZSTD_getCParams_internal() :
 * @return ZSTD_compressionParameters structure for a selected compression level, srcSize and dictSize.
 *  Note: srcSizeHint 0 means 0, use ZSTD_CONTENTSIZE_UNKNOWN for unknown.
 *        Use dictSize == 0 for unknown or unused.
 *  Note: `mode` controls how we treat the `dictSize`. See docs for `ZSTD_cParamMode_e`. */</comment>
<function><type><specifier>static</specifier> <name>ZSTD_compressionParameters</name></type> <name>ZSTD_getCParams_internal</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>compressionLevel</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>srcSizeHint</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>, <parameter><decl><type><name>ZSTD_cParamMode_e</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U64</name> <specifier>const</specifier></type> <name>rSize</name> <init>= <expr><call><name>ZSTD_getCParamRowSize</name><argument_list>(<argument><expr><name>srcSizeHint</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>tableID</name> <init>= <expr><operator>(</operator><name>rSize</name> <operator>&lt;=</operator> <literal type="number">256</literal> <name>KB</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>rSize</name> <operator>&lt;=</operator> <literal type="number">128</literal> <name>KB</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>rSize</name> <operator>&lt;=</operator> <literal type="number">16</literal> <name>KB</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>row</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_getCParams_internal (cLevel=%i)"</literal></expr></argument>, <argument><expr><name>compressionLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* row */</comment>
    <if_stmt><if>if <condition>(<expr><name>compressionLevel</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>row</name> <operator>=</operator> <name>ZSTD_CLEVEL_DEFAULT</name></expr>;</expr_stmt></block_content></block></if>   <comment type="block">/* 0 == default */</comment>
    <if type="elseif">else if <condition>(<expr><name>compressionLevel</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>row</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>   <comment type="block">/* entry 0 is baseline for fast mode */</comment>
    <if type="elseif">else if <condition>(<expr><name>compressionLevel</name> <operator>&gt;</operator> <name>ZSTD_MAX_CLEVEL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>row</name> <operator>=</operator> <name>ZSTD_MAX_CLEVEL</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>row</name> <operator>=</operator> <name>compressionLevel</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <block>{<block_content>   <decl_stmt><decl><type><name>ZSTD_compressionParameters</name></type> <name>cp</name> <init>= <expr><name><name>ZSTD_defaultCParameters</name><index>[<expr><name>tableID</name></expr>]</index><index>[<expr><name>row</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_getCParams_internal selected tableID: %u row: %u strat: %u"</literal></expr></argument>, <argument><expr><name>tableID</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>cp</name><operator>.</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* acceleration factor */</comment>
        <if_stmt><if>if <condition>(<expr><name>compressionLevel</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>clampedCompressionLevel</name> <init>= <expr><call><name>MAX</name><argument_list>(<argument><expr><call><name>ZSTD_minCLevel</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>compressionLevel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>cp</name><operator>.</operator><name>targetLength</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><operator>-</operator><name>clampedCompressionLevel</name><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* refine parameters based on srcSize &amp; dictSize */</comment>
        <return>return <expr><call><name>ZSTD_adjustCParams_internal</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>srcSizeHint</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! ZSTD_getCParams() :
 * @return ZSTD_compressionParameters structure for a selected compression level, srcSize and dictSize.
 *  Size values are optional, provide 0 if not known or unused */</comment>
<function><type><name>ZSTD_compressionParameters</name></type> <name>ZSTD_getCParams</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>compressionLevel</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>srcSizeHint</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>srcSizeHint</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>srcSizeHint</name> <operator>=</operator> <name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><call><name>ZSTD_getCParams_internal</name><argument_list>(<argument><expr><name>compressionLevel</name></expr></argument>, <argument><expr><name>srcSizeHint</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>, <argument><expr><name>ZSTD_cpm_unknown</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! ZSTD_getParams() :
 *  same idea as ZSTD_getCParams()
 * @return a `ZSTD_parameters` structure (instead of `ZSTD_compressionParameters`).
 *  Fields of `ZSTD_frameParameters` are set to default values */</comment>
<function><type><specifier>static</specifier> <name>ZSTD_parameters</name></type> <name>ZSTD_getParams_internal</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>compressionLevel</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>srcSizeHint</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>, <parameter><decl><type><name>ZSTD_cParamMode_e</name></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_parameters</name></type> <name>params</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_compressionParameters</name> <specifier>const</specifier></type> <name>cParams</name> <init>= <expr><call><name>ZSTD_getCParams_internal</name><argument_list>(<argument><expr><name>compressionLevel</name></expr></argument>, <argument><expr><name>srcSizeHint</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_getParams (cLevel=%i)"</literal></expr></argument>, <argument><expr><name>compressionLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>params</name><operator>.</operator><name>cParams</name></name> <operator>=</operator> <name>cParams</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>params</name><operator>.</operator><name>fParams</name><operator>.</operator><name>contentSizeFlag</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><name>params</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! ZSTD_getParams() :
 *  same idea as ZSTD_getCParams()
 * @return a `ZSTD_parameters` structure (instead of `ZSTD_compressionParameters`).
 *  Fields of `ZSTD_frameParameters` are set to default values */</comment>
<function><type><name>ZSTD_parameters</name></type> <name>ZSTD_getParams</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>compressionLevel</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>srcSizeHint</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>srcSizeHint</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>srcSizeHint</name> <operator>=</operator> <name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><call><name>ZSTD_getParams_internal</name><argument_list>(<argument><expr><name>compressionLevel</name></expr></argument>, <argument><expr><name>srcSizeHint</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>, <argument><expr><name>ZSTD_cpm_unknown</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
