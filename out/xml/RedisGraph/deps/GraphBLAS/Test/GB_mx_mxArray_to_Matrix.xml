<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Test/GB_mx_mxArray_to_Matrix.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_mx_mxArray_to_Matrix</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// Convert a built-in sparse or full matrix, or a struct to a GraphBLAS sparse</comment>
<comment type="line">// matrix.  The mxArray is either a struct containing two terms: a sparse or</comment>
<comment type="line">// full matrix or vector, and type (a string, "logical", "double", etc), or it</comment>
<comment type="line">// is just a plain sparse or full matrix.  If A.class is present, it is used to</comment>
<comment type="line">// typecast the built-in matrix into the corresponding type in GraphBLAS.</comment>

<comment type="line">// That is:</comment>
<comment type="line">// A = sparse (...) ;   % a sparse double or logical GraphBLAS matrix</comment>

<comment type="line">// A.matrix = A ; A.class = 'int8' ; Represents a built-in sparse or full matrix</comment>
<comment type="line">// that represents a GraphBLAS int8 matrix.  On input, the built-in sparse or</comment>
<comment type="line">// full matrix is typecasted.</comment>

<comment type="line">// The built-in matrix or struct is not modified.  If deep_copy is true, the</comment>
<comment type="line">// GraphBLAS matrix is always a deep copy and can be modified by GraphBLAS.</comment>
<comment type="line">// Otherwise, its pattern (A-&gt;p, A-&gt;h, and A-&gt;i) may be a shallow copy, and</comment>
<comment type="line">// A-&gt;x is a shallow copy if the built-in matrix is 'logical' or 'double'. </comment>

<comment type="line">// If the built-in matrix is double complex, it becomes a GraphBLAS</comment>
<comment type="line">// Complex or GxB_FC64 matrix.</comment>

<comment type="line">// A-&gt;x is always a deep copy for other types, since it must be typecasted from</comment>
<comment type="line">// a built-in matrix to GraphBLAS.</comment>

<comment type="line">// Like GB_mx_Matrix_to_mxArray, this could be done using only user-callable</comment>
<comment type="line">// GraphBLAS functions, but the method used here is faster.</comment>

<comment type="line">// A.sparsity sets the GxB_SPARSITY_CONTROL option: 0 to 15 (see GB_conform.c),</comment>
<comment type="line">// which is any sum of these 4 flags:</comment>
<comment type="line">//</comment>
<comment type="line">//    // GxB_SPARSITY_CONTROL can be any sum or bitwise OR of these 4 values:</comment>
<comment type="line">//    #define GxB_HYPERSPARSE 1   // hypersparse form</comment>
<comment type="line">//    #define GxB_SPARSE      2   // sparse form</comment>
<comment type="line">//    #define GxB_BITMAP      4   // a bitmap</comment>
<comment type="line">//    #define GxB_FULL        8   // full (all entries must be present)</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_mex.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FREE_ALL</name></cpp:macro>            \
<cpp:value>{                           \
    GrB_Matrix_free_(&amp;A) ;  \
}</cpp:value></cpp:define>

<function><type><name>GrB_Matrix</name></type> <name>GB_mx_mxArray_to_Matrix</name>     <comment type="line">// returns GraphBLAS version of A</comment>
<parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>mxArray</name> <modifier>*</modifier></type><name>A_builtin</name></decl></parameter>,           <comment type="line">// built-in version of A</comment>
    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,                   <comment type="line">// name of the argument</comment>
    <parameter><decl><type><name>bool</name></type> <name>deep_copy</name></decl></parameter>,                     <comment type="line">// if true, return a deep copy</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>empty</name></decl></parameter>    <comment type="line">// if false, 0-by-0 matrices are returned as NULL.</comment>
                        <comment type="line">// if true, a 0-by-0 matrix is returned.</comment>
)</parameter_list>
<block>{<block_content>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check for empty matrix</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>GB_CONTEXT</name> <argument_list>(<argument><expr><literal type="string">"mxArray_to_Matrix"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <decl_stmt><decl><type><name>GrB_Matrix</name></type> <name>A</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>A_builtin</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// input is not present; this is not an error if A is an</comment>
        <comment type="line">// optional input</comment>
        <return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>mxGetM</name> <argument_list>(<argument><expr><name>A_builtin</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>mxGetN</name> <argument_list>(<argument><expr><name>A_builtin</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// input is "[ ]", zero-by-zero.</comment>
        <if_stmt><if>if <condition>(<expr><name>empty</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// treat as a sparse 0-by-0 matrix, not NULL</comment>
            <expr_stmt><expr><call><name>GrB_Matrix_new</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>A</name></expr></argument>, <argument><expr><name>GrB_FP64</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"got A = [ ] from built-in"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <return>return <expr><operator>(</operator><name>A</name><operator>)</operator></expr> ;</return>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="line">// Treat as NULL in GraphBLAS.  Useful for mask matrices</comment>
            <return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr> ;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// get the matrix</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>A_iso</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>mxArray</name> <modifier>*</modifier></type><name>Amatrix</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Type</name></type> <name>atype_in</name></decl>, <decl><type ref="prev"/><name>atype_out</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GB_Type_code</name></type> <name>atype_in_code</name></decl>, <decl><type ref="prev"/><name>atype_out_code</name></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>mxIsStruct</name> <argument_list>(<argument><expr><name>A_builtin</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// look for A.matrix</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>fieldnumber</name> <init>= <expr><call><name>mxGetFieldNumber</name> <argument_list>(<argument><expr><name>A_builtin</name></expr></argument>, <argument><expr><literal type="string">"matrix"</literal></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>fieldnumber</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>Amatrix</name> <operator>=</operator> <call><name>mxGetFieldByNumber</name> <argument_list>(<argument><expr><name>A_builtin</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fieldnumber</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="line">// A.matrix not present, try A.vector</comment>
            <expr_stmt><expr><name>fieldnumber</name> <operator>=</operator> <call><name>mxGetFieldNumber</name> <argument_list>(<argument><expr><name>A_builtin</name></expr></argument>, <argument><expr><literal type="string">"vector"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>fieldnumber</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>FREE_ALL</name></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>mexWarnMsgIdAndTxt</name> <argument_list>(<argument><expr><literal type="string">"GB:warn"</literal></expr></argument>, <argument><expr><literal type="string">"invalid matrix/vector struct"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr> ;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>Amatrix</name> <operator>=</operator> <call><name>mxGetFieldByNumber</name> <argument_list>(<argument><expr><name>A_builtin</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fieldnumber</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>mxGetN</name> <argument_list>(<argument><expr><name>Amatrix</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>FREE_ALL</name></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>mexWarnMsgIdAndTxt</name> <argument_list>(<argument><expr><literal type="string">"GB:warn"</literal></expr></argument>, <argument><expr><literal type="string">"vector must be n-by-1"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr> ;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="line">// get the type</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>Amatrix</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <expr_stmt><expr><name>atype_in</name> <operator>=</operator> <call><name>GB_mx_Type</name> <argument_list>(<argument><expr><name>Amatrix</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name>atype_out</name> <operator>=</operator> <name>atype_in</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>fieldnumber</name> <operator>=</operator> <call><name>mxGetFieldNumber</name> <argument_list>(<argument><expr><name>A_builtin</name></expr></argument>, <argument><expr><literal type="string">"class"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>fieldnumber</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>mxArray</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>mxGetFieldByNumber</name> <argument_list>(<argument><expr><name>A_builtin</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fieldnumber</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
            <expr_stmt><expr><name>atype_out</name> <operator>=</operator> <call><name>GB_mx_string_to_Type</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>atype_in</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>atype_out</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>mexErrMsgTxt</name> <argument_list>(<argument><expr><literal type="string">"unknown class"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// get the iso property (false if not present)</comment>
        <expr_stmt><expr><name>fieldnumber</name> <operator>=</operator> <call><name>mxGetFieldNumber</name> <argument_list>(<argument><expr><name>A_builtin</name></expr></argument>, <argument><expr><literal type="string">"iso"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>fieldnumber</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>mxArray</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>mxGetFieldByNumber</name> <argument_list>(<argument><expr><name>A_builtin</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fieldnumber</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>mxIsLogicalScalar</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>A_iso</name> <operator>=</operator> <call><name>mxIsLogicalScalarTrue</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>A_iso</name> <operator>=</operator> <operator>(</operator><call><name>mxGetScalar</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="line">// just a matrix</comment>
        <expr_stmt><expr><name>Amatrix</name> <operator>=</operator> <name>A_builtin</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>atype_in</name> <operator>=</operator> <call><name>GB_mx_Type</name> <argument_list>(<argument><expr><name>Amatrix</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name>atype_out</name> <operator>=</operator> <name>atype_in</name></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>A_is_sparse</name> <init>= <expr><call><name>mxIsSparse</name> <argument_list>(<argument><expr><name>Amatrix</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// get the matrix type</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><name>atype_in_code</name>  <operator>=</operator> <name><name>atype_in</name><operator>-&gt;</operator><name>code</name></name></expr> ;</expr_stmt>
    <expr_stmt><expr><name>atype_out_code</name> <operator>=</operator> <name><name>atype_out</name><operator>-&gt;</operator><name>code</name></name></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// get the size and content of the built-in matrix</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>nrows</name> <init>= <expr><call><name>mxGetM</name> <argument_list>(<argument><expr><name>Amatrix</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>ncols</name> <init>= <expr><call><name>mxGetN</name> <argument_list>(<argument><expr><name>Amatrix</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>Mp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>Mi</name></decl>, <decl><type ref="prev"/><name>anz</name></decl>, <decl><type ref="prev"/><name>anzmax</name></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>A_is_sparse</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>Mp</name> <operator>=</operator> <operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator> <call><name>mxGetJc</name> <argument_list>(<argument><expr><name>Amatrix</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name>Mi</name> <operator>=</operator> <operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator> <call><name>mxGetIr</name> <argument_list>(<argument><expr><name>Amatrix</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name>anz</name> <operator>=</operator> <name><name>Mp</name> <index>[<expr><name>ncols</name></expr>]</index></name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>anzmax</name> <operator>=</operator> <call><name>mxGetNzmax</name> <argument_list>(<argument><expr><name>Amatrix</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>Mp</name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>Mi</name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>anz</name> <operator>=</operator> <name>nrows</name> <operator>*</operator> <name>ncols</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>anzmax</name> <operator>=</operator> <name>anz</name></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <decl_stmt><decl><type><name>GB_void</name> <modifier>*</modifier></type><name>Mx</name> <init>= <expr><call><name>mxGetData</name> <argument_list>(<argument><expr><name>Amatrix</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>anz</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// an empty matrix cannot be iso</comment>
        <expr_stmt><expr><name>A_iso</name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// look for A.values</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><call><name>mxIsStruct</name> <argument_list>(<argument><expr><name>A_builtin</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// this is used for int64 and uint64 only</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>fieldnumber</name> <init>= <expr><call><name>mxGetFieldNumber</name> <argument_list>(<argument><expr><name>A_builtin</name></expr></argument>, <argument><expr><literal type="string">"values"</literal></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>fieldnumber</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>mxArray</name> <modifier>*</modifier></type><name>values</name> <init>= <expr><call><name>mxGetFieldByNumber</name> <argument_list>(<argument><expr><name>A_builtin</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fieldnumber</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>mxIsComplex</name> <argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>mexErrMsgTxt</name> <argument_list>(<argument><expr><literal type="string">"A.values must be real"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>mxGetNumberOfElements</name> <argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>anz</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>Mx</name> <operator>=</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><name>atype_in</name> <operator>=</operator> <call><name>GB_mx_Type</name> <argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><name>atype_in_code</name> <operator>=</operator> <name><name>atype_in</name><operator>-&gt;</operator><name>code</name></name></expr> ;</expr_stmt>
                <expr_stmt><expr><name>anzmax</name> <operator>=</operator> <call><name>mxGetNumberOfElements</name> <argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ASSERT_TYPE_OK</name> <argument_list>(<argument><expr><name>atype_in</name></expr></argument>,  <argument><expr><literal type="string">"A type in"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_TYPE_OK</name> <argument_list>(<argument><expr><name>atype_out</name></expr></argument>, <argument><expr><literal type="string">"A type out"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>atype_in</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>atype_out</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>FREE_ALL</name></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>mexWarnMsgIdAndTxt</name> <argument_list>(<argument><expr><literal type="string">"GB:warn"</literal></expr></argument>, <argument><expr><literal type="string">"types must be numeric"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>GrB_Info</name></type> <name>info</name></decl> ;</decl_stmt>

    <comment type="line">// built-in matrices are sparse or full CSC, not hypersparse or bitmap</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_csc</name> <init>= <expr><name>true</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>sparsity</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>A_is_sparse</name><operator>)</operator></expr> ?</condition><then> <expr><name>GxB_SPARSE</name></expr> </then><else>: <expr><name>GxB_FULL</name></expr></else></ternary></expr></init></decl> ;</decl_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// get the pattern of A</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>deep_copy</name></expr>)</condition>
    <block>{<block_content>

        <comment type="line">// create the GraphBLAS matrix</comment>
        <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>GB_new</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>A</name></expr></argument>, <comment type="line">// sparse or full, new header</comment>
            <argument><expr><name>atype_out</name></expr></argument>, <argument><expr><operator>(</operator><name>GrB_Index</name><operator>)</operator> <name>nrows</name></expr></argument>, <argument><expr><operator>(</operator><name>GrB_Index</name><operator>)</operator> <name>ncols</name></expr></argument>,
            <argument><expr><name>GB_Ap_calloc</name></expr></argument>, <argument><expr><name>is_csc</name></expr></argument>, <argument><expr><name>sparsity</name></expr></argument>, <argument><expr><name>GxB_HYPER_DEFAULT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>info</name> <operator>!=</operator> <name>GrB_SUCCESS</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>FREE_ALL</name></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>mexWarnMsgIdAndTxt</name> <argument_list>(<argument><expr><literal type="string">"GB:warn"</literal></expr></argument>, <argument><expr><literal type="string">"new deep matrix failed"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr> ;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// A is a deep copy and can be modified by GraphBLAS</comment>
        <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>GB_bix_alloc</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>anz</name></expr></argument>, <argument><expr><name>sparsity</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>info</name> <operator>!=</operator> <name>GrB_SUCCESS</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>FREE_ALL</name></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>mexWarnMsgIdAndTxt</name> <argument_list>(<argument><expr><literal type="string">"GB:warn"</literal></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr> ;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>sparsity</name> <operator>!=</operator> <name>GxB_FULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name>Mp</name></expr></argument>, <argument><expr><operator>(</operator><name>ncols</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>i</name></name></expr></argument>, <argument><expr><name>Mi</name></expr></argument>, <argument><expr><name>anz</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>nvals</name></name> <operator>=</operator> <name><name>A</name><operator>-&gt;</operator><name>p</name> <index>[<expr><name>ncols</name></expr>]</index></name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>GB_MAGIC</name></expr> ;</expr_stmt>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>

        <comment type="line">// the GraphBLAS pattern (A-&gt;p and A-&gt;i) are pointers into the</comment>
        <comment type="line">// built-in matrix and must not be modified.</comment>

        <comment type="line">// [ create the GraphBLAS matrix, do not allocate A-&gt;p</comment>
        <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>GB_new</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>A</name></expr></argument>, <comment type="line">// sparse or full, new header</comment>
            <argument><expr><name>atype_out</name></expr></argument>, <argument><expr><operator>(</operator><name>GrB_Index</name><operator>)</operator> <name>nrows</name></expr></argument>, <argument><expr><operator>(</operator><name>GrB_Index</name><operator>)</operator> <name>ncols</name></expr></argument>,
            <argument><expr><name>GB_Ap_null</name></expr></argument>, <argument><expr><name>is_csc</name></expr></argument>, <argument><expr><name>sparsity</name></expr></argument>, <argument><expr><name>GxB_HYPER_DEFAULT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>info</name> <operator>!=</operator> <name>GrB_SUCCESS</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>FREE_ALL</name></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>mexWarnMsgIdAndTxt</name> <argument_list>(<argument><expr><literal type="string">"GB:warn"</literal></expr></argument>, <argument><expr><literal type="string">"new shallow matrix failed"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr> ;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>sparsity</name> <operator>!=</operator> <name>GxB_FULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name>Mp</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <name>Mi</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>p_size</name></name> <operator>=</operator> <operator>(</operator><name>ncols</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>i_size</name></name> <operator>=</operator> <call><name>GB_IMAX</name> <argument_list>(<argument><expr><name>anz</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>p_shallow</name></name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>i_shallow</name></name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>nvals</name></name> <operator>=</operator> <name><name>A</name><operator>-&gt;</operator><name>p</name> <index>[<expr><name>ncols</name></expr>]</index></name></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>p_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>i_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>p_shallow</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>i_shallow</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>h_shallow</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>      <comment type="line">// A-&gt;h is NULL</comment>
        <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>GB_MAGIC</name></expr> ;</expr_stmt>       <comment type="line">// A-&gt;p now initialized ]</comment>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// copy the numerical values from built-in to the GraphBLAS matrix</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>sparsity</name> <operator>==</operator> <name>GxB_FULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>x_shallow</name></name> <operator>=</operator> <operator>(</operator><operator>!</operator><name>deep_copy</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>atype_out_code</name> <operator>==</operator> <name>atype_in_code</name><operator>)</operator><operator>)</operator></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>x_shallow</name></name> <operator>=</operator> <operator>(</operator><operator>!</operator><name>deep_copy</name> <operator>&amp;&amp;</operator>
               <operator>(</operator><operator>(</operator><name>atype_out_code</name> <operator>==</operator> <name>GB_BOOL_code</name> <operator>||</operator>
                 <name>atype_out_code</name> <operator>==</operator> <name>GB_FP64_code</name> <operator>||</operator>
                 <name>atype_out_code</name> <operator>==</operator> <name>GB_FC64_code</name><operator>)</operator>
             <operator>&amp;&amp;</operator> <operator>(</operator><name>atype_out_code</name> <operator>==</operator> <name>atype_in_code</name><operator>)</operator><operator>)</operator><operator>)</operator></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>A</name><operator>-&gt;</operator><name>x_shallow</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// the built-in matrix and GraphBLAS matrix have the same type;</comment>
        <comment type="line">// (logical, double, or double complex), and a deep copy is not</comment>
        <comment type="line">// requested.  Just make a shallow copy.</comment>
        <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <name>Mx</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>x_size</name></name> <operator>=</operator> <name>anzmax</name> <operator>*</operator> <name><name>atype_out</name><operator>-&gt;</operator><name>size</name></name></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>deep_copy</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// allocate new space for the GraphBLAS values</comment>
            <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <call><name>GB_malloc_memory</name> <argument_list>(<argument><expr><name>anz</name> <operator>*</operator> <name><name>atype_out</name><operator>-&gt;</operator><name>size</name></name></expr></argument>,
                <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GB_void</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>A</name><operator>-&gt;</operator><name>x_size</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>A</name><operator>-&gt;</operator><name>x</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>FREE_ALL</name></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>mexWarnMsgIdAndTxt</name> <argument_list>(<argument><expr><literal type="string">"GB:warn"</literal></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr> ;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>A</name><operator>-&gt;</operator><name>x</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>anz</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>mexErrMsgTxt</name> <argument_list>(<argument><expr><literal type="string">"A-&gt;x is NULL!\n"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>GB_Type_code</name></type> <name>code1</name> <init>=
            <expr><ternary><condition><expr><operator>(</operator><name>atype_out_code</name> <operator>==</operator> <name>GB_UDT_code</name><operator>)</operator></expr> ?</condition><then> <expr><name>GB_FC64_code</name></expr> </then><else>: <expr><name>atype_out_code</name></expr></else></ternary></expr></init></decl> ;</decl_stmt>

        <decl_stmt><decl><type><name>GB_Type_code</name></type> <name>code2</name> <init>=
            <expr><ternary><condition><expr><operator>(</operator><name>atype_in_code</name> <operator>==</operator> <name>GB_UDT_code</name><operator>)</operator></expr> ?</condition><then> <expr><name>GB_FC64_code</name></expr> </then><else>: <expr><name>atype_in_code</name></expr></else></ternary></expr></init></decl> ;</decl_stmt>

        <decl_stmt><decl><type><name>size_t</name></type> <name>asize</name> <init>=
            <expr><ternary><condition><expr><operator>(</operator><name>atype_in_code</name> <operator>==</operator> <name>GB_UDT_code</name><operator>)</operator></expr> ?</condition><then> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>GxB_FC64_t</name></expr></argument>)</argument_list></sizeof></expr> </then><else>:<expr><name><name>atype_in</name><operator>-&gt;</operator><name>size</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>code1</name> <operator>==</operator> <name>code2</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>Mx</name></expr></argument>, <argument><expr><name>anz</name> <operator>*</operator> <name>asize</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>GB_cast_array</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>code1</name></expr></argument>, <argument><expr><name>Mx</name></expr></argument>, <argument><expr><name>code2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>anz</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// compute the # of non-empty vectors in A only when needed</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>sparsity</name> <operator>!=</operator> <name>GxB_FULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>nvec_nonempty</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// set the iso property</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>A_iso</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>A</name><operator>-&gt;</operator><name>x_shallow</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// convert A to iso, and reduce the size of A-&gt;x to a single entry</comment>
            <if_stmt><if>if <condition>(<expr><name><name>A</name><operator>-&gt;</operator><name>x_size</name></name> <operator>&gt;=</operator> <name><name>atype_out</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// use the first entry of A-&gt;x as the iso value of A</comment>
                <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>iso</name></name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="line">// A is converted to iso, but it doesn't have enough space in</comment>
                <comment type="line">// A-&gt;x for the iso value, so set it to zero</comment>
                <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>iso</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><call><name>GB_convert_any_to_iso</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="line">// just set the iso flag, leave A-&gt;x unmodified.  A can be iso</comment>
            <comment type="line">// only if A-&gt;x is large enough to hold at least 1 entry.</comment>
            <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>iso</name></name> <operator>=</operator> <operator>(</operator><name><name>A</name><operator>-&gt;</operator><name>x_size</name></name> <operator>&gt;=</operator> <name><name>atype_out</name><operator>-&gt;</operator><name>size</name></name><operator>)</operator></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"got natural A from built-in"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>h</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// look for CSR/CSC and hyper/non-hyper format</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>A_is_hyper</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>has_hyper_switch</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>has_sparsity_control</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>sparsity_control</name> <init>= <expr><name>GxB_AUTO_SPARSITY</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>hyper_switch</name> <init>= <expr><name>GxB_HYPER_DEFAULT</name></expr></init></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>mxIsStruct</name> <argument_list>(<argument><expr><name>A_builtin</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// look for A.is_csc</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>fieldnumber</name> <init>= <expr><call><name>mxGetFieldNumber</name> <argument_list>(<argument><expr><name>A_builtin</name></expr></argument>, <argument><expr><literal type="string">"is_csc"</literal></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>fieldnumber</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>is_csc</name> <operator>=</operator> <call><name>mxGetScalar</name> <argument_list>(<argument><expr><call><name>mxGetFieldByNumber</name> <argument_list>(<argument><expr><name>A_builtin</name></expr></argument>,
                <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fieldnumber</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// look for A.is_hyper (ignored if hyper_switch present</comment>
        <comment type="line">// or if A is full)</comment>
        <expr_stmt><expr><name>fieldnumber</name> <operator>=</operator> <call><name>mxGetFieldNumber</name> <argument_list>(<argument><expr><name>A_builtin</name></expr></argument>, <argument><expr><literal type="string">"is_hyper"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>fieldnumber</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>A_is_hyper</name> <operator>=</operator> <call><name>mxGetScalar</name> <argument_list>(<argument><expr><call><name>mxGetFieldByNumber</name> <argument_list>(<argument><expr><name>A_builtin</name></expr></argument>,
                <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fieldnumber</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// look for A.hyper_switch (ignored if A is full)</comment>
        <expr_stmt><expr><name>fieldnumber</name> <operator>=</operator> <call><name>mxGetFieldNumber</name> <argument_list>(<argument><expr><name>A_builtin</name></expr></argument>, <argument><expr><literal type="string">"hyper_switch"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>fieldnumber</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>has_hyper_switch</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name>hyper_switch</name> <operator>=</operator> <call><name>mxGetScalar</name> <argument_list>(<argument><expr><call><name>mxGetFieldByNumber</name> <argument_list>(<argument><expr><name>A_builtin</name></expr></argument>,
                <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fieldnumber</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// look for A.sparsity</comment>
        <expr_stmt><expr><name>fieldnumber</name> <operator>=</operator> <call><name>mxGetFieldNumber</name> <argument_list>(<argument><expr><name>A_builtin</name></expr></argument>, <argument><expr><literal type="string">"sparsity"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>fieldnumber</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>has_sparsity_control</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name>sparsity_control</name> <operator>=</operator> <call><name>mxGetScalar</name> <argument_list>(<argument><expr><call><name>mxGetFieldByNumber</name> <argument_list>(<argument><expr><name>A_builtin</name></expr></argument>,
                <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fieldnumber</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// convert to CSR if requested</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>nrows_old</name> <init>= <expr><call><name>GB_NROWS</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>ncols_old</name> <init>= <expr><call><name>GB_NCOLS</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_csc</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// this might convert A to hypersparse</comment>
        <expr_stmt><expr><call><name>GxB_Matrix_Option_set_</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>GxB_FORMAT</name></expr></argument>, <argument><expr><name>GxB_BY_ROW</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <comment type="line">// so convert it back; hypersparsity is defined below</comment>
        <if_stmt><if>if <condition>(<expr><name>sparsity</name> <operator>!=</operator> <name>GxB_FULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>bool</name></type> <name>burble</name> <init>= <expr><call><name>GB_Global_burble_get</name> <argument_list>( )</argument_list></call></expr></init></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>burble</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr><literal type="string">" [ GB_mx_mxArray_to_Matrix "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>GB_convert_hyper_to_sparse</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>burble</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr><literal type="string">"]\n"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name><name>A</name><operator>-&gt;</operator><name>is_csc</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"conformed from built-in"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>h</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>is_csc</name></name> <operator>==</operator> <name>is_csc</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// convert to hypersparse or set hypersparse ratio, if requested</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>sparsity</name> <operator>==</operator> <name>GxB_FULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// leave as-is</comment>
        <empty_stmt>;</empty_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>has_hyper_switch</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// this sets the hyper_switch and then conforms the matrix to its</comment>
        <comment type="line">// desired hypersparsity.  It may stay non-hypersparse.</comment>
        <expr_stmt><expr><call><name>GxB_Matrix_Option_set_</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>GxB_HYPER_SWITCH</name></expr></argument>, <argument><expr><name>hyper_switch</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>A_is_hyper</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// this forces the matrix to be always hypersparse</comment>
        <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"to always hyper"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>GxB_Matrix_Option_set_</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>GxB_SPARSITY_CONTROL</name></expr></argument>, <argument><expr><name>GxB_HYPERSPARSE</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"always hyper"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// set the sparsity control and conform the matrix</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>has_sparsity_control</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"setting sparsity"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>GxB_Matrix_Option_set_</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>GxB_SPARSITY_CONTROL</name></expr></argument>, <argument><expr><name>sparsity_control</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"set sparsity"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>is_csc</name></name> <operator>==</operator> <name>is_csc</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>nrows_old</name> <operator>==</operator> <call><name>GB_NROWS</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>ncols_old</name> <operator>==</operator> <call><name>GB_NCOLS</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// return the GraphBLAS matrix</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>GrB_Matrix_wait</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>GrB_MATERIALIZE</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>info</name> <operator>!=</operator> <name>GrB_SUCCESS</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>FREE_ALL</name></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>mexWarnMsgIdAndTxt</name> <argument_list>(<argument><expr><literal type="string">"GB:warn"</literal></expr></argument>, <argument><expr><literal type="string">"matrix wait failed"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"got A from built-in"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <return>return <expr><operator>(</operator><name>A</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

</unit>
