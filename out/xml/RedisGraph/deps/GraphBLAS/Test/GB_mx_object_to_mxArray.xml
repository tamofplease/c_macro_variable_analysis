<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Test/GB_mx_object_to_mxArray.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_mx_object_to_mxArray</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// Convert a GraphBLAS sparse or full matrix to a built-in struct C containing</comment>
<comment type="line">// C.matrix and a string C.class.  The GraphBLAS matrix is destroyed.</comment>

<comment type="line">// This could be done using only user-callable GraphBLAS functions, by</comment>
<comment type="line">// extracting the tuples and converting them into a built-in sparse matrix.  But</comment>
<comment type="line">// that would be much slower and take more memory.  Instead, most of the work</comment>
<comment type="line">// can be done by pointers, and directly accessing the internal contents of C.</comment>
<comment type="line">// If C has type GB_BOOL_code or GB_FP64_code, then C can be converted to a</comment>
<comment type="line">// built-in matrix in constant time with essentially no extra memory allocated.</comment>
<comment type="line">// This is faster, but it means that this Test interface will only work with</comment>
<comment type="line">// this specific implementation of GraphBLAS.</comment>

<comment type="line">// Note that the GraphBLAS matrix may contain explicit zeros.</comment>

<comment type="line">// If the GraphBLAS matrix is iso, it is converted to non-iso, but if it is</comment>
<comment type="line">// returned as a struct, the C.iso is set true.  Then when the struct is read</comment>
<comment type="line">// back into GraphBLAS, the flag can be used to restore the iso property of the</comment>
<comment type="line">// GraphBLAS matrix .</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_mex.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_AS_IF_FREE</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro>                \
<cpp:value>{                                       \
    GB_Global_memtable_remove (p) ;     \
    (p) = NULL ;                        \
}</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>MatrixFields</name> <index>[ ]</index></name> <init>= <expr><block>{ <expr><literal type="string">"matrix"</literal></expr>, <expr><literal type="string">"class"</literal></expr>, <expr><literal type="string">"iso"</literal></expr>, <expr><literal type="string">"values"</literal></expr> }</block></expr></init></decl> ;</decl_stmt>

<function><type><name>mxArray</name> <modifier>*</modifier></type><name>GB_mx_object_to_mxArray</name>   <comment type="line">// returns the built-in mxArray</comment>
<parameter_list>(
    <parameter><decl><type><name>GrB_Matrix</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>,             <comment type="line">// handle of GraphBLAS matrix to convert</comment>
    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>create_struct</name></decl></parameter>        <comment type="line">// if true, then return a struct</comment>
)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>GB_CONTEXT</name> <argument_list>(<argument><expr><literal type="string">"GB_mx_object_to_mxArray"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// get the inputs</comment>
    <decl_stmt><decl><type><name>mxArray</name> <modifier>*</modifier></type><name>A</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>Astruct</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>X</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Matrix</name></type> <name>C</name> <init>= <expr><operator>*</operator><name>handle</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Type</name></type> <name>ctype</name> <init>= <expr><name><name>C</name><operator>-&gt;</operator><name>type</name></name></expr></init></decl> ;</decl_stmt>

    <comment type="line">// may have pending tuples</comment>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// C must not be shallow</comment>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name><name>C</name><operator>-&gt;</operator><name>p_shallow</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name><name>C</name><operator>-&gt;</operator><name>h_shallow</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name><name>C</name><operator>-&gt;</operator><name>b_shallow</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name><name>C</name><operator>-&gt;</operator><name>i_shallow</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name><name>C</name><operator>-&gt;</operator><name>x_shallow</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// make sure there are no pending computations</comment>
    <if_stmt><if>if <condition>(<expr><call><name>GB_IS_FULL</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_JUMBLED</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_ZOMBIES</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_PENDING</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="line">// this may convert C to full</comment>
        <expr_stmt><expr><call><name>GrB_Matrix_wait</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>GrB_MATERIALIZE</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name>C</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>handle</name><operator>)</operator></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">// must be done after GrB_Matrix_wait:</comment>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>cnz</name> <init>= <expr><call><name>GB_nnz</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"TO mxArray after assembling pending tuples"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// ensure C is sparse or full, not hypersparse or bitmap</comment>
    <expr_stmt><expr><call><name>GxB_Matrix_Option_set_</name><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>GxB_SPARSITY_CONTROL</name></expr></argument>, <argument><expr><name>GxB_FULL</name> <operator>+</operator> <name>GxB_SPARSE</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"TO mxArray, sparse or full"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_IS_HYPERSPARSE</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// get the current sparsity</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>sparsity</name></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>GxB_Matrix_Option_get_</name><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>GxB_SPARSITY_STATUS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sparsity</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>sparsity</name> <operator>==</operator> <name>GxB_FULL</name> <operator>||</operator> <name>sparsity</name> <operator>==</operator> <name>GxB_SPARSE</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// make sure it's CSC</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>C</name><operator>-&gt;</operator><name>is_csc</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>GxB_Matrix_Option_set_</name><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>GxB_FORMAT</name></expr></argument>, <argument><expr><name>GxB_BY_COL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// setting to CSC may have transposed the matrix</comment>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GrB_Matrix_wait</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>GrB_MATERIALIZE</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_JUMBLED</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><name>cnz</name> <operator>=</operator> <call><name>GB_nnz</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"TO mxArray, non-hyper CSC"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_JUMBLED</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_IS_HYPERSPARSE</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_IS_SPARSE</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>GB_IS_FULL</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>is_csc</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// convert C to non-iso</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>C_iso</name> <init>= <expr><name><name>C</name><operator>-&gt;</operator><name>iso</name></name></expr></init></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>C_iso</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>GB_convert_any_to_non_iso</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"TO mxArray, non-iso non-hyper CSC"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// empty built-in matrices don't want NULL pointers</comment>
    <if_stmt><if>if <condition>(<expr><name><name>C</name><operator>-&gt;</operator><name>x</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>cnz</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <call><name>GB_malloc_memory</name> <argument_list>(<argument><expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>,
            <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GB_void</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>C</name><operator>-&gt;</operator><name>x_size</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>x_shallow</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>C_is_full</name> <init>= <expr><operator>(</operator><name>sparsity</name> <operator>==</operator> <name>GxB_FULL</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>C_is_full</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// empty built-in sparse matrices don't want NULL pointers</comment>
        <if_stmt><if>if <condition>(<expr><name><name>C</name><operator>-&gt;</operator><name>i</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>cnz</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator> <call><name>GB_malloc_memory</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>C</name><operator>-&gt;</operator><name>i_size</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>i</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>i_shallow</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>C</name><operator>-&gt;</operator><name>p</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>cnz</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator> <call><name>GB_malloc_memory</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>vdim</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, 
                <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>C</name><operator>-&gt;</operator><name>p_size</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name><name>C</name><operator>-&gt;</operator><name>vdim</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>p_shallow</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// create the built-in matrix A and link in the numerical values of C</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>C_is_full</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// C is full.</comment>
        <comment type="line">// allocate an empty dense matrix of the right type, then set content</comment>

        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>Cx</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>C</name><operator>-&gt;</operator><name>x</name></name></expr></init></decl> ;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>ctype</name> <operator>==</operator> <name>GrB_BOOL</name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><name>A</name> <operator>=</operator> <call><name>mxCreateLogicalMatrix</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>mxSetData</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>Cx</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>ctype</name> <operator>==</operator> <name>GrB_FP32</name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><name>A</name> <operator>=</operator> <call><name>mxCreateNumericMatrix</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>mxSINGLE_CLASS</name></expr></argument>, <argument><expr><name>mxREAL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>mxSetSingles</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>Cx</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>ctype</name> <operator>==</operator> <name>GrB_FP64</name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><name>A</name> <operator>=</operator> <call><name>mxCreateNumericMatrix</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>mxDOUBLE_CLASS</name></expr></argument>, <argument><expr><name>mxREAL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>mxSetDoubles</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>Cx</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>ctype</name> <operator>==</operator> <name>GrB_INT8</name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><name>A</name> <operator>=</operator> <call><name>mxCreateNumericMatrix</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>mxINT8_CLASS</name></expr></argument>, <argument><expr><name>mxREAL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>mxSetInt8s</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>Cx</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>ctype</name> <operator>==</operator> <name>GrB_INT16</name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><name>A</name> <operator>=</operator> <call><name>mxCreateNumericMatrix</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>mxINT16_CLASS</name></expr></argument>, <argument><expr><name>mxREAL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>mxSetInt16s</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>Cx</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>ctype</name> <operator>==</operator> <name>GrB_INT32</name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><name>A</name> <operator>=</operator> <call><name>mxCreateNumericMatrix</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>mxINT32_CLASS</name></expr></argument>, <argument><expr><name>mxREAL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>mxSetInt32s</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>Cx</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>ctype</name> <operator>==</operator> <name>GrB_INT64</name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><name>A</name> <operator>=</operator> <call><name>mxCreateNumericMatrix</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>mxINT64_CLASS</name></expr></argument>, <argument><expr><name>mxREAL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>mxSetInt64s</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>Cx</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>ctype</name> <operator>==</operator> <name>GrB_UINT8</name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><name>A</name> <operator>=</operator> <call><name>mxCreateNumericMatrix</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>mxUINT8_CLASS</name></expr></argument>, <argument><expr><name>mxREAL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>mxSetUint8s</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>Cx</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>ctype</name> <operator>==</operator> <name>GrB_UINT16</name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><name>A</name> <operator>=</operator> <call><name>mxCreateNumericMatrix</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>mxUINT16_CLASS</name></expr></argument>, <argument><expr><name>mxREAL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>mxSetUint16s</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>Cx</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>ctype</name> <operator>==</operator> <name>GrB_UINT32</name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><name>A</name> <operator>=</operator> <call><name>mxCreateNumericMatrix</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>mxUINT32_CLASS</name></expr></argument>, <argument><expr><name>mxREAL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>mxSetUint32s</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>Cx</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>ctype</name> <operator>==</operator> <name>GrB_UINT64</name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><name>A</name> <operator>=</operator> <call><name>mxCreateNumericMatrix</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>mxUINT64_CLASS</name></expr></argument>, <argument><expr><name>mxREAL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>mxSetUint64s</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>Cx</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>ctype</name> <operator>==</operator> <name>GxB_FC32</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>A</name> <operator>=</operator> <call><name>mxCreateNumericMatrix</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>mxSINGLE_CLASS</name></expr></argument>, <argument><expr><name>mxCOMPLEX</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>mxSetComplexSingles</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>Cx</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>ctype</name> <operator>==</operator> <name>Complex</name> <operator>||</operator> <name>ctype</name> <operator>==</operator> <name>GxB_FC64</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>A</name> <operator>=</operator> <call><name>mxCreateNumericMatrix</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>mxDOUBLE_CLASS</name></expr></argument>, <argument><expr><name>mxCOMPLEX</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>mxSetComplexDoubles</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>Cx</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>mexErrMsgTxt</name> <argument_list>(<argument><expr><literal type="string">"... unsupported type"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><call><name>mexMakeMemoryPersistent</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>x_shallow</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>GB_AS_IF_FREE</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>   <comment type="line">// unlink C-&gt;x from C; now in built-in C</comment>

    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>C</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>GrB_BOOL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// C is boolean, which is the same as a built-in logical sparse matrix</comment>
        <expr_stmt><expr><name>A</name> <operator>=</operator> <call><name>mxCreateSparseLogicalMatrix</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>mexMakeMemoryPersistent</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>mxSetData</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <name><name>C</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>x_shallow</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>

        <comment type="line">// C-&gt;x is treated as if it was freed</comment>
        <expr_stmt><expr><call><name>GB_AS_IF_FREE</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>   <comment type="line">// unlink C-&gt;x from C; now in built-in C</comment>

    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>C</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>GrB_FP64</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// C is double, which is the same as a built-in double sparse matrix</comment>
        <expr_stmt><expr><name>A</name> <operator>=</operator> <call><name>mxCreateSparse</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>mxREAL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>mexMakeMemoryPersistent</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>mxSetData</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>x_shallow</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>

        <comment type="line">// C-&gt;x is treated as if it was freed</comment>
        <expr_stmt><expr><call><name>GB_AS_IF_FREE</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>   <comment type="line">// unlink C-&gt;x from C; in built-in C</comment>

    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>C</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>Complex</name> <operator>||</operator> <name><name>C</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>GxB_FC64</name></expr>)</condition>
    <block>{<block_content>

        <comment type="line">// user-defined Complex type, or GraphBLAS GxB_FC64</comment>
        <expr_stmt><expr><name>A</name> <operator>=</operator> <call><name>mxCreateSparse</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>vlen</name></name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>vdim</name></name></expr></argument>, <argument><expr><name>cnz</name></expr></argument>, <argument><expr><name>mxCOMPLEX</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><call><name>mxGetComplexDoubles</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>cnz</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>GxB_FC64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>C</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>GxB_FC32</name></expr>)</condition>
    <block>{<block_content>

        <comment type="line">// C is single complex, typecast to sparse double complex</comment>
        <expr_stmt><expr><name>A</name> <operator>=</operator> <call><name>mxCreateSparse</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>vlen</name></name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>vdim</name></name></expr></argument>, <argument><expr><name>cnz</name></expr></argument>, <argument><expr><name>mxCOMPLEX</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <decl_stmt><decl><type><name>GB_void</name> <modifier>*</modifier></type><name>Ax</name> <init>= <expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <call><name>mxGetComplexDoubles</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>Ax</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>cnz</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>mexErrMsgTxt</name> <argument_list>(<argument><expr><literal type="string">"Ax is NULL!\n"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>GB_cast_array</name> <argument_list>(<argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>GB_FC64_code</name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>code</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>cnz</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>

        <comment type="line">// otherwise C is cast into a built-in double sparse matrix</comment>
        <expr_stmt><expr><name>A</name> <operator>=</operator> <call><name>mxCreateSparse</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>mxREAL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>Sx_size</name></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>Sx</name> <init>= <expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator> <call><name>GB_malloc_memory</name> <argument_list>(<argument><expr><name>cnz</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>,
            <argument><expr><operator>&amp;</operator><name>Sx_size</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>Sx</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>cnz</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>mexErrMsgTxt</name> <argument_list>(<argument><expr><literal type="string">"Sx is NULL!\n"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>GB_cast_array</name> <argument_list>(<argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name>Sx</name></expr></argument>, <argument><expr><name>GB_FP64_code</name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>code</name></name></expr></argument>,
            <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>cnz</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>mexMakeMemoryPersistent</name> <argument_list>(<argument><expr><name>Sx</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>mxSetPr</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>Sx</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <comment type="line">// Sx was just malloc'd.  Treat it as if GraphBLAS has freed it</comment>
        <expr_stmt><expr><call><name>GB_AS_IF_FREE</name> <argument_list>(<argument><expr><name>Sx</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>create_struct</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// If C is int64 or uint64, then typecasting can lose information,</comment>
            <comment type="line">// so keep an uncasted copy of C-&gt;x as well.</comment>
            <expr_stmt><expr><name>X</name> <operator>=</operator> <call><name>GB_mx_create_full</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>mxSetM</name> <argument_list>(<argument><expr><name>X</name></expr></argument>, <argument><expr><name>cnz</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>mxSetN</name> <argument_list>(<argument><expr><name>X</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>mxSetData</name> <argument_list>(<argument><expr><name>X</name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>mexMakeMemoryPersistent</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>x_shallow</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
            <comment type="line">// treat C-&gt;x as if it were freed</comment>
            <expr_stmt><expr><call><name>GB_AS_IF_FREE</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">// set nrows, ncols, nzmax, and the pattern of A</comment>
    <expr_stmt><expr><call><name>mxSetM</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>vlen</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>mxSetN</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>vdim</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>mxSetNzmax</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>cnz</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>C_is_full</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>mxFree</name> <argument_list>(<argument><expr><call><name>mxGetJc</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>mxFree</name> <argument_list>(<argument><expr><call><name>mxGetIr</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>mexMakeMemoryPersistent</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>mexMakeMemoryPersistent</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>i</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>mxSetJc</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name> <operator>*</operator><operator>)</operator> <name><name>C</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>mxSetIr</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name> <operator>*</operator><operator>)</operator> <name><name>C</name><operator>-&gt;</operator><name>i</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <comment type="line">// treat C-&gt;p as if freed</comment>
        <expr_stmt><expr><call><name>GB_AS_IF_FREE</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <comment type="line">// treat C-&gt;i as if freed</comment>
        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>i_shallow</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>GB_AS_IF_FREE</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>i</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// free C, but leave any shallow components untouched</comment>
    <comment type="line">// since these have been transplanted into the built-in matrix.</comment>
    <expr_stmt><expr><call><name>GrB_Matrix_free_</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>create_struct</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// create the type</comment>
        <decl_stmt><decl><type><name>mxArray</name> <modifier>*</modifier></type><name>atype</name> <init>= <expr><call><name>GB_mx_Type_to_mxstring</name> <argument_list>(<argument><expr><name>ctype</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
        <comment type="line">// create the iso flag</comment>
        <decl_stmt><decl><type><name>mxArray</name> <modifier>*</modifier></type><name>c_iso</name> <init>= <expr><call><name>mxCreateLogicalScalar</name> <argument_list>(<argument><expr><name>C_iso</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
        <comment type="line">// create the output struct</comment>
        <expr_stmt><expr><name>Astruct</name> <operator>=</operator> <call><name>mxCreateStructMatrix</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
           <argument><expr><ternary><condition><expr><operator>(</operator><name>X</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">3</literal></expr> </then><else>: <expr><literal type="number">4</literal></expr></else></ternary></expr></argument>, <argument><expr><name>MatrixFields</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>mxSetFieldByNumber</name> <argument_list>(<argument><expr><name>Astruct</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>A</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>mxSetFieldByNumber</name> <argument_list>(<argument><expr><name>Astruct</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>atype</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>mxSetFieldByNumber</name> <argument_list>(<argument><expr><name>Astruct</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>c_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>X</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>mxSetFieldByNumber</name> <argument_list>(<argument><expr><name>Astruct</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>X</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><operator>(</operator><name>Astruct</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <return>return <expr><operator>(</operator><name>A</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

</unit>
