<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Demo/Source/usercomplex.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GraphBLAS/Demo/Source/usercomplex.c:  complex numbers as a user-defined type</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MATLAB_MEX_FILE</name></cpp:ifdef>

    <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_mex.h"</cpp:file></cpp:include>

    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OK</name><parameter_list>(<parameter><type><name>method</name></type></parameter>)</parameter_list></cpp:macro>                                                      \
    <cpp:value>{                                                                       \
        info = method ;                                                     \
        if (! (info == GrB_SUCCESS || info == GrB_NO_VALUE))                \
        {                                                                   \
            return (info) ;                                                 \
        }                                                                   \
    }</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

    <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GraphBLAS.h"</cpp:file></cpp:include>
    <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_PUBLIC</name></cpp:undef>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_LIBRARY</name></cpp:macro></cpp:define>
    <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"graphblas_demos.h"</cpp:file></cpp:include>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__INTEL_COMPILER</name></expr></cpp:if>
    <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name> <name>(</name><name>disable</name><name>:</name> <name>58</name> <name>167</name> <name>144</name> <name>161</name> <name>177</name> <name>181</name> <name>186</name> <name>188</name> <name>589</name> <name>593</name> <name>869</name> <name>981</name> \
        <name>1418</name> <name>1419</name> <name>1572</name> <name>1599</name> <name>2259</name> <name>2282</name> <name>2557</name> <name>2547</name> <name>3280</name> <name>)</name></cpp:pragma>
    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>__GNUC__</name></expr></cpp:elif>
    <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>GCC</name> <name>diagnostic</name> <name>ignored</name> <cpp:literal>"-Wunused-parameter"</cpp:literal></cpp:pragma>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name> <argument_list>( <argument><expr><name>__cplusplus</name></expr></argument> )</argument_list></call></expr></cpp:if>
    <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>GCC</name> <name>diagnostic</name> <name>ignored</name> <cpp:literal>"-Wincompatible-pointer-types"</cpp:literal></cpp:pragma>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OK</name></cpp:undef>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OK</name><parameter_list>(<parameter><type><name>method</name></type></parameter>)</parameter_list></cpp:macro>                                                      \
    <cpp:value>{                                                                       \
        info = method ;                                                     \
        if (! (info == GrB_SUCCESS || info == GrB_NO_VALUE))                \
        {                                                                   \
            Complex_finalize ( ) ;                                          \
            return (info) ;                                                 \
        }                                                                   \
    }</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>GrB_BinaryOp</name></type> <name>Complex_first</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>Complex_second</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>Complex_min</name> <init>= <expr><name>NULL</name></expr></init></decl>,
             <decl><type ref="prev"/><name>Complex_max</name>   <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>Complex_plus</name>   <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>Complex_minus</name> <init>= <expr><name>NULL</name></expr></init></decl>,
             <decl><type ref="prev"/><name>Complex_times</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>Complex_div</name>    <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>Complex_rminus</name> <init>= <expr><name>NULL</name></expr></init></decl>,
             <decl><type ref="prev"/><name>Complex_rdiv</name>  <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>Complex_pair</name>   <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>

<decl_stmt><decl><type><name>GrB_BinaryOp</name></type> <name>Complex_iseq</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>Complex_isne</name> <init>= <expr><name>NULL</name></expr></init></decl>,
             <decl><type ref="prev"/><name>Complex_isgt</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>Complex_islt</name> <init>= <expr><name>NULL</name></expr></init></decl>,
             <decl><type ref="prev"/><name>Complex_isge</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>Complex_isle</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>

<decl_stmt><decl><type><name>GrB_BinaryOp</name></type> <name>Complex_or</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>Complex_and</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>Complex_xor</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>

<decl_stmt><decl><type><name>GrB_BinaryOp</name></type> <name>Complex_eq</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>Complex_ne</name> <init>= <expr><name>NULL</name></expr></init></decl>,
             <decl><type ref="prev"/><name>Complex_gt</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>Complex_lt</name> <init>= <expr><name>NULL</name></expr></init></decl>,
             <decl><type ref="prev"/><name>Complex_ge</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>Complex_le</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>

<decl_stmt><decl><type><name>GrB_BinaryOp</name></type> <name>Complex_complex</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>

<decl_stmt><decl><type><name>GrB_UnaryOp</name></type>  <name>Complex_identity</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>Complex_ainv</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>Complex_minv</name> <init>= <expr><name>NULL</name></expr></init></decl>,
             <decl><type ref="prev"/><name>Complex_not</name> <init>= <expr><name>NULL</name></expr></init></decl>,      <decl><type ref="prev"/><name>Complex_conj</name> <init>= <expr><name>NULL</name></expr></init></decl>,
             <decl><type ref="prev"/><name>Complex_one</name> <init>= <expr><name>NULL</name></expr></init></decl>,      <decl><type ref="prev"/><name>Complex_abs</name>  <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>

<decl_stmt><decl><type><name>GrB_UnaryOp</name></type> <name>Complex_real</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>Complex_imag</name> <init>= <expr><name>NULL</name></expr></init></decl>,
            <decl><type ref="prev"/><name>Complex_cabs</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>Complex_angle</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>

<decl_stmt><decl><type><name>GrB_UnaryOp</name></type> <name>Complex_complex_real</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>Complex_complex_imag</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>

<decl_stmt><decl><type><name>GrB_Type</name></type> <name>Complex</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
<decl_stmt><decl><type><name>GrB_Monoid</name></type>   <name>Complex_plus_monoid</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>Complex_times_monoid</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
<decl_stmt><decl><type><name>GrB_Semiring</name></type> <name>Complex_plus_times</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// binary functions, z=f(x,y), where CxC -&gt; Complex</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

 <function><type><name>void</name></type> <name>complex_first</name> <parameter_list>(<parameter><decl><type><name>GxB_FC64_t</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>y</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <operator>(</operator><operator>*</operator><name>x</name><operator>)</operator></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_FIRST</name></cpp:macro>                                                         \
<cpp:value>"void "                                                                       \
"complex_first GxB_FC64_t *z, const GxB_FC64_t *x, const GxB_FC64_t *y)   \n" \
"{                                                                        \n" \
"   (*z) = (*x) :                                                         \n" \
"}"</cpp:value></cpp:define>

 <function><type><name>void</name></type> <name>complex_second</name> <parameter_list>(<parameter><decl><type><name>GxB_FC64_t</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>y</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <operator>(</operator><operator>*</operator><name>y</name><operator>)</operator></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_SECOND</name></cpp:macro>                                                        \
<cpp:value>"void "                                                                       \
"complex_second (GxB_FC64_t *z, const GxB_FC64_t *x, const GxB_FC64_t *y) \n" \
"{                                                                        \n" \
"   (*z) = (*y) ;                                                         \n" \
"}"</cpp:value></cpp:define>

 <function><type><name>void</name></type> <name>complex_pair</name> <parameter_list>(<parameter><decl><type><name>GxB_FC64_t</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>y</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <call><name>GxB_CMPLX</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_PAIR</name></cpp:macro>                                                          \
<cpp:value>"void "                                                                       \
"complex_pair (GxB_FC64_t *z, const GxB_FC64_t *x, const GxB_FC64_t *y)   \n" \
"{                                                                        \n" \
"   (*z) = GxB_CMPLX (1,0) ;                                              \n" \
"}"</cpp:value></cpp:define>

 <function><type><name>void</name></type>
 <name>complex_plus</name> <parameter_list>(<parameter><decl><type><name>GxB_FC64_t</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>y</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <operator>(</operator><operator>*</operator><name>x</name><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>*</operator><name>y</name><operator>)</operator></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_PLUS</name></cpp:macro>                                                          \
<cpp:value>"void "                                                                       \
"complex_plus (GxB_FC64_t *z, const GxB_FC64_t *x, const GxB_FC64_t *y)   \n" \
"{                                                                        \n" \
"   (*z) = (*x) + (*y) ;                                                  \n" \
"}"</cpp:value></cpp:define>

 <function><type><name>void</name></type> <name>complex_minus</name> <parameter_list>(<parameter><decl><type><name>GxB_FC64_t</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>y</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <operator>(</operator><operator>*</operator><name>x</name><operator>)</operator> <operator>-</operator> <operator>(</operator><operator>*</operator><name>y</name><operator>)</operator></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_MINUS</name></cpp:macro>                                                         \
<cpp:value>"void "                                                                       \
"complex_minus (GxB_FC64_t *z, const GxB_FC64_t *x, const GxB_FC64_t *y)  \n" \
"{                                                                        \n" \
"   (*z) = (*x) - (*y) ;                                                  \n" \
"}"</cpp:value></cpp:define>

 <function><type><name>void</name></type> <name>complex_rminus</name> <parameter_list>(<parameter><decl><type><name>GxB_FC64_t</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>y</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <operator>(</operator><operator>*</operator><name>y</name><operator>)</operator> <operator>-</operator> <operator>(</operator><operator>*</operator><name>x</name><operator>)</operator></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_RMINUS</name></cpp:macro>                                                        \
<cpp:value>"void "                                                                       \
"complex_rminus (GxB_FC64_t *z, const GxB_FC64_t *x, const GxB_FC64_t *y) \n" \
"{                                                                        \n" \
"   (*z) = (*y) - (*x) ;                                                  \n" \
"}"</cpp:value></cpp:define>

 <function><type><name>void</name></type> <name>complex_times</name> <parameter_list>(<parameter><decl><type><name>GxB_FC64_t</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>y</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <operator>(</operator><operator>*</operator><name>x</name><operator>)</operator> <operator>*</operator> <operator>(</operator><operator>*</operator><name>y</name><operator>)</operator></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_TIMES</name></cpp:macro>                                                         \
<cpp:value>"void "                                                                       \
"complex_times (GxB_FC64_t *z, const GxB_FC64_t *x, const GxB_FC64_t *y)  \n" \
"{                                                                        \n" \
"   (*z) = (*x) * (*y) ;                                                  \n" \
"}"</cpp:value></cpp:define>

 <function><type><name>void</name></type> <name>complex_div</name> <parameter_list>(<parameter><decl><type><name>GxB_FC64_t</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>y</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <operator>(</operator><operator>*</operator><name>x</name><operator>)</operator> <operator>/</operator> <operator>(</operator><operator>*</operator><name>y</name><operator>)</operator></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_DIV</name></cpp:macro>                                                           \
<cpp:value>"void "                                                                       \
"complex_div (GxB_FC64_t *z, const GxB_FC64_t *x, const GxB_FC64_t *y)    \n" \
"{                                                                        \n" \
"   (*z) = (*x) / (*y) ;                                                  \n" \
"}"</cpp:value></cpp:define>

 <function><type><name>void</name></type> <name>complex_rdiv</name> <parameter_list>(<parameter><decl><type><name>GxB_FC64_t</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>y</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <operator>(</operator><operator>*</operator><name>y</name><operator>)</operator> <operator>/</operator> <operator>(</operator><operator>*</operator><name>x</name><operator>)</operator></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_RDIV</name></cpp:macro>                                                          \
<cpp:value>"void "                                                                       \
"complex_rdiv (GxB_FC64_t *z, const GxB_FC64_t *x, const GxB_FC64_t *y)   \n" \
"{                                                                        \n" \
"   (*z) = (*y) / (*x) ;                                                  \n" \
"}"</cpp:value></cpp:define>

<comment type="line">// min (x,y): complex number with smallest magnitude.  If tied, select the</comment>
<comment type="line">// one with the smallest phase angle.  No special cases for NaNs.</comment>

 <function><type><name>void</name></type> <name>complex_min</name> <parameter_list>(<parameter><decl><type><name>GxB_FC64_t</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>y</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>absx</name> <init>= <expr><call><name>cabs</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>absy</name> <init>= <expr><call><name>cabs</name> <argument_list>(<argument><expr><operator>*</operator><name>y</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>absx</name> <operator>&lt;</operator> <name>absy</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <operator>(</operator><operator>*</operator><name>x</name><operator>)</operator></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>absx</name> <operator>&gt;</operator> <name>absy</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <operator>(</operator><operator>*</operator><name>y</name><operator>)</operator></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>carg</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>carg</name> <argument_list>(<argument><expr><operator>*</operator><name>y</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><operator>*</operator><name>x</name><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><operator>*</operator><name>y</name><operator>)</operator></expr></else></ternary></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_MIN</name></cpp:macro>                                                           \
<cpp:value>"void "                                                                       \
"complex_min (GxB_FC64_t *z, const GxB_FC64_t *x, const GxB_FC64_t *y)    \n" \
"{                                                                        \n" \
"   double absx = cabs (*x) ;                                             \n" \
"   double absy = cabs (*y) ;                                             \n" \
"   if (absx &lt; absy)                                                      \n" \
"   {                                                                     \n" \
"       (*z) = (*x) ;                                                     \n" \
"   }                                                                     \n" \
"   else if (absx &gt; absy)                                                 \n" \
"   {                                                                     \n" \
"       (*z) = (*y) ;                                                     \n" \
"   }                                                                     \n" \
"   else                                                                  \n" \
"   {                                                                     \n" \
"       (*z) = (carg (*x) &lt; carg (*y)) ? (*x) : (*y) ;                    \n" \
"   }                                                                     \n" \
"}"</cpp:value></cpp:define>

<comment type="line">// max (x,y): complex number with largest magnitude.  If tied, select the one</comment>
<comment type="line">// with the largest phase angle.  No special cases for NaNs.</comment>

 <function><type><name>void</name></type> <name>complex_max</name> <parameter_list>(<parameter><decl><type><name>GxB_FC64_t</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>y</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>absx</name> <init>= <expr><call><name>cabs</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>absy</name> <init>= <expr><call><name>cabs</name> <argument_list>(<argument><expr><operator>*</operator><name>y</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>absx</name> <operator>&gt;</operator> <name>absy</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <operator>(</operator><operator>*</operator><name>x</name><operator>)</operator></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>absx</name> <operator>&lt;</operator> <name>absy</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <operator>(</operator><operator>*</operator><name>y</name><operator>)</operator></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>carg</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>carg</name> <argument_list>(<argument><expr><operator>*</operator><name>y</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><operator>*</operator><name>x</name><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><operator>*</operator><name>y</name><operator>)</operator></expr></else></ternary></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_MAX</name></cpp:macro>                                                           \
<cpp:value>"void "                                                                       \
"complex_max (GxB_FC64_t *z, const GxB_FC64_t *x, const GxB_FC64_t *y)    \n" \
"{                                                                        \n" \
"   double absx = cabs (*x) ;                                             \n" \
"   double absy = cabs (*y) ;                                             \n" \
"   if (absx &gt; absy)                                                      \n" \
"   {                                                                     \n" \
"       (*z) = (*x) ;                                                     \n" \
"   }                                                                     \n" \
"   else if (absx &lt; absy)                                                 \n" \
"   {                                                                     \n" \
"       (*z) = (*y) ;                                                     \n" \
"   }                                                                     \n" \
"   else                                                                  \n" \
"   {                                                                     \n" \
"       (*z) = (carg (*x) &gt; carg (*y)) ? (*x) : (*y) ;                    \n" \
"   }                                                                     \n" \
"}"</cpp:value></cpp:define>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// 6 binary functions, z=f(x,y); CxC -&gt; Complex ; (1,0) = true, (0,0) = false</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

 <function><type><name>void</name></type> <name>complex_iseq</name> <parameter_list>(<parameter><decl><type><name>GxB_FC64_t</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>y</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>eq</name> <init>= <expr><operator>(</operator><call><name>creal</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>creal</name> <argument_list>(<argument><expr><operator>*</operator><name>y</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>cimag</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>cimag</name> <argument_list>(<argument><expr><operator>*</operator><name>y</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <ternary><condition><expr><name>eq</name></expr> ?</condition><then> <expr><call><name>GxB_CMPLX</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>GxB_CMPLX</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_ISEQ</name></cpp:macro>                                                          \
<cpp:value>"void "                                                                       \
"complex_iseq (GxB_FC64_t *z, const GxB_FC64_t *x, const GxB_FC64_t *y)   \n" \
"{                                                                        \n" \
"   bool eq = (creal (*x) == creal (*y) &amp;&amp; cimag (*x) == cimag (*y)) ;    \n" \
"   (*z) = eq ? GxB_CMPLX (1,0) : GxB_CMPLX (0,0) ;                       \n" \
"}"</cpp:value></cpp:define>

 <function><type><name>void</name></type> <name>complex_isne</name> <parameter_list>(<parameter><decl><type><name>GxB_FC64_t</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>y</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>ne</name> <init>= <expr><operator>(</operator><call><name>creal</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>creal</name> <argument_list>(<argument><expr><operator>*</operator><name>y</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>cimag</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>cimag</name> <argument_list>(<argument><expr><operator>*</operator><name>y</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <ternary><condition><expr><name>ne</name></expr> ?</condition><then> <expr><call><name>GxB_CMPLX</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>GxB_CMPLX</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_ISNE</name></cpp:macro>                                                          \
<cpp:value>"void "                                                                       \
"complex_isne (GxB_FC64_t *z, const GxB_FC64_t *x, const GxB_FC64_t *y)   \n" \
"{                                                                        \n" \
"   bool ne = (creal (*x) != creal (*y) || cimag (*x) != cimag (*y)) ;    \n" \
"   (*z) = ne ? GxB_CMPLX (1,0) : GxB_CMPLX (0,0) ;                       \n" \
"}"</cpp:value></cpp:define>

 <function><type><name>void</name></type> <name>complex_isgt</name> <parameter_list>(<parameter><decl><type><name>GxB_FC64_t</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>y</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>gt</name> <init>= <expr><operator>(</operator><call><name>creal</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>creal</name> <argument_list>(<argument><expr><operator>*</operator><name>y</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <ternary><condition><expr><name>gt</name></expr> ?</condition><then> <expr><call><name>GxB_CMPLX</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>GxB_CMPLX</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_ISGT</name></cpp:macro>                                                          \
<cpp:value>"void "                                                                       \
"complex_isgt (GxB_FC64_t *z, const GxB_FC64_t *x, const GxB_FC64_t *y)   \n" \
"{                                                                        \n" \
"   bool gt = (creal (*x) &gt; creal (*y)) ;                                 \n" \
"   (*z) = gt ? GxB_CMPLX (1,0) : GxB_CMPLX (0,0) ;                       \n" \
"}"</cpp:value></cpp:define>

 <function><type><name>void</name></type> <name>complex_islt</name> <parameter_list>(<parameter><decl><type><name>GxB_FC64_t</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>y</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>lt</name> <init>= <expr><operator>(</operator><call><name>creal</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>creal</name> <argument_list>(<argument><expr><operator>*</operator><name>y</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <ternary><condition><expr><name>lt</name></expr> ?</condition><then> <expr><call><name>GxB_CMPLX</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>GxB_CMPLX</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_ISLT</name></cpp:macro>                                                          \
<cpp:value>"void "                                                                       \
"complex_islt (GxB_FC64_t *z, const GxB_FC64_t *x, const GxB_FC64_t *y)   \n" \
"{                                                                        \n" \
"   bool lt = (creal (*x) &lt; creal (*y)) ;                                 \n" \
"   (*z) = lt ? GxB_CMPLX (1,0) : GxB_CMPLX (0,0) ;                       \n" \
"}"</cpp:value></cpp:define>

 <function><type><name>void</name></type> <name>complex_isge</name> <parameter_list>(<parameter><decl><type><name>GxB_FC64_t</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>y</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>ge</name> <init>= <expr><operator>(</operator><call><name>creal</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <call><name>creal</name> <argument_list>(<argument><expr><operator>*</operator><name>y</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <ternary><condition><expr><name>ge</name></expr> ?</condition><then> <expr><call><name>GxB_CMPLX</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>GxB_CMPLX</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_ISGE</name></cpp:macro>                                                          \
<cpp:value>"void "                                                                       \
"complex_isge (GxB_FC64_t *z, const GxB_FC64_t *x, const GxB_FC64_t *y)   \n" \
"{                                                                        \n" \
"   bool ge = (creal (*x) &gt;= creal (*y)) ;                                \n" \
"   (*z) = ge ? GxB_CMPLX (1,0) : GxB_CMPLX (0,0) ;                       \n" \
"}"</cpp:value></cpp:define>

 <function><type><name>void</name></type> <name>complex_isle</name> <parameter_list>(<parameter><decl><type><name>GxB_FC64_t</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>y</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>le</name> <init>= <expr><operator>(</operator><call><name>creal</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <call><name>creal</name> <argument_list>(<argument><expr><operator>*</operator><name>y</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <ternary><condition><expr><name>le</name></expr> ?</condition><then> <expr><call><name>GxB_CMPLX</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>GxB_CMPLX</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_ISLE</name></cpp:macro>                                                          \
<cpp:value>"void "                                                                       \
"complex_isle (GxB_FC64_t *z, const GxB_FC64_t *x, const GxB_FC64_t *y)   \n" \
"{                                                                        \n" \
"   bool le = (creal (*x) &lt;= creal (*y)) ;                                \n" \
"   (*z) = le ? GxB_CMPLX (1,0) : GxB_CMPLX (0,0) ;                       \n" \
"}"</cpp:value></cpp:define>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// binary boolean functions, z=f(x,y), where CxC -&gt; Complex</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

 <function><type><name>void</name></type> <name>complex_or</name> <parameter_list>(<parameter><decl><type><name>GxB_FC64_t</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>y</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>xbool</name> <init>= <expr><operator>(</operator><call><name>creal</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>cimag</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>ybool</name> <init>= <expr><operator>(</operator><call><name>creal</name> <argument_list>(<argument><expr><operator>*</operator><name>y</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>cimag</name> <argument_list>(<argument><expr><operator>*</operator><name>y</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>xbool</name> <operator>||</operator> <name>ybool</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>GxB_CMPLX</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>GxB_CMPLX</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_OR</name></cpp:macro>                                                            \
<cpp:value>"void "                                                                       \
"complex_or (GxB_FC64_t *z, const GxB_FC64_t *x, const GxB_FC64_t *y)     \n" \
"{                                                                        \n" \
"   bool xbool = (creal (*x) != 0 || cimag (*x) != 0) ;                   \n" \
"   bool ybool = (creal (*y) != 0 || cimag (*y) != 0) ;                   \n" \
"   (*z) = (xbool || ybool) ? GxB_CMPLX (1,0) : GxB_CMPLX (0,0) ;         \n" \
"}"</cpp:value></cpp:define>

 <function><type><name>void</name></type> <name>complex_and</name> <parameter_list>(<parameter><decl><type><name>GxB_FC64_t</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>y</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>xbool</name> <init>= <expr><operator>(</operator><call><name>creal</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>cimag</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>ybool</name> <init>= <expr><operator>(</operator><call><name>creal</name> <argument_list>(<argument><expr><operator>*</operator><name>y</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>cimag</name> <argument_list>(<argument><expr><operator>*</operator><name>y</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>xbool</name> <operator>&amp;&amp;</operator> <name>ybool</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>GxB_CMPLX</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>GxB_CMPLX</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_AND</name></cpp:macro>                                                           \
<cpp:value>"void "                                                                       \
"complex_and (GxB_FC64_t *z, const GxB_FC64_t *x, const GxB_FC64_t *y)    \n" \
"{                                                                        \n" \
"   bool xbool = (creal (*x) != 0 || cimag (*x) != 0) ;                   \n" \
"   bool ybool = (creal (*y) != 0 || cimag (*y) != 0) ;                   \n" \
"   (*z) = (xbool &amp;&amp; ybool) ? GxB_CMPLX (1,0) : GxB_CMPLX (0,0) ;         \n" \
"}"</cpp:value></cpp:define>

 <function><type><name>void</name></type> <name>complex_xor</name> <parameter_list>(<parameter><decl><type><name>GxB_FC64_t</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>y</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>xbool</name> <init>= <expr><operator>(</operator><call><name>creal</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>cimag</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>ybool</name> <init>= <expr><operator>(</operator><call><name>creal</name> <argument_list>(<argument><expr><operator>*</operator><name>y</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>cimag</name> <argument_list>(<argument><expr><operator>*</operator><name>y</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>xbool</name> <operator>!=</operator> <name>ybool</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>GxB_CMPLX</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>GxB_CMPLX</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_XOR</name></cpp:macro>                                                           \
<cpp:value>"void "                                                                       \
"complex_xor (GxB_FC64_t *z, const GxB_FC64_t *x, const GxB_FC64_t *y)    \n" \
"{                                                                        \n" \
"   bool xbool = (creal (*x) != 0 || cimag (*x) != 0) ;                   \n" \
"   bool ybool = (creal (*y) != 0 || cimag (*y) != 0) ;                   \n" \
"   (*z) = (xbool != ybool) ? GxB_CMPLX (1,0) : GxB_CMPLX (0,0) ;         \n" \
"}"</cpp:value></cpp:define>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// 6 binary functions, z=f(x,y), where CxC -&gt; bool</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

 <function><type><name>void</name></type> <name>complex_eq</name> <parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>y</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <operator>(</operator><call><name>creal</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>creal</name> <argument_list>(<argument><expr><operator>*</operator><name>y</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>cimag</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>cimag</name> <argument_list>(<argument><expr><operator>*</operator><name>y</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_EQ</name></cpp:macro>                                                            \
<cpp:value>"void complex_eq (bool *z, const GxB_FC64_t *x, const GxB_FC64_t *y)      \n" \
"{                                                                        \n" \
"   (*z) = (creal (*x) == creal (*y) &amp;&amp; cimag (*x) == cimag (*y)) ;       \n" \
"}"</cpp:value></cpp:define>

 <function><type><name>void</name></type> <name>complex_ne</name> <parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>y</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <operator>(</operator><call><name>creal</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>creal</name> <argument_list>(<argument><expr><operator>*</operator><name>y</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>cimag</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>cimag</name> <argument_list>(<argument><expr><operator>*</operator><name>y</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_NE</name></cpp:macro>                                                            \
<cpp:value>"void complex_ne (bool *z, const GxB_FC64_t *x, const GxB_FC64_t *y)      \n" \
"{                                                                        \n" \
"   (*z) = (creal (*x) != creal (*y) || cimag (*x) != cimag (*y)) ;       \n" \
"}"</cpp:value></cpp:define>

 <function><type><name>void</name></type> <name>complex_gt</name> <parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>y</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <operator>(</operator><call><name>creal</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>creal</name> <argument_list>(<argument><expr><operator>*</operator><name>y</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_GT</name></cpp:macro>                                                            \
<cpp:value>"void complex_gt (bool *z, const GxB_FC64_t *x, const GxB_FC64_t *y)      \n" \
"{                                                                        \n" \
"   (*z) = (creal (*x) &gt; creal (*y)) ;                                    \n" \
"}"</cpp:value></cpp:define>

 <function><type><name>void</name></type> <name>complex_lt</name> <parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>y</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <operator>(</operator><call><name>creal</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>creal</name> <argument_list>(<argument><expr><operator>*</operator><name>y</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_LT</name></cpp:macro>                                                            \
<cpp:value>"void complex_lt (bool *z, const GxB_FC64_t *x, const GxB_FC64_t *y)      \n" \
"{                                                                        \n" \
"   (*z) = (creal (*x) &lt; creal (*y)) ;                                    \n" \
"}"</cpp:value></cpp:define>

 <function><type><name>void</name></type> <name>complex_ge</name> <parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>y</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <operator>(</operator><call><name>creal</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <call><name>creal</name> <argument_list>(<argument><expr><operator>*</operator><name>y</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_GE</name></cpp:macro>                                                            \
<cpp:value>"void complex_ge (bool *z, const GxB_FC64_t *x, const GxB_FC64_t *y)      \n" \
"{                                                                        \n" \
"   (*z) = (creal (*x) &gt;= creal (*y)) ;                                   \n" \
"}"</cpp:value></cpp:define>

 <function><type><name>void</name></type> <name>complex_le</name> <parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>y</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <operator>(</operator><call><name>creal</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <call><name>creal</name> <argument_list>(<argument><expr><operator>*</operator><name>y</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_LE</name></cpp:macro>                                                            \
<cpp:value>"void complex_le (bool *z, const GxB_FC64_t *x, const GxB_FC64_t *y)      \n" \
"{                                                                        \n" \
"   (*z) = (creal (*x) &lt;= creal (*y)) ;                                   \n" \
"}"</cpp:value></cpp:define>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// binary functions, z=f(x,y), where double x double -&gt; complex</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

 <function><type><name>void</name></type> <name>complex_complex</name> <parameter_list>(<parameter><decl><type><name>GxB_FC64_t</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>double</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>double</name> <modifier>*</modifier></type><name>y</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <call><name>GxB_CMPLX</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>,<argument><expr><operator>*</operator><name>y</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_COMPLEX</name></cpp:macro>                                                       \
<cpp:value>"void complex_complex (GxB_FC64_t *z, const double *x, const double *y)   \n" \
"{                                                                        \n" \
"   (*z) = GxB_CMPLX (*x,*y) ;                                            \n" \
"}"</cpp:value></cpp:define>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// unary functions, z=f(x) where Complex -&gt; Complex</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

 <function><type><name>void</name></type> <name>complex_one</name> <parameter_list>(<parameter><decl><type><name>GxB_FC64_t</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <call><name>GxB_CMPLX</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_ONE</name></cpp:macro>                                                           \
<cpp:value>"void complex_one (GxB_FC64_t *z, const GxB_FC64_t *x)                    \n" \
"{                                                                        \n" \
"   (*z) = GxB_CMPLX (1,0) ;                                              \n" \
"}"</cpp:value></cpp:define>

 <function><type><name>void</name></type> <name>complex_identity</name> <parameter_list>(<parameter><decl><type><name>GxB_FC64_t</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <operator>(</operator><operator>*</operator><name>x</name><operator>)</operator></expr>  ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_IDENTITY</name></cpp:macro>                                                      \
<cpp:value>"void complex_identity (GxB_FC64_t *z, const GxB_FC64_t *x)               \n" \
"{                                                                        \n" \
"   (*z) = (*x)  ;                                                        \n" \
"}"</cpp:value></cpp:define>

 <function><type><name>void</name></type> <name>complex_ainv</name> <parameter_list>(<parameter><decl><type><name>GxB_FC64_t</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <operator>-</operator><operator>(</operator><operator>*</operator><name>x</name><operator>)</operator></expr>  ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_AINV</name></cpp:macro>                                                          \
<cpp:value>"void complex_ainv (GxB_FC64_t *z, const GxB_FC64_t *x)                   \n" \
"{                                                                        \n" \
"   (*z) = -(*x)  ;                                                       \n" \
"}"</cpp:value></cpp:define>

 <function><type><name>void</name></type> <name>complex_minv</name> <parameter_list>(<parameter><decl><type><name>GxB_FC64_t</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator>  <literal type="number">1.</literal> <operator>/</operator> <operator>(</operator><operator>*</operator><name>x</name><operator>)</operator></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_MINV</name></cpp:macro>                                                          \
<cpp:value>"void complex_minv (GxB_FC64_t *z, const GxB_FC64_t *x)                   \n" \
"{                                                                        \n" \
"   (*z) =  1. / (*x) ;                                                   \n" \
"}"</cpp:value></cpp:define>

 <function><type><name>void</name></type> <name>complex_conj</name> <parameter_list>(<parameter><decl><type><name>GxB_FC64_t</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <call><name>conj</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_CONJ</name></cpp:macro>                                                          \
<cpp:value>"void complex_conj (GxB_FC64_t *z, const GxB_FC64_t *x)                   \n" \
"{                                                                        \n" \
"   (*z) = conj (*x) ;                                                    \n" \
"}"</cpp:value></cpp:define>

 <function><type><name>void</name></type> <name>complex_abs</name> <parameter_list>(<parameter><decl><type><name>GxB_FC64_t</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <call><name>GxB_CMPLX</name> <argument_list>(<argument><expr><call><name>cabs</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_ABS</name></cpp:macro>                                                           \
<cpp:value>"void complex_abs (GxB_FC64_t *z, const GxB_FC64_t *x)                    \n" \
"{                                                                        \n" \
"   (*z) = GxB_CMPLX (cabs (*x), 0) ;                                     \n" \
"}"</cpp:value></cpp:define>

 <function><type><name>void</name></type> <name>complex_not</name> <parameter_list>(<parameter><decl><type><name>GxB_FC64_t</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>xbool</name> <init>= <expr><operator>(</operator><call><name>creal</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>cimag</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <ternary><condition><expr><name>xbool</name></expr> ?</condition><then> <expr><call><name>GxB_CMPLX</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>GxB_CMPLX</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_NOT</name></cpp:macro>                                                           \
<cpp:value>"void complex_not (GxB_FC64_t *z, const GxB_FC64_t *x)                    \n" \
"{                                                                        \n" \
"   bool xbool = (creal (*x) != 0 || cimag (*x) != 0) ;                   \n" \
"   (*z) = xbool ? GxB_CMPLX (0,0) : GxB_CMPLX (1,0) ;                    \n" \
"}"</cpp:value></cpp:define>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// unary functions, z=f(x) where Complex -&gt; double</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

 <function><type><name>void</name></type> <name>complex_real</name> <parameter_list>(<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <call><name>creal</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_REAL</name></cpp:macro>                                                          \
<cpp:value>"void complex_real (double *z, const GxB_FC64_t *x)                       \n" \
"{                                                                        \n" \
"   (*z) = creal (*x) ;                                                   \n" \
"}"</cpp:value></cpp:define>

 <function><type><name>void</name></type> <name>complex_imag</name> <parameter_list>(<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <call><name>cimag</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_IMAG</name></cpp:macro>                                                          \
<cpp:value>"void complex_imag (double *z, const GxB_FC64_t *x)                       \n" \
"{                                                                        \n" \
"   (*z) = cimag (*x) ;                                                   \n" \
"}"</cpp:value></cpp:define>

 <function><type><name>void</name></type> <name>complex_cabs</name> <parameter_list>(<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <call><name>cabs</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_CABS</name></cpp:macro>                                                          \
<cpp:value>"void complex_cabs (double *z, const GxB_FC64_t *x)                       \n" \
"{                                                                        \n" \
"   (*z) = cabs (*x) ;                                                    \n" \
"}"</cpp:value></cpp:define>

 <function><type><name>void</name></type> <name>complex_angle</name> <parameter_list>(<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GxB_FC64_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <call><name>carg</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_ANGLE</name></cpp:macro>                                                         \
<cpp:value>"void complex_angle (double *z, const GxB_FC64_t *x)                      \n" \
"{                                                                        \n" \
"   (*z) = carg (*x) ;                                                    \n" \
"}"</cpp:value></cpp:define>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// unary functions, z=f(x) where double -&gt; Complex</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

 <function><type><name>void</name></type> <name>complex_complex_real</name> <parameter_list>(<parameter><decl><type><name>GxB_FC64_t</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>double</name> <modifier>*</modifier></type><name>x</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <call><name>GxB_CMPLX</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_COMPLEX_REAL</name></cpp:macro>                                                  \
<cpp:value>"void complex_complex_real (GxB_FC64_t *z, const double *x)               \n" \
"{                                                                        \n" \
"   (*z) = GxB_CMPLX (*x, 0) ;                                            \n" \
"}"</cpp:value></cpp:define>

 <function><type><name>void</name></type> <name>complex_complex_imag</name> <parameter_list>(<parameter><decl><type><name>GxB_FC64_t</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>double</name> <modifier>*</modifier></type><name>x</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator> <operator>=</operator> <call><name>GxB_CMPLX</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
 </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLEX_COMPLEX_IMAG</name></cpp:macro>                                                  \
<cpp:value>"void complex_complex_imag (GxB_FC64_t *z, const double *x)               \n" \
"{                                                                        \n" \
"   (*z) = GxB_CMPLX (0, *x) ;                                            \n" \
"}"</cpp:value></cpp:define>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// Complex_init: create the complex type, operators, monoids, and semiring</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>U</name></cpp:macro> <cpp:value>(GxB_unary_function)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>B</name></cpp:macro> <cpp:value>(GxB_binary_function)</cpp:value></cpp:define>

<function><type><name>GrB_Info</name></type> <name>Complex_init</name> <parameter_list>(<parameter><decl><type><name>bool</name></type> <name>builtin_complex</name></decl></parameter>)</parameter_list>
<block>{<block_content>

    <decl_stmt><decl><type><name>GrB_Info</name></type> <name>info</name></decl> ;</decl_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// create the Complex type, or set to GxB_FC64</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>builtin_complex</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// use the built-in type</comment>
        <expr_stmt><expr><name>Complex</name> <operator>=</operator> <name>GxB_FC64</name></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="line">// create the user-defined type</comment>
        <comment type="line">// Normally, the typename should be "GxB_FC64_t",</comment>
        <comment type="line">// but the C type GxB_FC64_t is already defined.</comment>
        <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GxB_Type_new</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GxB_FC64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"mycomplex"</literal></expr></argument>,
            <argument><expr><literal type="string">"typedef struct { double xreal ; double ximag ; } mycomplex ;"</literal></expr></argument> )</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// create the Complex binary operators, CxC-&gt;Complex</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>builtin_complex</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// use the built-in versions</comment>
        <expr_stmt><expr><name>Complex_first</name>  <operator>=</operator> <name>GxB_FIRST_FC64</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>Complex_second</name> <operator>=</operator> <name>GxB_SECOND_FC64</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>Complex_pair</name>   <operator>=</operator> <name>GxB_PAIR_FC64</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>Complex_plus</name>   <operator>=</operator> <name>GxB_PLUS_FC64</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>Complex_minus</name>  <operator>=</operator> <name>GxB_MINUS_FC64</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>Complex_rminus</name> <operator>=</operator> <name>GxB_RMINUS_FC64</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>Complex_times</name>  <operator>=</operator> <name>GxB_TIMES_FC64</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>Complex_div</name>    <operator>=</operator> <name>GxB_DIV_FC64</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>Complex_rdiv</name>   <operator>=</operator> <name>GxB_RDIV_FC64</name></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="line">// create user-defined versions</comment>
        <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_BinaryOp_new</name> <argument_list>(<argument>&amp;Complex_first</argument>  , <argument>B complex_first</argument>  ,
            <argument>Complex</argument>, <argument>Complex</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_first"</literal></argument>, <argument>COMPLEX_FIRST</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <comment type="line">// FUTURE C API suggestion:</comment>
<comment type="line">//      OK (GrB_BinaryOp_new (&amp;Complex_first  , B complex_first  ,</comment>
<comment type="line">//          Complex, Complex, Complex)) ;</comment>
<comment type="line">//      GrB_set (Complex_first, GRB_NAME, "complex_first") ;</comment>
<comment type="line">//      GrB_set (Complex_first, GRB_DEFN, COMPLEX_FIRST) ;</comment>

        <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_BinaryOp_new</name> <argument_list>(<argument>&amp;Complex_second</argument> , <argument>B complex_second</argument> ,
            <argument>Complex</argument>, <argument>Complex</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_second"</literal></argument>, <argument>COMPLEX_SECOND</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_BinaryOp_new</name> <argument_list>(<argument>&amp;Complex_pair</argument>   , <argument>B complex_pair</argument>   ,
            <argument>Complex</argument>, <argument>Complex</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_pair"</literal></argument>, <argument>COMPLEX_PAIR</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_BinaryOp_new</name> <argument_list>(<argument>&amp;Complex_plus</argument>   , <argument>B complex_plus</argument>   ,
            <argument>Complex</argument>, <argument>Complex</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_plus"</literal></argument>, <argument>COMPLEX_PLUS</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_BinaryOp_new</name> <argument_list>(<argument>&amp;Complex_minus</argument>  , <argument>B complex_minus</argument>  ,
            <argument>Complex</argument>, <argument>Complex</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_minus"</literal></argument>, <argument>COMPLEX_MINUS</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_BinaryOp_new</name> <argument_list>(<argument>&amp;Complex_rminus</argument> , <argument>B complex_rminus</argument> ,
            <argument>Complex</argument>, <argument>Complex</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_rminus"</literal></argument>, <argument>COMPLEX_RMINUS</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_BinaryOp_new</name> <argument_list>(<argument>&amp;Complex_times</argument>  , <argument>B complex_times</argument>  ,
            <argument>Complex</argument>, <argument>Complex</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_times"</literal></argument>, <argument>COMPLEX_TIMES</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_BinaryOp_new</name> <argument_list>(<argument>&amp;Complex_div</argument>    , <argument>B complex_div</argument>    ,
            <argument>Complex</argument>, <argument>Complex</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_div"</literal></argument>, <argument>COMPLEX_DIV</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_BinaryOp_new</name> <argument_list>(<argument>&amp;Complex_rdiv</argument>   , <argument>B complex_rdiv</argument>   ,
            <argument>Complex</argument>, <argument>Complex</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_rdiv"</literal></argument>, <argument>COMPLEX_RDIV</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">// these are not built-in</comment>
    <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_BinaryOp_new</name> <argument_list>(<argument>&amp;Complex_min</argument>    , <argument>B complex_min</argument>    ,
        <argument>Complex</argument>, <argument>Complex</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_min"</literal></argument>, <argument>COMPLEX_MIN</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_BinaryOp_new</name> <argument_list>(<argument>&amp;Complex_max</argument>    , <argument>B complex_max</argument>    ,
        <argument>Complex</argument>, <argument>Complex</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_max"</literal></argument>, <argument>COMPLEX_MAX</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// create the Complex binary comparators, CxC -&gt; Complex</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>builtin_complex</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// use the built-in versions</comment>
        <expr_stmt><expr><name>Complex_iseq</name> <operator>=</operator> <name>GxB_ISEQ_FC64</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>Complex_isne</name> <operator>=</operator> <name>GxB_ISNE_FC64</name></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="line">// create user-defined versions</comment>
        <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_BinaryOp_new</name> <argument_list>(<argument>&amp;Complex_iseq</argument> , <argument>B complex_iseq</argument> ,
            <argument>Complex</argument>, <argument>Complex</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_iseq"</literal></argument>, <argument>COMPLEX_ISEQ</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_BinaryOp_new</name> <argument_list>(<argument>&amp;Complex_isne</argument> , <argument>B complex_isne</argument> ,
            <argument>Complex</argument>, <argument>Complex</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_isne"</literal></argument>, <argument>COMPLEX_ISNE</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">// these are not built-in</comment>
    <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_BinaryOp_new</name> <argument_list>(<argument>&amp;Complex_isgt</argument> , <argument>B complex_isgt</argument> ,
        <argument>Complex</argument>, <argument>Complex</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_isgt"</literal></argument>, <argument>COMPLEX_ISGT</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_BinaryOp_new</name> <argument_list>(<argument>&amp;Complex_islt</argument> , <argument>B complex_islt</argument> ,
        <argument>Complex</argument>, <argument>Complex</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_islt"</literal></argument>, <argument>COMPLEX_ISLT</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_BinaryOp_new</name> <argument_list>(<argument>&amp;Complex_isge</argument> , <argument>B complex_isge</argument> ,
        <argument>Complex</argument>, <argument>Complex</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_isge"</literal></argument>, <argument>COMPLEX_ISGE</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_BinaryOp_new</name> <argument_list>(<argument>&amp;Complex_isle</argument> , <argument>B complex_isle</argument> ,
        <argument>Complex</argument>, <argument>Complex</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_isle"</literal></argument>, <argument>COMPLEX_ISLE</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// create the Complex boolean operators, CxC -&gt; Complex</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// these are not built-in</comment>
    <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_BinaryOp_new</name> <argument_list>(<argument>&amp;Complex_or</argument>  , <argument>B complex_or</argument>  ,
        <argument>Complex</argument>, <argument>Complex</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_or"</literal></argument>, <argument>COMPLEX_OR</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_BinaryOp_new</name> <argument_list>(<argument>&amp;Complex_and</argument> , <argument>B complex_and</argument> ,
        <argument>Complex</argument>, <argument>Complex</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_and"</literal></argument>, <argument>COMPLEX_AND</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_BinaryOp_new</name> <argument_list>(<argument>&amp;Complex_xor</argument> , <argument>B complex_xor</argument> ,
        <argument>Complex</argument>, <argument>Complex</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_xor"</literal></argument>, <argument>COMPLEX_XOR</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// create the Complex binary operators, CxC -&gt; bool</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>builtin_complex</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// use the built-in versions</comment>
        <expr_stmt><expr><name>Complex_eq</name> <operator>=</operator> <name>GxB_EQ_FC64</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>Complex_ne</name> <operator>=</operator> <name>GxB_NE_FC64</name></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="line">// create user-defined versions</comment>
        <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_BinaryOp_new</name> <argument_list>(<argument>&amp;Complex_eq</argument> , <argument>B complex_eq</argument> ,
            <argument>GrB_BOOL</argument>, <argument>Complex</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_eq"</literal></argument>, <argument>COMPLEX_EQ</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_BinaryOp_new</name> <argument_list>(<argument>&amp;Complex_ne</argument> , <argument>B complex_ne</argument> ,
            <argument>GrB_BOOL</argument>, <argument>Complex</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_ne"</literal></argument>, <argument>COMPLEX_NE</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">// these are not built-in</comment>
    <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_BinaryOp_new</name> <argument_list>(<argument>&amp;Complex_gt</argument> , <argument>B complex_gt</argument> ,
        <argument>GrB_BOOL</argument>, <argument>Complex</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_gt"</literal></argument>, <argument>COMPLEX_GT</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_BinaryOp_new</name> <argument_list>(<argument>&amp;Complex_lt</argument> , <argument>B complex_lt</argument> ,
        <argument>GrB_BOOL</argument>, <argument>Complex</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_lt"</literal></argument>, <argument>COMPLEX_LT</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_BinaryOp_new</name> <argument_list>(<argument>&amp;Complex_ge</argument> , <argument>B complex_ge</argument> ,
        <argument>GrB_BOOL</argument>, <argument>Complex</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_ge"</literal></argument>, <argument>COMPLEX_GE</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_BinaryOp_new</name> <argument_list>(<argument>&amp;Complex_le</argument> , <argument>B complex_le</argument> ,
        <argument>GrB_BOOL</argument>, <argument>Complex</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_le"</literal></argument>, <argument>COMPLEX_LE</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// create the Complex binary operator, double x double -&gt; Complex</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>builtin_complex</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// use the built-in versions</comment>
        <expr_stmt><expr><name>Complex_complex</name> <operator>=</operator> <name>GxB_CMPLX_FP64</name></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="line">// create user-defined versions</comment>
        <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_BinaryOp_new</name> <argument_list>(<argument>&amp;Complex_complex</argument>, <argument>B complex_complex</argument>,
            <argument>Complex</argument>, <argument>GrB_FP64</argument>, <argument>GrB_FP64</argument>, <argument><literal type="string">"complex_complex"</literal></argument>, <argument>COMPLEX_COMPLEX</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// create the Complex unary operators, Complex-&gt;Complex</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>builtin_complex</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// use the built-in versions</comment>
        <expr_stmt><expr><name>Complex_one</name>      <operator>=</operator> <name>GxB_ONE_FC64</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>Complex_identity</name> <operator>=</operator> <name>GxB_IDENTITY_FC64</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>Complex_ainv</name>     <operator>=</operator> <name>GxB_AINV_FC64</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>Complex_minv</name>     <operator>=</operator> <name>GxB_MINV_FC64</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>Complex_conj</name>     <operator>=</operator> <name>GxB_CONJ_FC64</name></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="line">// create user-defined versions</comment>
        <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_UnaryOp_new</name> <argument_list>(<argument>&amp;Complex_one</argument>     , <argument>U complex_one</argument>     ,
            <argument>Complex</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_one"</literal></argument>, <argument>COMPLEX_ONE</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_UnaryOp_new</name> <argument_list>(<argument>&amp;Complex_identity</argument>, <argument>U complex_identity</argument>,
            <argument>Complex</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_identity"</literal></argument>, <argument>COMPLEX_IDENTITY</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_UnaryOp_new</name> <argument_list>(<argument>&amp;Complex_ainv</argument>    , <argument>U complex_ainv</argument>    ,
            <argument>Complex</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_ainv"</literal></argument>, <argument>COMPLEX_AINV</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_UnaryOp_new</name> <argument_list>(<argument>&amp;Complex_minv</argument>    , <argument>U complex_minv</argument>    ,
            <argument>Complex</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_minv"</literal></argument>, <argument>COMPLEX_MINV</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_UnaryOp_new</name> <argument_list>(<argument>&amp;Complex_conj</argument>    , <argument>U complex_conj</argument>    ,
            <argument>Complex</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_conj"</literal></argument>, <argument>COMPLEX_CONJ</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">// these are not built-in</comment>
    <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_UnaryOp_new</name> <argument_list>(<argument>&amp;Complex_abs</argument>     , <argument>U complex_abs</argument>     ,
        <argument>Complex</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_abs"</literal></argument>, <argument>COMPLEX_ABS</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_UnaryOp_new</name> <argument_list>(<argument>&amp;Complex_not</argument>     , <argument>U complex_not</argument>     ,
        <argument>Complex</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_not"</literal></argument>, <argument>COMPLEX_NOT</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// create the unary functions, Complex -&gt; double</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>builtin_complex</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// use the built-in versions</comment>
        <expr_stmt><expr><name>Complex_real</name>  <operator>=</operator> <name>GxB_CREAL_FC64</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>Complex_imag</name>  <operator>=</operator> <name>GxB_CIMAG_FC64</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>Complex_cabs</name>  <operator>=</operator> <name>GxB_ABS_FC64</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>Complex_angle</name> <operator>=</operator> <name>GxB_CARG_FC64</name></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="line">// create user-defined versions</comment>
        <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_UnaryOp_new</name> <argument_list>(<argument>&amp;Complex_real</argument>  , <argument>U complex_real</argument>  ,
            <argument>GrB_FP64</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_real"</literal></argument>, <argument>COMPLEX_REAL</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_UnaryOp_new</name> <argument_list>(<argument>&amp;Complex_imag</argument>  , <argument>U complex_imag</argument>  ,
            <argument>GrB_FP64</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_imag"</literal></argument>, <argument>COMPLEX_IMAG</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_UnaryOp_new</name> <argument_list>(<argument>&amp;Complex_cabs</argument>  , <argument>U complex_cabs</argument>  ,
            <argument>GrB_FP64</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_cabs"</literal></argument>, <argument>COMPLEX_CABS</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_UnaryOp_new</name> <argument_list>(<argument>&amp;Complex_angle</argument> , <argument>U complex_angle</argument> ,
            <argument>GrB_FP64</argument>, <argument>Complex</argument>, <argument><literal type="string">"complex_angle"</literal></argument>, <argument>COMPLEX_ANGLE</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// create the unary functions, double -&gt; Complex</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// these are not built-in</comment>
    <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_UnaryOp_new</name> <argument_list>(<argument>&amp;Complex_complex_real</argument>, <argument>U complex_complex_real</argument>,
        <argument>Complex</argument>, <argument>GrB_FP64</argument>, <argument><literal type="string">"complex_complex_real"</literal></argument>, <argument>COMPLEX_COMPLEX_REAL</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><macro><name>GxB_UnaryOp_new</name> <argument_list>(<argument>&amp;Complex_complex_imag</argument>, <argument>U complex_complex_imag</argument>,
        <argument>Complex</argument>, <argument>GrB_FP64</argument>, <argument><literal type="string">"complex_complex_imag"</literal></argument>, <argument>COMPLEX_COMPLEX_IMAG</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// create the Complex monoids</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>builtin_complex</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// use the built-in versions</comment>
        <expr_stmt><expr><name>Complex_plus_monoid</name>  <operator>=</operator> <name>GxB_PLUS_FC64_MONOID</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>Complex_times_monoid</name> <operator>=</operator> <name>GxB_TIMES_FC64_MONOID</name></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="line">// create user-defined versions</comment>
        <decl_stmt><decl><type><name>GxB_FC64_t</name></type> <name>C_1</name> <init>= <expr><call><name>GxB_CMPLX</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>GxB_FC64_t</name></type> <name>C_0</name> <init>= <expr><call><name>GxB_CMPLX</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
        <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GrB_Monoid_new_UDT</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_plus_monoid</name></expr></argument>,  <argument><expr><name>Complex_plus</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name>C_0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GrB_Monoid_new_UDT</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_times_monoid</name></expr></argument>, <argument><expr><name>Complex_times</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>C_1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//----------------------------------------------------------------------</comment>
    <comment type="line">// create the Complex plus-times semiring</comment>
    <comment type="line">//----------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>builtin_complex</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// use the built-in versions</comment>
        <expr_stmt><expr><name>Complex_plus_times</name> <operator>=</operator> <name>GxB_PLUS_TIMES_FC64</name></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="line">// more could be created, but this suffices for testing GraphBLAS</comment>
        <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GrB_Semiring_new</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_plus_times</name></expr></argument>, <argument><expr><name>Complex_plus_monoid</name></expr></argument>,
            <argument><expr><name>Complex_times</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><operator>(</operator><name>GrB_SUCCESS</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>


<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// Complex_finalize: free all complex types, operators, monoids, and semiring</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// These may be built-in types and operators.  They are safe to free; the</comment>
<comment type="line">// GrB_*_free functions silently do nothing if asked to free bulit-in objects.</comment>

<function><type><name>GrB_Info</name></type> <name>Complex_finalize</name> <parameter_list>( )</parameter_list>
<block>{<block_content>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// free the Complex plus-times semiring</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>GrB_Semiring_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_plus_times</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// free the Complex monoids</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>GrB_Monoid_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_plus_monoid</name></expr></argument> )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GrB_Monoid_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_times_monoid</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// free the Complex binary operators, CxC-&gt;complex</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>GrB_BinaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_first</name></expr></argument> )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GrB_BinaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_second</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GrB_BinaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_pair</name></expr></argument>  )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GrB_BinaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_min</name></expr></argument>   )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GrB_BinaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_max</name></expr></argument>   )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GrB_BinaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_plus</name></expr></argument>  )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GrB_BinaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_minus</name></expr></argument> )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GrB_BinaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_rminus</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GrB_BinaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_times</name></expr></argument> )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GrB_BinaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_div</name></expr></argument>   )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GrB_BinaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_rdiv</name></expr></argument>  )</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>GrB_BinaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_iseq</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GrB_BinaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_isne</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GrB_BinaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_isgt</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GrB_BinaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_islt</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GrB_BinaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_isge</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GrB_BinaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_isle</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>GrB_BinaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_or</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GrB_BinaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_and</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GrB_BinaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_xor</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// free the Complex binary operators, CxC -&gt; bool</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>GrB_BinaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_eq</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GrB_BinaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_ne</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GrB_BinaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_gt</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GrB_BinaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_lt</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GrB_BinaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_ge</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GrB_BinaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_le</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// free the Complex binary operator, double x double -&gt; complex</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>GrB_BinaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_complex</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// free the Complex unary operators, complex-&gt;complex</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>GrB_UnaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_one</name></expr></argument>     )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GrB_UnaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_identity</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GrB_UnaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_ainv</name></expr></argument>    )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GrB_UnaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_abs</name></expr></argument>     )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GrB_UnaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_minv</name></expr></argument>    )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GrB_UnaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_not</name></expr></argument>     )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GrB_UnaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_conj</name></expr></argument>    )</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// free the unary functions, complex -&gt; double</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>GrB_UnaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_real</name></expr></argument> )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GrB_UnaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_imag</name></expr></argument> )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GrB_UnaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_cabs</name></expr></argument> )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GrB_UnaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_angle</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// free the unary functions, double -&gt; complex</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>GrB_UnaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_complex_real</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GrB_UnaryOp_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex_complex_imag</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// free the Complex type</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>GrB_Type_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Complex</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <return>return <expr><operator>(</operator><name>GrB_SUCCESS</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

</unit>
