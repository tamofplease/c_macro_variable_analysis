<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Demo/Source/wathen.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GraphBLAS/Demo/Source/wathen.c: a finite-element matrix on a regular mesh</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// Create a finite-element matrix on an nx-by-ny 2D mesh, as computed by</comment>
<comment type="line">// wathen.m.</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GraphBLAS.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_PUBLIC</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_LIBRARY</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"graphblas_demos.h"</cpp:file></cpp:include>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// scale by rho</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<decl_stmt><decl><type><name>double</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
<function><type><name>void</name></type> <name>rho_scale</name> <parameter_list>(<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>double</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>f</name><operator>)</operator> <operator>=</operator> <name>r</name> <operator>*</operator> <operator>(</operator><operator>*</operator><name>e</name><operator>)</operator></expr> ;</expr_stmt>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// Wathen function</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function><type><name>GB_PUBLIC</name>
<name>GrB_Info</name></type> <name>wathen</name>             <comment type="line">// construct a random Wathen matrix</comment>
<parameter_list>(
    <parameter><decl><type><name>GrB_Matrix</name> <modifier>*</modifier></type><name>A_output</name></decl></parameter>,   <comment type="line">// output matrix</comment>
    <parameter><decl><type><name>int64_t</name></type> <name>nx</name></decl></parameter>,             <comment type="line">// grid dimension nx</comment>
    <parameter><decl><type><name>int64_t</name></type> <name>ny</name></decl></parameter>,             <comment type="line">// grid dimension ny</comment>
    <parameter><decl><type><name>bool</name></type> <name>scale</name></decl></parameter>,             <comment type="line">// if true, scale the rows</comment>
    <parameter><decl><type><name>int</name></type> <name>method</name></decl></parameter>,             <comment type="line">// 0 to 3</comment>
    <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>rho_given</name></decl></parameter>       <comment type="line">// nx-by-ny dense matrix, if NULL use random rho</comment>
)</parameter_list>
<block>{<block_content>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check inputs</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>nx</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>ny</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>A_output</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>method</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>method</name></expr></argument> &gt;</argument_list></name> <literal type="number">3</literal></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><operator>(</operator><name>GrB_INVALID_VALUE</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// macro to free all workspace.  Not every method uses every object</comment>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FREE_ALL</name></cpp:macro>                            \
        <cpp:value>GrB_Matrix_free (&amp;A) ;                  \
        GrB_Matrix_free (&amp;F) ;                  \
        GrB_Matrix_free (&amp;D) ;                  \
        GrB_Matrix_free (&amp;E) ;                  \
        GrB_UnaryOp_free (&amp;rho_op) ;            \
        if (rho_rand != NULL) free (rho_rand) ; \
        if (I != NULL) free (I) ;               \
        if (J != NULL) free (J) ;               \
        if (X != NULL) free (X) ;</cpp:value></cpp:define>

    <decl_stmt><decl><type><name>GrB_Info</name></type> <name>info</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Matrix</name></type> <name>A</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>F</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>E</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>D</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_UnaryOp</name></type> <name>rho_op</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>rho_rand</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>X</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>rho</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Index</name> <modifier>*</modifier></type><name>I</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>J</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// construct the coefficients</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>d</name></cpp:macro> <cpp:value>((double) 45),</cpp:value></cpp:define>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>double</name></type> <name><name>e</name> <index>[<expr><literal type="number">8</literal></expr>]</index><index>[<expr><literal type="number">8</literal></expr>]</index></name> <init>= <expr><block>{
        <expr><block>{  <expr><literal type="number">6</literal><operator>/</operator><name>d</name>   <operator>-</operator><literal type="number">6</literal><operator>/</operator><name>d</name>    <literal type="number">2</literal><operator>/</operator><name>d</name>   <operator>-</operator><literal type="number">8</literal><operator>/</operator><name>d</name>    <literal type="number">3</literal><operator>/</operator><name>d</name>   <operator>-</operator><literal type="number">8</literal><operator>/</operator><name>d</name>    <literal type="number">2</literal><operator>/</operator><name>d</name>   <operator>-</operator><literal type="number">6</literal><operator>/</operator><name>d</name></expr>   }</block></expr>,
        <expr><block>{ <expr><operator>-</operator><literal type="number">6</literal><operator>/</operator><name>d</name>   <literal type="number">32</literal><operator>/</operator><name>d</name>   <operator>-</operator><literal type="number">6</literal><operator>/</operator><name>d</name>   <literal type="number">20</literal><operator>/</operator><name>d</name>   <operator>-</operator><literal type="number">8</literal><operator>/</operator><name>d</name>   <literal type="number">16</literal><operator>/</operator><name>d</name>   <operator>-</operator><literal type="number">8</literal><operator>/</operator><name>d</name>   <literal type="number">20</literal><operator>/</operator><name>d</name></expr>   }</block></expr>,
        <expr><block>{  <expr><literal type="number">2</literal><operator>/</operator><name>d</name>   <operator>-</operator><literal type="number">6</literal><operator>/</operator><name>d</name>    <literal type="number">6</literal><operator>/</operator><name>d</name>   <operator>-</operator><literal type="number">6</literal><operator>/</operator><name>d</name>    <literal type="number">2</literal><operator>/</operator><name>d</name>   <operator>-</operator><literal type="number">8</literal><operator>/</operator><name>d</name>    <literal type="number">3</literal><operator>/</operator><name>d</name>   <operator>-</operator><literal type="number">8</literal><operator>/</operator><name>d</name></expr>   }</block></expr>,
        <expr><block>{ <expr><operator>-</operator><literal type="number">8</literal><operator>/</operator><name>d</name>   <literal type="number">20</literal><operator>/</operator><name>d</name>   <operator>-</operator><literal type="number">6</literal><operator>/</operator><name>d</name>   <literal type="number">32</literal><operator>/</operator><name>d</name>   <operator>-</operator><literal type="number">6</literal><operator>/</operator><name>d</name>   <literal type="number">20</literal><operator>/</operator><name>d</name>   <operator>-</operator><literal type="number">8</literal><operator>/</operator><name>d</name>   <literal type="number">16</literal><operator>/</operator><name>d</name></expr>   }</block></expr>,
        <expr><block>{  <expr><literal type="number">3</literal><operator>/</operator><name>d</name>   <operator>-</operator><literal type="number">8</literal><operator>/</operator><name>d</name>    <literal type="number">2</literal><operator>/</operator><name>d</name>   <operator>-</operator><literal type="number">6</literal><operator>/</operator><name>d</name>    <literal type="number">6</literal><operator>/</operator><name>d</name>   <operator>-</operator><literal type="number">6</literal><operator>/</operator><name>d</name>    <literal type="number">2</literal><operator>/</operator><name>d</name>   <operator>-</operator><literal type="number">8</literal><operator>/</operator><name>d</name></expr>   }</block></expr>,
        <expr><block>{ <expr><operator>-</operator><literal type="number">8</literal><operator>/</operator><name>d</name>   <literal type="number">16</literal><operator>/</operator><name>d</name>   <operator>-</operator><literal type="number">8</literal><operator>/</operator><name>d</name>   <literal type="number">20</literal><operator>/</operator><name>d</name>   <operator>-</operator><literal type="number">6</literal><operator>/</operator><name>d</name>   <literal type="number">32</literal><operator>/</operator><name>d</name>   <operator>-</operator><literal type="number">6</literal><operator>/</operator><name>d</name>   <literal type="number">20</literal><operator>/</operator><name>d</name></expr>   }</block></expr>,
        <expr><block>{  <expr><literal type="number">2</literal><operator>/</operator><name>d</name>   <operator>-</operator><literal type="number">8</literal><operator>/</operator><name>d</name>    <literal type="number">3</literal><operator>/</operator><name>d</name>   <operator>-</operator><literal type="number">8</literal><operator>/</operator><name>d</name>    <literal type="number">2</literal><operator>/</operator><name>d</name>   <operator>-</operator><literal type="number">6</literal><operator>/</operator><name>d</name>    <literal type="number">6</literal><operator>/</operator><name>d</name>   <operator>-</operator><literal type="number">6</literal><operator>/</operator><name>d</name></expr>   }</block></expr>,
        <expr><block>{ <expr><operator>-</operator><literal type="number">6</literal><operator>/</operator><name>d</name>   <literal type="number">20</literal><operator>/</operator><name>d</name>   <operator>-</operator><literal type="number">8</literal><operator>/</operator><name>d</name>   <literal type="number">16</literal><operator>/</operator><name>d</name>   <operator>-</operator><literal type="number">8</literal><operator>/</operator><name>d</name>   <literal type="number">20</literal><operator>/</operator><name>d</name>   <operator>-</operator><literal type="number">6</literal><operator>/</operator><name>d</name>   <literal type="number">32</literal><operator>/</operator><name>d</name></expr>   }</block></expr> }</block></expr></init></decl> ;</decl_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// A = sparse (n,n) ;</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>n</name> <init>= <expr><literal type="number">3</literal><operator>*</operator><name>nx</name><operator>*</operator><name>ny</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>nx</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>ny</name> <operator>+</operator><literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GrB_Matrix_new</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>A</name></expr></argument>, <argument><expr><name>GrB_FP64</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// RHO = 100 * rand (nx,ny) ;</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// i and j are 1-based, so the same index computations from wathen.m</comment>
    <comment type="line">// can be used</comment>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RHO</name><parameter_list>(<parameter><type><name>i</name></type></parameter>,<parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rho [(i-1)+((j-1)*nx)]</cpp:value></cpp:define>

    <if_stmt><if>if <condition>(<expr><name>rho_given</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// compute a random RHO matrix</comment>
        <expr_stmt><expr><name>rho_rand</name> <operator>=</operator> <operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>nx</name> <operator>*</operator> <name>ny</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>rho_rand</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>   <comment type="line">// out of memory</comment>
            <expr_stmt><expr><name>FREE_ALL</name></expr> ;</expr_stmt>
            <return>return <expr><operator>(</operator><name>GrB_OUT_OF_MEMORY</name><operator>)</operator></expr> ;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>rho</name> <operator>=</operator> <name>rho_rand</name></expr> ;</expr_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">1</literal></expr></init></decl> ;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>ny</name></expr> ;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl> ;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>nx</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><call><name>RHO</name> <argument_list>(<argument><expr><name>i</name></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">100</literal> <operator>*</operator> <call><name>simple_rand_x</name> <argument_list>( )</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></for>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="line">// use rho_given on input</comment>
        <expr_stmt><expr><name>rho</name> <operator>=</operator> <name>rho_given</name></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>em</name><parameter_list>(<parameter><type><name>krow</name></type></parameter>,<parameter><type><name>kcol</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(e [krow][kcol] * RHO (i,j))</cpp:value></cpp:define>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// nn = zeros (8,1) ;</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GrB_Index</name></type> <name><name>nn</name> <index>[<expr><literal type="number">8</literal></expr>]</index></name></decl> ;</decl_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// construct the Wathen matrix, using one of four equivalent methods</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <switch>switch <condition>(<expr><name>method</name></expr>)</condition>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// create tuples and use build, just like wathen.m</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <case>case <expr><literal type="number">0</literal></expr>:</case>
        <block>{<block_content>
            <comment type="line">// This method is fastest of the 4 methods here.  The code here is</comment>
            <comment type="line">// nearly identical to the wathen.m M-file, except that here an</comment>
            <comment type="line">// adjustment to the indices must be made since GraphBLAS matrices</comment>
            <comment type="line">// are indexed starting at row and column 0, not 1.  It requires</comment>
            <comment type="line">// more code on the part of the user application, however, as</comment>
            <comment type="line">// compared to methods 1, 2, and 3.</comment>

            <comment type="line">// allocate the tuples</comment>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>ntriplets</name> <init>= <expr><name>nx</name><operator>*</operator><name>ny</name><operator>*</operator><literal type="number">64</literal></expr></init></decl> ;</decl_stmt>
            <expr_stmt><expr><name>I</name> <operator>=</operator> <operator>(</operator><name>GrB_Index</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>ntriplets</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>GrB_Index</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>J</name> <operator>=</operator> <operator>(</operator><name>GrB_Index</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>ntriplets</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>GrB_Index</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>X</name> <operator>=</operator> <operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>ntriplets</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>double</name></expr></argument> )</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>I</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>J</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>X</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>   <comment type="line">// out of memory</comment>
                <expr_stmt><expr><name>FREE_ALL</name></expr> ;</expr_stmt>
                <return>return <expr><operator>(</operator><name>GrB_OUT_OF_MEMORY</name><operator>)</operator></expr> ;</return>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>ntriplets</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">1</literal></expr></init></decl> ;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>ny</name></expr> ;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl> ;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>nx</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>nn</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">3</literal><operator>*</operator><name>j</name><operator>*</operator><name>nx</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>i</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>nn</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>nn</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>nn</name> <index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>nn</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>nn</name> <index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><literal type="number">3</literal><operator>*</operator><name>j</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><name>nx</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>j</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>nn</name> <index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <literal type="number">3</literal><operator>*</operator><operator>(</operator><name>j</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><name>nx</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>i</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>j</name> <operator>-</operator> <literal type="number">3</literal></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>nn</name> <index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name><name>nn</name> <index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>nn</name> <index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name><name>nn</name> <index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>nn</name> <index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name><name>nn</name> <index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
                    <for>for <control>(<init><decl><type><name>int</name></type> <name>krow</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>krow</name> <operator>&lt;</operator> <literal type="number">8</literal></expr> ;</condition> <incr><expr><name>krow</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>nn</name> <index>[<expr><name>krow</name></expr>]</index></name><operator>--</operator></expr> ;</expr_stmt></block_content></block></for>

                    <for>for <control>(<init><decl><type><name>int</name></type> <name>krow</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>krow</name> <operator>&lt;</operator> <literal type="number">8</literal></expr> ;</condition> <incr><expr><name>krow</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <for>for <control>(<init><decl><type><name>int</name></type> <name>kcol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>kcol</name> <operator>&lt;</operator> <literal type="number">8</literal></expr> ;</condition> <incr><expr><name>kcol</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>I</name> <index>[<expr><name>ntriplets</name></expr>]</index></name> <operator>=</operator> <name><name>nn</name> <index>[<expr><name>krow</name></expr>]</index></name></expr> ;</expr_stmt>
                            <expr_stmt><expr><name><name>J</name> <index>[<expr><name>ntriplets</name></expr>]</index></name> <operator>=</operator> <name><name>nn</name> <index>[<expr><name>kcol</name></expr>]</index></name></expr> ;</expr_stmt>
                            <expr_stmt><expr><name><name>X</name> <index>[<expr><name>ntriplets</name></expr>]</index></name> <operator>=</operator> <call><name>em</name> <argument_list>(<argument><expr><name>krow</name></expr></argument>,<argument><expr><name>kcol</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><name>ntriplets</name><operator>++</operator></expr> ;</expr_stmt>
                        </block_content>}</block></for>
                    </block_content>}</block></for>
                </block_content>}</block></for>
            </block_content>}</block></for>

            <comment type="line">// A = sparse (I,J,X,n,n) ;</comment>
            <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GrB_Matrix_build_FP64</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>I</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>X</name></expr></argument>, <argument><expr><name>ntriplets</name></expr></argument>, <argument><expr><name>GrB_PLUS_FP64</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        </block_content>}</block>
        <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// scalar assignment</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <case>case <expr><literal type="number">1</literal></expr>:</case>
        <block>{<block_content>
            <comment type="line">// This method is the simplest, and only takes about 2x the time as</comment>
            <comment type="line">// method 0.  It would be impossibly slow in the equivalent MATLAB.</comment>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">1</literal></expr></init></decl> ;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>ny</name></expr> ;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl> ;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>nx</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>nn</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">3</literal><operator>*</operator><name>j</name><operator>*</operator><name>nx</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>i</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>nn</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>nn</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>nn</name> <index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>nn</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>nn</name> <index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><literal type="number">3</literal><operator>*</operator><name>j</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><name>nx</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>j</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>nn</name> <index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <literal type="number">3</literal><operator>*</operator><operator>(</operator><name>j</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><name>nx</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>i</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>j</name> <operator>-</operator> <literal type="number">3</literal></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>nn</name> <index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name><name>nn</name> <index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>nn</name> <index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name><name>nn</name> <index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>nn</name> <index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name><name>nn</name> <index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
                    <for>for <control>(<init><decl><type><name>int</name></type> <name>krow</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>krow</name> <operator>&lt;</operator> <literal type="number">8</literal></expr> ;</condition> <incr><expr><name>krow</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>nn</name> <index>[<expr><name>krow</name></expr>]</index></name><operator>--</operator></expr> ;</expr_stmt></block_content></block></for>

                    <for>for <control>(<init><decl><type><name>int</name></type> <name>krow</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>krow</name> <operator>&lt;</operator> <literal type="number">8</literal></expr> ;</condition> <incr><expr><name>krow</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <for>for <control>(<init><decl><type><name>int</name></type> <name>kcol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>kcol</name> <operator>&lt;</operator> <literal type="number">8</literal></expr> ;</condition> <incr><expr><name>kcol</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content>
                            <comment type="line">// A (nn[krow],nn[kcol]) += em (krow,kcol)</comment>
                            <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GrB_Matrix_assign_FP64</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><name>GrB_PLUS_FP64</name></expr></argument>, <argument><expr><call><name>em</name> <argument_list>(<argument><expr><name>krow</name></expr></argument>,<argument><expr><name>kcol</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><operator>(</operator><operator>&amp;</operator><name><name>nn</name> <index>[<expr><name>krow</name></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><operator>&amp;</operator><name><name>nn</name> <index>[<expr><name>kcol</name></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        </block_content>}</block></for>
                    </block_content>}</block></for>
                </block_content>}</block></for>
            </block_content>}</block></for>
        </block_content>}</block>
        <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// matrix assignment, create F one entry at a time</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <case>case <expr><literal type="number">2</literal></expr>:</case>
        <block>{<block_content>
            <comment type="line">// This method constructs F and then assigns it all at once into A.</comment>
            <comment type="line">// It is about 2x to 3x slower than method 1.</comment>

            <comment type="line">// create a single 8-by-8 finite-element matrix F</comment>
            <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GrB_Matrix_new</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>F</name></expr></argument>, <argument><expr><name>GrB_FP64</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">1</literal></expr></init></decl> ;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>ny</name></expr> ;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl> ;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>nx</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>nn</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">3</literal><operator>*</operator><name>j</name><operator>*</operator><name>nx</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>i</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>nn</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>nn</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>nn</name> <index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>nn</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>nn</name> <index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><literal type="number">3</literal><operator>*</operator><name>j</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><name>nx</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>j</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>nn</name> <index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <literal type="number">3</literal><operator>*</operator><operator>(</operator><name>j</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><name>nx</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>i</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>j</name> <operator>-</operator> <literal type="number">3</literal></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>nn</name> <index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name><name>nn</name> <index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>nn</name> <index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name><name>nn</name> <index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>nn</name> <index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name><name>nn</name> <index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
                    <for>for <control>(<init><decl><type><name>int</name></type> <name>krow</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>krow</name> <operator>&lt;</operator> <literal type="number">8</literal></expr> ;</condition> <incr><expr><name>krow</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>nn</name> <index>[<expr><name>krow</name></expr>]</index></name><operator>--</operator></expr> ;</expr_stmt></block_content></block></for>

                    <for>for <control>(<init><decl><type><name>int</name></type> <name>krow</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>krow</name> <operator>&lt;</operator> <literal type="number">8</literal></expr> ;</condition> <incr><expr><name>krow</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <for>for <control>(<init><decl><type><name>int</name></type> <name>kcol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>kcol</name> <operator>&lt;</operator> <literal type="number">8</literal></expr> ;</condition> <incr><expr><name>kcol</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content>
                            <comment type="line">// F (krow,kcol) = em (krow, kcol)</comment>
                            <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GrB_Matrix_setElement_FP64</name> <argument_list>(<argument><expr><name>F</name></expr></argument>,
                                <argument><expr><call><name>em</name> <argument_list>(<argument><expr><name>krow</name></expr></argument>,<argument><expr><name>kcol</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>krow</name></expr></argument>, <argument><expr><name>kcol</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        </block_content>}</block></for>
                    </block_content>}</block></for>

                    <comment type="line">// A (nn,nn) += F</comment>
                    <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GrB_Matrix_assign</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>GrB_PLUS_FP64</name></expr></argument>,
                        <argument><expr><name>F</name></expr></argument>, <argument><expr><name>nn</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>nn</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></for>
        </block_content>}</block>
        <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// matrix assignment, create F all at once</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <case>case <expr><literal type="number">3</literal></expr>:</case>
        <block>{<block_content>
            <comment type="line">// This method is as fast as method 2 (that is, 2x to 3x slower</comment>
            <comment type="line">// than method 1).  It is very flexible since any method can be</comment>
            <comment type="line">// used to construct the finite-element matrix.  Then A(nn,nn)+=F</comment>
            <comment type="line">// is very efficient when F is a matrix.</comment>

            <comment type="line">// create a single 8-by-8 finite-element matrix F</comment>
            <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GrB_Matrix_new</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>F</name></expr></argument>, <argument><expr><name>GrB_FP64</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

            <comment type="line">// create a single 8-by-8 coefficient matrix E</comment>
            <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GrB_Matrix_new</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>E</name></expr></argument>, <argument><expr><name>GrB_FP64</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>krow</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>krow</name> <operator>&lt;</operator> <literal type="number">8</literal></expr> ;</condition> <incr><expr><name>krow</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>kcol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>kcol</name> <operator>&lt;</operator> <literal type="number">8</literal></expr> ;</condition> <incr><expr><name>kcol</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>double</name></type> <name>ex</name> <init>= <expr><name><name>e</name> <index>[<expr><name>krow</name></expr>]</index><index>[<expr><name>kcol</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                    <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GrB_Matrix_setElement_FP64</name> <argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><name>ex</name></expr></argument>, <argument><expr><name>krow</name></expr></argument>, <argument><expr><name>kcol</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></for>

            <comment type="line">// create a unary operator to scale by RHO(i,j)</comment>
            <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GrB_UnaryOp_new</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>rho_op</name></expr></argument>, 
                <argument><expr><operator>(</operator><name>GxB_unary_function</name><operator>)</operator> <name>rho_scale</name></expr></argument>, <argument><expr><name>GrB_FP64</name></expr></argument>, <argument><expr><name>GrB_FP64</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">1</literal></expr></init></decl> ;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>ny</name></expr> ;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl> ;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>nx</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>nn</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">3</literal><operator>*</operator><name>j</name><operator>*</operator><name>nx</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>i</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>nn</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>nn</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>nn</name> <index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>nn</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>nn</name> <index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><literal type="number">3</literal><operator>*</operator><name>j</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><name>nx</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>j</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>nn</name> <index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <literal type="number">3</literal><operator>*</operator><operator>(</operator><name>j</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><name>nx</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>i</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>j</name> <operator>-</operator> <literal type="number">3</literal></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>nn</name> <index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name><name>nn</name> <index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>nn</name> <index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name><name>nn</name> <index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>nn</name> <index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name><name>nn</name> <index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
                    <for>for <control>(<init><decl><type><name>int</name></type> <name>krow</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>krow</name> <operator>&lt;</operator> <literal type="number">8</literal></expr> ;</condition> <incr><expr><name>krow</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>nn</name> <index>[<expr><name>krow</name></expr>]</index></name><operator>--</operator></expr> ;</expr_stmt></block_content></block></for>

                    <comment type="line">// F = E * RHO(i,j)</comment>
                    <comment type="line">// note that this computation on F does not force</comment>
                    <comment type="line">// A to be assembled.</comment>
                    <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>RHO</name> <argument_list>(<argument><expr><name>i</name></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GrB_Matrix_apply</name> <argument_list>(<argument><expr><name>F</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>rho_op</name></expr></argument>, <argument><expr><name>E</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

                    <comment type="line">// A (nn,nn) += F</comment>
                    <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GrB_Matrix_assign</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>GrB_PLUS_FP64</name></expr></argument>,
                        <argument><expr><name>F</name></expr></argument>, <argument><expr><name>nn</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>nn</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></for>
        </block_content>}</block>
        <break>break ;</break>

        <default>default:</default>
            <expr_stmt><expr><call><name>CHECK</name> <argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>GrB_INVALID_VALUE</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <break>break ;</break>
    </block_content>}</block></switch>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// scale the matrix, if requested</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// An alternative to multiplying by the inverse of the diagonal would be to</comment>
    <comment type="line">// compute A=A/D using the PLUS_DIV_FP64 semiring, which scales the columns</comment>
    <comment type="line">// instead of the rows, and then transposing the result, since A is</comment>
    <comment type="line">// symmetric but D\A and A/D are not.  Alternatively, a user-defined</comment>
    <comment type="line">// operator z=f(x,y) that computes z=y/x could be used, along with a</comment>
    <comment type="line">// user-defined semiring.</comment>

    <if_stmt><if>if <condition>(<expr><name>scale</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// D = sparse (n,n)</comment>
        <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GrB_Matrix_new</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>D</name></expr></argument>, <argument><expr><name>GrB_FP64</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="line">// D (i,i) = 1 / A (i,i) ;</comment>
            <decl_stmt><decl><type><name>double</name></type> <name>di</name></decl> ;</decl_stmt>
            <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GrB_Matrix_extractElement_FP64</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>di</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GrB_Matrix_setElement_FP64</name> <argument_list>(<argument><expr><name>D</name></expr></argument>, <argument><expr><literal type="number">1</literal><operator>/</operator><name>di</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></for>
        <comment type="line">// A = D*A</comment>
        <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GrB_mxm</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>GxB_PLUS_TIMES_FP64</name></expr></argument>, <argument><expr><name>D</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// force completion</comment>
    <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GrB_Matrix_wait</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>GrB_MATERIALIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// free workspace and return the result</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><operator>*</operator><name>A_output</name> <operator>=</operator> <name>A</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name>A</name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name>FREE_ALL</name></expr> ;</expr_stmt>
    <return>return <expr><operator>(</operator><name>GrB_SUCCESS</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

</unit>
