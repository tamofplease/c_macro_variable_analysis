<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/lz4/lz4.c"><comment type="block">/*
   LZ4 - Fast LZ compression algorithm
   Copyright (C) 2011-present, Yann Collet.

   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
    - LZ4 homepage : http://www.lz4.org
    - LZ4 source repository : https://github.com/lz4/lz4
*/</comment>

<comment type="block">/*-************************************
*  Tuning parameters
**************************************/</comment>
<comment type="block">/*
 * LZ4_HEAPMODE :
 * Select how default compression functions will allocate memory for their hash table,
 * in memory stack (0:default, fastest), or in memory heap (1:requires malloc()).
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LZ4_HEAPMODE</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>LZ4_HEAPMODE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * LZ4_ACCELERATION_DEFAULT :
 * Select "acceleration" for LZ4_compress_fast() when parameter value &lt;= 0
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LZ4_ACCELERATION_DEFAULT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<comment type="block">/*
 * LZ4_ACCELERATION_MAX :
 * Any "acceleration" value higher than this threshold
 * get treated as LZ4_ACCELERATION_MAX instead (fix #876)
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LZ4_ACCELERATION_MAX</name></cpp:macro> <cpp:value>65537</cpp:value></cpp:define>


<comment type="block">/*-************************************
*  CPU Feature Detection
**************************************/</comment>
<comment type="block">/* LZ4_FORCE_MEMORY_ACCESS
 * By default, access to unaligned memory is controlled by `memcpy()`, which is safe and portable.
 * Unfortunately, on some target/compiler combinations, the generated assembly is sub-optimal.
 * The below switch allow to select different access method for improved performance.
 * Method 0 (default) : use `memcpy()`. Safe and portable.
 * Method 1 : `__packed` statement. It depends on compiler extension (ie, not portable).
 *            This method is safe if your compiler supports it, and *generally* as fast or faster than `memcpy`.
 * Method 2 : direct access. This method is portable but violate C standard.
 *            It can generate buggy code on targets which assembly generation depends on alignment.
 *            But in some circumstances, it's the only known way to get the most performance (ie GCC + ARMv6)
 * See https://fastcompression.blogspot.fr/2015/08/accessing-unaligned-memory.html for details.
 * Prefer these methods in priority order (0 &gt; 1 &gt; 2)
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LZ4_FORCE_MEMORY_ACCESS</name></cpp:ifndef>   <comment type="block">/* can be defined externally */</comment>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> \
  <operator>(</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__ARM_ARCH_6__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__ARM_ARCH_6J__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__ARM_ARCH_6K__</name></expr></argument>)</argument_list></call> \
  <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__ARM_ARCH_6Z__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__ARM_ARCH_6ZK__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__ARM_ARCH_6T2__</name></expr></argument>)</argument_list></call> <operator>)</operator></expr></cpp:if>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>LZ4_FORCE_MEMORY_ACCESS</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:elif>#  <cpp:directive>elif</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__INTEL_COMPILER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>LZ4_FORCE_MEMORY_ACCESS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * LZ4_FORCE_SW_BITCOUNT
 * Define this parameter if your target system or compiler does not support hardware bit count
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_WIN32_WCE</name></expr></argument>)</argument_list></call></expr></cpp:if>   <comment type="block">/* Visual Studio for WinCE doesn't support Hardware bit count */</comment>
<cpp:undef>#  <cpp:directive>undef</cpp:directive>  <name>LZ4_FORCE_SW_BITCOUNT</name></cpp:undef>  <comment type="block">/* avoid double def */</comment>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>LZ4_FORCE_SW_BITCOUNT</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<comment type="block">/*-************************************
*  Dependency
**************************************/</comment>
<comment type="block">/*
 * LZ4_SRC_INCLUDED:
 * Amalgamation flag, whether lz4.c is included
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LZ4_SRC_INCLUDED</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>LZ4_SRC_INCLUDED</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LZ4_STATIC_LINKING_ONLY</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LZ4_STATIC_LINKING_ONLY</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LZ4_DISABLE_DEPRECATE_WARNINGS</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LZ4_DISABLE_DEPRECATE_WARNINGS</name></cpp:macro></cpp:define> <comment type="block">/* due to LZ4_decompress_safe_withPrefix64k */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LZ4_STATIC_LINKING_ONLY</name></cpp:macro></cpp:define>  <comment type="block">/* LZ4_DISTANCE_MAX */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lz4.h"</cpp:file></cpp:include>
<comment type="block">/* see also "memory routines" below */</comment>


<comment type="block">/*-************************************
*  Compiler Options
**************************************/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>_MSC_VER</name> <operator>&gt;=</operator> <literal type="number">1400</literal><operator>)</operator></expr></cpp:if>  <comment type="block">/* Visual Studio 2005+ */</comment>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;intrin.h&gt;</cpp:file></cpp:include>               <comment type="block">/* only present in VS2005+ */</comment>
<cpp:pragma>#  <cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name> <name>:</name> <name>4127</name><name>)</name></cpp:pragma>   <comment type="block">/* disable: C4127: conditional expression is constant */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* _MSC_VER */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LZ4_FORCE_INLINE</name></cpp:ifndef>
<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>    <comment type="block">/* Visual Studio */</comment>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>LZ4_FORCE_INLINE</name></cpp:macro> <cpp:value>static __forceinline</cpp:value></cpp:define>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#    <cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name> <argument_list>(<argument><expr><name>__STDC_VERSION__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>__STDC_VERSION__</name> <operator>&gt;=</operator> <literal type="number">199901L</literal></expr></cpp:if>   <comment type="block">/* C99 */</comment>
<cpp:ifdef>#      <cpp:directive>ifdef</cpp:directive> <name>__GNUC__</name></cpp:ifdef>
<cpp:define>#        <cpp:directive>define</cpp:directive> <cpp:macro><name>LZ4_FORCE_INLINE</name></cpp:macro> <cpp:value>static inline __attribute__((always_inline))</cpp:value></cpp:define>
<cpp:else>#      <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#        <cpp:directive>define</cpp:directive> <cpp:macro><name>LZ4_FORCE_INLINE</name></cpp:macro> <cpp:value>static inline</cpp:value></cpp:define>
<cpp:endif>#      <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#    <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#      <cpp:directive>define</cpp:directive> <cpp:macro><name>LZ4_FORCE_INLINE</name></cpp:macro> <cpp:value>static</cpp:value></cpp:define>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __STDC_VERSION__ */</comment>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* _MSC_VER */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* LZ4_FORCE_INLINE */</comment>

<comment type="block">/* LZ4_FORCE_O2 and LZ4_FORCE_INLINE
 * gcc on ppc64le generates an unrolled SIMDized loop for LZ4_wildCopy8,
 * together with a simple 8-byte copy loop as a fall-back path.
 * However, this optimization hurts the decompression speed by &gt;30%,
 * because the execution does not go to the optimized loop
 * for typical compressible data, and all of the preamble checks
 * before going to the fall-back path become useless overhead.
 * This optimization happens only with the -O3 flag, and -O2 generates
 * a simple 8-byte copy loop.
 * With gcc on ppc64le, all of the LZ4_decompress_* and LZ4_wildCopy8
 * functions are annotated with __attribute__((optimize("O2"))),
 * and also LZ4_wildCopy8 is forcibly inlined, so that the O2 attribute
 * of LZ4_wildCopy8 does not affect the compression speed.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__PPC64__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__LITTLE_ENDIAN__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>LZ4_FORCE_O2</name></cpp:macro>  <cpp:value>__attribute__((optimize("O2")))</cpp:value></cpp:define>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>LZ4_FORCE_INLINE</name></cpp:undef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>LZ4_FORCE_INLINE</name></cpp:macro>  <cpp:value>static __inline __attribute__((optimize("O2"),always_inline))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>LZ4_FORCE_O2</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>__GNUC__</name> <operator>&gt;=</operator> <literal type="number">3</literal><operator>)</operator><operator>)</operator> <operator>||</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__INTEL_COMPILER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>__INTEL_COMPILER</name> <operator>&gt;=</operator> <literal type="number">800</literal><operator>)</operator><operator>)</operator> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>expect</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>,<parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>(__builtin_expect ((expr),(value)) )</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>expect</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>,<parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>(expr)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>likely</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>likely</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>)</parameter_list></cpp:macro>     <cpp:value>expect((expr) != 0, 1)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>unlikely</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unlikely</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>)</parameter_list></cpp:macro>   <cpp:value>expect((expr) != 0, 0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Should the alignment test prove unreliable, for some reason,
 * it can be disabled by setting LZ4_ALIGN_TEST to 0 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LZ4_ALIGN_TEST</name></cpp:ifndef>  <comment type="block">/* can be externally provided */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>LZ4_ALIGN_TEST</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*-************************************
*  Memory routines
**************************************/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LZ4_USER_MEMORY_FUNCTIONS</name></cpp:ifdef>
<comment type="block">/* memory management functions can be customized by user project.
 * Below functions must exist somewhere in the Project
 * and be available at link time */</comment>
<function_decl><type><name>void</name><modifier>*</modifier></type> <name>LZ4_malloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name><modifier>*</modifier></type> <name>LZ4_calloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>  <name>LZ4_free</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>p</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ALLOC</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro>          <cpp:value>LZ4_malloc(s)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ALLOC_AND_ZERO</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>LZ4_calloc(1,s)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>FREEMEM</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro>        <cpp:value>LZ4_free(p)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>   <comment type="block">/* malloc, calloc, free */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ALLOC</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro>          <cpp:value>malloc(s)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ALLOC_AND_ZERO</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>calloc(1,s)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>FREEMEM</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro>        <cpp:value>free(p)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>   <comment type="block">/* memset, memcpy */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MEM_INIT</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>v</name></type></parameter>,<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro>   <cpp:value>memset((p),(v),(s))</cpp:value></cpp:define>


<comment type="block">/*-************************************
*  Common Constants
**************************************/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MINMATCH</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WILDCOPYLENGTH</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LASTLITERALS</name></cpp:macro>   <cpp:value>5</cpp:value></cpp:define>   <comment type="block">/* see ../doc/lz4_Block_format.md#parsing-restrictions */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MFLIMIT</name></cpp:macro>       <cpp:value>12</cpp:value></cpp:define>   <comment type="block">/* see ../doc/lz4_Block_format.md#parsing-restrictions */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATCH_SAFEGUARD_DISTANCE</name></cpp:macro>  <cpp:value>((2*WILDCOPYLENGTH) - MINMATCH)</cpp:value></cpp:define>   <comment type="block">/* ensure it's possible to write 2 x wildcopyLength without overflowing output buffer */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FASTLOOP_SAFE_DISTANCE</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>LZ4_minLength</name> <init>= <expr><operator>(</operator><name>MFLIMIT</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KB</name></cpp:macro> <cpp:value>*(1 &lt;&lt;10)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MB</name></cpp:macro> <cpp:value>*(1 &lt;&lt;20)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB</name></cpp:macro> <cpp:value>*(1U&lt;&lt;30)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LZ4_DISTANCE_ABSOLUTE_MAX</name></cpp:macro> <cpp:value>65535</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>LZ4_DISTANCE_MAX</name> <operator>&gt;</operator> <name>LZ4_DISTANCE_ABSOLUTE_MAX</name><operator>)</operator></expr></cpp:if>   <comment type="block">/* max supported by LZ4 format */</comment>
<cpp:error>#  <cpp:directive>error</cpp:directive> <cpp:literal>"LZ4_DISTANCE_MAX is too big : must be &lt;= 65535"</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ML_BITS</name></cpp:macro>  <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ML_MASK</name></cpp:macro>  <cpp:value>((1U&lt;&lt;ML_BITS)-1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUN_BITS</name></cpp:macro> <cpp:value>(8-ML_BITS)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUN_MASK</name></cpp:macro> <cpp:value>((1U&lt;&lt;RUN_BITS)-1)</cpp:value></cpp:define>


<comment type="block">/*-************************************
*  Error detection
**************************************/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LZ4_DEBUG</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>LZ4_DEBUG</name><operator>&gt;=</operator><literal type="number">1</literal><operator>)</operator></expr></cpp:if>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>assert</name></cpp:ifndef>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>assert</name><parameter_list>(<parameter><type><name>condition</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void)0)</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LZ4_STATIC_ASSERT</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro>   <cpp:value>{ enum { LZ4_static_assert = 1/(int)(!!(c)) }; }</cpp:value></cpp:define>   <comment type="block">/* use after variable declarations */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LZ4_DEBUG</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>LZ4_DEBUG</name><operator>&gt;=</operator><literal type="number">2</literal><operator>)</operator></expr></cpp:if>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
   <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>g_debuglog_enable</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUGLOG</name><parameter_list>(<parameter><type><name>l</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{                          \
        if ((g_debuglog_enable) &amp;&amp; (l&lt;=LZ4_DEBUG)) {  \
            fprintf(stderr, __FILE__ ": ");           \
            fprintf(stderr, __VA_ARGS__);             \
            fprintf(stderr, " \n");                   \
    }   }</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUGLOG</name><parameter_list>(<parameter><type><name>l</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{}</cpp:value></cpp:define>    <comment type="block">/* disabled */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type> <name>LZ4_isAligned</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>alignment</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><name>ptr</name> <operator>&amp;</operator> <operator>(</operator><name>alignment</name> <operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*-************************************
*  Types
**************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><call><name>defined</name> <argument_list>(<argument><expr><name>__STDC_VERSION__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>__STDC_VERSION__</name> <operator>&gt;=</operator> <literal type="number">199901L</literal><operator>)</operator> <comment type="block">/* C99 */</comment><operator>)</operator></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
  <typedef>typedef  <type><name>uint8_t</name></type> <name>BYTE</name>;</typedef>
  <typedef>typedef <type><name>uint16_t</name></type> <name>U16</name>;</typedef>
  <typedef>typedef <type><name>uint32_t</name></type> <name>U32</name>;</typedef>
  <typedef>typedef  <type><name>int32_t</name></type> <name>S32</name>;</typedef>
  <typedef>typedef <type><name>uint64_t</name></type> <name>U64</name>;</typedef>
  <typedef>typedef <type><name>uintptr_t</name></type> <name>uptrval</name>;</typedef>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><name>UINT_MAX</name> <operator>!=</operator> <literal type="number">4294967295UL</literal></expr></cpp:if>
<cpp:error>#   <cpp:directive>error</cpp:directive> <cpp:literal>"LZ4 code (when not C++ or C99) assumes that sizeof(int) == 4"</cpp:literal></cpp:error>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
  <typedef>typedef <type><name>unsigned</name> <name>char</name></type>       <name>BYTE</name>;</typedef>
  <typedef>typedef <type><name>unsigned</name> <name>short</name></type>      <name>U16</name>;</typedef>
  <typedef>typedef <type><name>unsigned</name> <name>int</name></type>        <name>U32</name>;</typedef>
  <typedef>typedef   <type><name>signed</name> <name>int</name></type>        <name>S32</name>;</typedef>
  <typedef>typedef <type><name>unsigned</name> <name>long</name> <name>long</name></type>  <name>U64</name>;</typedef>
  <typedef>typedef <type><name>size_t</name></type>              <name>uptrval</name>;</typedef>   <comment type="block">/* generally true, except OpenVMS-64 */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__x86_64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <typedef>typedef <type><name>U64</name></type>    <name>reg_t</name>;</typedef>   <comment type="block">/* 64-bits in x32 mode */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <typedef>typedef <type><name>size_t</name></type> <name>reg_t</name>;</typedef>   <comment type="block">/* 32-bits in x32 mode */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><enum>enum <block>{
    <decl><name>notLimited</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
    <decl><name>limitedOutput</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
    <decl><name>fillOutput</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>
}</block></enum></type> <name>limitedOutput_directive</name>;</typedef>


<comment type="block">/*-************************************
*  Reading and writing into memory
**************************************/</comment>

<comment type="block" format="doxygen">/**
 * LZ4 relies on memcpy with a constant size being inlined. In freestanding
 * environments, the compiler can't assume the implementation of memcpy() is
 * standard compliant, so it can't apply its specialized memcpy() inlining
 * logic. When possible, use __builtin_memcpy() to tell the compiler to analyze
 * memcpy() as if it were standard compliant, so it can inline it in freestanding
 * environments. This is needed when decompressing the Linux Kernel, for example.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>__GNUC__</name> <operator>&gt;=</operator> <literal type="number">4</literal><operator>)</operator></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LZ4_memcpy</name><parameter_list>(<parameter><type><name>dst</name></type></parameter>, <parameter><type><name>src</name></type></parameter>, <parameter><type><name>size</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>__builtin_memcpy(dst, src, size)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LZ4_memcpy</name><parameter_list>(<parameter><type><name>dst</name></type></parameter>, <parameter><type><name>src</name></type></parameter>, <parameter><type><name>size</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>memcpy(dst, src, size)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>unsigned</name></type> <name>LZ4_isLittleEndian</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <union><specifier>const</specifier> union <block>{ <decl_stmt><decl><type><name>U32</name></type> <name>u</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>BYTE</name></type> <name><name>c</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt> }</block> <decl><name>one</name> <init>= <expr><block>{ <expr><literal type="number">1</literal></expr> }</block></expr></init></decl>;</union>   <comment type="block">/* don't use static : performance detrimental */</comment>
    <return>return <expr><name><name>one</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LZ4_FORCE_MEMORY_ACCESS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>LZ4_FORCE_MEMORY_ACCESS</name><operator>==</operator><literal type="number">2</literal><operator>)</operator></expr></cpp:if>
<comment type="block">/* lie to the compiler about data alignment; use with caution */</comment>

<function><type><specifier>static</specifier> <name>U16</name></type> <name>LZ4_read16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>memPtr</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>U16</name><operator>*</operator><operator>)</operator> <name>memPtr</name></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>U32</name></type> <name>LZ4_read32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>memPtr</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>U32</name><operator>*</operator><operator>)</operator> <name>memPtr</name></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>reg_t</name></type> <name>LZ4_read_ARCH</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>memPtr</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>reg_t</name><operator>*</operator><operator>)</operator> <name>memPtr</name></expr>;</return> </block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>LZ4_write16</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>memPtr</name></decl></parameter>, <parameter><decl><type><name>U16</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>U16</name><operator>*</operator><operator>)</operator><name>memPtr</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>LZ4_write32</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>memPtr</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>U32</name><operator>*</operator><operator>)</operator><name>memPtr</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> </block_content>}</block></function>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LZ4_FORCE_MEMORY_ACCESS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>LZ4_FORCE_MEMORY_ACCESS</name><operator>==</operator><literal type="number">1</literal><operator>)</operator></expr></cpp:elif>

<comment type="block">/* __pack instructions are safer, but compiler specific, hence potentially problematic for some compilers */</comment>
<comment type="block">/* currently only defined for gcc and icc */</comment>
<typedef>typedef <type><union>union <block>{ <decl_stmt><decl><type><name>U16</name></type> <name>u16</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>U32</name></type> <name>u32</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>reg_t</name></type> <name>uArch</name></decl>;</decl_stmt> }</block></union></type> <name>__attribute__</name>((<name>packed</name>)) <name>unalign</name>;</typedef>

<function><type><specifier>static</specifier> <name>U16</name></type> <name>LZ4_read16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>unalign</name><operator>*</operator><operator>)</operator><name>ptr</name><operator>)</operator><operator>-&gt;</operator><name>u16</name></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>U32</name></type> <name>LZ4_read32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>unalign</name><operator>*</operator><operator>)</operator><name>ptr</name><operator>)</operator><operator>-&gt;</operator><name>u32</name></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>reg_t</name></type> <name>LZ4_read_ARCH</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>unalign</name><operator>*</operator><operator>)</operator><name>ptr</name><operator>)</operator><operator>-&gt;</operator><name>uArch</name></expr>;</return> </block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>LZ4_write16</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>memPtr</name></decl></parameter>, <parameter><decl><type><name>U16</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><operator>(</operator><operator>(</operator><name>unalign</name><operator>*</operator><operator>)</operator><name>memPtr</name><operator>)</operator><operator>-&gt;</operator><name>u16</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>LZ4_write32</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>memPtr</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><operator>(</operator><operator>(</operator><name>unalign</name><operator>*</operator><operator>)</operator><name>memPtr</name><operator>)</operator><operator>-&gt;</operator><name>u32</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> </block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* safe and portable access using memcpy() */</comment>

<function><type><specifier>static</specifier> <name>U16</name></type> <name>LZ4_read16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>memPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U16</name></type> <name>val</name></decl>;</decl_stmt> <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><name>memPtr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>U32</name></type> <name>LZ4_read32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>memPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name></type> <name>val</name></decl>;</decl_stmt> <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><name>memPtr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>reg_t</name></type> <name>LZ4_read_ARCH</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>memPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>reg_t</name></type> <name>val</name></decl>;</decl_stmt> <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><name>memPtr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>LZ4_write16</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>memPtr</name></decl></parameter>, <parameter><decl><type><name>U16</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><name>memPtr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>LZ4_write32</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>memPtr</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><name>memPtr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* LZ4_FORCE_MEMORY_ACCESS */</comment>


<function><type><specifier>static</specifier> <name>U16</name></type> <name>LZ4_readLE16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>memPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>LZ4_isLittleEndian</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>LZ4_read16</name><argument_list>(<argument><expr><name>memPtr</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>p</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>memPtr</name></expr></init></decl>;</decl_stmt>
        <return>return <expr><operator>(</operator><name>U16</name><operator>)</operator><operator>(</operator><operator>(</operator><name>U16</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator><operator>)</operator></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>LZ4_writeLE16</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>memPtr</name></decl></parameter>, <parameter><decl><type><name>U16</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>LZ4_isLittleEndian</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>LZ4_write16</name><argument_list>(<argument><expr><name>memPtr</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>p</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>memPtr</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator> <name>value</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><operator>(</operator><name>value</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* customized variant of memcpy, which can overwrite up to 8 bytes beyond dstEnd */</comment>
<function><type><name>LZ4_FORCE_INLINE</name>
<name>void</name></type> <name>LZ4_wildCopy8</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dstPtr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>srcPtr</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dstEnd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>d</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dstPtr</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>s</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>srcPtr</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>e</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dstEnd</name></expr></init></decl>;</decl_stmt>

    <do>do <block>{<block_content> <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><name>d</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>d</name><operator>+=</operator><literal type="number">8</literal></expr>;</expr_stmt> <expr_stmt><expr><name>s</name><operator>+=</operator><literal type="number">8</literal></expr>;</expr_stmt> </block_content>}</block> while <condition>(<expr><name>d</name><operator>&lt;</operator><name>e</name></expr>)</condition>;</do>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name></type> <name><name>inc32table</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>,  <expr><literal type="number">1</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type>      <name><name>dec64table</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">4</literal></expr>,  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>}</block></expr></init></decl>;</decl_stmt>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LZ4_FAST_DEC_LOOP</name></cpp:ifndef>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__i386__</name> <operator>||</operator> <name>defined</name> <name>_M_IX86</name> <operator>||</operator> <name>defined</name> <name>__x86_64__</name> <operator>||</operator> <name>defined</name> <name>_M_X64</name></expr></cpp:if>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>LZ4_FAST_DEC_LOOP</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:elif>#  <cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__aarch64__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
     <comment type="block">/* On aarch64, we disable this optimization for clang because on certain
      * mobile chipsets, performance is reduced with clang. For information
      * refer to https://github.com/lz4/lz4/pull/707 */</comment>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>LZ4_FAST_DEC_LOOP</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>LZ4_FAST_DEC_LOOP</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LZ4_FAST_DEC_LOOP</name></expr></cpp:if>

<function><type><name>LZ4_FORCE_INLINE</name> <name>void</name></type>
<name>LZ4_memcpy_using_offset_base</name><parameter_list>(<parameter><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>dstPtr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>srcPtr</name></decl></parameter>, <parameter><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>dstEnd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>srcPtr</name> <operator>+</operator> <name>offset</name> <operator>==</operator> <name>dstPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>LZ4_write32</name><argument_list>(<argument><expr><name>dstPtr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* silence an msan warning when offset==0 */</comment>
        <expr_stmt><expr><name><name>dstPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>srcPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dstPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>srcPtr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dstPtr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>srcPtr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dstPtr</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>srcPtr</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>srcPtr</name> <operator>+=</operator> <name><name>inc32table</name><index>[<expr><name>offset</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><name>dstPtr</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>srcPtr</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>srcPtr</name> <operator>-=</operator> <name><name>dec64table</name><index>[<expr><name>offset</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dstPtr</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><name>dstPtr</name></expr></argument>, <argument><expr><name>srcPtr</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dstPtr</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>srcPtr</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>LZ4_wildCopy8</name><argument_list>(<argument><expr><name>dstPtr</name></expr></argument>, <argument><expr><name>srcPtr</name></expr></argument>, <argument><expr><name>dstEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* customized variant of memcpy, which can overwrite up to 32 bytes beyond dstEnd
 * this version copies two times 16 bytes (instead of one time 32 bytes)
 * because it must be compatible with offsets &gt;= 16. */</comment>
<function><type><name>LZ4_FORCE_INLINE</name> <name>void</name></type>
<name>LZ4_wildCopy32</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dstPtr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>srcPtr</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dstEnd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>d</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dstPtr</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>s</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>srcPtr</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>e</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dstEnd</name></expr></init></decl>;</decl_stmt>

    <do>do <block>{<block_content> <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><name>d</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><name>d</name><operator>+</operator><literal type="number">16</literal></expr></argument>,<argument><expr><name>s</name><operator>+</operator><literal type="number">16</literal></expr></argument>,<argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>d</name><operator>+=</operator><literal type="number">32</literal></expr>;</expr_stmt> <expr_stmt><expr><name>s</name><operator>+=</operator><literal type="number">32</literal></expr>;</expr_stmt> </block_content>}</block> while <condition>(<expr><name>d</name><operator>&lt;</operator><name>e</name></expr>)</condition>;</do>
</block_content>}</block></function>

<comment type="block">/* LZ4_memcpy_using_offset()  presumes :
 * - dstEnd &gt;= dstPtr + MINMATCH
 * - there is at least 8 bytes available to write after dstEnd */</comment>
<function><type><name>LZ4_FORCE_INLINE</name> <name>void</name></type>
<name>LZ4_memcpy_using_offset</name><parameter_list>(<parameter><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>dstPtr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>srcPtr</name></decl></parameter>, <parameter><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>dstEnd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BYTE</name></type> <name><name>v</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dstEnd</name> <operator>&gt;=</operator> <name>dstPtr</name> <operator>+</operator> <name>MINMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch<condition>(<expr><name>offset</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><literal type="number">1</literal></expr>:</case>
        <expr_stmt><expr><call><name>MEM_INIT</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>*</operator><name>srcPtr</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><literal type="number">2</literal></expr>:</case>
        <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>srcPtr</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>v</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>srcPtr</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>v</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><literal type="number">4</literal></expr>:</case>
        <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>srcPtr</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>v</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name>srcPtr</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <default>default:</default>
        <expr_stmt><expr><call><name>LZ4_memcpy_using_offset_base</name><argument_list>(<argument><expr><name>dstPtr</name></expr></argument>, <argument><expr><name>srcPtr</name></expr></argument>, <argument><expr><name>dstEnd</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><name>dstPtr</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dstPtr</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>dstPtr</name> <operator>&lt;</operator> <name>dstEnd</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><name>dstPtr</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dstPtr</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*-************************************
*  Common functions
**************************************/</comment>
<function><type><specifier>static</specifier> <name>unsigned</name></type> <name>LZ4_NbCommonBytes</name> <parameter_list>(<parameter><decl><type><name>reg_t</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>val</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>LZ4_isLittleEndian</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
<cpp:if>#       <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>_MSC_VER</name> <operator>&gt;=</operator> <literal type="number">1800</literal><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_M_AMD64</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LZ4_FORCE_SW_BITCOUNT</name></expr></argument>)</argument_list></call></expr></cpp:if>
            <comment type="block">/* x64 CPUS without BMI support interpret `TZCNT` as `REP BSF` */</comment>
            <return>return <expr><operator>(</operator><name>unsigned</name><operator>)</operator><call><name>_tzcnt_u64</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>;</return>
<cpp:elif>#       <cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_WIN64</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LZ4_FORCE_SW_BITCOUNT</name></expr></argument>)</argument_list></call></expr></cpp:elif>
            <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>_BitScanForward64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><operator>(</operator><name>U64</name><operator>)</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>r</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>;</return>
<cpp:elif>#       <cpp:directive>elif</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>__GNUC__</name> <operator>&gt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>||</operator> \
                            <operator>(</operator><operator>(</operator><name>__GNUC__</name> <operator>==</operator> <literal type="number">3</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>__GNUC_MINOR__</name> <operator>&gt;=</operator> <literal type="number">4</literal><operator>)</operator><operator>)</operator><operator>)</operator><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> \
                                        <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LZ4_FORCE_SW_BITCOUNT</name></expr></argument>)</argument_list></call></expr></cpp:elif>
            <return>return <expr><operator>(</operator><name>unsigned</name><operator>)</operator><call><name>__builtin_ctzll</name><argument_list>(<argument><expr><operator>(</operator><name>U64</name><operator>)</operator><name>val</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>;</return>
<cpp:else>#       <cpp:directive>else</cpp:directive></cpp:else>
            <decl_stmt><decl><type><specifier>const</specifier> <name>U64</name></type> <name>m</name> <init>= <expr><literal type="number">0x0101010101010101ULL</literal></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>val</name> <operator>^=</operator> <name>val</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <return>return <expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>U64</name><operator>)</operator><operator>(</operator><operator>(</operator><name>val</name> <operator>&amp;</operator> <operator>(</operator><name>m</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>*</operator> <name>m</name><operator>)</operator><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">56</literal><operator>)</operator></expr>;</return>
<cpp:endif>#       <cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if> <else>else <comment type="block">/* 32 bits */</comment> <block>{<block_content>
<cpp:if>#       <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>_MSC_VER</name> <operator>&gt;=</operator> <literal type="number">1400</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LZ4_FORCE_SW_BITCOUNT</name></expr></argument>)</argument_list></call></expr></cpp:if>
            <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>r</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>_BitScanForward</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>r</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>;</return>
<cpp:elif>#       <cpp:directive>elif</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>__GNUC__</name> <operator>&gt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>||</operator> \
                            <operator>(</operator><operator>(</operator><name>__GNUC__</name> <operator>==</operator> <literal type="number">3</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>__GNUC_MINOR__</name> <operator>&gt;=</operator> <literal type="number">4</literal><operator>)</operator><operator>)</operator><operator>)</operator><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> \
                        <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__TINYC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LZ4_FORCE_SW_BITCOUNT</name></expr></argument>)</argument_list></call></expr></cpp:elif>
            <return>return <expr><operator>(</operator><name>unsigned</name><operator>)</operator><call><name>__builtin_ctz</name><argument_list>(<argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>val</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>;</return>
<cpp:else>#       <cpp:directive>else</cpp:directive></cpp:else>
            <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>m</name> <init>= <expr><literal type="number">0x01010101</literal></expr></init></decl>;</decl_stmt>
            <return>return <expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>val</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>^</operator> <name>val</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>m</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>*</operator> <name>m</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">24</literal></expr>;</return>
<cpp:endif>#       <cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else   <comment type="block">/* Big Endian CPU */</comment> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">8</literal></expr>)</condition> <block>{<block_content>
<cpp:if>#       <cpp:directive>if</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>__GNUC__</name> <operator>&gt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>||</operator> \
                            <operator>(</operator><operator>(</operator><name>__GNUC__</name> <operator>==</operator> <literal type="number">3</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>__GNUC_MINOR__</name> <operator>&gt;=</operator> <literal type="number">4</literal><operator>)</operator><operator>)</operator><operator>)</operator><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> \
                        <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__TINYC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LZ4_FORCE_SW_BITCOUNT</name></expr></argument>)</argument_list></call></expr></cpp:if>
            <return>return <expr><operator>(</operator><name>unsigned</name><operator>)</operator><call><name>__builtin_clzll</name><argument_list>(<argument><expr><operator>(</operator><name>U64</name><operator>)</operator><name>val</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>;</return>
<cpp:else>#       <cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1</literal></expr></cpp:if>
            <comment type="block">/* this method is probably faster,
             * but adds a 128 bytes lookup table */</comment>
            <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>ctz7_tab</name><index>[<expr><literal type="number">128</literal></expr>]</index></name> <init>= <expr><block>{
                <expr><literal type="number">7</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>,
                <expr><literal type="number">4</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>,
                <expr><literal type="number">5</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>,
                <expr><literal type="number">4</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>,
                <expr><literal type="number">6</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>,
                <expr><literal type="number">4</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>,
                <expr><literal type="number">5</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>,
                <expr><literal type="number">4</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>,
            }</block></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U64</name> <specifier>const</specifier></type> <name>mask</name> <init>= <expr><literal type="number">0x0101010101010101ULL</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U64</name> <specifier>const</specifier></type> <name>t</name> <init>= <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>val</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>-</operator> <name>mask</name><operator>)</operator> <operator>|</operator> <name>val</name><operator>)</operator> <operator>&amp;</operator> <name>mask</name></expr></init></decl>;</decl_stmt>
            <return>return <expr><name><name>ctz7_tab</name><index>[<expr><operator>(</operator><name>t</name> <operator>*</operator> <literal type="number">0x0080402010080402ULL</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">57</literal></expr>]</index></name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <comment type="block">/* this method doesn't consume memory space like the previous one,
             * but it contains several branches,
             * that may end up slowing execution */</comment>
            <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>U32</name></type> <name>by32</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">4</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* 32 on 64 bits (goal), 16 on 32 bits.
            Just to avoid some static analyzer complaining about shift by 32 on 32-bits target.
            Note that this code path is never triggered in 32-bits mode. */</comment>
            <decl_stmt><decl><type><name>unsigned</name></type> <name>r</name></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>val</name><operator>&gt;&gt;</operator><name>by32</name><operator>)</operator></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>r</name><operator>=</operator><literal type="number">4</literal></expr>;</expr_stmt> </block_content>}</block></if> <else>else <block>{<block_content> <expr_stmt><expr><name>r</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name>val</name><operator>&gt;&gt;=</operator><name>by32</name></expr>;</expr_stmt> </block_content>}</block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>val</name><operator>&gt;&gt;</operator><literal type="number">16</literal><operator>)</operator></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>r</name><operator>+=</operator><literal type="number">2</literal></expr>;</expr_stmt> <expr_stmt><expr><name>val</name><operator>&gt;&gt;=</operator><literal type="number">8</literal></expr>;</expr_stmt> </block_content>}</block></if> <else>else <block>{<block_content> <expr_stmt><expr><name>val</name><operator>&gt;&gt;=</operator><literal type="number">24</literal></expr>;</expr_stmt> </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name>r</name> <operator>+=</operator> <operator>(</operator><operator>!</operator><name>val</name><operator>)</operator></expr>;</expr_stmt>
            <return>return <expr><name>r</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#       <cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if> <else>else <comment type="block">/* 32 bits */</comment> <block>{<block_content>
<cpp:if>#       <cpp:directive>if</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>__GNUC__</name> <operator>&gt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>||</operator> \
                            <operator>(</operator><operator>(</operator><name>__GNUC__</name> <operator>==</operator> <literal type="number">3</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>__GNUC_MINOR__</name> <operator>&gt;=</operator> <literal type="number">4</literal><operator>)</operator><operator>)</operator><operator>)</operator><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> \
                                        <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LZ4_FORCE_SW_BITCOUNT</name></expr></argument>)</argument_list></call></expr></cpp:if>
            <return>return <expr><operator>(</operator><name>unsigned</name><operator>)</operator><call><name>__builtin_clz</name><argument_list>(<argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>val</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>;</return>
<cpp:else>#       <cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr><name>val</name> <operator>&gt;&gt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>val</name> <operator>+</operator> <literal type="number">0x00FFFF00</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x00FFFFFF</literal><operator>)</operator> <operator>+</operator> <name>val</name><operator>)</operator> <operator>|</operator>
              <operator>(</operator><name>val</name> <operator>+</operator> <literal type="number">0x00FF0000</literal><operator>)</operator><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>
            <return>return <expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>val</name> <operator>^</operator> <literal type="number">3</literal></expr>;</return>
<cpp:endif>#       <cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STEPSIZE</name></cpp:macro> <cpp:value>sizeof(reg_t)</cpp:value></cpp:define>
<function><type><name>LZ4_FORCE_INLINE</name>
<name>unsigned</name></type> <name>LZ4_count</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>pIn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>pMatch</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>pInLimit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>pStart</name> <init>= <expr><name>pIn</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><name>pIn</name> <operator>&lt;</operator> <name>pInLimit</name><operator>-</operator><operator>(</operator><name>STEPSIZE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>reg_t</name> <specifier>const</specifier></type> <name>diff</name> <init>= <expr><call><name>LZ4_read_ARCH</name><argument_list>(<argument><expr><name>pMatch</name></expr></argument>)</argument_list></call> <operator>^</operator> <call><name>LZ4_read_ARCH</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>diff</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>pIn</name><operator>+=</operator><name>STEPSIZE</name></expr>;</expr_stmt> <expr_stmt><expr><name>pMatch</name><operator>+=</operator><name>STEPSIZE</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <return>return <expr><call><name>LZ4_NbCommonBytes</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>   </block_content>}</block></if></if_stmt>

    <while>while <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><name>pIn</name> <operator>&lt;</operator> <name>pInLimit</name><operator>-</operator><operator>(</operator><name>STEPSIZE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>reg_t</name> <specifier>const</specifier></type> <name>diff</name> <init>= <expr><call><name>LZ4_read_ARCH</name><argument_list>(<argument><expr><name>pMatch</name></expr></argument>)</argument_list></call> <operator>^</operator> <call><name>LZ4_read_ARCH</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>diff</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>pIn</name><operator>+=</operator><name>STEPSIZE</name></expr>;</expr_stmt> <expr_stmt><expr><name>pMatch</name><operator>+=</operator><name>STEPSIZE</name></expr>;</expr_stmt> <continue>continue;</continue> </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>pIn</name> <operator>+=</operator> <call><name>LZ4_NbCommonBytes</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name>pIn</name> <operator>-</operator> <name>pStart</name><operator>)</operator></expr>;</return>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>STEPSIZE</name><operator>==</operator><literal type="number">8</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>pIn</name><operator>&lt;</operator><operator>(</operator><name>pInLimit</name><operator>-</operator><literal type="number">3</literal><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>LZ4_read32</name><argument_list>(<argument><expr><name>pMatch</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>LZ4_read32</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>pIn</name><operator>+=</operator><literal type="number">4</literal></expr>;</expr_stmt> <expr_stmt><expr><name>pMatch</name><operator>+=</operator><literal type="number">4</literal></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pIn</name><operator>&lt;</operator><operator>(</operator><name>pInLimit</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>LZ4_read16</name><argument_list>(<argument><expr><name>pMatch</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>LZ4_read16</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>pIn</name><operator>+=</operator><literal type="number">2</literal></expr>;</expr_stmt> <expr_stmt><expr><name>pMatch</name><operator>+=</operator><literal type="number">2</literal></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pIn</name><operator>&lt;</operator><name>pInLimit</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>pMatch</name> <operator>==</operator> <operator>*</operator><name>pIn</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pIn</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name>pIn</name> <operator>-</operator> <name>pStart</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LZ4_COMMONDEFS_ONLY</name></cpp:ifndef>
<comment type="block">/*-************************************
*  Local Constants
**************************************/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>LZ4_64Klimit</name> <init>= <expr><operator>(</operator><operator>(</operator><literal type="number">64</literal> <name>KB</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>MFLIMIT</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>U32</name></type> <name>LZ4_skipTrigger</name> <init>= <expr><literal type="number">6</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Increase this value ==&gt; compression run slower on incompressible data */</comment>


<comment type="block">/*-************************************
*  Local Structures and types
**************************************/</comment>
<typedef>typedef <type><enum>enum <block>{ <decl><name>clearedTable</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><name>byPtr</name></decl>, <decl><name>byU32</name></decl>, <decl><name>byU16</name></decl> }</block></enum></type> <name>tableType_t</name>;</typedef>

<comment type="block" format="doxygen">/**
 * This enum distinguishes several different modes of accessing previous
 * content in the stream.
 *
 * - noDict        : There is no preceding content.
 * - withPrefix64k : Table entries up to ctx-&gt;dictSize before the current blob
 *                   blob being compressed are valid and refer to the preceding
 *                   content (of length ctx-&gt;dictSize), which is available
 *                   contiguously preceding in memory the content currently
 *                   being compressed.
 * - usingExtDict  : Like withPrefix64k, but the preceding content is somewhere
 *                   else in memory, starting at ctx-&gt;dictionary with length
 *                   ctx-&gt;dictSize.
 * - usingDictCtx  : Like usingExtDict, but everything concerning the preceding
 *                   content is in a separate context, pointed to by
 *                   ctx-&gt;dictCtx. ctx-&gt;dictionary, ctx-&gt;dictSize, and table
 *                   entries in the current context that refer to positions
 *                   preceding the beginning of the current compression are
 *                   ignored. Instead, ctx-&gt;dictCtx-&gt;dictionary and ctx-&gt;dictCtx
 *                   -&gt;dictSize describe the location and size of the preceding
 *                   content, and matches are found by looking in the ctx
 *                   -&gt;dictCtx-&gt;hashTable.
 */</comment>
<typedef>typedef <type><enum>enum <block>{ <decl><name>noDict</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><name>withPrefix64k</name></decl>, <decl><name>usingExtDict</name></decl>, <decl><name>usingDictCtx</name></decl> }</block></enum></type> <name>dict_directive</name>;</typedef>
<typedef>typedef <type><enum>enum <block>{ <decl><name>noDictIssue</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><name>dictSmall</name></decl> }</block></enum></type> <name>dictIssue_directive</name>;</typedef>


<comment type="block">/*-************************************
*  Local Utils
**************************************/</comment>
<function><type><name>int</name></type> <name>LZ4_versionNumber</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>LZ4_VERSION_NUMBER</name></expr>;</return> </block_content>}</block></function>
<function><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>LZ4_versionString</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>LZ4_VERSION_STRING</name></expr>;</return> </block_content>}</block></function>
<function><type><name>int</name></type> <name>LZ4_compressBound</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>isize</name></decl></parameter>)</parameter_list>  <block>{<block_content> <return>return <expr><call><name>LZ4_COMPRESSBOUND</name><argument_list>(<argument><expr><name>isize</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>int</name></type> <name>LZ4_sizeofState</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>LZ4_STREAMSIZE</name></expr>;</return> </block_content>}</block></function>


<comment type="block">/*-************************************
*  Internal Definitions used in Tests
**************************************/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<extern>extern <literal type="string">"C"</literal> <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><name>int</name></type> <name>LZ4_compress_forceExtDict</name> <parameter_list>(<parameter><decl><type><name>LZ4_stream_t</name><modifier>*</modifier></type> <name>LZ4_dict</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>LZ4_decompress_safe_forceExtDict</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dest</name></decl></parameter>,
                                     <parameter><decl><type><name>int</name></type> <name>compressedSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxOutputSize</name></decl></parameter>,
                                     <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dictStart</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
</block_content>}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*-******************************
*  Compression functions
********************************/</comment>
<function><type><name>LZ4_FORCE_INLINE</name> <name>U32</name></type> <name>LZ4_hash4</name><parameter_list>(<parameter><decl><type><name>U32</name></type> <name>sequence</name></decl></parameter>, <parameter><decl><type><name>tableType_t</name> <specifier>const</specifier></type> <name>tableType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>tableType</name> <operator>==</operator> <name>byU16</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>(</operator><operator>(</operator><name>sequence</name> <operator>*</operator> <literal type="number">2654435761U</literal><operator>)</operator> <operator>&gt;&gt;</operator> <operator>(</operator><operator>(</operator><name>MINMATCH</name><operator>*</operator><literal type="number">8</literal><operator>)</operator><operator>-</operator><operator>(</operator><name>LZ4_HASHLOG</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>)</operator></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><operator>(</operator><operator>(</operator><name>sequence</name> <operator>*</operator> <literal type="number">2654435761U</literal><operator>)</operator> <operator>&gt;&gt;</operator> <operator>(</operator><operator>(</operator><name>MINMATCH</name><operator>*</operator><literal type="number">8</literal><operator>)</operator><operator>-</operator><name>LZ4_HASHLOG</name><operator>)</operator><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>LZ4_FORCE_INLINE</name> <name>U32</name></type> <name>LZ4_hash5</name><parameter_list>(<parameter><decl><type><name>U64</name></type> <name>sequence</name></decl></parameter>, <parameter><decl><type><name>tableType_t</name> <specifier>const</specifier></type> <name>tableType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>hashLog</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>tableType</name> <operator>==</operator> <name>byU16</name><operator>)</operator></expr> ?</condition><then> <expr><name>LZ4_HASHLOG</name><operator>+</operator><literal type="number">1</literal></expr> </then><else>: <expr><name>LZ4_HASHLOG</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>LZ4_isLittleEndian</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U64</name></type> <name>prime5bytes</name> <init>= <expr><literal type="number">889523592379ULL</literal></expr></init></decl>;</decl_stmt>
        <return>return <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>sequence</name> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>*</operator> <name>prime5bytes</name><operator>)</operator> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">64</literal> <operator>-</operator> <name>hashLog</name><operator>)</operator><operator>)</operator></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U64</name></type> <name>prime8bytes</name> <init>= <expr><literal type="number">11400714785074694791ULL</literal></expr></init></decl>;</decl_stmt>
        <return>return <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>sequence</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>*</operator> <name>prime8bytes</name><operator>)</operator> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">64</literal> <operator>-</operator> <name>hashLog</name><operator>)</operator><operator>)</operator></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>LZ4_FORCE_INLINE</name> <name>U32</name></type> <name>LZ4_hashPosition</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier> <specifier>const</specifier></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>tableType_t</name> <specifier>const</specifier></type> <name>tableType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>reg_t</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">8</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>tableType</name> <operator>!=</operator> <name>byU16</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>LZ4_hash5</name><argument_list>(<argument><expr><call><name>LZ4_read_ARCH</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tableType</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>LZ4_hash4</name><argument_list>(<argument><expr><call><name>LZ4_read32</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tableType</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>LZ4_FORCE_INLINE</name> <name>void</name></type> <name>LZ4_clearHash</name><parameter_list>(<parameter><decl><type><name>U32</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>tableBase</name></decl></parameter>, <parameter><decl><type><name>tableType_t</name> <specifier>const</specifier></type> <name>tableType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch <condition>(<expr><name>tableType</name></expr>)</condition>
    <block>{<block_content>
    <default>default:</default> <comment type="block">/* fallthrough */</comment>
    <case>case <expr><name>clearedTable</name></expr>:</case> <block>{<block_content> <comment type="block">/* illegal! */</comment> <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return;</return> </block_content>}</block>
    <case>case <expr><name>byPtr</name></expr>:</case> <block>{<block_content> <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier><modifier>*</modifier></type> <name>hashTable</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>*</operator><operator>)</operator><name>tableBase</name></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name><name>hashTable</name><index>[<expr><name>h</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <return>return;</return> </block_content>}</block>
    <case>case <expr><name>byU32</name></expr>:</case> <block>{<block_content> <decl_stmt><decl><type><name>U32</name><modifier>*</modifier></type> <name>hashTable</name> <init>= <expr><operator>(</operator><name>U32</name><operator>*</operator><operator>)</operator> <name>tableBase</name></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name><name>hashTable</name><index>[<expr><name>h</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <return>return;</return> </block_content>}</block>
    <case>case <expr><name>byU16</name></expr>:</case> <block>{<block_content> <decl_stmt><decl><type><name>U16</name><modifier>*</modifier></type> <name>hashTable</name> <init>= <expr><operator>(</operator><name>U16</name><operator>*</operator><operator>)</operator> <name>tableBase</name></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name><name>hashTable</name><index>[<expr><name>h</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <return>return;</return> </block_content>}</block>
    </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>LZ4_FORCE_INLINE</name> <name>void</name></type> <name>LZ4_putIndexOnHash</name><parameter_list>(<parameter><decl><type><name>U32</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>tableBase</name></decl></parameter>, <parameter><decl><type><name>tableType_t</name> <specifier>const</specifier></type> <name>tableType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch <condition>(<expr><name>tableType</name></expr>)</condition>
    <block>{<block_content>
    <default>default:</default> <comment type="block">/* fallthrough */</comment>
    <case>case <expr><name>clearedTable</name></expr>:</case> <comment type="block">/* fallthrough */</comment>
    <case>case <expr><name>byPtr</name></expr>:</case> <block>{<block_content> <comment type="block">/* illegal! */</comment> <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return;</return> </block_content>}</block>
    <case>case <expr><name>byU32</name></expr>:</case> <block>{<block_content> <decl_stmt><decl><type><name>U32</name><modifier>*</modifier></type> <name>hashTable</name> <init>= <expr><operator>(</operator><name>U32</name><operator>*</operator><operator>)</operator> <name>tableBase</name></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name><name>hashTable</name><index>[<expr><name>h</name></expr>]</index></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt> <return>return;</return> </block_content>}</block>
    <case>case <expr><name>byU16</name></expr>:</case> <block>{<block_content> <decl_stmt><decl><type><name>U16</name><modifier>*</modifier></type> <name>hashTable</name> <init>= <expr><operator>(</operator><name>U16</name><operator>*</operator><operator>)</operator> <name>tableBase</name></expr></init></decl>;</decl_stmt> <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>idx</name> <operator>&lt;</operator> <literal type="number">65536</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>hashTable</name><index>[<expr><name>h</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>U16</name><operator>)</operator><name>idx</name></expr>;</expr_stmt> <return>return;</return> </block_content>}</block>
    </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>LZ4_FORCE_INLINE</name> <name>void</name></type> <name>LZ4_putPositionOnHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>h</name></decl></parameter>,
                                  <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>tableBase</name></decl></parameter>, <parameter><decl><type><name>tableType_t</name> <specifier>const</specifier></type> <name>tableType</name></decl></parameter>,
                            <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>srcBase</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch <condition>(<expr><name>tableType</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>clearedTable</name></expr>:</case> <block>{<block_content> <comment type="block">/* illegal! */</comment> <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return;</return> </block_content>}</block>
    <case>case <expr><name>byPtr</name></expr>:</case> <block>{<block_content> <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier><modifier>*</modifier></type> <name>hashTable</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>*</operator><operator>)</operator><name>tableBase</name></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name><name>hashTable</name><index>[<expr><name>h</name></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt> <return>return;</return> </block_content>}</block>
    <case>case <expr><name>byU32</name></expr>:</case> <block>{<block_content> <decl_stmt><decl><type><name>U32</name><modifier>*</modifier></type> <name>hashTable</name> <init>= <expr><operator>(</operator><name>U32</name><operator>*</operator><operator>)</operator> <name>tableBase</name></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name><name>hashTable</name><index>[<expr><name>h</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>p</name><operator>-</operator><name>srcBase</name><operator>)</operator></expr>;</expr_stmt> <return>return;</return> </block_content>}</block>
    <case>case <expr><name>byU16</name></expr>:</case> <block>{<block_content> <decl_stmt><decl><type><name>U16</name><modifier>*</modifier></type> <name>hashTable</name> <init>= <expr><operator>(</operator><name>U16</name><operator>*</operator><operator>)</operator> <name>tableBase</name></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name><name>hashTable</name><index>[<expr><name>h</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>U16</name><operator>)</operator><operator>(</operator><name>p</name><operator>-</operator><name>srcBase</name><operator>)</operator></expr>;</expr_stmt> <return>return;</return> </block_content>}</block>
    </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>LZ4_FORCE_INLINE</name> <name>void</name></type> <name>LZ4_putPosition</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>tableBase</name></decl></parameter>, <parameter><decl><type><name>tableType_t</name></type> <name>tableType</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>srcBase</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>h</name> <init>= <expr><call><name>LZ4_hashPosition</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>LZ4_putPositionOnHash</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>tableBase</name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>, <argument><expr><name>srcBase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* LZ4_getIndexOnHash() :
 * Index of match position registered in hash table.
 * hash position must be calculated by using base+index, or dictBase+index.
 * Assumption 1 : only valid if tableType == byU32 or byU16.
 * Assumption 2 : h is presumed valid (within limits of hash table)
 */</comment>
<function><type><name>LZ4_FORCE_INLINE</name> <name>U32</name></type> <name>LZ4_getIndexOnHash</name><parameter_list>(<parameter><decl><type><name>U32</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>tableBase</name></decl></parameter>, <parameter><decl><type><name>tableType_t</name></type> <name>tableType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LZ4_STATIC_ASSERT</name><argument_list>(<argument><expr><name>LZ4_MEMORY_USAGE</name> <operator>&gt;</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>tableType</name> <operator>==</operator> <name>byU32</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>hashTable</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>U32</name><operator>*</operator><operator>)</operator> <name>tableBase</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>h</name> <operator>&lt;</operator> <operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>LZ4_MEMORY_USAGE</name><operator>-</operator><literal type="number">2</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name><name>hashTable</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>tableType</name> <operator>==</operator> <name>byU16</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>U16</name><modifier>*</modifier> <specifier>const</specifier></type> <name>hashTable</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>U16</name><operator>*</operator><operator>)</operator> <name>tableBase</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>h</name> <operator>&lt;</operator> <operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>LZ4_MEMORY_USAGE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name><name>hashTable</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* forbidden case */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>LZ4_getPositionOnHash</name><parameter_list>(<parameter><decl><type><name>U32</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>tableBase</name></decl></parameter>, <parameter><decl><type><name>tableType_t</name></type> <name>tableType</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>srcBase</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>tableType</name> <operator>==</operator> <name>byPtr</name></expr>)</condition> <block>{<block_content> <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier><modifier>*</modifier></type> <name>hashTable</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator> <specifier>const</specifier><operator>*</operator><operator>)</operator> <name>tableBase</name></expr></init></decl>;</decl_stmt> <return>return <expr><name><name>hashTable</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</return> </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>tableType</name> <operator>==</operator> <name>byU32</name></expr>)</condition> <block>{<block_content> <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>hashTable</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>U32</name><operator>*</operator><operator>)</operator> <name>tableBase</name></expr></init></decl>;</decl_stmt> <return>return <expr><name><name>hashTable</name><index>[<expr><name>h</name></expr>]</index></name> <operator>+</operator> <name>srcBase</name></expr>;</return> </block_content>}</block></if></if_stmt>
    <block>{<block_content> <decl_stmt><decl><type><specifier>const</specifier> <name>U16</name><modifier>*</modifier> <specifier>const</specifier></type> <name>hashTable</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>U16</name><operator>*</operator><operator>)</operator> <name>tableBase</name></expr></init></decl>;</decl_stmt> <return>return <expr><name><name>hashTable</name><index>[<expr><name>h</name></expr>]</index></name> <operator>+</operator> <name>srcBase</name></expr>;</return> </block_content>}</block>   <comment type="block">/* default, to ensure a return */</comment>
</block_content>}</block></function>

<function><type><name>LZ4_FORCE_INLINE</name> <specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type>
<name>LZ4_getPosition</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>p</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>tableBase</name></decl></parameter>, <parameter><decl><type><name>tableType_t</name></type> <name>tableType</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>srcBase</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>h</name> <init>= <expr><call><name>LZ4_hashPosition</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>LZ4_getPositionOnHash</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>tableBase</name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>, <argument><expr><name>srcBase</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>LZ4_FORCE_INLINE</name> <name>void</name></type>
<name>LZ4_prepareTable</name><parameter_list>(<parameter><decl><type><name>LZ4_stream_t_internal</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cctx</name></decl></parameter>,
           <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>inputSize</name></decl></parameter>,
           <parameter><decl><type><specifier>const</specifier> <name>tableType_t</name></type> <name>tableType</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* If the table hasn't been used, it's guaranteed to be zeroed out, and is
     * therefore safe to use no matter what mode we're in. Otherwise, we figure
     * out if it's safe to leave as is or whether it needs to be reset.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>tableType_t</name><operator>)</operator><name><name>cctx</name><operator>-&gt;</operator><name>tableType</name></name> <operator>!=</operator> <name>clearedTable</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>inputSize</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>tableType_t</name><operator>)</operator><name><name>cctx</name><operator>-&gt;</operator><name>tableType</name></name> <operator>!=</operator> <name>tableType</name>
          <operator>||</operator> <operator>(</operator><operator>(</operator><name>tableType</name> <operator>==</operator> <name>byU16</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>cctx</name><operator>-&gt;</operator><name>currentOffset</name></name> <operator>+</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>inputSize</name> <operator>&gt;=</operator> <literal type="number">0xFFFFU</literal><operator>)</operator>
          <operator>||</operator> <operator>(</operator><operator>(</operator><name>tableType</name> <operator>==</operator> <name>byU32</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>cctx</name><operator>-&gt;</operator><name>currentOffset</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <name>GB</name><operator>)</operator>
          <operator>||</operator> <name>tableType</name> <operator>==</operator> <name>byPtr</name>
          <operator>||</operator> <name>inputSize</name> <operator>&gt;=</operator> <literal type="number">4</literal> <name>KB</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"LZ4_prepareTable: Resetting table in %p"</literal></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MEM_INIT</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>hashTable</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>LZ4_HASHTABLESIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>currentOffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>tableType</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>clearedTable</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"LZ4_prepareTable: Re-use hash table (no reset)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Adding a gap, so all previous entries are &gt; LZ4_DISTANCE_MAX back, is faster
     * than compressing without a gap. However, compressing with
     * currentOffset == 0 is faster still, so we preserve that case.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>currentOffset</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>tableType</name> <operator>==</operator> <name>byU32</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"LZ4_prepareTable: adding 64KB to currentOffset"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>currentOffset</name></name> <operator>+=</operator> <literal type="number">64</literal> <name>KB</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Finally, clear history */</comment>
    <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>dictCtx</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>dictionary</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>dictSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** LZ4_compress_generic() :
 *  inlined, to ensure branches are decided at compilation time.
 *  Presumed already validated at this stage:
 *  - source != NULL
 *  - inputSize &gt; 0
 */</comment>
<function><type><name>LZ4_FORCE_INLINE</name> <name>int</name></type> <name>LZ4_compress_generic_validated</name><parameter_list>(
                 <parameter><decl><type><name>LZ4_stream_t_internal</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cctx</name></decl></parameter>,
                 <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>source</name></decl></parameter>,
                 <parameter><decl><type><name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dest</name></decl></parameter>,
                 <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>inputSize</name></decl></parameter>,
                 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>inputConsumed</name></decl></parameter>, <comment type="block">/* only written when outputDirective == fillOutput */</comment>
                 <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>maxOutputSize</name></decl></parameter>,
                 <parameter><decl><type><specifier>const</specifier> <name>limitedOutput_directive</name></type> <name>outputDirective</name></decl></parameter>,
                 <parameter><decl><type><specifier>const</specifier> <name>tableType_t</name></type> <name>tableType</name></decl></parameter>,
                 <parameter><decl><type><specifier>const</specifier> <name>dict_directive</name></type> <name>dictDirective</name></decl></parameter>,
                 <parameter><decl><type><specifier>const</specifier> <name>dictIssue_directive</name></type> <name>dictIssue</name></decl></parameter>,
                 <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>acceleration</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator> <name>source</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>startIndex</name> <init>= <expr><name><name>cctx</name><operator>-&gt;</operator><name>currentOffset</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>base</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator> <name>source</name> <operator>-</operator> <name>startIndex</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>lowLimit</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>LZ4_stream_t_internal</name><modifier>*</modifier></type> <name>dictCtx</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>LZ4_stream_t_internal</name><operator>*</operator><operator>)</operator> <name><name>cctx</name><operator>-&gt;</operator><name>dictCtx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictionary</name> <init>=
        <expr><ternary><condition><expr><name>dictDirective</name> <operator>==</operator> <name>usingDictCtx</name></expr> ?</condition><then> <expr><name><name>dictCtx</name><operator>-&gt;</operator><name>dictionary</name></name></expr> </then><else>: <expr><name><name>cctx</name><operator>-&gt;</operator><name>dictionary</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dictSize</name> <init>=
        <expr><ternary><condition><expr><name>dictDirective</name> <operator>==</operator> <name>usingDictCtx</name></expr> ?</condition><then> <expr><name><name>dictCtx</name><operator>-&gt;</operator><name>dictSize</name></name></expr> </then><else>: <expr><name><name>cctx</name><operator>-&gt;</operator><name>dictSize</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dictDelta</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>dictDirective</name> <operator>==</operator> <name>usingDictCtx</name><operator>)</operator></expr> ?</condition><then> <expr><name>startIndex</name> <operator>-</operator> <name><name>dictCtx</name><operator>-&gt;</operator><name>currentOffset</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>   <comment type="block">/* make indexes in dictCtx comparable with index in current context */</comment>

    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>maybe_extMem</name> <init>= <expr><operator>(</operator><name>dictDirective</name> <operator>==</operator> <name>usingExtDict</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>dictDirective</name> <operator>==</operator> <name>usingDictCtx</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>prefixIdxLimit</name> <init>= <expr><name>startIndex</name> <operator>-</operator> <name>dictSize</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* used when dictDirective == dictSmall */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictEnd</name> <init>= <expr><ternary><condition><expr><name>dictionary</name></expr> ?</condition><then> <expr><name>dictionary</name> <operator>+</operator> <name>dictSize</name></expr> </then><else>: <expr><name>dictionary</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>anchor</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator> <name>source</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name> <init>= <expr><name>ip</name> <operator>+</operator> <name>inputSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>mflimitPlusOne</name> <init>= <expr><name>iend</name> <operator>-</operator> <name>MFLIMIT</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>matchlimit</name> <init>= <expr><name>iend</name> <operator>-</operator> <name>LASTLITERALS</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* the dictCtx currentOffset is indexed on the start of the dictionary,
     * while a dictionary in the current context precedes the currentOffset */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>dictBase</name> <init>= <expr><ternary><condition><expr><operator>!</operator><name>dictionary</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><ternary><condition><expr><operator>(</operator><name>dictDirective</name> <operator>==</operator> <name>usingDictCtx</name><operator>)</operator></expr> ?</condition><then>
                            <expr><name>dictionary</name> <operator>+</operator> <name>dictSize</name> <operator>-</operator> <name><name>dictCtx</name><operator>-&gt;</operator><name>currentOffset</name></name></expr> </then><else>:
                            <expr><name>dictionary</name> <operator>+</operator> <name>dictSize</name> <operator>-</operator> <name>startIndex</name></expr></else></ternary></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator> <name>dest</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>olimit</name> <init>= <expr><name>op</name> <operator>+</operator> <name>maxOutputSize</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>U32</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>forwardH</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"LZ4_compress_generic_validated: srcSize=%i, tableType=%u"</literal></expr></argument>, <argument><expr><name>inputSize</name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ip</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* If init conditions are not met, we don't have to mark stream
     * as having dirty context, since no action was taken yet */</comment>
    <if_stmt><if>if <condition>(<expr><name>outputDirective</name> <operator>==</operator> <name>fillOutput</name> <operator>&amp;&amp;</operator> <name>maxOutputSize</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content> <return>return <expr><literal type="number">0</literal></expr>;</return> </block_content>}</block></if></if_stmt> <comment type="block">/* Impossible to store anything */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>tableType</name> <operator>==</operator> <name>byU16</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>inputSize</name><operator>&gt;=</operator><name>LZ4_64Klimit</name><operator>)</operator></expr>)</condition> <block>{<block_content> <return>return <expr><literal type="number">0</literal></expr>;</return> </block_content>}</block></if></if_stmt>  <comment type="block">/* Size too large (not within 64K limit) */</comment>
    <if_stmt><if>if <condition>(<expr><name>tableType</name><operator>==</operator><name>byPtr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dictDirective</name><operator>==</operator><name>noDict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>      <comment type="block">/* only supported use case with byPtr */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>acceleration</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>lowLimit</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>source</name> <operator>-</operator> <operator>(</operator><ternary><condition><expr><name>dictDirective</name> <operator>==</operator> <name>withPrefix64k</name></expr> ?</condition><then> <expr><name>dictSize</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* Update context state */</comment>
    <if_stmt><if>if <condition>(<expr><name>dictDirective</name> <operator>==</operator> <name>usingDictCtx</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Subsequent linked blocks can't use the dictionary. */</comment>
        <comment type="block">/* Instead, they use the block we just compressed. */</comment>
        <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>dictCtx</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>dictSize</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>inputSize</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>dictSize</name></name> <operator>+=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>inputSize</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>currentOffset</name></name> <operator>+=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>inputSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>tableType</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>tableType</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>inputSize</name><operator>&lt;</operator><name>LZ4_minLength</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>_last_literals</name>;</goto></block_content></block></if></if_stmt>        <comment type="block">/* Input too small, no compression (all literals) */</comment>

    <comment type="block">/* First Byte */</comment>
    <expr_stmt><expr><call><name>LZ4_putPosition</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>hashTable</name></name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ip</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>forwardH</name> <operator>=</operator> <call><name>LZ4_hashPosition</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Main Loop */</comment>
    <for>for <control>( <init>;</init> <condition>;</condition> <incr/>)</control> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>match</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>token</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>filledIp</name></decl>;</decl_stmt>

        <comment type="block">/* Find a match */</comment>
        <if_stmt><if>if <condition>(<expr><name>tableType</name> <operator>==</operator> <name>byPtr</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>forwardIp</name> <init>= <expr><name>ip</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>step</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>searchMatchNb</name> <init>= <expr><name>acceleration</name> <operator>&lt;&lt;</operator> <name>LZ4_skipTrigger</name></expr></init></decl>;</decl_stmt>
            <do>do <block>{<block_content>
                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>h</name> <init>= <expr><name>forwardH</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>ip</name> <operator>=</operator> <name>forwardIp</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>forwardIp</name> <operator>+=</operator> <name>step</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>step</name> <operator>=</operator> <operator>(</operator><name>searchMatchNb</name><operator>++</operator> <operator>&gt;&gt;</operator> <name>LZ4_skipTrigger</name><operator>)</operator></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>forwardIp</name> <operator>&gt;</operator> <name>mflimitPlusOne</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>_last_literals</name>;</goto></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ip</name> <operator>&lt;</operator> <name>mflimitPlusOne</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>LZ4_getPositionOnHash</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>hashTable</name></name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>forwardH</name> <operator>=</operator> <call><name>LZ4_hashPosition</name><argument_list>(<argument><expr><name>forwardIp</name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LZ4_putPositionOnHash</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>hashTable</name></name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            </block_content>}</block> while <condition>( <expr><operator>(</operator><name>match</name><operator>+</operator><name>LZ4_DISTANCE_MAX</name> <operator>&lt;</operator> <name>ip</name><operator>)</operator>
                   <operator>||</operator> <operator>(</operator><call><name>LZ4_read32</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>LZ4_read32</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition>;</do>

        </block_content>}</block></if> <else>else <block>{<block_content>   <comment type="block">/* byU32, byU16 */</comment>

            <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>forwardIp</name> <init>= <expr><name>ip</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>step</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>searchMatchNb</name> <init>= <expr><name>acceleration</name> <operator>&lt;&lt;</operator> <name>LZ4_skipTrigger</name></expr></init></decl>;</decl_stmt>
            <do>do <block>{<block_content>
                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>h</name> <init>= <expr><name>forwardH</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>current</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>forwardIp</name> <operator>-</operator> <name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>U32</name></type> <name>matchIndex</name> <init>= <expr><call><name>LZ4_getIndexOnHash</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>hashTable</name></name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>matchIndex</name> <operator>&lt;=</operator> <name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>forwardIp</name> <operator>-</operator> <name>base</name> <operator>&lt;</operator> <operator>(</operator><name>ptrdiff_t</name><operator>)</operator><operator>(</operator><literal type="number">2</literal> <name>GB</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>ip</name> <operator>=</operator> <name>forwardIp</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>forwardIp</name> <operator>+=</operator> <name>step</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>step</name> <operator>=</operator> <operator>(</operator><name>searchMatchNb</name><operator>++</operator> <operator>&gt;&gt;</operator> <name>LZ4_skipTrigger</name><operator>)</operator></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>forwardIp</name> <operator>&gt;</operator> <name>mflimitPlusOne</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>_last_literals</name>;</goto></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ip</name> <operator>&lt;</operator> <name>mflimitPlusOne</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>dictDirective</name> <operator>==</operator> <name>usingDictCtx</name></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>matchIndex</name> <operator>&lt;</operator> <name>startIndex</name></expr>)</condition> <block>{<block_content>
                        <comment type="block">/* there was no match, try the dictionary */</comment>
                        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tableType</name> <operator>==</operator> <name>byU32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>matchIndex</name> <operator>=</operator> <call><name>LZ4_getIndexOnHash</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name><name>dictCtx</name><operator>-&gt;</operator><name>hashTable</name></name></expr></argument>, <argument><expr><name>byU32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>match</name> <operator>=</operator> <name>dictBase</name> <operator>+</operator> <name>matchIndex</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>matchIndex</name> <operator>+=</operator> <name>dictDelta</name></expr>;</expr_stmt>   <comment type="block">/* make dictCtx index comparable with current context */</comment>
                        <expr_stmt><expr><name>lowLimit</name> <operator>=</operator> <name>dictionary</name></expr>;</expr_stmt>
                    </block_content>}</block></if> <else>else <block>{<block_content>
                        <expr_stmt><expr><name>match</name> <operator>=</operator> <name>base</name> <operator>+</operator> <name>matchIndex</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>lowLimit</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>source</name></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>dictDirective</name><operator>==</operator><name>usingExtDict</name></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>matchIndex</name> <operator>&lt;</operator> <name>startIndex</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"extDict candidate: matchIndex=%5u  &lt;  startIndex=%5u"</literal></expr></argument>, <argument><expr><name>matchIndex</name></expr></argument>, <argument><expr><name>startIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>startIndex</name> <operator>-</operator> <name>matchIndex</name> <operator>&gt;=</operator> <name>MINMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>match</name> <operator>=</operator> <name>dictBase</name> <operator>+</operator> <name>matchIndex</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>lowLimit</name> <operator>=</operator> <name>dictionary</name></expr>;</expr_stmt>
                    </block_content>}</block></if> <else>else <block>{<block_content>
                        <expr_stmt><expr><name>match</name> <operator>=</operator> <name>base</name> <operator>+</operator> <name>matchIndex</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>lowLimit</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>source</name></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>   <comment type="block">/* single continuous memory segment */</comment>
                    <expr_stmt><expr><name>match</name> <operator>=</operator> <name>base</name> <operator>+</operator> <name>matchIndex</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <expr_stmt><expr><name>forwardH</name> <operator>=</operator> <call><name>LZ4_hashPosition</name><argument_list>(<argument><expr><name>forwardIp</name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LZ4_putIndexOnHash</name><argument_list>(<argument><expr><name>current</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>hashTable</name></name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"candidate at pos=%u  (offset=%u \n"</literal></expr></argument>, <argument><expr><name>matchIndex</name></expr></argument>, <argument><expr><name>current</name> <operator>-</operator> <name>matchIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>dictIssue</name> <operator>==</operator> <name>dictSmall</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>matchIndex</name> <operator>&lt;</operator> <name>prefixIdxLimit</name><operator>)</operator></expr>)</condition> <block>{<block_content> <continue>continue;</continue> </block_content>}</block></if></if_stmt>    <comment type="block">/* match outside of valid area */</comment>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>matchIndex</name> <operator>&lt;</operator> <name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>( <expr><operator>(</operator><operator>(</operator><name>tableType</name> <operator>!=</operator> <name>byU16</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>LZ4_DISTANCE_MAX</name> <operator>&lt;</operator> <name>LZ4_DISTANCE_ABSOLUTE_MAX</name><operator>)</operator><operator>)</operator>
                  <operator>&amp;&amp;</operator> <operator>(</operator><name>matchIndex</name><operator>+</operator><name>LZ4_DISTANCE_MAX</name> <operator>&lt;</operator> <name>current</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt> <comment type="block">/* too far */</comment>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>current</name> <operator>-</operator> <name>matchIndex</name><operator>)</operator> <operator>&lt;=</operator> <name>LZ4_DISTANCE_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* match now expected within distance */</comment>

                <if_stmt><if>if <condition>(<expr><call><name>LZ4_read32</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>LZ4_read32</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>maybe_extMem</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>current</name> <operator>-</operator> <name>matchIndex</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <break>break;</break>   <comment type="block">/* match found */</comment>
                </block_content>}</block></if></if_stmt>

            </block_content>}</block> while<condition>(<expr><literal type="number">1</literal></expr>)</condition>;</do>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Catch up */</comment>
        <expr_stmt><expr><name>filledIp</name> <operator>=</operator> <name>ip</name></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><operator>(</operator><name>ip</name><operator>&gt;</operator><name>anchor</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>match</name> <operator>&gt;</operator> <name>lowLimit</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>unlikely</name><argument_list>(<argument><expr><name><name>ip</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><name><name>match</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>ip</name><operator>--</operator></expr>;</expr_stmt> <expr_stmt><expr><name>match</name><operator>--</operator></expr>;</expr_stmt> </block_content>}</block></while>

        <comment type="block">/* Encode Literals */</comment>
        <block>{<block_content>   <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>litLength</name> <init>= <expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>anchor</name><operator>)</operator></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <name>op</name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>outputDirective</name> <operator>==</operator> <name>limitedOutput</name><operator>)</operator> <operator>&amp;&amp;</operator>  <comment type="block">/* Check output buffer overflow */</comment>
                <operator>(</operator><call><name>unlikely</name><argument_list>(<argument><expr><name>op</name> <operator>+</operator> <name>litLength</name> <operator>+</operator> <operator>(</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LASTLITERALS</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>litLength</name><operator>/</operator><literal type="number">255</literal><operator>)</operator> <operator>&gt;</operator> <name>olimit</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition> <block>{<block_content>
                <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */</comment>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>outputDirective</name> <operator>==</operator> <name>fillOutput</name><operator>)</operator> <operator>&amp;&amp;</operator>
                <operator>(</operator><call><name>unlikely</name><argument_list>(<argument><expr><name>op</name> <operator>+</operator> <operator>(</operator><name>litLength</name><operator>+</operator><literal type="number">240</literal><operator>)</operator><operator>/</operator><literal type="number">255</literal> <comment type="block">/* litlen */</comment> <operator>+</operator> <name>litLength</name> <comment type="block">/* literals */</comment> <operator>+</operator> <literal type="number">2</literal> <comment type="block">/* offset */</comment> <operator>+</operator> <literal type="number">1</literal> <comment type="block">/* token */</comment> <operator>+</operator> <name>MFLIMIT</name> <operator>-</operator> <name>MINMATCH</name> <comment type="block">/* min last literals so last match is &lt;= end - MFLIMIT */</comment> <operator>&gt;</operator> <name>olimit</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>op</name><operator>--</operator></expr>;</expr_stmt>
                <goto>goto <name>_last_literals</name>;</goto>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>litLength</name> <operator>&gt;=</operator> <name>RUN_MASK</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>litLength</name> <operator>-</operator> <name>RUN_MASK</name><operator>)</operator></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><operator>*</operator><name>token</name> <operator>=</operator> <operator>(</operator><name>RUN_MASK</name><operator>&lt;&lt;</operator><name>ML_BITS</name><operator>)</operator></expr>;</expr_stmt>
                <for>for<control>(<init>;</init> <condition><expr><name>len</name> <operator>&gt;=</operator> <literal type="number">255</literal></expr> ;</condition> <incr><expr><name>len</name><operator>-=</operator><literal type="number">255</literal></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>op</name><operator>++</operator> <operator>=</operator> <literal type="number">255</literal></expr>;</expr_stmt></block_content></block></for>
                <expr_stmt><expr><operator>*</operator><name>op</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><name>len</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>token</name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><operator>(</operator><name>litLength</name><operator>&lt;&lt;</operator><name>ML_BITS</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <comment type="block">/* Copy Literals */</comment>
            <expr_stmt><expr><call><name>LZ4_wildCopy8</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>op</name><operator>+</operator><name>litLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>op</name><operator>+=</operator><name>litLength</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"seq.start:%i, literals=%u, match.start:%i"</literal></expr></argument>,
                        <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>anchor</name><operator>-</operator><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>source</name><operator>)</operator></expr></argument>, <argument><expr><name>litLength</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>source</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

<label><name>_next_match</name>:</label>
        <comment type="block">/* at this stage, the following variables must be correctly set :
         * - ip : at start of LZ operation
         * - match : at start of previous pattern occurence; can be within current prefix, or within extDict
         * - offset : if maybe_ext_memSegment==1 (constant)
         * - lowLimit : must be == dictionary to mean "match is within extDict"; must be == source otherwise
         * - token and *token : position to write 4-bits for match length; higher 4-bits for literal length supposed already written
         */</comment>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>outputDirective</name> <operator>==</operator> <name>fillOutput</name><operator>)</operator> <operator>&amp;&amp;</operator>
            <operator>(</operator><name>op</name> <operator>+</operator> <literal type="number">2</literal> <comment type="block">/* offset */</comment> <operator>+</operator> <literal type="number">1</literal> <comment type="block">/* token */</comment> <operator>+</operator> <name>MFLIMIT</name> <operator>-</operator> <name>MINMATCH</name> <comment type="block">/* min last literals so last match is &lt;= end - MFLIMIT */</comment> <operator>&gt;</operator> <name>olimit</name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <comment type="block">/* the match was too close to the end, rewind and go to last literals */</comment>
            <expr_stmt><expr><name>op</name> <operator>=</operator> <name>token</name></expr>;</expr_stmt>
            <goto>goto <name>_last_literals</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Encode Offset */</comment>
        <if_stmt><if>if <condition>(<expr><name>maybe_extMem</name></expr>)</condition> <block>{<block_content>   <comment type="block">/* static test */</comment>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"             with offset=%u  (ext if &gt; %i)"</literal></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>source</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>offset</name> <operator>&lt;=</operator> <name>LZ4_DISTANCE_MAX</name> <operator>&amp;&amp;</operator> <name>offset</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LZ4_writeLE16</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><operator>(</operator><name>U16</name><operator>)</operator><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>op</name><operator>+=</operator><literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else  <block>{<block_content>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"             with offset=%u  (same segment)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>match</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ip</name><operator>-</operator><name>match</name> <operator>&lt;=</operator> <name>LZ4_DISTANCE_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LZ4_writeLE16</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><operator>(</operator><name>U16</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>match</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>op</name><operator>+=</operator><literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Encode MatchLength */</comment>
        <block>{<block_content>   <decl_stmt><decl><type><name>unsigned</name></type> <name>matchCode</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>( <expr><operator>(</operator><name>dictDirective</name><operator>==</operator><name>usingExtDict</name> <operator>||</operator> <name>dictDirective</name><operator>==</operator><name>usingDictCtx</name><operator>)</operator>
              <operator>&amp;&amp;</operator> <operator>(</operator><name>lowLimit</name><operator>==</operator><name>dictionary</name><operator>)</operator></expr> <comment type="block">/* match within extDict */</comment> )</condition> <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>limit</name> <init>= <expr><name>ip</name> <operator>+</operator> <operator>(</operator><name>dictEnd</name><operator>-</operator><name>match</name><operator>)</operator></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dictEnd</name> <operator>&gt;</operator> <name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>limit</name> <operator>&gt;</operator> <name>matchlimit</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>limit</name> <operator>=</operator> <name>matchlimit</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>matchCode</name> <operator>=</operator> <call><name>LZ4_count</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><name>MINMATCH</name></expr></argument>, <argument><expr><name>match</name><operator>+</operator><name>MINMATCH</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>ip</name> <operator>+=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>matchCode</name> <operator>+</operator> <name>MINMATCH</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>ip</name><operator>==</operator><name>limit</name></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier></type> <name>more</name> <init>= <expr><call><name>LZ4_count</name><argument_list>(<argument><expr><name>limit</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>source</name></expr></argument>, <argument><expr><name>matchlimit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>matchCode</name> <operator>+=</operator> <name>more</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>more</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"             with matchLength=%u starting in extDict"</literal></expr></argument>, <argument><expr><name>matchCode</name><operator>+</operator><name>MINMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>matchCode</name> <operator>=</operator> <call><name>LZ4_count</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><name>MINMATCH</name></expr></argument>, <argument><expr><name>match</name><operator>+</operator><name>MINMATCH</name></expr></argument>, <argument><expr><name>matchlimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>ip</name> <operator>+=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>matchCode</name> <operator>+</operator> <name>MINMATCH</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"             with matchLength=%u"</literal></expr></argument>, <argument><expr><name>matchCode</name><operator>+</operator><name>MINMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>outputDirective</name><operator>)</operator> <operator>&amp;&amp;</operator>    <comment type="block">/* Check output buffer overflow */</comment>
                <operator>(</operator><call><name>unlikely</name><argument_list>(<argument><expr><name>op</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <name>LASTLITERALS</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>matchCode</name><operator>+</operator><literal type="number">240</literal><operator>)</operator><operator>/</operator><literal type="number">255</literal> <operator>&gt;</operator> <name>olimit</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>outputDirective</name> <operator>==</operator> <name>fillOutput</name></expr>)</condition> <block>{<block_content>
                    <comment type="block">/* Match description too long : reduce it */</comment>
                    <decl_stmt><decl><type><name>U32</name></type> <name>newMatchCode</name> <init>= <expr><literal type="number">15</literal> <comment type="block">/* in token */</comment> <operator>-</operator> <literal type="number">1</literal> <comment type="block">/* to avoid needing a zero byte */</comment> <operator>+</operator> <operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>olimit</name> <operator>-</operator> <name>op</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>LASTLITERALS</name><operator>)</operator> <operator>*</operator> <literal type="number">255</literal></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>ip</name> <operator>-=</operator> <name>matchCode</name> <operator>-</operator> <name>newMatchCode</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>newMatchCode</name> <operator>&lt;</operator> <name>matchCode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>matchCode</name> <operator>=</operator> <name>newMatchCode</name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>ip</name> <operator>&lt;=</operator> <name>filledIp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <comment type="block">/* We have already filled up to filledIp so if ip ends up less than filledIp
                         * we have positions in the hash table beyond the current position. This is
                         * a problem if we reuse the hash table. So we have to remove these positions
                         * from the hash table.
                         */</comment>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ptr</name></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Clearing %u positions"</literal></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>filledIp</name> <operator>-</operator> <name>ip</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <name>ip</name></expr>;</init> <condition><expr><name>ptr</name> <operator>&lt;=</operator> <name>filledIp</name></expr>;</condition> <incr><expr><operator>++</operator><name>ptr</name></expr></incr>)</control> <block>{<block_content>
                            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>h</name> <init>= <expr><call><name>LZ4_hashPosition</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><call><name>LZ4_clearHash</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>hashTable</name></name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></for>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>outputDirective</name> <operator>==</operator> <name>limitedOutput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */</comment>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>matchCode</name> <operator>&gt;=</operator> <name>ML_MASK</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>token</name> <operator>+=</operator> <name>ML_MASK</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>matchCode</name> <operator>-=</operator> <name>ML_MASK</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LZ4_write32</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="number">0xFFFFFFFF</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <while>while <condition>(<expr><name>matchCode</name> <operator>&gt;=</operator> <literal type="number">4</literal><operator>*</operator><literal type="number">255</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>op</name><operator>+=</operator><literal type="number">4</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>LZ4_write32</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="number">0xFFFFFFFF</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>matchCode</name> <operator>-=</operator> <literal type="number">4</literal><operator>*</operator><literal type="number">255</literal></expr>;</expr_stmt>
                </block_content>}</block></while>
                <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>matchCode</name> <operator>/</operator> <literal type="number">255</literal></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>op</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><operator>(</operator><name>matchCode</name> <operator>%</operator> <literal type="number">255</literal><operator>)</operator></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>token</name> <operator>+=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><operator>(</operator><name>matchCode</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block>
        <comment type="block">/* Ensure we have enough space for the last literals. */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>outputDirective</name> <operator>==</operator> <name>fillOutput</name> <operator>&amp;&amp;</operator> <name>op</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LASTLITERALS</name> <operator>&gt;</operator> <name>olimit</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>anchor</name> <operator>=</operator> <name>ip</name></expr>;</expr_stmt>

        <comment type="block">/* Test end of chunk */</comment>
        <if_stmt><if>if <condition>(<expr><name>ip</name> <operator>&gt;=</operator> <name>mflimitPlusOne</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

        <comment type="block">/* Fill table */</comment>
        <expr_stmt><expr><call><name>LZ4_putPosition</name><argument_list>(<argument><expr><name>ip</name><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>hashTable</name></name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Test next position */</comment>
        <if_stmt><if>if <condition>(<expr><name>tableType</name> <operator>==</operator> <name>byPtr</name></expr>)</condition> <block>{<block_content>

            <expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>LZ4_getPosition</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>hashTable</name></name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LZ4_putPosition</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>hashTable</name></name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>( <expr><operator>(</operator><name>match</name><operator>+</operator><name>LZ4_DISTANCE_MAX</name> <operator>&gt;=</operator> <name>ip</name><operator>)</operator>
              <operator>&amp;&amp;</operator> <operator>(</operator><call><name>LZ4_read32</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>LZ4_read32</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition>
            <block>{<block_content> <expr_stmt><expr><name>token</name><operator>=</operator><name>op</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><operator>*</operator><name>token</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt> <goto>goto <name>_next_match</name>;</goto> </block_content>}</block></if></if_stmt>

        </block_content>}</block></if> <else>else <block>{<block_content>   <comment type="block">/* byU32, byU16 */</comment>

            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>h</name> <init>= <expr><call><name>LZ4_hashPosition</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>current</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name></type> <name>matchIndex</name> <init>= <expr><call><name>LZ4_getIndexOnHash</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>hashTable</name></name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>matchIndex</name> <operator>&lt;</operator> <name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>dictDirective</name> <operator>==</operator> <name>usingDictCtx</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>matchIndex</name> <operator>&lt;</operator> <name>startIndex</name></expr>)</condition> <block>{<block_content>
                    <comment type="block">/* there was no match, try the dictionary */</comment>
                    <expr_stmt><expr><name>matchIndex</name> <operator>=</operator> <call><name>LZ4_getIndexOnHash</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name><name>dictCtx</name><operator>-&gt;</operator><name>hashTable</name></name></expr></argument>, <argument><expr><name>byU32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>match</name> <operator>=</operator> <name>dictBase</name> <operator>+</operator> <name>matchIndex</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>lowLimit</name> <operator>=</operator> <name>dictionary</name></expr>;</expr_stmt>   <comment type="block">/* required for match length counter */</comment>
                    <expr_stmt><expr><name>matchIndex</name> <operator>+=</operator> <name>dictDelta</name></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><name>match</name> <operator>=</operator> <name>base</name> <operator>+</operator> <name>matchIndex</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>lowLimit</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>source</name></expr>;</expr_stmt>  <comment type="block">/* required for match length counter */</comment>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>dictDirective</name><operator>==</operator><name>usingExtDict</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>matchIndex</name> <operator>&lt;</operator> <name>startIndex</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>match</name> <operator>=</operator> <name>dictBase</name> <operator>+</operator> <name>matchIndex</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>lowLimit</name> <operator>=</operator> <name>dictionary</name></expr>;</expr_stmt>   <comment type="block">/* required for match length counter */</comment>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><name>match</name> <operator>=</operator> <name>base</name> <operator>+</operator> <name>matchIndex</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>lowLimit</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>source</name></expr>;</expr_stmt>   <comment type="block">/* required for match length counter */</comment>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>   <comment type="block">/* single memory segment */</comment>
                <expr_stmt><expr><name>match</name> <operator>=</operator> <name>base</name> <operator>+</operator> <name>matchIndex</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><call><name>LZ4_putIndexOnHash</name><argument_list>(<argument><expr><name>current</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>hashTable</name></name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>matchIndex</name> <operator>&lt;</operator> <name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>( <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>dictIssue</name><operator>==</operator><name>dictSmall</name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>matchIndex</name> <operator>&gt;=</operator> <name>prefixIdxLimit</name><operator>)</operator></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator>
              <operator>&amp;&amp;</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><operator>(</operator><name>tableType</name><operator>==</operator><name>byU16</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>LZ4_DISTANCE_MAX</name> <operator>==</operator> <name>LZ4_DISTANCE_ABSOLUTE_MAX</name><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>(</operator><name>matchIndex</name><operator>+</operator><name>LZ4_DISTANCE_MAX</name> <operator>&gt;=</operator> <name>current</name><operator>)</operator></expr></else></ternary><operator>)</operator>
              <operator>&amp;&amp;</operator> <operator>(</operator><call><name>LZ4_read32</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>LZ4_read32</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition> <block>{<block_content>
                <expr_stmt><expr><name>token</name><operator>=</operator><name>op</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>token</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>maybe_extMem</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>current</name> <operator>-</operator> <name>matchIndex</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"seq.start:%i, literals=%u, match.start:%i"</literal></expr></argument>,
                            <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>anchor</name><operator>-</operator><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>source</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>source</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>_next_match</name>;</goto>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Prepare next loop */</comment>
        <expr_stmt><expr><name>forwardH</name> <operator>=</operator> <call><name>LZ4_hashPosition</name><argument_list>(<argument><expr><operator>++</operator><name>ip</name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block></for>

<label><name>_last_literals</name>:</label>
    <comment type="block">/* Encode Last Literals */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name></type> <name>lastRun</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>iend</name> <operator>-</operator> <name>anchor</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>( <expr><operator>(</operator><name>outputDirective</name><operator>)</operator> <operator>&amp;&amp;</operator>  <comment type="block">/* Check output buffer overflow */</comment>
            <operator>(</operator><name>op</name> <operator>+</operator> <name>lastRun</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><operator>(</operator><name>lastRun</name><operator>+</operator><literal type="number">255</literal><operator>-</operator><name>RUN_MASK</name><operator>)</operator><operator>/</operator><literal type="number">255</literal><operator>)</operator> <operator>&gt;</operator> <name>olimit</name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>outputDirective</name> <operator>==</operator> <name>fillOutput</name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* adapt lastRun to fill 'dst' */</comment>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>olimit</name> <operator>&gt;=</operator> <name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>lastRun</name>  <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>olimit</name><operator>-</operator><name>op</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr><comment type="block">/*token*/</comment>;</expr_stmt>
                <expr_stmt><expr><name>lastRun</name> <operator>-=</operator> <operator>(</operator><name>lastRun</name> <operator>+</operator> <literal type="number">256</literal> <operator>-</operator> <name>RUN_MASK</name><operator>)</operator> <operator>/</operator> <literal type="number">256</literal></expr>;</expr_stmt>  <comment type="block">/*additional length tokens*/</comment>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>outputDirective</name> <operator>==</operator> <name>limitedOutput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */</comment>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"Final literal run : %i literals"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>lastRun</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>lastRun</name> <operator>&gt;=</operator> <name>RUN_MASK</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>size_t</name></type> <name>accumulator</name> <init>= <expr><name>lastRun</name> <operator>-</operator> <name>RUN_MASK</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><operator>*</operator><name>op</name><operator>++</operator> <operator>=</operator> <name>RUN_MASK</name> <operator>&lt;&lt;</operator> <name>ML_BITS</name></expr>;</expr_stmt>
            <for>for<control>(<init>;</init> <condition><expr><name>accumulator</name> <operator>&gt;=</operator> <literal type="number">255</literal></expr> ;</condition> <incr><expr><name>accumulator</name><operator>-=</operator><literal type="number">255</literal></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>op</name><operator>++</operator> <operator>=</operator> <literal type="number">255</literal></expr>;</expr_stmt></block_content></block></for>
            <expr_stmt><expr><operator>*</operator><name>op</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator> <name>accumulator</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>op</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><operator>(</operator><name>lastRun</name><operator>&lt;&lt;</operator><name>ML_BITS</name><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>lastRun</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ip</name> <operator>=</operator> <name>anchor</name> <operator>+</operator> <name>lastRun</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>lastRun</name></expr>;</expr_stmt>
    </block_content>}</block>

    <if_stmt><if>if <condition>(<expr><name>outputDirective</name> <operator>==</operator> <name>fillOutput</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>inputConsumed</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>ip</name><operator>)</operator><operator>-</operator><name>source</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>op</name><operator>)</operator> <operator>-</operator> <name>dest</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>result</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"LZ4_compress_generic: compressed %i bytes into %i bytes"</literal></expr></argument>, <argument><expr><name>inputSize</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** LZ4_compress_generic() :
 *  inlined, to ensure branches are decided at compilation time;
 *  takes care of src == (NULL, 0)
 *  and forward the rest to LZ4_compress_generic_validated */</comment>
<function><type><name>LZ4_FORCE_INLINE</name> <name>int</name></type> <name>LZ4_compress_generic</name><parameter_list>(
                 <parameter><decl><type><name>LZ4_stream_t_internal</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cctx</name></decl></parameter>,
                 <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>src</name></decl></parameter>,
                 <parameter><decl><type><name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dst</name></decl></parameter>,
                 <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>srcSize</name></decl></parameter>,
                 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>inputConsumed</name></decl></parameter>, <comment type="block">/* only written when outputDirective == fillOutput */</comment>
                 <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>dstCapacity</name></decl></parameter>,
                 <parameter><decl><type><specifier>const</specifier> <name>limitedOutput_directive</name></type> <name>outputDirective</name></decl></parameter>,
                 <parameter><decl><type><specifier>const</specifier> <name>tableType_t</name></type> <name>tableType</name></decl></parameter>,
                 <parameter><decl><type><specifier>const</specifier> <name>dict_directive</name></type> <name>dictDirective</name></decl></parameter>,
                 <parameter><decl><type><specifier>const</specifier> <name>dictIssue_directive</name></type> <name>dictIssue</name></decl></parameter>,
                 <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>acceleration</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"LZ4_compress_generic: srcSize=%i, dstCapacity=%i"</literal></expr></argument>,
                <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>U32</name><operator>)</operator><name>srcSize</name> <operator>&gt;</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>LZ4_MAX_INPUT_SIZE</name></expr>)</condition> <block>{<block_content> <return>return <expr><literal type="number">0</literal></expr>;</return> </block_content>}</block></if></if_stmt>  <comment type="block">/* Unsupported srcSize, too large (or negative) */</comment>
    <if_stmt><if>if <condition>(<expr><name>srcSize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>   <comment type="block">/* src == NULL supported if srcSize == 0 */</comment>
        <if_stmt><if>if <condition>(<expr><name>outputDirective</name> <operator>!=</operator> <name>notLimited</name> <operator>&amp;&amp;</operator> <name>dstCapacity</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* no output, can't write anything */</comment>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"Generating an empty block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>outputDirective</name> <operator>==</operator> <name>notLimited</name> <operator>||</operator> <name>dstCapacity</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dst</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>outputDirective</name> <operator>==</operator> <name>fillOutput</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>inputConsumed</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>inputConsumed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>src</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>LZ4_compress_generic_validated</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>,
                <argument><expr><name>inputConsumed</name></expr></argument>, <comment type="block">/* only written into if outputDirective == fillOutput */</comment>
                <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>outputDirective</name></expr></argument>,
                <argument><expr><name>tableType</name></expr></argument>, <argument><expr><name>dictDirective</name></expr></argument>, <argument><expr><name>dictIssue</name></expr></argument>, <argument><expr><name>acceleration</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>LZ4_compress_fast_extState</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>state</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>inputSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxOutputSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>acceleration</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LZ4_stream_t_internal</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ctx</name> <init>= <expr><operator>&amp;</operator> <call><name>LZ4_initStream</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LZ4_stream_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>-&gt;</operator> <name>internal_donotuse</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ctx</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>acceleration</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>acceleration</name> <operator>=</operator> <name>LZ4_ACCELERATION_DEFAULT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>acceleration</name> <operator>&gt;</operator> <name>LZ4_ACCELERATION_MAX</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>acceleration</name> <operator>=</operator> <name>LZ4_ACCELERATION_MAX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>maxOutputSize</name> <operator>&gt;=</operator> <call><name>LZ4_compressBound</name><argument_list>(<argument><expr><name>inputSize</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>inputSize</name> <operator>&lt;</operator> <name>LZ4_64Klimit</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><call><name>LZ4_compress_generic</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>inputSize</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>notLimited</name></expr></argument>, <argument><expr><name>byU16</name></expr></argument>, <argument><expr><name>noDict</name></expr></argument>, <argument><expr><name>noDictIssue</name></expr></argument>, <argument><expr><name>acceleration</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>tableType_t</name></type> <name>tableType</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">4</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>uptrval</name><operator>)</operator><name>source</name> <operator>&gt;</operator> <name>LZ4_DISTANCE_MAX</name><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><name>byPtr</name></expr> </then><else>: <expr><name>byU32</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <return>return <expr><call><name>LZ4_compress_generic</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>inputSize</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>notLimited</name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>, <argument><expr><name>noDict</name></expr></argument>, <argument><expr><name>noDictIssue</name></expr></argument>, <argument><expr><name>acceleration</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>inputSize</name> <operator>&lt;</operator> <name>LZ4_64Klimit</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><call><name>LZ4_compress_generic</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>inputSize</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>maxOutputSize</name></expr></argument>, <argument><expr><name>limitedOutput</name></expr></argument>, <argument><expr><name>byU16</name></expr></argument>, <argument><expr><name>noDict</name></expr></argument>, <argument><expr><name>noDictIssue</name></expr></argument>, <argument><expr><name>acceleration</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>tableType_t</name></type> <name>tableType</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">4</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>uptrval</name><operator>)</operator><name>source</name> <operator>&gt;</operator> <name>LZ4_DISTANCE_MAX</name><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><name>byPtr</name></expr> </then><else>: <expr><name>byU32</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <return>return <expr><call><name>LZ4_compress_generic</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>inputSize</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>maxOutputSize</name></expr></argument>, <argument><expr><name>limitedOutput</name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>, <argument><expr><name>noDict</name></expr></argument>, <argument><expr><name>noDictIssue</name></expr></argument>, <argument><expr><name>acceleration</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * LZ4_compress_fast_extState_fastReset() :
 * A variant of LZ4_compress_fast_extState().
 *
 * Using this variant avoids an expensive initialization step. It is only safe
 * to call if the state buffer is known to be correctly initialized already
 * (see comment in lz4.h on LZ4_resetStream_fast() for a definition of
 * "correctly initialized").
 */</comment>
<function><type><name>int</name></type> <name>LZ4_compress_fast_extState_fastReset</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>state</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dstCapacity</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>acceleration</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LZ4_stream_t_internal</name><modifier>*</modifier></type> <name>ctx</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>LZ4_stream_t</name><operator>*</operator><operator>)</operator><name>state</name><operator>)</operator><operator>-&gt;</operator><name>internal_donotuse</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>acceleration</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>acceleration</name> <operator>=</operator> <name>LZ4_ACCELERATION_DEFAULT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>acceleration</name> <operator>&gt;</operator> <name>LZ4_ACCELERATION_MAX</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>acceleration</name> <operator>=</operator> <name>LZ4_ACCELERATION_MAX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>dstCapacity</name> <operator>&gt;=</operator> <call><name>LZ4_compressBound</name><argument_list>(<argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>srcSize</name> <operator>&lt;</operator> <name>LZ4_64Klimit</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>tableType_t</name></type> <name>tableType</name> <init>= <expr><name>byU16</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>LZ4_prepareTable</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>currentOffset</name></name></expr>)</condition> <block>{<block_content>
                <return>return <expr><call><name>LZ4_compress_generic</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>notLimited</name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>, <argument><expr><name>noDict</name></expr></argument>, <argument><expr><name>dictSmall</name></expr></argument>, <argument><expr><name>acceleration</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <return>return <expr><call><name>LZ4_compress_generic</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>notLimited</name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>, <argument><expr><name>noDict</name></expr></argument>, <argument><expr><name>noDictIssue</name></expr></argument>, <argument><expr><name>acceleration</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>tableType_t</name></type> <name>tableType</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">4</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>uptrval</name><operator>)</operator><name>src</name> <operator>&gt;</operator> <name>LZ4_DISTANCE_MAX</name><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><name>byPtr</name></expr> </then><else>: <expr><name>byU32</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>LZ4_prepareTable</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name>LZ4_compress_generic</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>notLimited</name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>, <argument><expr><name>noDict</name></expr></argument>, <argument><expr><name>noDictIssue</name></expr></argument>, <argument><expr><name>acceleration</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>srcSize</name> <operator>&lt;</operator> <name>LZ4_64Klimit</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>tableType_t</name></type> <name>tableType</name> <init>= <expr><name>byU16</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>LZ4_prepareTable</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>currentOffset</name></name></expr>)</condition> <block>{<block_content>
                <return>return <expr><call><name>LZ4_compress_generic</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>limitedOutput</name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>, <argument><expr><name>noDict</name></expr></argument>, <argument><expr><name>dictSmall</name></expr></argument>, <argument><expr><name>acceleration</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <return>return <expr><call><name>LZ4_compress_generic</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>limitedOutput</name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>, <argument><expr><name>noDict</name></expr></argument>, <argument><expr><name>noDictIssue</name></expr></argument>, <argument><expr><name>acceleration</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>tableType_t</name></type> <name>tableType</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">4</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>uptrval</name><operator>)</operator><name>src</name> <operator>&gt;</operator> <name>LZ4_DISTANCE_MAX</name><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><name>byPtr</name></expr> </then><else>: <expr><name>byU32</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>LZ4_prepareTable</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name>LZ4_compress_generic</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>limitedOutput</name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>, <argument><expr><name>noDict</name></expr></argument>, <argument><expr><name>noDictIssue</name></expr></argument>, <argument><expr><name>acceleration</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>LZ4_compress_fast</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>inputSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxOutputSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>acceleration</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>LZ4_HEAPMODE</name><operator>)</operator></expr></cpp:if>
    <decl_stmt><decl><type><name>LZ4_stream_t</name><modifier>*</modifier></type> <name>ctxPtr</name> <init>= <expr><call><name>ALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LZ4_stream_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>   <comment type="block">/* malloc-calloc always properly aligned */</comment>
    <if_stmt><if>if <condition>(<expr><name>ctxPtr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>LZ4_stream_t</name></type> <name>ctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LZ4_stream_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ctxPtr</name> <init>= <expr><operator>&amp;</operator><name>ctx</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>LZ4_compress_fast_extState</name><argument_list>(<argument><expr><name>ctxPtr</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>inputSize</name></expr></argument>, <argument><expr><name>maxOutputSize</name></expr></argument>, <argument><expr><name>acceleration</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>LZ4_HEAPMODE</name><operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><call><name>FREEMEM</name><argument_list>(<argument><expr><name>ctxPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>LZ4_compress_default</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxOutputSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>LZ4_compress_fast</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>maxOutputSize</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Note!: This function leaves the stream in an unclean/broken state!
 * It is not safe to subsequently use the same state with a _fastReset() or
 * _continue() call without resetting it. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>LZ4_compress_destSize_extState</name> <parameter_list>(<parameter><decl><type><name>LZ4_stream_t</name><modifier>*</modifier></type> <name>state</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>srcSizePtr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targetDstSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>void</name><modifier>*</modifier> <specifier>const</specifier></type> <name>s</name> <init>= <expr><call><name>LZ4_initStream</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><operator>*</operator><name>state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>s</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>targetDstSize</name> <operator>&gt;=</operator> <call><name>LZ4_compressBound</name><argument_list>(<argument><expr><operator>*</operator><name>srcSizePtr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* compression success is guaranteed */</comment>
        <return>return <expr><call><name>LZ4_compress_fast_extState</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>*</operator><name>srcSizePtr</name></expr></argument>, <argument><expr><name>targetDstSize</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>srcSizePtr</name> <operator>&lt;</operator> <name>LZ4_64Klimit</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><call><name>LZ4_compress_generic</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>internal_donotuse</name></name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>*</operator><name>srcSizePtr</name></expr></argument>, <argument><expr><name>srcSizePtr</name></expr></argument>, <argument><expr><name>targetDstSize</name></expr></argument>, <argument><expr><name>fillOutput</name></expr></argument>, <argument><expr><name>byU16</name></expr></argument>, <argument><expr><name>noDict</name></expr></argument>, <argument><expr><name>noDictIssue</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <decl_stmt><decl><type><name>tableType_t</name> <specifier>const</specifier></type> <name>addrMode</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">4</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>uptrval</name><operator>)</operator><name>src</name> <operator>&gt;</operator> <name>LZ4_DISTANCE_MAX</name><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><name>byPtr</name></expr> </then><else>: <expr><name>byU32</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <return>return <expr><call><name>LZ4_compress_generic</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>internal_donotuse</name></name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>*</operator><name>srcSizePtr</name></expr></argument>, <argument><expr><name>srcSizePtr</name></expr></argument>, <argument><expr><name>targetDstSize</name></expr></argument>, <argument><expr><name>fillOutput</name></expr></argument>, <argument><expr><name>addrMode</name></expr></argument>, <argument><expr><name>noDict</name></expr></argument>, <argument><expr><name>noDictIssue</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>   </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>LZ4_compress_destSize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>srcSizePtr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targetDstSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>LZ4_HEAPMODE</name><operator>)</operator></expr></cpp:if>
    <decl_stmt><decl><type><name>LZ4_stream_t</name><modifier>*</modifier></type> <name>ctx</name> <init>= <expr><operator>(</operator><name>LZ4_stream_t</name><operator>*</operator><operator>)</operator><call><name>ALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LZ4_stream_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>   <comment type="block">/* malloc-calloc always properly aligned */</comment>
    <if_stmt><if>if <condition>(<expr><name>ctx</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>LZ4_stream_t</name></type> <name>ctxBody</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LZ4_stream_t</name><modifier>*</modifier></type> <name>ctx</name> <init>= <expr><operator>&amp;</operator><name>ctxBody</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><call><name>LZ4_compress_destSize_extState</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcSizePtr</name></expr></argument>, <argument><expr><name>targetDstSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>LZ4_HEAPMODE</name><operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><call><name>FREEMEM</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>



<comment type="block">/*-******************************
*  Streaming functions
********************************/</comment>

<function><type><name>LZ4_stream_t</name><modifier>*</modifier></type> <name>LZ4_createStream</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LZ4_stream_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>lz4s</name> <init>= <expr><operator>(</operator><name>LZ4_stream_t</name><operator>*</operator><operator>)</operator><call><name>ALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LZ4_stream_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>LZ4_STATIC_ASSERT</name><argument_list>(<argument><expr><name>LZ4_STREAMSIZE</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LZ4_stream_t_internal</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* A compilation error here means LZ4_STREAMSIZE is not large enough */</comment>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"LZ4_createStream %p"</literal></expr></argument>, <argument><expr><name>lz4s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>lz4s</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>LZ4_initStream</name><argument_list>(<argument><expr><name>lz4s</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>lz4s</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>lz4s</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>LZ4_stream_t_alignment</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LZ4_ALIGN_TEST</name></expr></cpp:if>
    <typedef>typedef <type><struct>struct <block>{ <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>LZ4_stream_t</name></type> <name>t</name></decl>;</decl_stmt> }</block></struct></type> <name>t_a</name>;</typedef>
    <return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>t_a</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LZ4_stream_t</name></expr></argument>)</argument_list></sizeof></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr><literal type="number">1</literal></expr>;</return>  <comment type="block">/* effectively disabled */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>LZ4_stream_t</name><modifier>*</modifier></type> <name>LZ4_initStream</name> <parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"LZ4_initStream"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content> <return>return <expr><name>NULL</name></expr>;</return> </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LZ4_stream_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content> <return>return <expr><name>NULL</name></expr>;</return> </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>LZ4_isAligned</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><call><name>LZ4_stream_t_alignment</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>MEM_INIT</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LZ4_stream_t_internal</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>LZ4_stream_t</name><operator>*</operator><operator>)</operator><name>buffer</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* resetStream is now deprecated,
 * prefer initStream() which is more general */</comment>
<function><type><name>void</name></type> <name>LZ4_resetStream</name> <parameter_list>(<parameter><decl><type><name>LZ4_stream_t</name><modifier>*</modifier></type> <name>LZ4_stream</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"LZ4_resetStream (ctx:%p)"</literal></expr></argument>, <argument><expr><name>LZ4_stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MEM_INIT</name><argument_list>(<argument><expr><name>LZ4_stream</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LZ4_stream_t_internal</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>LZ4_resetStream_fast</name><parameter_list>(<parameter><decl><type><name>LZ4_stream_t</name><modifier>*</modifier></type> <name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>LZ4_prepareTable</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>internal_donotuse</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>byU32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>LZ4_freeStream</name> <parameter_list>(<parameter><decl><type><name>LZ4_stream_t</name><modifier>*</modifier></type> <name>LZ4_stream</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>LZ4_stream</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* support free on NULL */</comment>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"LZ4_freeStream %p"</literal></expr></argument>, <argument><expr><name>LZ4_stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FREEMEM</name><argument_list>(<argument><expr><name>LZ4_stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_UNIT</name></cpp:macro> <cpp:value>sizeof(reg_t)</cpp:value></cpp:define>
<function><type><name>int</name></type> <name>LZ4_loadDict</name> <parameter_list>(<parameter><decl><type><name>LZ4_stream_t</name><modifier>*</modifier></type> <name>LZ4_dict</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>dictionary</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dictSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LZ4_stream_t_internal</name><modifier>*</modifier></type> <name>dict</name> <init>= <expr><operator>&amp;</operator><name><name>LZ4_dict</name><operator>-&gt;</operator><name>internal_donotuse</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>tableType_t</name></type> <name>tableType</name> <init>= <expr><name>byU32</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>p</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>dictionary</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictEnd</name> <init>= <expr><name>p</name> <operator>+</operator> <name>dictSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>base</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"LZ4_loadDict (%i bytes from %p into %p)"</literal></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>, <argument><expr><name>dictionary</name></expr></argument>, <argument><expr><name>LZ4_dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* It's necessary to reset the context,
     * and not just continue it with prepareTable()
     * to avoid any risk of generating overflowing matchIndex
     * when compressing using this dictionary */</comment>
    <expr_stmt><expr><call><name>LZ4_resetStream</name><argument_list>(<argument><expr><name>LZ4_dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We always increment the offset by 64 KB, since, if the dict is longer,
     * we truncate it to the last 64k, and if it's shorter, we still want to
     * advance by a whole window length so we can provide the guarantee that
     * there are only valid offsets in the window, which allows an optimization
     * in LZ4_compress_fast_continue() where it uses noDictIssue even when the
     * dictionary isn't a full 64k. */</comment>
    <expr_stmt><expr><name><name>dict</name><operator>-&gt;</operator><name>currentOffset</name></name> <operator>+=</operator> <literal type="number">64</literal> <name>KB</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>dictSize</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><name>HASH_UNIT</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>dictEnd</name> <operator>-</operator> <name>p</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">64</literal> <name>KB</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name> <operator>=</operator> <name>dictEnd</name> <operator>-</operator> <literal type="number">64</literal> <name>KB</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>base</name> <operator>=</operator> <name>dictEnd</name> <operator>-</operator> <name><name>dict</name><operator>-&gt;</operator><name>currentOffset</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dict</name><operator>-&gt;</operator><name>dictionary</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dict</name><operator>-&gt;</operator><name>dictSize</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>dictEnd</name> <operator>-</operator> <name>p</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dict</name><operator>-&gt;</operator><name>tableType</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>tableType</name></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>p</name> <operator>&lt;=</operator> <name>dictEnd</name><operator>-</operator><name>HASH_UNIT</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>LZ4_putPosition</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>dict</name><operator>-&gt;</operator><name>hashTable</name></name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name><operator>+=</operator><literal type="number">3</literal></expr>;</expr_stmt>
    </block_content>}</block></while>

    <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>dict</name><operator>-&gt;</operator><name>dictSize</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>LZ4_attach_dictionary</name><parameter_list>(<parameter><decl><type><name>LZ4_stream_t</name><modifier>*</modifier></type> <name>workingStream</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LZ4_stream_t</name><modifier>*</modifier></type> <name>dictionaryStream</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>LZ4_stream_t_internal</name><modifier>*</modifier></type> <name>dictCtx</name> <init>= <expr><ternary><condition><expr><name>dictionaryStream</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>:
        <expr><operator>&amp;</operator><operator>(</operator><name><name>dictionaryStream</name><operator>-&gt;</operator><name>internal_donotuse</name></name><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"LZ4_attach_dictionary (%p, %p, size %u)"</literal></expr></argument>,
             <argument><expr><name>workingStream</name></expr></argument>, <argument><expr><name>dictionaryStream</name></expr></argument>,
             <argument><expr><ternary><condition><expr><name>dictCtx</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name><name>dictCtx</name><operator>-&gt;</operator><name>dictSize</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>dictCtx</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* If the current offset is zero, we will never look in the
         * external dictionary context, since there is no value a table
         * entry can take that indicate a miss. In that case, we need
         * to bump the offset to something non-zero.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>workingStream</name><operator>-&gt;</operator><name>internal_donotuse</name><operator>.</operator><name>currentOffset</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>workingStream</name><operator>-&gt;</operator><name>internal_donotuse</name><operator>.</operator><name>currentOffset</name></name> <operator>=</operator> <literal type="number">64</literal> <name>KB</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Don't actually attach an empty dictionary.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>dictCtx</name><operator>-&gt;</operator><name>dictSize</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>dictCtx</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>workingStream</name><operator>-&gt;</operator><name>internal_donotuse</name><operator>.</operator><name>dictCtx</name></name> <operator>=</operator> <name>dictCtx</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>LZ4_renormDictT</name><parameter_list>(<parameter><decl><type><name>LZ4_stream_t_internal</name><modifier>*</modifier></type> <name>LZ4_dict</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nextSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nextSize</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>LZ4_dict</name><operator>-&gt;</operator><name>currentOffset</name></name> <operator>+</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>nextSize</name> <operator>&gt;</operator> <literal type="number">0x80000000</literal></expr>)</condition> <block>{<block_content>   <comment type="block">/* potential ptrdiff_t overflow (32-bits mode) */</comment>
        <comment type="block">/* rescale hash table */</comment>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>delta</name> <init>= <expr><name><name>LZ4_dict</name><operator>-&gt;</operator><name>currentOffset</name></name> <operator>-</operator> <literal type="number">64</literal> <name>KB</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>dictEnd</name> <init>= <expr><name><name>LZ4_dict</name><operator>-&gt;</operator><name>dictionary</name></name> <operator>+</operator> <name><name>LZ4_dict</name><operator>-&gt;</operator><name>dictSize</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"LZ4_renormDictT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>LZ4_HASH_SIZE_U32</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>LZ4_dict</name><operator>-&gt;</operator><name>hashTable</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name>delta</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>LZ4_dict</name><operator>-&gt;</operator><name>hashTable</name><index>[<expr><name>i</name></expr>]</index></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name><name>LZ4_dict</name><operator>-&gt;</operator><name>hashTable</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-=</operator> <name>delta</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>LZ4_dict</name><operator>-&gt;</operator><name>currentOffset</name></name> <operator>=</operator> <literal type="number">64</literal> <name>KB</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>LZ4_dict</name><operator>-&gt;</operator><name>dictSize</name></name> <operator>&gt;</operator> <literal type="number">64</literal> <name>KB</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>LZ4_dict</name><operator>-&gt;</operator><name>dictSize</name></name> <operator>=</operator> <literal type="number">64</literal> <name>KB</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>LZ4_dict</name><operator>-&gt;</operator><name>dictionary</name></name> <operator>=</operator> <name>dictEnd</name> <operator>-</operator> <name><name>LZ4_dict</name><operator>-&gt;</operator><name>dictSize</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>LZ4_compress_fast_continue</name> <parameter_list>(<parameter><decl><type><name>LZ4_stream_t</name><modifier>*</modifier></type> <name>LZ4_stream</name></decl></parameter>,
                                <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dest</name></decl></parameter>,
                                <parameter><decl><type><name>int</name></type> <name>inputSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxOutputSize</name></decl></parameter>,
                                <parameter><decl><type><name>int</name></type> <name>acceleration</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>tableType_t</name></type> <name>tableType</name> <init>= <expr><name>byU32</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LZ4_stream_t_internal</name><modifier>*</modifier></type> <name>streamPtr</name> <init>= <expr><operator>&amp;</operator><name><name>LZ4_stream</name><operator>-&gt;</operator><name>internal_donotuse</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>dictEnd</name> <init>= <expr><name><name>streamPtr</name><operator>-&gt;</operator><name>dictionary</name></name> <operator>+</operator> <name><name>streamPtr</name><operator>-&gt;</operator><name>dictSize</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"LZ4_compress_fast_continue (inputSize=%i)"</literal></expr></argument>, <argument><expr><name>inputSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LZ4_renormDictT</name><argument_list>(<argument><expr><name>streamPtr</name></expr></argument>, <argument><expr><name>inputSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* avoid index overflow */</comment>
    <if_stmt><if>if <condition>(<expr><name>acceleration</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>acceleration</name> <operator>=</operator> <name>LZ4_ACCELERATION_DEFAULT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>acceleration</name> <operator>&gt;</operator> <name>LZ4_ACCELERATION_MAX</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>acceleration</name> <operator>=</operator> <name>LZ4_ACCELERATION_MAX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* invalidate tiny dictionaries */</comment>
    <if_stmt><if>if <condition>( <expr><operator>(</operator><name><name>streamPtr</name><operator>-&gt;</operator><name>dictSize</name></name><operator>-</operator><literal type="number">1</literal> <operator>&lt;</operator> <literal type="number">4</literal><operator>-</operator><literal type="number">1</literal><operator>)</operator>   <comment type="block">/* intentional underflow */</comment>
      <operator>&amp;&amp;</operator> <operator>(</operator><name>dictEnd</name> <operator>!=</operator> <operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>source</name><operator>)</operator></expr> )</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"LZ4_compress_fast_continue: dictSize(%u) at addr:%p is too small"</literal></expr></argument>, <argument><expr><name><name>streamPtr</name><operator>-&gt;</operator><name>dictSize</name></name></expr></argument>, <argument><expr><name><name>streamPtr</name><operator>-&gt;</operator><name>dictionary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>streamPtr</name><operator>-&gt;</operator><name>dictSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>streamPtr</name><operator>-&gt;</operator><name>dictionary</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>source</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dictEnd</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>source</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check overlapping input/dictionary space */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>sourceEnd</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator> <name>source</name> <operator>+</operator> <name>inputSize</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>sourceEnd</name> <operator>&gt;</operator> <name><name>streamPtr</name><operator>-&gt;</operator><name>dictionary</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>sourceEnd</name> <operator>&lt;</operator> <name>dictEnd</name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>streamPtr</name><operator>-&gt;</operator><name>dictSize</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>dictEnd</name> <operator>-</operator> <name>sourceEnd</name><operator>)</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>streamPtr</name><operator>-&gt;</operator><name>dictSize</name></name> <operator>&gt;</operator> <literal type="number">64</literal> <name>KB</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>streamPtr</name><operator>-&gt;</operator><name>dictSize</name></name> <operator>=</operator> <literal type="number">64</literal> <name>KB</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>streamPtr</name><operator>-&gt;</operator><name>dictSize</name></name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>streamPtr</name><operator>-&gt;</operator><name>dictSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>streamPtr</name><operator>-&gt;</operator><name>dictionary</name></name> <operator>=</operator> <name>dictEnd</name> <operator>-</operator> <name><name>streamPtr</name><operator>-&gt;</operator><name>dictSize</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/* prefix mode : source data follows dictionary */</comment>
    <if_stmt><if>if <condition>(<expr><name>dictEnd</name> <operator>==</operator> <operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>source</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>streamPtr</name><operator>-&gt;</operator><name>dictSize</name></name> <operator>&lt;</operator> <literal type="number">64</literal> <name>KB</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>streamPtr</name><operator>-&gt;</operator><name>dictSize</name></name> <operator>&lt;</operator> <name><name>streamPtr</name><operator>-&gt;</operator><name>currentOffset</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>LZ4_compress_generic</name><argument_list>(<argument><expr><name>streamPtr</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>inputSize</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>maxOutputSize</name></expr></argument>, <argument><expr><name>limitedOutput</name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>, <argument><expr><name>withPrefix64k</name></expr></argument>, <argument><expr><name>dictSmall</name></expr></argument>, <argument><expr><name>acceleration</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <return>return <expr><call><name>LZ4_compress_generic</name><argument_list>(<argument><expr><name>streamPtr</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>inputSize</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>maxOutputSize</name></expr></argument>, <argument><expr><name>limitedOutput</name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>, <argument><expr><name>withPrefix64k</name></expr></argument>, <argument><expr><name>noDictIssue</name></expr></argument>, <argument><expr><name>acceleration</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* external dictionary mode */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>streamPtr</name><operator>-&gt;</operator><name>dictCtx</name></name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* We depend here on the fact that dictCtx'es (produced by
             * LZ4_loadDict) guarantee that their tables contain no references
             * to offsets between dictCtx-&gt;currentOffset - 64 KB and
             * dictCtx-&gt;currentOffset - dictCtx-&gt;dictSize. This makes it safe
             * to use noDictIssue even when the dict isn't a full 64 KB.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>inputSize</name> <operator>&gt;</operator> <literal type="number">4</literal> <name>KB</name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* For compressing large blobs, it is faster to pay the setup
                 * cost to copy the dictionary's tables into the active context,
                 * so that the compression loop is only looking into one table.
                 */</comment>
                <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><name>streamPtr</name></expr></argument>, <argument><expr><name><name>streamPtr</name><operator>-&gt;</operator><name>dictCtx</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>streamPtr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>LZ4_compress_generic</name><argument_list>(<argument><expr><name>streamPtr</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>inputSize</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>maxOutputSize</name></expr></argument>, <argument><expr><name>limitedOutput</name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>, <argument><expr><name>usingExtDict</name></expr></argument>, <argument><expr><name>noDictIssue</name></expr></argument>, <argument><expr><name>acceleration</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>LZ4_compress_generic</name><argument_list>(<argument><expr><name>streamPtr</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>inputSize</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>maxOutputSize</name></expr></argument>, <argument><expr><name>limitedOutput</name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>, <argument><expr><name>usingDictCtx</name></expr></argument>, <argument><expr><name>noDictIssue</name></expr></argument>, <argument><expr><name>acceleration</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>streamPtr</name><operator>-&gt;</operator><name>dictSize</name></name> <operator>&lt;</operator> <literal type="number">64</literal> <name>KB</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>streamPtr</name><operator>-&gt;</operator><name>dictSize</name></name> <operator>&lt;</operator> <name><name>streamPtr</name><operator>-&gt;</operator><name>currentOffset</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>LZ4_compress_generic</name><argument_list>(<argument><expr><name>streamPtr</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>inputSize</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>maxOutputSize</name></expr></argument>, <argument><expr><name>limitedOutput</name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>, <argument><expr><name>usingExtDict</name></expr></argument>, <argument><expr><name>dictSmall</name></expr></argument>, <argument><expr><name>acceleration</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>LZ4_compress_generic</name><argument_list>(<argument><expr><name>streamPtr</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>inputSize</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>maxOutputSize</name></expr></argument>, <argument><expr><name>limitedOutput</name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>, <argument><expr><name>usingExtDict</name></expr></argument>, <argument><expr><name>noDictIssue</name></expr></argument>, <argument><expr><name>acceleration</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>streamPtr</name><operator>-&gt;</operator><name>dictionary</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>source</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>streamPtr</name><operator>-&gt;</operator><name>dictSize</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>inputSize</name></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>


<comment type="block">/* Hidden debug function, to force-test external dictionary mode */</comment>
<function><type><name>int</name></type> <name>LZ4_compress_forceExtDict</name> <parameter_list>(<parameter><decl><type><name>LZ4_stream_t</name><modifier>*</modifier></type> <name>LZ4_dict</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LZ4_stream_t_internal</name><modifier>*</modifier></type> <name>streamPtr</name> <init>= <expr><operator>&amp;</operator><name><name>LZ4_dict</name><operator>-&gt;</operator><name>internal_donotuse</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LZ4_renormDictT</name><argument_list>(<argument><expr><name>streamPtr</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>streamPtr</name><operator>-&gt;</operator><name>dictSize</name></name> <operator>&lt;</operator> <literal type="number">64</literal> <name>KB</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>streamPtr</name><operator>-&gt;</operator><name>dictSize</name></name> <operator>&lt;</operator> <name><name>streamPtr</name><operator>-&gt;</operator><name>currentOffset</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>LZ4_compress_generic</name><argument_list>(<argument><expr><name>streamPtr</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>notLimited</name></expr></argument>, <argument><expr><name>byU32</name></expr></argument>, <argument><expr><name>usingExtDict</name></expr></argument>, <argument><expr><name>dictSmall</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>LZ4_compress_generic</name><argument_list>(<argument><expr><name>streamPtr</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>notLimited</name></expr></argument>, <argument><expr><name>byU32</name></expr></argument>, <argument><expr><name>usingExtDict</name></expr></argument>, <argument><expr><name>noDictIssue</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>streamPtr</name><operator>-&gt;</operator><name>dictionary</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>source</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>streamPtr</name><operator>-&gt;</operator><name>dictSize</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>srcSize</name></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*! LZ4_saveDict() :
 *  If previously compressed data block is not guaranteed to remain available at its memory location,
 *  save it into a safer place (char* safeBuffer).
 *  Note : you don't need to call LZ4_loadDict() afterwards,
 *         dictionary is immediately usable, you can therefore call LZ4_compress_fast_continue().
 *  Return : saved dictionary size in bytes (necessarily &lt;= dictSize), or 0 if error.
 */</comment>
<function><type><name>int</name></type> <name>LZ4_saveDict</name> <parameter_list>(<parameter><decl><type><name>LZ4_stream_t</name><modifier>*</modifier></type> <name>LZ4_dict</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>safeBuffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dictSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LZ4_stream_t_internal</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dict</name> <init>= <expr><operator>&amp;</operator><name><name>LZ4_dict</name><operator>-&gt;</operator><name>internal_donotuse</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>previousDictEnd</name> <init>= <expr><name><name>dict</name><operator>-&gt;</operator><name>dictionary</name></name> <operator>+</operator> <name><name>dict</name><operator>-&gt;</operator><name>dictSize</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>U32</name><operator>)</operator><name>dictSize</name> <operator>&gt;</operator> <literal type="number">64</literal> <name>KB</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>dictSize</name> <operator>=</operator> <literal type="number">64</literal> <name>KB</name></expr>;</expr_stmt> </block_content>}</block></if></if_stmt> <comment type="block">/* useless to define a dictionary &gt; 64 KB */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>U32</name><operator>)</operator><name>dictSize</name> <operator>&gt;</operator> <name><name>dict</name><operator>-&gt;</operator><name>dictSize</name></name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>dictSize</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>dict</name><operator>-&gt;</operator><name>dictSize</name></name></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>safeBuffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dictSize</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>dictSize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>safeBuffer</name></expr></argument>, <argument><expr><name>previousDictEnd</name> <operator>-</operator> <name>dictSize</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>dict</name><operator>-&gt;</operator><name>dictionary</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>safeBuffer</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dict</name><operator>-&gt;</operator><name>dictSize</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>dictSize</name></expr>;</expr_stmt>

    <return>return <expr><name>dictSize</name></expr>;</return>
</block_content>}</block></function>



<comment type="block">/*-*******************************
 *  Decompression functions
 ********************************/</comment>

<typedef>typedef <type><enum>enum <block>{ <decl><name>endOnOutputSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><name>endOnInputSize</name> <init>= <expr><literal type="number">1</literal></expr></init></decl> }</block></enum></type> <name>endCondition_directive</name>;</typedef>
<typedef>typedef <type><enum>enum <block>{ <decl><name>decode_full_block</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><name>partial_decode</name> <init>= <expr><literal type="number">1</literal></expr></init></decl> }</block></enum></type> <name>earlyEnd_directive</name>;</typedef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MIN</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>( (a) &lt; (b) ? (a) : (b) )</cpp:value></cpp:define>

<comment type="block">/* Read the variable-length literal or match length.
 *
 * ip - pointer to use as input.
 * lencheck - end ip.  Return an error if ip advances &gt;= lencheck.
 * loop_check - check ip &gt;= lencheck in body of loop.  Returns loop_error if so.
 * initial_check - check ip &gt;= lencheck before start of loop.  Returns initial_error if so.
 * error (output) - error code.  Should be set to 0 before call.
 */</comment>
<typedef>typedef <type><enum>enum <block>{ <decl><name>loop_error</name> <init>= <expr><operator>-</operator><literal type="number">2</literal></expr></init></decl>, <decl><name>initial_error</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><name>ok</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> }</block></enum></type> <name>variable_length_error</name>;</typedef>
<function><type><name>LZ4_FORCE_INLINE</name> <name>unsigned</name></type>
<name>read_variable_length</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier><modifier>*</modifier></type><name>ip</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>lencheck</name></decl></parameter>,
                     <parameter><decl><type><name>int</name></type> <name>loop_check</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>initial_check</name></decl></parameter>,
                     <parameter><decl><type><name>variable_length_error</name><modifier>*</modifier></type> <name>error</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U32</name></type> <name>length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>s</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>initial_check</name> <operator>&amp;&amp;</operator> <call><name>unlikely</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>ip</name><operator>)</operator> <operator>&gt;=</operator> <name>lencheck</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>    <comment type="block">/* overflow detection */</comment>
        <expr_stmt><expr><operator>*</operator><name>error</name> <operator>=</operator> <name>initial_error</name></expr>;</expr_stmt>
        <return>return <expr><name>length</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <do>do <block>{<block_content>
        <expr_stmt><expr><name>s</name> <operator>=</operator> <operator>*</operator><operator>*</operator><name>ip</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>ip</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>length</name> <operator>+=</operator> <name>s</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>loop_check</name> <operator>&amp;&amp;</operator> <call><name>unlikely</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>ip</name><operator>)</operator> <operator>&gt;=</operator> <name>lencheck</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>    <comment type="block">/* overflow detection */</comment>
            <expr_stmt><expr><operator>*</operator><name>error</name> <operator>=</operator> <name>loop_error</name></expr>;</expr_stmt>
            <return>return <expr><name>length</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block> while <condition>(<expr><name>s</name><operator>==</operator><literal type="number">255</literal></expr>)</condition>;</do>

    <return>return <expr><name>length</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! LZ4_decompress_generic() :
 *  This generic decompression function covers all use cases.
 *  It shall be instantiated several times, using different sets of directives.
 *  Note that it is important for performance that this function really get inlined,
 *  in order to remove useless branches during compilation optimization.
 */</comment>
<function><type><name>LZ4_FORCE_INLINE</name> <name>int</name></type>
<name>LZ4_decompress_generic</name><parameter_list>(
                 <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>src</name></decl></parameter>,
                 <parameter><decl><type><name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dst</name></decl></parameter>,
                 <parameter><decl><type><name>int</name></type> <name>srcSize</name></decl></parameter>,
                 <parameter><decl><type><name>int</name></type> <name>outputSize</name></decl></parameter>,         <comment type="block">/* If endOnInput==endOnInputSize, this value is `dstCapacity` */</comment>

                 <parameter><decl><type><name>endCondition_directive</name></type> <name>endOnInput</name></decl></parameter>,   <comment type="block">/* endOnOutputSize, endOnInputSize */</comment>
                 <parameter><decl><type><name>earlyEnd_directive</name></type> <name>partialDecoding</name></decl></parameter>,  <comment type="block">/* full, partial */</comment>
                 <parameter><decl><type><name>dict_directive</name></type> <name>dict</name></decl></parameter>,                 <comment type="block">/* noDict, withPrefix64k, usingExtDict */</comment>
                 <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>lowPrefix</name></decl></parameter>,  <comment type="block">/* always &lt;= dst, == dst when no prefix */</comment>
                 <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictStart</name></decl></parameter>,  <comment type="block">/* only if dict==usingExtDict */</comment>
                 <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>dictSize</name></decl></parameter>         <comment type="block">/* note : = 0 if noDict */</comment>
                 )</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>src</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return> </block_content>}</block></if></if_stmt>

    <block>{<block_content>   <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator> <name>src</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name> <init>= <expr><name>ip</name> <operator>+</operator> <name>srcSize</name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator> <name>dst</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend</name> <init>= <expr><name>op</name> <operator>+</operator> <name>outputSize</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>cpy</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictEnd</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>dictStart</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name>dictStart</name> <operator>+</operator> <name>dictSize</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>safeDecode</name> <init>= <expr><operator>(</operator><name>endOnInput</name><operator>==</operator><name>endOnInputSize</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>checkOffset</name> <init>= <expr><operator>(</operator><operator>(</operator><name>safeDecode</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>dictSize</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><literal type="number">64</literal> <name>KB</name><operator>)</operator><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>


        <comment type="block">/* Set up the "end" pointers for the shortcut. */</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>shortiend</name> <init>= <expr><name>iend</name> <operator>-</operator> <operator>(</operator><ternary><condition><expr><name>endOnInput</name></expr> ?</condition><then> <expr><literal type="number">14</literal></expr> </then><else>: <expr><literal type="number">8</literal></expr></else></ternary><operator>)</operator> <comment type="block">/*maxLL*/</comment> <operator>-</operator> <literal type="number">2</literal></expr></init></decl> <comment type="block">/*offset*/</comment>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>shortoend</name> <init>= <expr><name>oend</name> <operator>-</operator> <operator>(</operator><ternary><condition><expr><name>endOnInput</name></expr> ?</condition><then> <expr><literal type="number">14</literal></expr> </then><else>: <expr><literal type="number">8</literal></expr></else></ternary><operator>)</operator> <comment type="block">/*maxLL*/</comment> <operator>-</operator> <literal type="number">18</literal></expr></init></decl> <comment type="block">/*maxML*/</comment>;</decl_stmt>

        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>match</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>offset</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name></type> <name>token</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>length</name></decl>;</decl_stmt>


        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"LZ4_decompress_generic (srcSize:%i, dstSize:%i)"</literal></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>outputSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Special cases */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lowPrefix</name> <operator>&lt;=</operator> <name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>endOnInput</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>unlikely</name><argument_list>(<argument><expr><name>outputSize</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Empty output buffer */</comment>
            <if_stmt><if>if <condition>(<expr><name>partialDecoding</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            <return>return <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>srcSize</name><operator>==</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>ip</name><operator>==</operator><literal type="number">0</literal><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>endOnInput</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>unlikely</name><argument_list>(<argument><expr><name>outputSize</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <return>return <expr><operator>(</operator><ternary><condition><expr><operator>*</operator><name>ip</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</return> </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>endOnInput</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>unlikely</name><argument_list>(<argument><expr><name>srcSize</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return> </block_content>}</block></if></if_stmt>

	<comment type="block">/* Currently the fast loop shows a regression on qualcomm arm chips. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LZ4_FAST_DEC_LOOP</name></expr></cpp:if>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>oend</name> <operator>-</operator> <name>op</name><operator>)</operator> <operator>&lt;</operator> <name>FASTLOOP_SAFE_DISTANCE</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"skip fast decode loop"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>safe_decode</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Fast loop : decode sequences as long as output &lt; iend-FASTLOOP_SAFE_DISTANCE */</comment>
        <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Main fastloop assertion: We can always wildcopy FASTLOOP_SAFE_DISTANCE */</comment>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>oend</name> <operator>-</operator> <name>op</name> <operator>&gt;=</operator> <name>FASTLOOP_SAFE_DISTANCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>endOnInput</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ip</name> <operator>&lt;</operator> <name>iend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <operator>*</operator><name>ip</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>length</name> <operator>=</operator> <name>token</name> <operator>&gt;&gt;</operator> <name>ML_BITS</name></expr>;</expr_stmt>  <comment type="block">/* literal length */</comment>

            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>endOnInput</name> <operator>||</operator> <name>ip</name> <operator>&lt;=</operator> <name>iend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* ip &lt; iend before the increment */</comment>

            <comment type="block">/* decode literal length */</comment>
            <if_stmt><if>if <condition>(<expr><name>length</name> <operator>==</operator> <name>RUN_MASK</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>variable_length_error</name></type> <name>error</name> <init>= <expr><name>ok</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>length</name> <operator>+=</operator> <call><name>read_variable_length</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ip</name></expr></argument>, <argument><expr><name>iend</name><operator>-</operator><name>RUN_MASK</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>endOnInput</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>endOnInput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>error</name> <operator>==</operator> <name>initial_error</name></expr>)</condition> <block>{<block_content> <goto>goto <name>_output_error</name>;</goto> </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>safeDecode</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>unlikely</name><argument_list>(<argument><expr><operator>(</operator><name>uptrval</name><operator>)</operator><operator>(</operator><name>op</name><operator>)</operator><operator>+</operator><name>length</name><operator>&lt;</operator><operator>(</operator><name>uptrval</name><operator>)</operator><operator>(</operator><name>op</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <goto>goto <name>_output_error</name>;</goto> </block_content>}</block></if></if_stmt> <comment type="block">/* overflow detection */</comment>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>safeDecode</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>unlikely</name><argument_list>(<argument><expr><operator>(</operator><name>uptrval</name><operator>)</operator><operator>(</operator><name>ip</name><operator>)</operator><operator>+</operator><name>length</name><operator>&lt;</operator><operator>(</operator><name>uptrval</name><operator>)</operator><operator>(</operator><name>ip</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <goto>goto <name>_output_error</name>;</goto> </block_content>}</block></if></if_stmt> <comment type="block">/* overflow detection */</comment>

                <comment type="block">/* copy literals */</comment>
                <expr_stmt><expr><name>cpy</name> <operator>=</operator> <name>op</name><operator>+</operator><name>length</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LZ4_STATIC_ASSERT</name><argument_list>(<argument><expr><name>MFLIMIT</name> <operator>&gt;=</operator> <name>WILDCOPYLENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>endOnInput</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* LZ4_decompress_safe() */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>cpy</name><operator>&gt;</operator><name>oend</name><operator>-</operator><literal type="number">32</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>ip</name><operator>+</operator><name>length</name><operator>&gt;</operator><name>iend</name><operator>-</operator><literal type="number">32</literal><operator>)</operator></expr>)</condition> <block>{<block_content> <goto>goto <name>safe_literal_copy</name>;</goto> </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><call><name>LZ4_wildCopy32</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>cpy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>   <comment type="block">/* LZ4_decompress_fast() */</comment>
                    <if_stmt><if>if <condition>(<expr><name>cpy</name><operator>&gt;</operator><name>oend</name><operator>-</operator><literal type="number">8</literal></expr>)</condition> <block>{<block_content> <goto>goto <name>safe_literal_copy</name>;</goto> </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><call><name>LZ4_wildCopy8</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>cpy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* LZ4_decompress_fast() cannot copy more than 8 bytes at a time :
                                                 * it doesn't know input length, and only relies on end-of-block properties */</comment>
                </block_content>}</block></else></if_stmt>
                <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>cpy</name></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>cpy</name> <operator>=</operator> <name>op</name><operator>+</operator><name>length</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>endOnInput</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* LZ4_decompress_safe() */</comment>
                    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"copy %u bytes in a 16-bytes stripe"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/* We don't need to check oend, since we check it once for each loop below */</comment>
                    <if_stmt><if>if <condition>(<expr><name>ip</name> <operator>&gt;</operator> <name>iend</name><operator>-</operator><operator>(</operator><literal type="number">16</literal> <operator>+</operator> <literal type="number">1</literal><comment type="block">/*max lit + offset + nextToken*/</comment><operator>)</operator></expr>)</condition> <block>{<block_content> <goto>goto <name>safe_literal_copy</name>;</goto> </block_content>}</block></if></if_stmt>
                    <comment type="block">/* Literals can only be 14, but hope compilers optimize if we copy by a register size */</comment>
                    <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* LZ4_decompress_fast() */</comment>
                    <comment type="block">/* LZ4_decompress_fast() cannot copy more than 8 bytes at a time :
                     * it doesn't know input length, and relies on end-of-block properties */</comment>
                    <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>length</name> <operator>&gt;</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><name>op</name><operator>+</operator><literal type="number">8</literal></expr></argument>, <argument><expr><name>ip</name><operator>+</operator><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
                </block_content>}</block></else></if_stmt>
                <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>cpy</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/* get offset */</comment>
            <expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>LZ4_readLE16</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>ip</name><operator>+=</operator><literal type="number">2</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>match</name> <operator>=</operator> <name>op</name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>match</name> <operator>&lt;=</operator> <name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* get matchlength */</comment>
            <expr_stmt><expr><name>length</name> <operator>=</operator> <name>token</name> <operator>&amp;</operator> <name>ML_MASK</name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>length</name> <operator>==</operator> <name>ML_MASK</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>variable_length_error</name></type> <name>error</name> <init>= <expr><name>ok</name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>checkOffset</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>unlikely</name><argument_list>(<argument><expr><name>match</name> <operator>+</operator> <name>dictSize</name> <operator>&lt;</operator> <name>lowPrefix</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <goto>goto <name>_output_error</name>;</goto> </block_content>}</block></if></if_stmt> <comment type="block">/* Error : offset outside buffers */</comment>
                <expr_stmt><expr><name>length</name> <operator>+=</operator> <call><name>read_variable_length</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ip</name></expr></argument>, <argument><expr><name>iend</name> <operator>-</operator> <name>LASTLITERALS</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>endOnInput</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>error</name> <operator>!=</operator> <name>ok</name></expr>)</condition> <block>{<block_content> <goto>goto <name>_output_error</name>;</goto> </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>safeDecode</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>unlikely</name><argument_list>(<argument><expr><operator>(</operator><name>uptrval</name><operator>)</operator><operator>(</operator><name>op</name><operator>)</operator><operator>+</operator><name>length</name><operator>&lt;</operator><operator>(</operator><name>uptrval</name><operator>)</operator><name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <goto>goto <name>_output_error</name>;</goto> </block_content>}</block></if></if_stmt> <comment type="block">/* overflow detection */</comment>
                <expr_stmt><expr><name>length</name> <operator>+=</operator> <name>MINMATCH</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>op</name> <operator>+</operator> <name>length</name> <operator>&gt;=</operator> <name>oend</name> <operator>-</operator> <name>FASTLOOP_SAFE_DISTANCE</name></expr>)</condition> <block>{<block_content>
                    <goto>goto <name>safe_match_copy</name>;</goto>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>length</name> <operator>+=</operator> <name>MINMATCH</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>op</name> <operator>+</operator> <name>length</name> <operator>&gt;=</operator> <name>oend</name> <operator>-</operator> <name>FASTLOOP_SAFE_DISTANCE</name></expr>)</condition> <block>{<block_content>
                    <goto>goto <name>safe_match_copy</name>;</goto>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* Fastpath check: Avoids a branch in LZ4_wildCopy32 if true */</comment>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>dict</name> <operator>==</operator> <name>withPrefix64k</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>match</name> <operator>&gt;=</operator> <name>lowPrefix</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;=</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>match</name> <operator>&gt;=</operator> <name>lowPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>match</name> <operator>&lt;=</operator> <name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name> <operator>+</operator> <literal type="number">18</literal> <operator>&lt;=</operator> <name>oend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><name>op</name><operator>+</operator><literal type="number">8</literal></expr></argument>, <argument><expr><name>match</name><operator>+</operator><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><name>op</name><operator>+</operator><literal type="number">16</literal></expr></argument>, <argument><expr><name>match</name><operator>+</operator><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
                        <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>   </block_content>}</block></if></if_stmt>   </block_content>}</block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>checkOffset</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>unlikely</name><argument_list>(<argument><expr><name>match</name> <operator>+</operator> <name>dictSize</name> <operator>&lt;</operator> <name>lowPrefix</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <goto>goto <name>_output_error</name>;</goto> </block_content>}</block></if></if_stmt> <comment type="block">/* Error : offset outside buffers */</comment>
            <comment type="block">/* match starting within external dictionary */</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>dict</name><operator>==</operator><name>usingExtDict</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>match</name> <operator>&lt;</operator> <name>lowPrefix</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>op</name><operator>+</operator><name>length</name> <operator>&gt;</operator> <name>oend</name><operator>-</operator><name>LASTLITERALS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>partialDecoding</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"partialDecoding: dictionary match, close to dstEnd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>length</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name><operator>-</operator><name>op</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if> <else>else <block>{<block_content>
                        <goto>goto <name>_output_error</name>;</goto>  <comment type="block">/* end-of-block condition violated */</comment>
                </block_content>}</block></else></if_stmt>   </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>length</name> <operator>&lt;=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>lowPrefix</name><operator>-</operator><name>match</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                    <comment type="block">/* match fits entirely within external dictionary : just copy */</comment>
                    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>dictEnd</name> <operator>-</operator> <operator>(</operator><name>lowPrefix</name><operator>-</operator><name>match</name><operator>)</operator></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <comment type="block">/* match stretches into both external dictionary and current block */</comment>
                    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>copySize</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>lowPrefix</name> <operator>-</operator> <name>match</name><operator>)</operator></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>restSize</name> <init>= <expr><name>length</name> <operator>-</operator> <name>copySize</name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>dictEnd</name> <operator>-</operator> <name>copySize</name></expr></argument>, <argument><expr><name>copySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>copySize</name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>restSize</name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>op</name> <operator>-</operator> <name>lowPrefix</name><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* overlap copy */</comment>
                        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>endOfMatch</name> <init>= <expr><name>op</name> <operator>+</operator> <name>restSize</name></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>copyFrom</name> <init>= <expr><name>lowPrefix</name></expr></init></decl>;</decl_stmt>
                        <while>while <condition>(<expr><name>op</name> <operator>&lt;</operator> <name>endOfMatch</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><operator>*</operator><name>op</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>copyFrom</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
                    </block_content>}</block></if> <else>else <block>{<block_content>
                        <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>lowPrefix</name></expr></argument>, <argument><expr><name>restSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>restSize</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>   </block_content>}</block></else></if_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* copy match within block */</comment>
            <expr_stmt><expr><name>cpy</name> <operator>=</operator> <name>op</name> <operator>+</operator> <name>length</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>op</name> <operator>&lt;=</operator> <name>oend</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>oend</name><operator>-</operator><name>op</name> <operator>&gt;=</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>offset</name><operator>&lt;</operator><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>LZ4_memcpy_using_offset</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name>cpy</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>LZ4_wildCopy32</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name>cpy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><name>op</name> <operator>=</operator> <name>cpy</name></expr>;</expr_stmt>   <comment type="block">/* wildcopy correction */</comment>
        </block_content>}</block></while>
    <label><name>safe_decode</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/* Main Loop : decode remaining sequences where output &lt; FASTLOOP_SAFE_DISTANCE */</comment>
        <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <operator>*</operator><name>ip</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>length</name> <operator>=</operator> <name>token</name> <operator>&gt;&gt;</operator> <name>ML_BITS</name></expr>;</expr_stmt>  <comment type="block">/* literal length */</comment>

            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>endOnInput</name> <operator>||</operator> <name>ip</name> <operator>&lt;=</operator> <name>iend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* ip &lt; iend before the increment */</comment>

            <comment type="block">/* A two-stage shortcut for the most common case:
             * 1) If the literal length is 0..14, and there is enough space,
             * enter the shortcut and copy 16 bytes on behalf of the literals
             * (in the fast mode, only 8 bytes can be safely copied this way).
             * 2) Further if the match length is 4..18, copy 18 bytes in a similar
             * manner; but we ensure that there's enough space in the output for
             * those 18 bytes earlier, upon entering the shortcut (in other words,
             * there is a combined check for both stages).
             */</comment>
            <if_stmt><if>if <condition>( <expr><operator>(</operator><ternary><condition><expr><name>endOnInput</name></expr> ?</condition><then> <expr><name>length</name> <operator>!=</operator> <name>RUN_MASK</name></expr> </then><else>: <expr><name>length</name> <operator>&lt;=</operator> <literal type="number">8</literal></expr></else></ternary><operator>)</operator>
                <comment type="block">/* strictly "less than" on input, to re-enter the loop with at least one byte */</comment>
              <operator>&amp;&amp;</operator> <call><name>likely</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>endOnInput</name></expr> ?</condition><then> <expr><name>ip</name> <operator>&lt;</operator> <name>shortiend</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>op</name> <operator>&lt;=</operator> <name>shortoend</name><operator>)</operator></expr></argument>)</argument_list></call></expr> )</condition> <block>{<block_content>
                <comment type="block">/* Copy the literals */</comment>
                <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><ternary><condition><expr><name>endOnInput</name></expr> ?</condition><then> <expr><literal type="number">16</literal></expr> </then><else>: <expr><literal type="number">8</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt> <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>

                <comment type="block">/* The second stage: prepare for match copying, decode full info.
                 * If it doesn't work out, the info won't be wasted. */</comment>
                <expr_stmt><expr><name>length</name> <operator>=</operator> <name>token</name> <operator>&amp;</operator> <name>ML_MASK</name></expr>;</expr_stmt> <comment type="block">/* match length */</comment>
                <expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>LZ4_readLE16</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>ip</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>match</name> <operator>=</operator> <name>op</name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>match</name> <operator>&lt;=</operator> <name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* check overflow */</comment>

                <comment type="block">/* Do not deal with overlapping matches. */</comment>
                <if_stmt><if>if <condition>( <expr><operator>(</operator><name>length</name> <operator>!=</operator> <name>ML_MASK</name><operator>)</operator>
                  <operator>&amp;&amp;</operator> <operator>(</operator><name>offset</name> <operator>&gt;=</operator> <literal type="number">8</literal><operator>)</operator>
                  <operator>&amp;&amp;</operator> <operator>(</operator><name>dict</name><operator>==</operator><name>withPrefix64k</name> <operator>||</operator> <name>match</name> <operator>&gt;=</operator> <name>lowPrefix</name><operator>)</operator></expr> )</condition> <block>{<block_content>
                    <comment type="block">/* Copy the match. */</comment>
                    <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><name>op</name> <operator>+</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>match</name> <operator>+</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><name>op</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name>match</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><name>op</name> <operator>+</operator><literal type="number">16</literal></expr></argument>, <argument><expr><name>match</name> <operator>+</operator><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>length</name> <operator>+</operator> <name>MINMATCH</name></expr>;</expr_stmt>
                    <comment type="block">/* Both stages worked, load the next token. */</comment>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* The second stage didn't work out, but the info is ready.
                 * Propel it right to the point of match copying. */</comment>
                <goto>goto <name>_copy_match</name>;</goto>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* decode literal length */</comment>
            <if_stmt><if>if <condition>(<expr><name>length</name> <operator>==</operator> <name>RUN_MASK</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>variable_length_error</name></type> <name>error</name> <init>= <expr><name>ok</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>length</name> <operator>+=</operator> <call><name>read_variable_length</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ip</name></expr></argument>, <argument><expr><name>iend</name><operator>-</operator><name>RUN_MASK</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>endOnInput</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>endOnInput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>error</name> <operator>==</operator> <name>initial_error</name></expr>)</condition> <block>{<block_content> <goto>goto <name>_output_error</name>;</goto> </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>safeDecode</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>unlikely</name><argument_list>(<argument><expr><operator>(</operator><name>uptrval</name><operator>)</operator><operator>(</operator><name>op</name><operator>)</operator><operator>+</operator><name>length</name><operator>&lt;</operator><operator>(</operator><name>uptrval</name><operator>)</operator><operator>(</operator><name>op</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <goto>goto <name>_output_error</name>;</goto> </block_content>}</block></if></if_stmt> <comment type="block">/* overflow detection */</comment>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>safeDecode</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>unlikely</name><argument_list>(<argument><expr><operator>(</operator><name>uptrval</name><operator>)</operator><operator>(</operator><name>ip</name><operator>)</operator><operator>+</operator><name>length</name><operator>&lt;</operator><operator>(</operator><name>uptrval</name><operator>)</operator><operator>(</operator><name>ip</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <goto>goto <name>_output_error</name>;</goto> </block_content>}</block></if></if_stmt> <comment type="block">/* overflow detection */</comment>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* copy literals */</comment>
            <expr_stmt><expr><name>cpy</name> <operator>=</operator> <name>op</name><operator>+</operator><name>length</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LZ4_FAST_DEC_LOOP</name></expr></cpp:if>
        <label><name>safe_literal_copy</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>LZ4_STATIC_ASSERT</name><argument_list>(<argument><expr><name>MFLIMIT</name> <operator>&gt;=</operator> <name>WILDCOPYLENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>( <expr><operator>(</operator><operator>(</operator><name>endOnInput</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>cpy</name><operator>&gt;</operator><name>oend</name><operator>-</operator><name>MFLIMIT</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>ip</name><operator>+</operator><name>length</name><operator>&gt;</operator><name>iend</name><operator>-</operator><operator>(</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>LASTLITERALS</name><operator>)</operator><operator>)</operator><operator>)</operator> <operator>)</operator>
              <operator>||</operator> <operator>(</operator><operator>(</operator><operator>!</operator><name>endOnInput</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>cpy</name><operator>&gt;</operator><name>oend</name><operator>-</operator><name>WILDCOPYLENGTH</name><operator>)</operator><operator>)</operator></expr> )</condition>
            <block>{<block_content>
                <comment type="block">/* We've either hit the input parsing restriction or the output parsing restriction.
                 * In the normal scenario, decoding a full block, it must be the last sequence,
                 * otherwise it's an error (invalid input or dimensions).
                 * In partialDecoding scenario, it's necessary to ensure there is no buffer overflow.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>partialDecoding</name></expr>)</condition> <block>{<block_content>
                    <comment type="block">/* Since we are partial decoding we may be in this block because of the output parsing
                     * restriction, which is not valid since the output buffer is allowed to be undersized.
                     */</comment>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>endOnInput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <macro><name>DEBUGLOG</name><argument_list>(<argument><literal type="number">7</literal></argument>, <argument><literal type="string">"partialDecoding: copying literals, close to input or output end"</literal></argument>)</argument_list></macro>
                    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"partialDecoding: literal length = %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"partialDecoding: remaining space in dstBuffer : %i"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>oend</name> <operator>-</operator> <name>op</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"partialDecoding: remaining space in srcBuffer : %i"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>iend</name> <operator>-</operator> <name>ip</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/* Finishing in the middle of a literals segment,
                     * due to lack of input.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name>ip</name><operator>+</operator><name>length</name> <operator>&gt;</operator> <name>iend</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>length</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>iend</name><operator>-</operator><name>ip</name><operator>)</operator></expr>;</expr_stmt>
                        <expr_stmt><expr><name>cpy</name> <operator>=</operator> <name>op</name> <operator>+</operator> <name>length</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <comment type="block">/* Finishing in the middle of a literals segment,
                     * due to lack of output space.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name>cpy</name> <operator>&gt;</operator> <name>oend</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>cpy</name> <operator>=</operator> <name>oend</name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name><operator>&lt;=</operator><name>oend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>length</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name><operator>-</operator><name>op</name><operator>)</operator></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <comment type="block">/* We must be on the last sequence because of the parsing limitations so check
                     * that we exactly regenerate the original size (must be exact when !endOnInput).
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>endOnInput</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>cpy</name> <operator>!=</operator> <name>oend</name><operator>)</operator></expr>)</condition> <block>{<block_content> <goto>goto <name>_output_error</name>;</goto> </block_content>}</block></if></if_stmt>
                     <comment type="block">/* We must be on the last sequence (or invalid) because of the parsing limitations
                      * so check that we exactly consume the input and don't overrun the output buffer.
                      */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>endOnInput</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>ip</name><operator>+</operator><name>length</name> <operator>!=</operator> <name>iend</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>cpy</name> <operator>&gt;</operator> <name>oend</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
                        <macro><name>DEBUGLOG</name><argument_list>(<argument><literal type="number">6</literal></argument>, <argument><literal type="string">"should have been last run of literals"</literal></argument>)</argument_list></macro>
                        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"ip(%p) + length(%i) = %p != iend (%p)"</literal></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>length</name></expr></argument>, <argument><expr><name>ip</name><operator>+</operator><name>length</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"or cpy(%p) &gt; oend(%p)"</literal></expr></argument>, <argument><expr><name>cpy</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <goto>goto <name>_output_error</name>;</goto>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></else></if_stmt>
                <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* supports overlapping memory regions; only matters for in-place decompression scenarios */</comment>
                <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
                <comment type="block">/* Necessarily EOF when !partialDecoding.
                 * When partialDecoding, it is EOF if we've either
                 * filled the output buffer or
                 * can't proceed with reading an offset for following match.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>partialDecoding</name> <operator>||</operator> <operator>(</operator><name>cpy</name> <operator>==</operator> <name>oend</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>ip</name> <operator>&gt;=</operator> <operator>(</operator><name>iend</name><operator>-</operator><literal type="number">2</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>LZ4_wildCopy8</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>cpy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* may overwrite up to WILDCOPYLENGTH beyond cpy */</comment>
                <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>cpy</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/* get offset */</comment>
            <expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>LZ4_readLE16</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>ip</name><operator>+=</operator><literal type="number">2</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>match</name> <operator>=</operator> <name>op</name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>

            <comment type="block">/* get matchlength */</comment>
            <expr_stmt><expr><name>length</name> <operator>=</operator> <name>token</name> <operator>&amp;</operator> <name>ML_MASK</name></expr>;</expr_stmt>

    <label><name>_copy_match</name>:</label>
            <if_stmt><if>if <condition>(<expr><name>length</name> <operator>==</operator> <name>ML_MASK</name></expr>)</condition> <block>{<block_content>
              <decl_stmt><decl><type><name>variable_length_error</name></type> <name>error</name> <init>= <expr><name>ok</name></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><name>length</name> <operator>+=</operator> <call><name>read_variable_length</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ip</name></expr></argument>, <argument><expr><name>iend</name> <operator>-</operator> <name>LASTLITERALS</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>endOnInput</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if_stmt><if>if <condition>(<expr><name>error</name> <operator>!=</operator> <name>ok</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>_output_error</name>;</goto></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>safeDecode</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>unlikely</name><argument_list>(<argument><expr><operator>(</operator><name>uptrval</name><operator>)</operator><operator>(</operator><name>op</name><operator>)</operator><operator>+</operator><name>length</name><operator>&lt;</operator><operator>(</operator><name>uptrval</name><operator>)</operator><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>_output_error</name>;</goto></block_content></block></if></if_stmt>   <comment type="block">/* overflow detection */</comment>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>length</name> <operator>+=</operator> <name>MINMATCH</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LZ4_FAST_DEC_LOOP</name></expr></cpp:if>
        <label><name>safe_match_copy</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>checkOffset</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>unlikely</name><argument_list>(<argument><expr><name>match</name> <operator>+</operator> <name>dictSize</name> <operator>&lt;</operator> <name>lowPrefix</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>_output_error</name>;</goto></block_content></block></if></if_stmt>   <comment type="block">/* Error : offset outside buffers */</comment>
            <comment type="block">/* match starting within external dictionary */</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>dict</name><operator>==</operator><name>usingExtDict</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>match</name> <operator>&lt;</operator> <name>lowPrefix</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>op</name><operator>+</operator><name>length</name> <operator>&gt;</operator> <name>oend</name><operator>-</operator><name>LASTLITERALS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>partialDecoding</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>length</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name><operator>-</operator><name>op</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content> <goto>goto <name>_output_error</name>;</goto></block_content></block></else></if_stmt>   <comment type="block">/* doesn't respect parsing restriction */</comment>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>length</name> <operator>&lt;=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>lowPrefix</name><operator>-</operator><name>match</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                    <comment type="block">/* match fits entirely within external dictionary : just copy */</comment>
                    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>dictEnd</name> <operator>-</operator> <operator>(</operator><name>lowPrefix</name><operator>-</operator><name>match</name><operator>)</operator></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <comment type="block">/* match stretches into both external dictionary and current block */</comment>
                    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>copySize</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>lowPrefix</name> <operator>-</operator> <name>match</name><operator>)</operator></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>restSize</name> <init>= <expr><name>length</name> <operator>-</operator> <name>copySize</name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>dictEnd</name> <operator>-</operator> <name>copySize</name></expr></argument>, <argument><expr><name>copySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>copySize</name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>restSize</name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>op</name> <operator>-</operator> <name>lowPrefix</name><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* overlap copy */</comment>
                        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>endOfMatch</name> <init>= <expr><name>op</name> <operator>+</operator> <name>restSize</name></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>copyFrom</name> <init>= <expr><name>lowPrefix</name></expr></init></decl>;</decl_stmt>
                        <while>while <condition>(<expr><name>op</name> <operator>&lt;</operator> <name>endOfMatch</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>op</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>copyFrom</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
                    </block_content>}</block></if> <else>else <block>{<block_content>
                        <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>lowPrefix</name></expr></argument>, <argument><expr><name>restSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>restSize</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>   </block_content>}</block></else></if_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>match</name> <operator>&gt;=</operator> <name>lowPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* copy match within block */</comment>
            <expr_stmt><expr><name>cpy</name> <operator>=</operator> <name>op</name> <operator>+</operator> <name>length</name></expr>;</expr_stmt>

            <comment type="block">/* partialDecoding : may end anywhere within the block */</comment>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name><operator>&lt;=</operator><name>oend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>partialDecoding</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>cpy</name> <operator>&gt;</operator> <name>oend</name><operator>-</operator><name>MATCH_SAFEGUARD_DISTANCE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>mlen</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name>length</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name><operator>-</operator><name>op</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>matchEnd</name> <init>= <expr><name>match</name> <operator>+</operator> <name>mlen</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>copyEnd</name> <init>= <expr><name>op</name> <operator>+</operator> <name>mlen</name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>matchEnd</name> <operator>&gt;</operator> <name>op</name></expr>)</condition> <block>{<block_content>   <comment type="block">/* overlap copy */</comment>
                    <while>while <condition>(<expr><name>op</name> <operator>&lt;</operator> <name>copyEnd</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><operator>*</operator><name>op</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>match</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name>mlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <expr_stmt><expr><name>op</name> <operator>=</operator> <name>copyEnd</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>oend</name></expr>)</condition> <block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>offset</name><operator>&lt;</operator><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>LZ4_write32</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* silence msan warning when offset==0 */</comment>
                <expr_stmt><expr><name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>match</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>op</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>match</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>op</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>match</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>op</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>match</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>match</name> <operator>+=</operator> <name><name>inc32table</name><index>[<expr><name>offset</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><name>op</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>match</name> <operator>-=</operator> <name><name>dec64table</name><index>[<expr><name>offset</name></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>match</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name>op</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>cpy</name> <operator>&gt;</operator> <name>oend</name><operator>-</operator><name>MATCH_SAFEGUARD_DISTANCE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oCopyLimit</name> <init>= <expr><name>oend</name> <operator>-</operator> <operator>(</operator><name>WILDCOPYLENGTH</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>cpy</name> <operator>&gt;</operator> <name>oend</name><operator>-</operator><name>LASTLITERALS</name></expr>)</condition> <block>{<block_content> <goto>goto <name>_output_error</name>;</goto> </block_content>}</block></if></if_stmt> <comment type="block">/* Error : last LASTLITERALS bytes must be literals (uncompressed) */</comment>
                <if_stmt><if>if <condition>(<expr><name>op</name> <operator>&lt;</operator> <name>oCopyLimit</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>LZ4_wildCopy8</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name>oCopyLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>match</name> <operator>+=</operator> <name>oCopyLimit</name> <operator>-</operator> <name>op</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>op</name> <operator>=</operator> <name>oCopyLimit</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <while>while <condition>(<expr><name>op</name> <operator>&lt;</operator> <name>cpy</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><operator>*</operator><name>op</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>match</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>LZ4_memcpy</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>length</name> <operator>&gt;</operator> <literal type="number">16</literal></expr>)</condition>  <block>{<block_content> <expr_stmt><expr><call><name>LZ4_wildCopy8</name><argument_list>(<argument><expr><name>op</name><operator>+</operator><literal type="number">8</literal></expr></argument>, <argument><expr><name>match</name><operator>+</operator><literal type="number">8</literal></expr></argument>, <argument><expr><name>cpy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name>op</name> <operator>=</operator> <name>cpy</name></expr>;</expr_stmt>   <comment type="block">/* wildcopy correction */</comment>
        </block_content>}</block></while>

        <comment type="block">/* end of decoding */</comment>
        <if_stmt><if>if <condition>(<expr><name>endOnInput</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"decoded %i bytes"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>op</name><operator>)</operator><operator>-</operator><name>dst</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
           <return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>op</name><operator>)</operator><operator>-</operator><name>dst</name><operator>)</operator></expr>;</return>     <comment type="block">/* Nb of output bytes decoded */</comment>
       </block_content>}</block></if> <else>else <block>{<block_content>
           <return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>ip</name><operator>)</operator><operator>-</operator><name>src</name><operator>)</operator></expr>;</return>   <comment type="block">/* Nb of input bytes read */</comment>
       </block_content>}</block></else></if_stmt>

        <comment type="block">/* Overflow error detected */</comment>
    <label><name>_output_error</name>:</label>
        <return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><operator>-</operator><operator>(</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>ip</name><operator>)</operator><operator>-</operator><name>src</name><operator>)</operator><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*===== Instantiate the API decoding functions. =====*/</comment>

<function><type><name>LZ4_FORCE_O2</name>
<name>int</name></type> <name>LZ4_decompress_safe</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compressedSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxDecompressedSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>LZ4_decompress_generic</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>compressedSize</name></expr></argument>, <argument><expr><name>maxDecompressedSize</name></expr></argument>,
                                  <argument><expr><name>endOnInputSize</name></expr></argument>, <argument><expr><name>decode_full_block</name></expr></argument>, <argument><expr><name>noDict</name></expr></argument>,
                                  <argument><expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>LZ4_FORCE_O2</name>
<name>int</name></type> <name>LZ4_decompress_safe_partial</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compressedSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targetOutputSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dstCapacity</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>dstCapacity</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>targetOutputSize</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>LZ4_decompress_generic</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>compressedSize</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>,
                                  <argument><expr><name>endOnInputSize</name></expr></argument>, <argument><expr><name>partial_decode</name></expr></argument>,
                                  <argument><expr><name>noDict</name></expr></argument>, <argument><expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>LZ4_FORCE_O2</name>
<name>int</name></type> <name>LZ4_decompress_fast</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>originalSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>LZ4_decompress_generic</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>originalSize</name></expr></argument>,
                                  <argument><expr><name>endOnOutputSize</name></expr></argument>, <argument><expr><name>decode_full_block</name></expr></argument>, <argument><expr><name>withPrefix64k</name></expr></argument>,
                                  <argument><expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dest</name> <operator>-</operator> <literal type="number">64</literal> <name>KB</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*===== Instantiate a few more decoding cases, used more than once. =====*/</comment>

<function><type><name>LZ4_FORCE_O2</name> <comment type="block">/* Exported, an obsolete API function. */</comment>
<name>int</name></type> <name>LZ4_decompress_safe_withPrefix64k</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compressedSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxOutputSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>LZ4_decompress_generic</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>compressedSize</name></expr></argument>, <argument><expr><name>maxOutputSize</name></expr></argument>,
                                  <argument><expr><name>endOnInputSize</name></expr></argument>, <argument><expr><name>decode_full_block</name></expr></argument>, <argument><expr><name>withPrefix64k</name></expr></argument>,
                                  <argument><expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dest</name> <operator>-</operator> <literal type="number">64</literal> <name>KB</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Another obsolete API function, paired with the previous one. */</comment>
<function><type><name>int</name></type> <name>LZ4_decompress_fast_withPrefix64k</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>originalSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* LZ4_decompress_fast doesn't validate match offsets,
     * and thus serves well with any prefixed dictionary. */</comment>
    <return>return <expr><call><name>LZ4_decompress_fast</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>originalSize</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>LZ4_FORCE_O2</name>
<specifier>static</specifier> <name>int</name></type> <name>LZ4_decompress_safe_withSmallPrefix</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compressedSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxOutputSize</name></decl></parameter>,
                                               <parameter><decl><type><name>size_t</name></type> <name>prefixSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>LZ4_decompress_generic</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>compressedSize</name></expr></argument>, <argument><expr><name>maxOutputSize</name></expr></argument>,
                                  <argument><expr><name>endOnInputSize</name></expr></argument>, <argument><expr><name>decode_full_block</name></expr></argument>, <argument><expr><name>noDict</name></expr></argument>,
                                  <argument><expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dest</name><operator>-</operator><name>prefixSize</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>LZ4_FORCE_O2</name>
<name>int</name></type> <name>LZ4_decompress_safe_forceExtDict</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dest</name></decl></parameter>,
                                     <parameter><decl><type><name>int</name></type> <name>compressedSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxOutputSize</name></decl></parameter>,
                                     <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dictStart</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>LZ4_decompress_generic</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>compressedSize</name></expr></argument>, <argument><expr><name>maxOutputSize</name></expr></argument>,
                                  <argument><expr><name>endOnInputSize</name></expr></argument>, <argument><expr><name>decode_full_block</name></expr></argument>, <argument><expr><name>usingExtDict</name></expr></argument>,
                                  <argument><expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dest</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>dictStart</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>LZ4_FORCE_O2</name>
<specifier>static</specifier> <name>int</name></type> <name>LZ4_decompress_fast_extDict</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>originalSize</name></decl></parameter>,
                                       <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dictStart</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>LZ4_decompress_generic</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>originalSize</name></expr></argument>,
                                  <argument><expr><name>endOnOutputSize</name></expr></argument>, <argument><expr><name>decode_full_block</name></expr></argument>, <argument><expr><name>usingExtDict</name></expr></argument>,
                                  <argument><expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dest</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>dictStart</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* The "double dictionary" mode, for use with e.g. ring buffers: the first part
 * of the dictionary is passed as prefix, and the second via dictStart + dictSize.
 * These routines are used only once, in LZ4_decompress_*_continue().
 */</comment>
<function><type><name>LZ4_FORCE_INLINE</name>
<name>int</name></type> <name>LZ4_decompress_safe_doubleDict</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compressedSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxOutputSize</name></decl></parameter>,
                                   <parameter><decl><type><name>size_t</name></type> <name>prefixSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dictStart</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>LZ4_decompress_generic</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>compressedSize</name></expr></argument>, <argument><expr><name>maxOutputSize</name></expr></argument>,
                                  <argument><expr><name>endOnInputSize</name></expr></argument>, <argument><expr><name>decode_full_block</name></expr></argument>, <argument><expr><name>usingExtDict</name></expr></argument>,
                                  <argument><expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dest</name><operator>-</operator><name>prefixSize</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>dictStart</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>LZ4_FORCE_INLINE</name>
<name>int</name></type> <name>LZ4_decompress_fast_doubleDict</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>originalSize</name></decl></parameter>,
                                   <parameter><decl><type><name>size_t</name></type> <name>prefixSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dictStart</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>LZ4_decompress_generic</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>originalSize</name></expr></argument>,
                                  <argument><expr><name>endOnOutputSize</name></expr></argument>, <argument><expr><name>decode_full_block</name></expr></argument>, <argument><expr><name>usingExtDict</name></expr></argument>,
                                  <argument><expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dest</name><operator>-</operator><name>prefixSize</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>dictStart</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*===== streaming decompression functions =====*/</comment>

<function><type><name>LZ4_streamDecode_t</name><modifier>*</modifier></type> <name>LZ4_createStreamDecode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LZ4_streamDecode_t</name><modifier>*</modifier></type> <name>lz4s</name> <init>= <expr><operator>(</operator><name>LZ4_streamDecode_t</name><operator>*</operator><operator>)</operator> <call><name>ALLOC_AND_ZERO</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LZ4_streamDecode_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>LZ4_STATIC_ASSERT</name><argument_list>(<argument><expr><name>LZ4_STREAMDECODESIZE</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LZ4_streamDecode_t_internal</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* A compilation error here means LZ4_STREAMDECODESIZE is not large enough */</comment>
    <return>return <expr><name>lz4s</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>LZ4_freeStreamDecode</name> <parameter_list>(<parameter><decl><type><name>LZ4_streamDecode_t</name><modifier>*</modifier></type> <name>LZ4_stream</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>LZ4_stream</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content> <return>return <expr><literal type="number">0</literal></expr>;</return> </block_content>}</block></if></if_stmt>  <comment type="block">/* support free on NULL */</comment>
    <expr_stmt><expr><call><name>FREEMEM</name><argument_list>(<argument><expr><name>LZ4_stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! LZ4_setStreamDecode() :
 *  Use this function to instruct where to find the dictionary.
 *  This function is not necessary if previous data is still available where it was decoded.
 *  Loading a size of 0 is allowed (same effect as no dictionary).
 * @return : 1 if OK, 0 if error
 */</comment>
<function><type><name>int</name></type> <name>LZ4_setStreamDecode</name> <parameter_list>(<parameter><decl><type><name>LZ4_streamDecode_t</name><modifier>*</modifier></type> <name>LZ4_streamDecode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>dictionary</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dictSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LZ4_streamDecode_t_internal</name><modifier>*</modifier></type> <name>lz4sd</name> <init>= <expr><operator>&amp;</operator><name><name>LZ4_streamDecode</name><operator>-&gt;</operator><name>internal_donotuse</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>lz4sd</name><operator>-&gt;</operator><name>prefixSize</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>dictSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lz4sd</name><operator>-&gt;</operator><name>prefixEnd</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator> <name>dictionary</name> <operator>+</operator> <name>dictSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lz4sd</name><operator>-&gt;</operator><name>externalDict</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lz4sd</name><operator>-&gt;</operator><name>extDictSize</name></name>  <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! LZ4_decoderRingBufferSize() :
 *  when setting a ring buffer for streaming decompression (optional scenario),
 *  provides the minimum size of this ring buffer
 *  to be compatible with any source respecting maxBlockSize condition.
 *  Note : in a ring buffer scenario,
 *  blocks are presumed decompressed next to each other.
 *  When not enough space remains for next block (remainingSize &lt; maxBlockSize),
 *  decoding resumes from beginning of ring buffer.
 * @return : minimum ring buffer size,
 *           or 0 if there is an error (invalid maxBlockSize).
 */</comment>
<function><type><name>int</name></type> <name>LZ4_decoderRingBufferSize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>maxBlockSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>maxBlockSize</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>maxBlockSize</name> <operator>&gt;</operator> <name>LZ4_MAX_INPUT_SIZE</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>maxBlockSize</name> <operator>&lt;</operator> <literal type="number">16</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>maxBlockSize</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><call><name>LZ4_DECODER_RING_BUFFER_SIZE</name><argument_list>(<argument><expr><name>maxBlockSize</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
*_continue() :
    These decoding functions allow decompression of multiple blocks in "streaming" mode.
    Previously decoded blocks must still be available at the memory position where they were decoded.
    If it's not possible, save the relevant part of decoded data into a safe buffer,
    and indicate where it stands using LZ4_setStreamDecode()
*/</comment>
<function><type><name>LZ4_FORCE_O2</name>
<name>int</name></type> <name>LZ4_decompress_safe_continue</name> <parameter_list>(<parameter><decl><type><name>LZ4_streamDecode_t</name><modifier>*</modifier></type> <name>LZ4_streamDecode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compressedSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxOutputSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LZ4_streamDecode_t_internal</name><modifier>*</modifier></type> <name>lz4sd</name> <init>= <expr><operator>&amp;</operator><name><name>LZ4_streamDecode</name><operator>-&gt;</operator><name>internal_donotuse</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>lz4sd</name><operator>-&gt;</operator><name>prefixSize</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* The first call, no dictionary yet. */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>lz4sd</name><operator>-&gt;</operator><name>extDictSize</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>LZ4_decompress_safe</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>compressedSize</name></expr></argument>, <argument><expr><name>maxOutputSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>lz4sd</name><operator>-&gt;</operator><name>prefixSize</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>result</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lz4sd</name><operator>-&gt;</operator><name>prefixEnd</name></name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dest</name> <operator>+</operator> <name>result</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>lz4sd</name><operator>-&gt;</operator><name>prefixEnd</name></name> <operator>==</operator> <operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dest</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* They're rolling the current segment. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>lz4sd</name><operator>-&gt;</operator><name>prefixSize</name></name> <operator>&gt;=</operator> <literal type="number">64</literal> <name>KB</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>LZ4_decompress_safe_withPrefix64k</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>compressedSize</name></expr></argument>, <argument><expr><name>maxOutputSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>lz4sd</name><operator>-&gt;</operator><name>extDictSize</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>LZ4_decompress_safe_withSmallPrefix</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>compressedSize</name></expr></argument>, <argument><expr><name>maxOutputSize</name></expr></argument>,
                                                         <argument><expr><name><name>lz4sd</name><operator>-&gt;</operator><name>prefixSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>LZ4_decompress_safe_doubleDict</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>compressedSize</name></expr></argument>, <argument><expr><name>maxOutputSize</name></expr></argument>,
                                                    <argument><expr><name><name>lz4sd</name><operator>-&gt;</operator><name>prefixSize</name></name></expr></argument>, <argument><expr><name><name>lz4sd</name><operator>-&gt;</operator><name>externalDict</name></name></expr></argument>, <argument><expr><name><name>lz4sd</name><operator>-&gt;</operator><name>extDictSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>lz4sd</name><operator>-&gt;</operator><name>prefixSize</name></name> <operator>+=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>result</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lz4sd</name><operator>-&gt;</operator><name>prefixEnd</name></name>  <operator>+=</operator> <name>result</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* The buffer wraps around, or they're switching to another buffer. */</comment>
        <expr_stmt><expr><name><name>lz4sd</name><operator>-&gt;</operator><name>extDictSize</name></name> <operator>=</operator> <name><name>lz4sd</name><operator>-&gt;</operator><name>prefixSize</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lz4sd</name><operator>-&gt;</operator><name>externalDict</name></name> <operator>=</operator> <name><name>lz4sd</name><operator>-&gt;</operator><name>prefixEnd</name></name> <operator>-</operator> <name><name>lz4sd</name><operator>-&gt;</operator><name>extDictSize</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>LZ4_decompress_safe_forceExtDict</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>compressedSize</name></expr></argument>, <argument><expr><name>maxOutputSize</name></expr></argument>,
                                                  <argument><expr><name><name>lz4sd</name><operator>-&gt;</operator><name>externalDict</name></name></expr></argument>, <argument><expr><name><name>lz4sd</name><operator>-&gt;</operator><name>extDictSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>lz4sd</name><operator>-&gt;</operator><name>prefixSize</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>result</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lz4sd</name><operator>-&gt;</operator><name>prefixEnd</name></name>  <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dest</name> <operator>+</operator> <name>result</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>LZ4_FORCE_O2</name>
<name>int</name></type> <name>LZ4_decompress_fast_continue</name> <parameter_list>(<parameter><decl><type><name>LZ4_streamDecode_t</name><modifier>*</modifier></type> <name>LZ4_streamDecode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>originalSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LZ4_streamDecode_t_internal</name><modifier>*</modifier></type> <name>lz4sd</name> <init>= <expr><operator>&amp;</operator><name><name>LZ4_streamDecode</name><operator>-&gt;</operator><name>internal_donotuse</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>originalSize</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>lz4sd</name><operator>-&gt;</operator><name>prefixSize</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>lz4sd</name><operator>-&gt;</operator><name>extDictSize</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>LZ4_decompress_fast</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>originalSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>lz4sd</name><operator>-&gt;</operator><name>prefixSize</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>originalSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lz4sd</name><operator>-&gt;</operator><name>prefixEnd</name></name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dest</name> <operator>+</operator> <name>originalSize</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>lz4sd</name><operator>-&gt;</operator><name>prefixEnd</name></name> <operator>==</operator> <operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dest</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>lz4sd</name><operator>-&gt;</operator><name>prefixSize</name></name> <operator>&gt;=</operator> <literal type="number">64</literal> <name>KB</name> <operator>-</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>lz4sd</name><operator>-&gt;</operator><name>extDictSize</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>LZ4_decompress_fast</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>originalSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>LZ4_decompress_fast_doubleDict</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>originalSize</name></expr></argument>,
                                                    <argument><expr><name><name>lz4sd</name><operator>-&gt;</operator><name>prefixSize</name></name></expr></argument>, <argument><expr><name><name>lz4sd</name><operator>-&gt;</operator><name>externalDict</name></name></expr></argument>, <argument><expr><name><name>lz4sd</name><operator>-&gt;</operator><name>extDictSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>lz4sd</name><operator>-&gt;</operator><name>prefixSize</name></name> <operator>+=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>originalSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lz4sd</name><operator>-&gt;</operator><name>prefixEnd</name></name>  <operator>+=</operator> <name>originalSize</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>lz4sd</name><operator>-&gt;</operator><name>extDictSize</name></name> <operator>=</operator> <name><name>lz4sd</name><operator>-&gt;</operator><name>prefixSize</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lz4sd</name><operator>-&gt;</operator><name>externalDict</name></name> <operator>=</operator> <name><name>lz4sd</name><operator>-&gt;</operator><name>prefixEnd</name></name> <operator>-</operator> <name><name>lz4sd</name><operator>-&gt;</operator><name>extDictSize</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>LZ4_decompress_fast_extDict</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>originalSize</name></expr></argument>,
                                             <argument><expr><name><name>lz4sd</name><operator>-&gt;</operator><name>externalDict</name></name></expr></argument>, <argument><expr><name><name>lz4sd</name><operator>-&gt;</operator><name>extDictSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>lz4sd</name><operator>-&gt;</operator><name>prefixSize</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>originalSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lz4sd</name><operator>-&gt;</operator><name>prefixEnd</name></name>  <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dest</name> <operator>+</operator> <name>originalSize</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
Advanced decoding functions :
*_usingDict() :
    These decoding functions work the same as "_continue" ones,
    the dictionary must be explicitly provided within parameters
*/</comment>

<function><type><name>int</name></type> <name>LZ4_decompress_safe_usingDict</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compressedSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxOutputSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>dictStart</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dictSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>dictSize</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>LZ4_decompress_safe</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>compressedSize</name></expr></argument>, <argument><expr><name>maxOutputSize</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>dictStart</name><operator>+</operator><name>dictSize</name> <operator>==</operator> <name>dest</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>dictSize</name> <operator>&gt;=</operator> <literal type="number">64</literal> <name>KB</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><call><name>LZ4_decompress_safe_withPrefix64k</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>compressedSize</name></expr></argument>, <argument><expr><name>maxOutputSize</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dictSize</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>LZ4_decompress_safe_withSmallPrefix</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>compressedSize</name></expr></argument>, <argument><expr><name>maxOutputSize</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>dictSize</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dictSize</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>LZ4_decompress_safe_forceExtDict</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>compressedSize</name></expr></argument>, <argument><expr><name>maxOutputSize</name></expr></argument>, <argument><expr><name>dictStart</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>dictSize</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>LZ4_decompress_fast_usingDict</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>originalSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>dictStart</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dictSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>dictSize</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>dictStart</name><operator>+</operator><name>dictSize</name> <operator>==</operator> <name>dest</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>LZ4_decompress_fast</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>originalSize</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dictSize</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>LZ4_decompress_fast_extDict</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>originalSize</name></expr></argument>, <argument><expr><name>dictStart</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>dictSize</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*=*************************************************
*  Obsolete Functions
***************************************************/</comment>
<comment type="block">/* obsolete compression functions */</comment>
<function><type><name>int</name></type> <name>LZ4_compress_limitedOutput</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>inputSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxOutputSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>LZ4_compress_default</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>inputSize</name></expr></argument>, <argument><expr><name>maxOutputSize</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>LZ4_compress</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>LZ4_compress_default</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><call><name>LZ4_compressBound</name><argument_list>(<argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>LZ4_compress_limitedOutput_withState</name> <parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>state</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dstSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>LZ4_compress_fast_extState</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>dstSize</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>LZ4_compress_withState</name> <parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>state</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>LZ4_compress_fast_extState</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><call><name>LZ4_compressBound</name><argument_list>(<argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>LZ4_compress_limitedOutput_continue</name> <parameter_list>(<parameter><decl><type><name>LZ4_stream_t</name><modifier>*</modifier></type> <name>LZ4_stream</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dstCapacity</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>LZ4_compress_fast_continue</name><argument_list>(<argument><expr><name>LZ4_stream</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>LZ4_compress_continue</name> <parameter_list>(<parameter><decl><type><name>LZ4_stream_t</name><modifier>*</modifier></type> <name>LZ4_stream</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>inputSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>LZ4_compress_fast_continue</name><argument_list>(<argument><expr><name>LZ4_stream</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>inputSize</name></expr></argument>, <argument><expr><call><name>LZ4_compressBound</name><argument_list>(<argument><expr><name>inputSize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
These decompression functions are deprecated and should no longer be used.
They are only provided here for compatibility with older user programs.
- LZ4_uncompress is totally equivalent to LZ4_decompress_fast
- LZ4_uncompress_unknownOutputSize is totally equivalent to LZ4_decompress_safe
*/</comment>
<function><type><name>int</name></type> <name>LZ4_uncompress</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>outputSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>LZ4_decompress_fast</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>outputSize</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>LZ4_uncompress_unknownOutputSize</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxOutputSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>LZ4_decompress_safe</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>isize</name></expr></argument>, <argument><expr><name>maxOutputSize</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Obsolete Streaming functions */</comment>

<function><type><name>int</name></type> <name>LZ4_sizeofStreamState</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>LZ4_STREAMSIZE</name></expr>;</return> </block_content>}</block></function>

<function><type><name>int</name></type> <name>LZ4_resetStreamState</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>inputBuffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>inputBuffer</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LZ4_resetStream</name><argument_list>(<argument><expr><operator>(</operator><name>LZ4_stream_t</name><operator>*</operator><operator>)</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>LZ4_create</name> <parameter_list>(<parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>inputBuffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>inputBuffer</name></expr>;</expr_stmt>
    <return>return <expr><call><name>LZ4_createStream</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name><modifier>*</modifier></type> <name>LZ4_slideInputBuffer</name> <parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* avoid const char * -&gt; char * conversion warning */</comment>
    <return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>uptrval</name><operator>)</operator><operator>(</operator><operator>(</operator><name>LZ4_stream_t</name><operator>*</operator><operator>)</operator><name>state</name><operator>)</operator><operator>-&gt;</operator><name><name>internal_donotuse</name><operator>.</operator><name>dictionary</name></name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>   <comment type="block">/* LZ4_COMMONDEFS_ONLY */</comment>
</unit>
