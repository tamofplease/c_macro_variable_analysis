<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/lz4/lz4hc.c"><comment type="block">/*
    LZ4 HC - High Compression Mode of LZ4
    Copyright (C) 2011-2017, Yann Collet.

    BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are
    met:

    * Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

    You can contact the author at :
       - LZ4 source repository : https://github.com/lz4/lz4
       - LZ4 public forum : https://groups.google.com/forum/#!forum/lz4c
*/</comment>
<comment type="block">/* note : lz4hc is not an independent module, it requires lz4.h/lz4.c for proper compilation */</comment>


<comment type="block">/* *************************************
*  Tuning Parameter
***************************************/</comment>

<comment type="block" format="doxygen">/*! HEAPMODE :
 *  Select how default compression function will allocate workplace memory,
 *  in stack (0:fastest), or in heap (1:requires malloc()).
 *  Since workplace is rather large, heap mode is recommended.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LZ4HC_HEAPMODE</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>LZ4HC_HEAPMODE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*===    Dependency    ===*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LZ4_HC_STATIC_LINKING_ONLY</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lz4hc.h"</cpp:file></cpp:include>


<comment type="block">/*===   Common definitions   ===*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#  <cpp:directive>pragma</cpp:directive> <name>GCC</name> <name>diagnostic</name> <name>ignored</name> <cpp:literal>"-Wunused-function"</cpp:literal></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#  <cpp:directive>pragma</cpp:directive> <name>clang</name> <name>diagnostic</name> <name>ignored</name> <cpp:literal>"-Wunused-function"</cpp:literal></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LZ4_COMMONDEFS_ONLY</name></cpp:macro></cpp:define>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LZ4_SRC_INCLUDED</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lz4.c"</cpp:file></cpp:include>   <comment type="block">/* LZ4_count, constants, mem */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*===   Enums   ===*/</comment>
<typedef>typedef <type><enum>enum <block>{ <decl><name>noDictCtx</name></decl>, <decl><name>usingDictCtxHc</name></decl> }</block></enum></type> <name>dictCtx_directive</name>;</typedef>


<comment type="block">/*===   Constants   ===*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPTIMAL_ML</name></cpp:macro> <cpp:value>(int)((ML_MASK-1)+MINMATCH)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LZ4_OPT_NUM</name></cpp:macro>   <cpp:value>(1&lt;&lt;12)</cpp:value></cpp:define>


<comment type="block">/*===   Macros   ===*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>   <cpp:value>( (a) &lt; (b) ? (a) : (b) )</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>   <cpp:value>( (a) &gt; (b) ? (a) : (b) )</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_FUNCTION</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>         <cpp:value>(((i) * 2654435761U) &gt;&gt; ((MINMATCH*8)-LZ4HC_HASH_LOG))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DELTANEXTMAXD</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro>         <cpp:value>chainTable[(p) &amp; LZ4HC_MAXD_MASK]</cpp:value></cpp:define>    <comment type="block">/* flexible, LZ4HC_MAXD dependent */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DELTANEXTU16</name><parameter_list>(<parameter><type><name>table</name></type></parameter>, <parameter><type><name>pos</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>table[(U16)(pos)]</cpp:value></cpp:define>   <comment type="block">/* faster */</comment>
<comment type="block">/* Make fields passed to, and updated by LZ4HC_encodeSequence explicit */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UPDATABLE</name><parameter_list>(<parameter><type><name>ip</name></type></parameter>, <parameter><type><name>op</name></type></parameter>, <parameter><type><name>anchor</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>&amp;ip, &amp;op, &amp;anchor</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>U32</name></type> <name>LZ4HC_hashPtr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>HASH_FUNCTION</name><argument_list>(<argument><expr><call><name>LZ4_read32</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>


<comment type="block" format="doxygen">/**************************************
*  HC Compression
**************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>LZ4HC_clearTables</name> <parameter_list>(<parameter><decl><type><name>LZ4HC_CCtx_internal</name><modifier>*</modifier></type> <name>hc4</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>MEM_INIT</name><argument_list>(<argument><expr><name><name>hc4</name><operator>-&gt;</operator><name>hashTable</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>hc4</name><operator>-&gt;</operator><name>hashTable</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MEM_INIT</name><argument_list>(<argument><expr><name><name>hc4</name><operator>-&gt;</operator><name>chainTable</name></name></expr></argument>, <argument><expr><literal type="number">0xFF</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>hc4</name><operator>-&gt;</operator><name>chainTable</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>LZ4HC_init_internal</name> <parameter_list>(<parameter><decl><type><name>LZ4HC_CCtx_internal</name><modifier>*</modifier></type> <name>hc4</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>start</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uptrval</name></type> <name>startingOffset</name> <init>= <expr><operator>(</operator><name>uptrval</name><operator>)</operator><operator>(</operator><name><name>hc4</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>hc4</name><operator>-&gt;</operator><name>base</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>startingOffset</name> <operator>&gt;</operator> <literal type="number">1</literal> <name>GB</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>LZ4HC_clearTables</name><argument_list>(<argument><expr><name>hc4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>startingOffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>startingOffset</name> <operator>+=</operator> <literal type="number">64</literal> <name>KB</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hc4</name><operator>-&gt;</operator><name>nextToUpdate</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator> <name>startingOffset</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hc4</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name>start</name> <operator>-</operator> <name>startingOffset</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hc4</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hc4</name><operator>-&gt;</operator><name>dictBase</name></name> <operator>=</operator> <name>start</name> <operator>-</operator> <name>startingOffset</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hc4</name><operator>-&gt;</operator><name>dictLimit</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator> <name>startingOffset</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hc4</name><operator>-&gt;</operator><name>lowLimit</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator> <name>startingOffset</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Update chains up to ip (excluded) */</comment>
<function><type><name>LZ4_FORCE_INLINE</name> <name>void</name></type> <name>LZ4HC_Insert</name> <parameter_list>(<parameter><decl><type><name>LZ4HC_CCtx_internal</name><modifier>*</modifier></type> <name>hc4</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U16</name><modifier>*</modifier> <specifier>const</specifier></type> <name>chainTable</name> <init>= <expr><name><name>hc4</name><operator>-&gt;</operator><name>chainTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>hashTable</name>  <init>= <expr><name><name>hc4</name><operator>-&gt;</operator><name>hashTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>base</name> <init>= <expr><name><name>hc4</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>target</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>idx</name> <init>= <expr><name><name>hc4</name><operator>-&gt;</operator><name>nextToUpdate</name></name></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>idx</name> <operator>&lt;</operator> <name>target</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>h</name> <init>= <expr><call><name>LZ4HC_hashPtr</name><argument_list>(<argument><expr><name>base</name><operator>+</operator><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>delta</name> <init>= <expr><name>idx</name> <operator>-</operator> <name><name>hashTable</name><index>[<expr><name>h</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>delta</name><operator>&gt;</operator><name>LZ4_DISTANCE_MAX</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>delta</name> <operator>=</operator> <name>LZ4_DISTANCE_MAX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>DELTANEXTU16</name><argument_list>(<argument><expr><name>chainTable</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call> <operator>=</operator> <operator>(</operator><name>U16</name><operator>)</operator><name>delta</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hashTable</name><index>[<expr><name>h</name></expr>]</index></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><name><name>hc4</name><operator>-&gt;</operator><name>nextToUpdate</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** LZ4HC_countBack() :
 * @return : negative value, nb of common bytes before ip/match */</comment>
<function><type><name>LZ4_FORCE_INLINE</name>
<name>int</name></type> <name>LZ4HC_countBack</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ip</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>match</name></decl></parameter>,
                    <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iMin</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>mMin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>back</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>min</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>MAX</name><argument_list>(<argument><expr><name>iMin</name> <operator>-</operator> <name>ip</name></expr></argument>, <argument><expr><name>mMin</name> <operator>-</operator> <name>match</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>min</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ip</name> <operator>&gt;=</operator> <name>iMin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>iMin</name><operator>)</operator> <operator>&lt;</operator> <operator>(</operator><literal type="number">1U</literal><operator>&lt;&lt;</operator><literal type="number">31</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>match</name> <operator>&gt;=</operator> <name>mMin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>match</name> <operator>-</operator> <name>mMin</name><operator>)</operator> <operator>&lt;</operator> <operator>(</operator><literal type="number">1U</literal><operator>&lt;&lt;</operator><literal type="number">31</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>( <expr><operator>(</operator><name>back</name> <operator>&gt;</operator> <name>min</name><operator>)</operator>
         <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ip</name><index>[<expr><name>back</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>match</name><index>[<expr><name>back</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>back</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
    <return>return <expr><name>back</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>LZ4HC_rotl32</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_rotl(x,r)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>LZ4HC_rotl32</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x &lt;&lt; r) | (x &gt;&gt; (32 - r)))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function><type><specifier>static</specifier> <name>U32</name></type> <name>LZ4HC_rotatePattern</name><parameter_list>(<parameter><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>rotate</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>pattern</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>bitsToRotate</name> <init>= <expr><operator>(</operator><name>rotate</name> <operator>&amp;</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>bitsToRotate</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>pattern</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>LZ4HC_rotl32</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>bitsToRotate</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* LZ4HC_countPattern() :
 * pattern32 must be a sample of repetitive pattern of length 1, 2 or 4 (but not 3!) */</comment>
<function><type><specifier>static</specifier> <name>unsigned</name></type>
<name>LZ4HC_countPattern</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iEnd</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>pattern32</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iStart</name> <init>= <expr><name>ip</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>reg_t</name> <specifier>const</specifier></type> <name>pattern</name> <init>= <expr><ternary><condition><expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">8</literal><operator>)</operator></expr> ?</condition><then>
        <expr><operator>(</operator><name>reg_t</name><operator>)</operator><name>pattern32</name> <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>reg_t</name><operator>)</operator><name>pattern32</name><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">4</literal><operator>)</operator><operator>)</operator></expr> </then><else>: <expr><name>pattern32</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><name>ip</name> <operator>&lt;</operator> <name>iEnd</name><operator>-</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>reg_t</name> <specifier>const</specifier></type> <name>diff</name> <init>= <expr><call><name>LZ4_read_ARCH</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call> <operator>^</operator> <name>pattern</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>diff</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>ip</name><operator>+=</operator><sizeof>sizeof<argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt> <continue>continue;</continue> </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>ip</name> <operator>+=</operator> <call><name>LZ4_NbCommonBytes</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>iStart</name><operator>)</operator></expr>;</return>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><call><name>LZ4_isLittleEndian</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>reg_t</name></type> <name>patternByte</name> <init>= <expr><name>pattern</name></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>ip</name><operator>&lt;</operator><name>iEnd</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>ip</name> <operator>==</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><name>patternByte</name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>ip</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>patternByte</name> <operator>&gt;&gt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* big endian */</comment>
        <decl_stmt><decl><type><name>U32</name></type> <name>bitOffset</name> <init>= <expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">8</literal><operator>)</operator> <operator>-</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>ip</name> <operator>&lt;</operator> <name>iEnd</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier></type> <name>byte</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>)</operator><operator>(</operator><name>pattern</name> <operator>&gt;&gt;</operator> <name>bitOffset</name><operator>)</operator></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ip</name> <operator>!=</operator> <name>byte</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>ip</name> <operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>bitOffset</name> <operator>-=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>iStart</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* LZ4HC_reverseCountPattern() :
 * pattern must be a sample of repetitive pattern of length 1, 2 or 4 (but not 3!)
 * read using natural platform endianess */</comment>
<function><type><specifier>static</specifier> <name>unsigned</name></type>
<name>LZ4HC_reverseCountPattern</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iLow</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>pattern</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iStart</name> <init>= <expr><name>ip</name></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><name>ip</name> <operator>&gt;=</operator> <name>iLow</name><operator>+</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>LZ4_read32</name><argument_list>(<argument><expr><name>ip</name><operator>-</operator><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>pattern</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>ip</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
    <block>{<block_content>   <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>bytePtr</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name>pattern</name><operator>)</operator> <operator>+</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* works for any endianess */</comment>
        <while>while <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><name>ip</name><operator>&gt;</operator><name>iLow</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>ip</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <operator>*</operator><name>bytePtr</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>ip</name><operator>--</operator></expr>;</expr_stmt> <expr_stmt><expr><name>bytePtr</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>   </block_content>}</block>
    <return>return <expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name>iStart</name> <operator>-</operator> <name>ip</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* LZ4HC_protectDictEnd() :
 * Checks if the match is in the last 3 bytes of the dictionary, so reading the
 * 4 byte MINMATCH would overflow.
 * @returns true if the match index is okay.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>LZ4HC_protectDictEnd</name><parameter_list>(<parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>dictLimit</name></decl></parameter>, <parameter><decl><type><name>U32</name> <specifier>const</specifier></type> <name>matchIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>dictLimit</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name>matchIndex</name><operator>)</operator> <operator>&gt;=</operator> <literal type="number">3</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><enum>enum <block>{ <decl><name>rep_untested</name></decl>, <decl><name>rep_not</name></decl>, <decl><name>rep_confirmed</name></decl> }</block></enum></type> <name>repeat_state_e</name>;</typedef>
<typedef>typedef <type><enum>enum <block>{ <decl><name>favorCompressionRatio</name><init>=<expr><literal type="number">0</literal></expr></init></decl>, <decl><name>favorDecompressionSpeed</name></decl> }</block></enum></type> <name>HCfavor_e</name>;</typedef>

<function><type><name>LZ4_FORCE_INLINE</name> <name>int</name></type>
<name>LZ4HC_InsertAndGetWiderMatch</name> <parameter_list>(
    <parameter><decl><type><name>LZ4HC_CCtx_internal</name><modifier>*</modifier></type> <name>hc4</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ip</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iLowLimit</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iHighLimit</name></decl></parameter>,
    <parameter><decl><type><name>int</name></type> <name>longest</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier><modifier>*</modifier></type> <name>matchpos</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier><modifier>*</modifier></type> <name>startpos</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>maxNbAttempts</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>patternAnalysis</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>chainSwap</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>dictCtx_directive</name></type> <name>dict</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>HCfavor_e</name></type> <name>favorDecSpeed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>U16</name><modifier>*</modifier> <specifier>const</specifier></type> <name>chainTable</name> <init>= <expr><name><name>hc4</name><operator>-&gt;</operator><name>chainTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name><modifier>*</modifier> <specifier>const</specifier></type> <name>HashTable</name> <init>= <expr><name><name>hc4</name><operator>-&gt;</operator><name>hashTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>LZ4HC_CCtx_internal</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>dictCtx</name> <init>= <expr><name><name>hc4</name><operator>-&gt;</operator><name>dictCtx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>base</name> <init>= <expr><name><name>hc4</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>dictLimit</name> <init>= <expr><name><name>hc4</name><operator>-&gt;</operator><name>dictLimit</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>lowPrefixPtr</name> <init>= <expr><name>base</name> <operator>+</operator> <name>dictLimit</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>ipIndex</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>U32</name></type> <name>lowestMatchIndex</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>hc4</name><operator>-&gt;</operator><name>lowLimit</name></name> <operator>+</operator> <operator>(</operator><name>LZ4_DISTANCE_MAX</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;</operator> <name>ipIndex</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>hc4</name><operator>-&gt;</operator><name>lowLimit</name></name></expr> </then><else>: <expr><name>ipIndex</name> <operator>-</operator> <name>LZ4_DISTANCE_MAX</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictBase</name> <init>= <expr><name><name>hc4</name><operator>-&gt;</operator><name>dictBase</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>lookBackLength</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>iLowLimit</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nbAttempts</name> <init>= <expr><name>maxNbAttempts</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>matchChainPos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>pattern</name> <init>= <expr><call><name>LZ4_read32</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>matchIndex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>repeat_state_e</name></type> <name>repeat</name> <init>= <expr><name>rep_untested</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>srcPatternLength</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"LZ4HC_InsertAndGetWiderMatch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* First Match */</comment>
    <expr_stmt><expr><call><name>LZ4HC_Insert</name><argument_list>(<argument><expr><name>hc4</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>matchIndex</name> <operator>=</operator> <name><name>HashTable</name><index>[<expr><call><name>LZ4HC_hashPtr</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"First match at index %u / %u (lowestMatchIndex)"</literal></expr></argument>,
                <argument><expr><name>matchIndex</name></expr></argument>, <argument><expr><name>lowestMatchIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>matchIndex</name><operator>&gt;=</operator><name>lowestMatchIndex</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>nbAttempts</name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>matchLength</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>nbAttempts</name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>matchIndex</name> <operator>&lt;</operator> <name>ipIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>favorDecSpeed</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>ipIndex</name> <operator>-</operator> <name>matchIndex</name> <operator>&lt;</operator> <literal type="number">8</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
            <comment type="block">/* do nothing */</comment>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>matchIndex</name> <operator>&gt;=</operator> <name>dictLimit</name></expr>)</condition> <block>{<block_content>   <comment type="block">/* within current Prefix */</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>matchPtr</name> <init>= <expr><name>base</name> <operator>+</operator> <name>matchIndex</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>matchPtr</name> <operator>&gt;=</operator> <name>lowPrefixPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>matchPtr</name> <operator>&lt;</operator> <name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>longest</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>LZ4_read16</name><argument_list>(<argument><expr><name>iLowLimit</name> <operator>+</operator> <name>longest</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>LZ4_read16</name><argument_list>(<argument><expr><name>matchPtr</name> <operator>-</operator> <name>lookBackLength</name> <operator>+</operator> <name>longest</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>LZ4_read32</name><argument_list>(<argument><expr><name>matchPtr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>pattern</name></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>back</name> <init>= <expr><ternary><condition><expr><name>lookBackLength</name></expr> ?</condition><then> <expr><call><name>LZ4HC_countBack</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>matchPtr</name></expr></argument>, <argument><expr><name>iLowLimit</name></expr></argument>, <argument><expr><name>lowPrefixPtr</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>matchLength</name> <operator>=</operator> <name>MINMATCH</name> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>LZ4_count</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><name>MINMATCH</name></expr></argument>, <argument><expr><name>matchPtr</name><operator>+</operator><name>MINMATCH</name></expr></argument>, <argument><expr><name>iHighLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>matchLength</name> <operator>-=</operator> <name>back</name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>matchLength</name> <operator>&gt;</operator> <name>longest</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>longest</name> <operator>=</operator> <name>matchLength</name></expr>;</expr_stmt>
                        <expr_stmt><expr><operator>*</operator><name>matchpos</name> <operator>=</operator> <name>matchPtr</name> <operator>+</operator> <name>back</name></expr>;</expr_stmt>
                        <expr_stmt><expr><operator>*</operator><name>startpos</name> <operator>=</operator> <name>ip</name> <operator>+</operator> <name>back</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>   </block_content>}</block></if></if_stmt>   </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>   <comment type="block">/* lowestMatchIndex &lt;= matchIndex &lt; dictLimit */</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>matchPtr</name> <init>= <expr><name>dictBase</name> <operator>+</operator> <name>matchIndex</name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>LZ4_read32</name><argument_list>(<argument><expr><name>matchPtr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>pattern</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictStart</name> <init>= <expr><name>dictBase</name> <operator>+</operator> <name><name>hc4</name><operator>-&gt;</operator><name>lowLimit</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>back</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>vLimit</name> <init>= <expr><name>ip</name> <operator>+</operator> <operator>(</operator><name>dictLimit</name> <operator>-</operator> <name>matchIndex</name><operator>)</operator></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>vLimit</name> <operator>&gt;</operator> <name>iHighLimit</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>vLimit</name> <operator>=</operator> <name>iHighLimit</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>matchLength</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>LZ4_count</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><name>MINMATCH</name></expr></argument>, <argument><expr><name>matchPtr</name><operator>+</operator><name>MINMATCH</name></expr></argument>, <argument><expr><name>vLimit</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>MINMATCH</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ip</name><operator>+</operator><name>matchLength</name> <operator>==</operator> <name>vLimit</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>vLimit</name> <operator>&lt;</operator> <name>iHighLimit</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>matchLength</name> <operator>+=</operator> <call><name>LZ4_count</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><name>matchLength</name></expr></argument>, <argument><expr><name>lowPrefixPtr</name></expr></argument>, <argument><expr><name>iHighLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>back</name> <operator>=</operator> <ternary><condition><expr><name>lookBackLength</name></expr> ?</condition><then> <expr><call><name>LZ4HC_countBack</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>matchPtr</name></expr></argument>, <argument><expr><name>iLowLimit</name></expr></argument>, <argument><expr><name>dictStart</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
                <expr_stmt><expr><name>matchLength</name> <operator>-=</operator> <name>back</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>matchLength</name> <operator>&gt;</operator> <name>longest</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>longest</name> <operator>=</operator> <name>matchLength</name></expr>;</expr_stmt>
                    <expr_stmt><expr><operator>*</operator><name>matchpos</name> <operator>=</operator> <name>base</name> <operator>+</operator> <name>matchIndex</name> <operator>+</operator> <name>back</name></expr>;</expr_stmt>   <comment type="block">/* virtual pos, relative to ip, to retrieve offset */</comment>
                    <expr_stmt><expr><operator>*</operator><name>startpos</name> <operator>=</operator> <name>ip</name> <operator>+</operator> <name>back</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>   </block_content>}</block></if></if_stmt>   </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>chainSwap</name> <operator>&amp;&amp;</operator> <name>matchLength</name><operator>==</operator><name>longest</name></expr>)</condition> <block>{<block_content>    <comment type="block">/* better match =&gt; select a better chain */</comment>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lookBackLength</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* search forward only */</comment>
            <if_stmt><if>if <condition>(<expr><name>matchIndex</name> <operator>+</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>longest</name> <operator>&lt;=</operator> <name>ipIndex</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>kTrigger</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>U32</name></type> <name>distanceToNextMatch</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>end</name> <init>= <expr><name>longest</name> <operator>-</operator> <name>MINMATCH</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>step</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>accel</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>kTrigger</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>
                <for>for <control>(<init><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><name>pos</name> <operator>+=</operator> <name>step</name></expr></incr>)</control> <block>{<block_content>
                    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>candidateDist</name> <init>= <expr><call><name>DELTANEXTU16</name><argument_list>(<argument><expr><name>chainTable</name></expr></argument>, <argument><expr><name>matchIndex</name> <operator>+</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>step</name> <operator>=</operator> <operator>(</operator><name>accel</name><operator>++</operator> <operator>&gt;&gt;</operator> <name>kTrigger</name><operator>)</operator></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>candidateDist</name> <operator>&gt;</operator> <name>distanceToNextMatch</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>distanceToNextMatch</name> <operator>=</operator> <name>candidateDist</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>matchChainPos</name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>pos</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>accel</name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>kTrigger</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
                <if_stmt><if>if <condition>(<expr><name>distanceToNextMatch</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>distanceToNextMatch</name> <operator>&gt;</operator> <name>matchIndex</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>   <comment type="block">/* avoid overflow */</comment>
                    <expr_stmt><expr><name>matchIndex</name> <operator>-=</operator> <name>distanceToNextMatch</name></expr>;</expr_stmt>
                    <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>   </block_content>}</block></if></if_stmt>   </block_content>}</block></if></if_stmt>

        <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>distNextMatch</name> <init>= <expr><call><name>DELTANEXTU16</name><argument_list>(<argument><expr><name>chainTable</name></expr></argument>, <argument><expr><name>matchIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>patternAnalysis</name> <operator>&amp;&amp;</operator> <name>distNextMatch</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>matchChainPos</name><operator>==</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>matchCandidateIdx</name> <init>= <expr><name>matchIndex</name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
                <comment type="block">/* may be a repeated pattern */</comment>
                <if_stmt><if>if <condition>(<expr><name>repeat</name> <operator>==</operator> <name>rep_untested</name></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>( <expr><operator>(</operator><operator>(</operator><name>pattern</name> <operator>&amp;</operator> <literal type="number">0xFFFF</literal><operator>)</operator> <operator>==</operator> <operator>(</operator><name>pattern</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator><operator>)</operator>
                      <operator>&amp;</operator>  <operator>(</operator><operator>(</operator><name>pattern</name> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator>   <operator>==</operator> <operator>(</operator><name>pattern</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator><operator>)</operator></expr> )</condition> <block>{<block_content>
                        <expr_stmt><expr><name>repeat</name> <operator>=</operator> <name>rep_confirmed</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>srcPatternLength</name> <operator>=</operator> <call><name>LZ4HC_countPattern</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>iHighLimit</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                    </block_content>}</block></if> <else>else <block>{<block_content>
                        <expr_stmt><expr><name>repeat</name> <operator>=</operator> <name>rep_not</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>   </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>( <expr><operator>(</operator><name>repeat</name> <operator>==</operator> <name>rep_confirmed</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>matchCandidateIdx</name> <operator>&gt;=</operator> <name>lowestMatchIndex</name><operator>)</operator>
                  <operator>&amp;&amp;</operator> <call><name>LZ4HC_protectDictEnd</name><argument_list>(<argument><expr><name>dictLimit</name></expr></argument>, <argument><expr><name>matchCandidateIdx</name></expr></argument>)</argument_list></call></expr> )</condition> <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>extDict</name> <init>= <expr><name>matchCandidateIdx</name> <operator>&lt;</operator> <name>dictLimit</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>matchPtr</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>extDict</name></expr> ?</condition><then> <expr><name>dictBase</name></expr> </then><else>: <expr><name>base</name></expr></else></ternary><operator>)</operator> <operator>+</operator> <name>matchCandidateIdx</name></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>LZ4_read32</name><argument_list>(<argument><expr><name>matchPtr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>pattern</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* good candidate */</comment>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictStart</name> <init>= <expr><name>dictBase</name> <operator>+</operator> <name><name>hc4</name><operator>-&gt;</operator><name>lowLimit</name></name></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iLimit</name> <init>= <expr><ternary><condition><expr><name>extDict</name></expr> ?</condition><then> <expr><name>dictBase</name> <operator>+</operator> <name>dictLimit</name></expr> </then><else>: <expr><name>iHighLimit</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>size_t</name></type> <name>forwardPatternLength</name> <init>= <expr><call><name>LZ4HC_countPattern</name><argument_list>(<argument><expr><name>matchPtr</name><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
                        <if_stmt><if>if <condition>(<expr><name>extDict</name> <operator>&amp;&amp;</operator> <name>matchPtr</name> <operator>+</operator> <name>forwardPatternLength</name> <operator>==</operator> <name>iLimit</name></expr>)</condition> <block>{<block_content>
                            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>rotatedPattern</name> <init>= <expr><call><name>LZ4HC_rotatePattern</name><argument_list>(<argument><expr><name>forwardPatternLength</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><name>forwardPatternLength</name> <operator>+=</operator> <call><name>LZ4HC_countPattern</name><argument_list>(<argument><expr><name>lowPrefixPtr</name></expr></argument>, <argument><expr><name>iHighLimit</name></expr></argument>, <argument><expr><name>rotatedPattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        <block>{<block_content>   <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>lowestMatchPtr</name> <init>= <expr><ternary><condition><expr><name>extDict</name></expr> ?</condition><then> <expr><name>dictStart</name></expr> </then><else>: <expr><name>lowPrefixPtr</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>size_t</name></type> <name>backLength</name> <init>= <expr><call><name>LZ4HC_reverseCountPattern</name><argument_list>(<argument><expr><name>matchPtr</name></expr></argument>, <argument><expr><name>lowestMatchPtr</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>size_t</name></type> <name>currentSegmentLength</name></decl>;</decl_stmt>
                            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>extDict</name> <operator>&amp;&amp;</operator> <name>matchPtr</name> <operator>-</operator> <name>backLength</name> <operator>==</operator> <name>lowPrefixPtr</name> <operator>&amp;&amp;</operator> <name><name>hc4</name><operator>-&gt;</operator><name>lowLimit</name></name> <operator>&lt;</operator> <name>dictLimit</name></expr>)</condition> <block>{<block_content>
                                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>rotatedPattern</name> <init>= <expr><call><name>LZ4HC_rotatePattern</name><argument_list>(<argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><operator>-</operator><operator>(</operator><name>int</name><operator>)</operator><name>backLength</name><operator>)</operator></expr></argument>, <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                <expr_stmt><expr><name>backLength</name> <operator>+=</operator> <call><name>LZ4HC_reverseCountPattern</name><argument_list>(<argument><expr><name>dictBase</name> <operator>+</operator> <name>dictLimit</name></expr></argument>, <argument><expr><name>dictStart</name></expr></argument>, <argument><expr><name>rotatedPattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                            <comment type="block">/* Limit backLength not go further than lowestMatchIndex */</comment>
                            <expr_stmt><expr><name>backLength</name> <operator>=</operator> <name>matchCandidateIdx</name> <operator>-</operator> <call><name>MAX</name><argument_list>(<argument><expr><name>matchCandidateIdx</name> <operator>-</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>backLength</name></expr></argument>, <argument><expr><name>lowestMatchIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>matchCandidateIdx</name> <operator>-</operator> <name>backLength</name> <operator>&gt;=</operator> <name>lowestMatchIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>currentSegmentLength</name> <operator>=</operator> <name>backLength</name> <operator>+</operator> <name>forwardPatternLength</name></expr>;</expr_stmt>
                            <comment type="block">/* Adjust to end of pattern if the source pattern fits, otherwise the beginning of the pattern */</comment>
                            <if_stmt><if>if <condition>( <expr><operator>(</operator><name>currentSegmentLength</name> <operator>&gt;=</operator> <name>srcPatternLength</name><operator>)</operator>   <comment type="block">/* current pattern segment large enough to contain full srcPatternLength */</comment>
                              <operator>&amp;&amp;</operator> <operator>(</operator><name>forwardPatternLength</name> <operator>&lt;=</operator> <name>srcPatternLength</name><operator>)</operator></expr> )</condition> <block>{<block_content> <comment type="block">/* haven't reached this position yet */</comment>
                                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>newMatchIndex</name> <init>= <expr><name>matchCandidateIdx</name> <operator>+</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>forwardPatternLength</name> <operator>-</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>srcPatternLength</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* best position, full pattern, might be followed by more match */</comment>
                                <if_stmt><if>if <condition>(<expr><call><name>LZ4HC_protectDictEnd</name><argument_list>(<argument><expr><name>dictLimit</name></expr></argument>, <argument><expr><name>newMatchIndex</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                                    <expr_stmt><expr><name>matchIndex</name> <operator>=</operator> <name>newMatchIndex</name></expr>;</expr_stmt></block_content></block></if>
                                <else>else <block>{<block_content>
                                    <comment type="block">/* Can only happen if started in the prefix */</comment>
                                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>newMatchIndex</name> <operator>&gt;=</operator> <name>dictLimit</name> <operator>-</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <name>newMatchIndex</name> <operator>&lt;</operator> <name>dictLimit</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>extDict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <expr_stmt><expr><name>matchIndex</name> <operator>=</operator> <name>dictLimit</name></expr>;</expr_stmt>
                                </block_content>}</block></else></if_stmt>
                            </block_content>}</block></if> <else>else <block>{<block_content>
                                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>newMatchIndex</name> <init>= <expr><name>matchCandidateIdx</name> <operator>-</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>backLength</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* farthest position in current segment, will find a match of length currentSegmentLength + maybe some back */</comment>
                                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>LZ4HC_protectDictEnd</name><argument_list>(<argument><expr><name>dictLimit</name></expr></argument>, <argument><expr><name>newMatchIndex</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>newMatchIndex</name> <operator>&gt;=</operator> <name>dictLimit</name> <operator>-</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <name>newMatchIndex</name> <operator>&lt;</operator> <name>dictLimit</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>extDict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <expr_stmt><expr><name>matchIndex</name> <operator>=</operator> <name>dictLimit</name></expr>;</expr_stmt>
                                </block_content>}</block></if> <else>else <block>{<block_content>
                                    <expr_stmt><expr><name>matchIndex</name> <operator>=</operator> <name>newMatchIndex</name></expr>;</expr_stmt>
                                    <if_stmt><if>if <condition>(<expr><name>lookBackLength</name><operator>==</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* no back possible */</comment>
                                        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>maxML</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name>currentSegmentLength</name></expr></argument>, <argument><expr><name>srcPatternLength</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><name>longest</name> <operator>&lt;</operator> <name>maxML</name></expr>)</condition> <block>{<block_content>
                                            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>base</name> <operator>+</operator> <name>matchIndex</name> <operator>!=</operator> <name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>base</name><operator>)</operator> <operator>-</operator> <name>matchIndex</name> <operator>&gt;</operator> <name>LZ4_DISTANCE_MAX</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
                                            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>maxML</name> <operator>&lt;</operator> <literal type="number">2</literal> <name>GB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                            <expr_stmt><expr><name>longest</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>maxML</name></expr>;</expr_stmt>
                                            <expr_stmt><expr><operator>*</operator><name>matchpos</name> <operator>=</operator> <name>base</name> <operator>+</operator> <name>matchIndex</name></expr>;</expr_stmt>   <comment type="block">/* virtual pos, relative to ip, to retrieve offset */</comment>
                                            <expr_stmt><expr><operator>*</operator><name>startpos</name> <operator>=</operator> <name>ip</name></expr>;</expr_stmt>
                                        </block_content>}</block></if></if_stmt>
                                        <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>distToNextPattern</name> <init>= <expr><call><name>DELTANEXTU16</name><argument_list>(<argument><expr><name>chainTable</name></expr></argument>, <argument><expr><name>matchIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                            <if_stmt><if>if <condition>(<expr><name>distToNextPattern</name> <operator>&gt;</operator> <name>matchIndex</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>  <comment type="block">/* avoid overflow */</comment>
                                            <expr_stmt><expr><name>matchIndex</name> <operator>-=</operator> <name>distToNextPattern</name></expr>;</expr_stmt>
                        </block_content>}</block>   </block_content>}</block></if></if_stmt>   </block_content>}</block></else></if_stmt>   </block_content>}</block></else></if_stmt>   </block_content>}</block>
                        <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>   </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>   </block_content>}</block>   <comment type="block">/* PA optimization */</comment>

        <comment type="block">/* follow current chain */</comment>
        <expr_stmt><expr><name>matchIndex</name> <operator>-=</operator> <call><name>DELTANEXTU16</name><argument_list>(<argument><expr><name>chainTable</name></expr></argument>, <argument><expr><name>matchIndex</name> <operator>+</operator> <name>matchChainPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block></while>  <comment type="block">/* while ((matchIndex&gt;=lowestMatchIndex) &amp;&amp; (nbAttempts)) */</comment>

    <if_stmt><if>if <condition>( <expr><name>dict</name> <operator>==</operator> <name>usingDictCtxHc</name>
      <operator>&amp;&amp;</operator> <name>nbAttempts</name> <operator>&gt;</operator> <literal type="number">0</literal>
      <operator>&amp;&amp;</operator> <name>ipIndex</name> <operator>-</operator> <name>lowestMatchIndex</name> <operator>&lt;</operator> <name>LZ4_DISTANCE_MAX</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>dictEndOffset</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>dictCtx</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>dictCtx</name><operator>-&gt;</operator><name>base</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name></type> <name>dictMatchIndex</name> <init>= <expr><name><name>dictCtx</name><operator>-&gt;</operator><name>hashTable</name><index>[<expr><call><name>LZ4HC_hashPtr</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dictEndOffset</name> <operator>&lt;=</operator> <literal type="number">1</literal> <name>GB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>matchIndex</name> <operator>=</operator> <name>dictMatchIndex</name> <operator>+</operator> <name>lowestMatchIndex</name> <operator>-</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>dictEndOffset</name></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>ipIndex</name> <operator>-</operator> <name>matchIndex</name> <operator>&lt;=</operator> <name>LZ4_DISTANCE_MAX</name> <operator>&amp;&amp;</operator> <name>nbAttempts</name><operator>--</operator></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>matchPtr</name> <init>= <expr><name><name>dictCtx</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name>dictMatchIndex</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>LZ4_read32</name><argument_list>(<argument><expr><name>matchPtr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>pattern</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>mlt</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>back</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>vLimit</name> <init>= <expr><name>ip</name> <operator>+</operator> <operator>(</operator><name>dictEndOffset</name> <operator>-</operator> <name>dictMatchIndex</name><operator>)</operator></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>vLimit</name> <operator>&gt;</operator> <name>iHighLimit</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>vLimit</name> <operator>=</operator> <name>iHighLimit</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>mlt</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>LZ4_count</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><name>MINMATCH</name></expr></argument>, <argument><expr><name>matchPtr</name><operator>+</operator><name>MINMATCH</name></expr></argument>, <argument><expr><name>vLimit</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>MINMATCH</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>back</name> <operator>=</operator> <ternary><condition><expr><name>lookBackLength</name></expr> ?</condition><then> <expr><call><name>LZ4HC_countBack</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>matchPtr</name></expr></argument>, <argument><expr><name>iLowLimit</name></expr></argument>, <argument><expr><name><name>dictCtx</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name><name>dictCtx</name><operator>-&gt;</operator><name>dictLimit</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
                <expr_stmt><expr><name>mlt</name> <operator>-=</operator> <name>back</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>mlt</name> <operator>&gt;</operator> <name>longest</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>longest</name> <operator>=</operator> <name>mlt</name></expr>;</expr_stmt>
                    <expr_stmt><expr><operator>*</operator><name>matchpos</name> <operator>=</operator> <name>base</name> <operator>+</operator> <name>matchIndex</name> <operator>+</operator> <name>back</name></expr>;</expr_stmt>
                    <expr_stmt><expr><operator>*</operator><name>startpos</name> <operator>=</operator> <name>ip</name> <operator>+</operator> <name>back</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>   </block_content>}</block></if></if_stmt>

            <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>nextOffset</name> <init>= <expr><call><name>DELTANEXTU16</name><argument_list>(<argument><expr><name><name>dictCtx</name><operator>-&gt;</operator><name>chainTable</name></name></expr></argument>, <argument><expr><name>dictMatchIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>dictMatchIndex</name> <operator>-=</operator> <name>nextOffset</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>matchIndex</name> <operator>-=</operator> <name>nextOffset</name></expr>;</expr_stmt>
    </block_content>}</block>   </block_content>}</block></while>   </block_content>}</block></if></if_stmt>

    <return>return <expr><name>longest</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>LZ4_FORCE_INLINE</name>
<name>int</name></type> <name>LZ4HC_InsertAndFindBestMatch</name><parameter_list>(<parameter><decl><type><name>LZ4HC_CCtx_internal</name><modifier>*</modifier> <specifier>const</specifier></type> <name>hc4</name></decl></parameter>,   <comment type="block">/* Index table will be updated */</comment>
                                 <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ip</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iLimit</name></decl></parameter>,
                                 <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier><modifier>*</modifier></type> <name>matchpos</name></decl></parameter>,
                                 <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>maxNbAttempts</name></decl></parameter>,
                                 <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>patternAnalysis</name></decl></parameter>,
                                 <parameter><decl><type><specifier>const</specifier> <name>dictCtx_directive</name></type> <name>dict</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>uselessPtr</name> <init>= <expr><name>ip</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* note : LZ4HC_InsertAndGetWiderMatch() is able to modify the starting position of a match (*startpos),
     * but this won't be the case here, as we define iLowLimit==ip,
     * so LZ4HC_InsertAndGetWiderMatch() won't be allowed to search past ip */</comment>
    <return>return <expr><call><name>LZ4HC_InsertAndGetWiderMatch</name><argument_list>(<argument><expr><name>hc4</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>, <argument><expr><name>MINMATCH</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>matchpos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>uselessPtr</name></expr></argument>, <argument><expr><name>maxNbAttempts</name></expr></argument>, <argument><expr><name>patternAnalysis</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/*chainSwap*/</comment>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>favorCompressionRatio</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* LZ4HC_encodeSequence() :
 * @return : 0 if ok,
 *           1 if buffer issue detected */</comment>
<function><type><name>LZ4_FORCE_INLINE</name> <name>int</name></type> <name>LZ4HC_encodeSequence</name> <parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier><modifier>*</modifier></type> <name>_ip</name></decl></parameter>,
    <parameter><decl><type><name>BYTE</name><modifier>*</modifier><modifier>*</modifier></type> <name>_op</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier><modifier>*</modifier></type> <name>_anchor</name></decl></parameter>,
    <parameter><decl><type><name>int</name></type> <name>matchLength</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>match</name></decl></parameter>,
    <parameter><decl><type><name>limitedOutput_directive</name></type> <name>limit</name></decl></parameter>,
    <parameter><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>oend</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ip</name></cpp:macro>      <cpp:value>(*_ip)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>op</name></cpp:macro>      <cpp:value>(*_op)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>anchor</name></cpp:macro>  <cpp:value>(*_anchor)</cpp:value></cpp:define>

    <decl_stmt><decl><type><name>size_t</name></type> <name>length</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>token</name> <init>= <expr><name>op</name><operator>++</operator></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LZ4_DEBUG</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>LZ4_DEBUG</name> <operator>&gt;=</operator> <literal type="number">6</literal><operator>)</operator></expr></cpp:if>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>start</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>U32</name></type> <name>totalCost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>pos</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>start</name><operator>==</operator><name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>anchor</name> <operator>-</operator> <name>start</name><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>ll</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>anchor</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>llAdd</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>ll</name><operator>&gt;=</operator><literal type="number">15</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>ll</name><operator>-</operator><literal type="number">15</literal><operator>)</operator> <operator>/</operator> <literal type="number">255</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>mlAdd</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>matchLength</name><operator>&gt;=</operator><literal type="number">19</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>matchLength</name><operator>-</operator><literal type="number">19</literal><operator>)</operator> <operator>/</operator> <literal type="number">255</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>cost</name> <init>= <expr><literal type="number">1</literal> <operator>+</operator> <name>llAdd</name> <operator>+</operator> <name>ll</name> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <name>mlAdd</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>start</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>start</name> <operator>=</operator> <name>anchor</name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* only works for single segment */</comment>
    <comment type="block">/* g_debuglog_enable = (pos &gt;= 2228) &amp; (pos &lt;= 2262); */</comment>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"pos:%7u -- literals:%4u, match:%4i, offset:%5u, cost:%4u + %5u"</literal></expr></argument>,
                <argument><expr><name>pos</name></expr></argument>,
                <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>anchor</name><operator>)</operator></expr></argument>, <argument><expr><name>matchLength</name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>match</name><operator>)</operator></expr></argument>,
                <argument><expr><name>cost</name></expr></argument>, <argument><expr><name>totalCost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>totalCost</name> <operator>+=</operator> <name>cost</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Encode Literal length */</comment>
    <expr_stmt><expr><name>length</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>anchor</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LZ4_STATIC_ASSERT</name><argument_list>(<argument><expr><name>notLimited</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Check output limit */</comment>
    <if_stmt><if>if <condition>(<expr><name>limit</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>op</name> <operator>+</operator> <operator>(</operator><name>length</name> <operator>/</operator> <literal type="number">255</literal><operator>)</operator> <operator>+</operator> <name>length</name> <operator>+</operator> <operator>(</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LASTLITERALS</name><operator>)</operator><operator>)</operator> <operator>&gt;</operator> <name>oend</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"Not enough room to write %i literals (%i bytes remaining)"</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>length</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>oend</name> <operator>-</operator> <name>op</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>length</name> <operator>&gt;=</operator> <name>RUN_MASK</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><name>length</name> <operator>-</operator> <name>RUN_MASK</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><operator>*</operator><name>token</name> <operator>=</operator> <operator>(</operator><name>RUN_MASK</name> <operator>&lt;&lt;</operator> <name>ML_BITS</name><operator>)</operator></expr>;</expr_stmt>
        <for>for<control>(<init>;</init> <condition><expr><name>len</name> <operator>&gt;=</operator> <literal type="number">255</literal></expr> ;</condition> <incr><expr><name>len</name> <operator>-=</operator> <literal type="number">255</literal></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>op</name><operator>++</operator> <operator>=</operator> <literal type="number">255</literal></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><operator>*</operator><name>op</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><name>len</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>token</name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><operator>(</operator><name>length</name> <operator>&lt;&lt;</operator> <name>ML_BITS</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Copy Literals */</comment>
    <expr_stmt><expr><call><name>LZ4_wildCopy8</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>op</name> <operator>+</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>

    <comment type="block">/* Encode Offset */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>ip</name> <operator>-</operator> <name>match</name><operator>)</operator> <operator>&lt;=</operator> <name>LZ4_DISTANCE_MAX</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* note : consider providing offset as a value, rather than as a pointer difference */</comment>
    <expr_stmt><expr><call><name>LZ4_writeLE16</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><operator>(</operator><name>U16</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>match</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>op</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

    <comment type="block">/* Encode MatchLength */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>matchLength</name> <operator>&gt;=</operator> <name>MINMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>length</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>matchLength</name> <operator>-</operator> <name>MINMATCH</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>limit</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>op</name> <operator>+</operator> <operator>(</operator><name>length</name> <operator>/</operator> <literal type="number">255</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <name>LASTLITERALS</name><operator>)</operator> <operator>&gt;</operator> <name>oend</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"Not enough room to write match length"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>   <comment type="block">/* Check output limit */</comment>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>length</name> <operator>&gt;=</operator> <name>ML_MASK</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>token</name> <operator>+=</operator> <name>ML_MASK</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>length</name> <operator>-=</operator> <name>ML_MASK</name></expr>;</expr_stmt>
        <for>for<control>(<init>;</init> <condition><expr><name>length</name> <operator>&gt;=</operator> <literal type="number">510</literal></expr> ;</condition> <incr><expr><name>length</name> <operator>-=</operator> <literal type="number">510</literal></expr></incr>)</control> <block>{<block_content> <expr_stmt><expr><operator>*</operator><name>op</name><operator>++</operator> <operator>=</operator> <literal type="number">255</literal></expr>;</expr_stmt> <expr_stmt><expr><operator>*</operator><name>op</name><operator>++</operator> <operator>=</operator> <literal type="number">255</literal></expr>;</expr_stmt> </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name>length</name> <operator>&gt;=</operator> <literal type="number">255</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>length</name> <operator>-=</operator> <literal type="number">255</literal></expr>;</expr_stmt> <expr_stmt><expr><operator>*</operator><name>op</name><operator>++</operator> <operator>=</operator> <literal type="number">255</literal></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>op</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><name>length</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>token</name> <operator>+=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><operator>(</operator><name>length</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Prepare next loop */</comment>
    <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>matchLength</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>anchor</name> <operator>=</operator> <name>ip</name></expr>;</expr_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ip</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>op</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>anchor</name></cpp:undef>

<function><type><name>LZ4_FORCE_INLINE</name> <name>int</name></type> <name>LZ4HC_compress_hashChain</name> <parameter_list>(
    <parameter><decl><type><name>LZ4HC_CCtx_internal</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ctx</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>source</name></decl></parameter>,
    <parameter><decl><type><name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dest</name></decl></parameter>,
    <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>srcSizePtr</name></decl></parameter>,
    <parameter><decl><type><name>int</name> <specifier>const</specifier></type> <name>maxOutputSize</name></decl></parameter>,
    <parameter><decl><type><name>int</name></type> <name>maxNbAttempts</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>limitedOutput_directive</name></type> <name>limit</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>dictCtx_directive</name></type> <name>dict</name></decl></parameter>
    )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>inputSize</name> <init>= <expr><operator>*</operator><name>srcSizePtr</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>patternAnalysis</name> <init>= <expr><operator>(</operator><name>maxNbAttempts</name> <operator>&gt;</operator> <literal type="number">128</literal><operator>)</operator></expr></init></decl>;</decl_stmt>   <comment type="block">/* levels 9+ */</comment>

    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator> <name>source</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>anchor</name> <init>= <expr><name>ip</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name> <init>= <expr><name>ip</name> <operator>+</operator> <name>inputSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>mflimit</name> <init>= <expr><name>iend</name> <operator>-</operator> <name>MFLIMIT</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>matchlimit</name> <init>= <expr><operator>(</operator><name>iend</name> <operator>-</operator> <name>LASTLITERALS</name><operator>)</operator></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>optr</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator> <name>dest</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator> <name>dest</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>oend</name> <init>= <expr><name>op</name> <operator>+</operator> <name>maxOutputSize</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type>   <name>ml0</name></decl>, <decl><type ref="prev"/><name>ml</name></decl>, <decl><type ref="prev"/><name>ml2</name></decl>, <decl><type ref="prev"/><name>ml3</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>start0</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ref0</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ref</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>start2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ref2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>start3</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ref3</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* init */</comment>
    <expr_stmt><expr><operator>*</operator><name>srcSizePtr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>limit</name> <operator>==</operator> <name>fillOutput</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>oend</name> <operator>-=</operator> <name>LASTLITERALS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>                  <comment type="block">/* Hack for support LZ4 format restriction */</comment>
    <if_stmt><if>if <condition>(<expr><name>inputSize</name> <operator>&lt;</operator> <name>LZ4_minLength</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>_last_literals</name>;</goto></block_content></block></if></if_stmt>             <comment type="block">/* Input too small, no compression (all literals) */</comment>

    <comment type="block">/* Main Loop */</comment>
    <while>while <condition>(<expr><name>ip</name> <operator>&lt;=</operator> <name>mflimit</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>ml</name> <operator>=</operator> <call><name>LZ4HC_InsertAndFindBestMatch</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>matchlimit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ref</name></expr></argument>, <argument><expr><name>maxNbAttempts</name></expr></argument>, <argument><expr><name>patternAnalysis</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>ml</name><operator>&lt;</operator><name>MINMATCH</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>ip</name><operator>++</operator></expr>;</expr_stmt> <continue>continue;</continue> </block_content>}</block></if></if_stmt>

        <comment type="block">/* saved, in case we would skip too much */</comment>
        <expr_stmt><expr><name>start0</name> <operator>=</operator> <name>ip</name></expr>;</expr_stmt> <expr_stmt><expr><name>ref0</name> <operator>=</operator> <name>ref</name></expr>;</expr_stmt> <expr_stmt><expr><name>ml0</name> <operator>=</operator> <name>ml</name></expr>;</expr_stmt>

<label><name>_Search2</name>:</label>
        <if_stmt><if>if <condition>(<expr><name>ip</name><operator>+</operator><name>ml</name> <operator>&lt;=</operator> <name>mflimit</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>ml2</name> <operator>=</operator> <call><name>LZ4HC_InsertAndGetWiderMatch</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>,
                            <argument><expr><name>ip</name> <operator>+</operator> <name>ml</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>ip</name> <operator>+</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>matchlimit</name></expr></argument>, <argument><expr><name>ml</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ref2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start2</name></expr></argument>,
                            <argument><expr><name>maxNbAttempts</name></expr></argument>, <argument><expr><name>patternAnalysis</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>favorCompressionRatio</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>ml2</name> <operator>=</operator> <name>ml</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>ml2</name> <operator>==</operator> <name>ml</name></expr>)</condition> <block>{<block_content> <comment type="block">/* No better match =&gt; encode ML1 */</comment>
            <expr_stmt><expr><name>optr</name> <operator>=</operator> <name>op</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>LZ4HC_encodeSequence</name><argument_list>(<argument><expr><call><name>UPDATABLE</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ml</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>_dest_overflow</name>;</goto></block_content></block></if></if_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>start0</name> <operator>&lt;</operator> <name>ip</name></expr>)</condition> <block>{<block_content>   <comment type="block">/* first match was skipped at least once */</comment>
            <if_stmt><if>if <condition>(<expr><name>start2</name> <operator>&lt;</operator> <name>ip</name> <operator>+</operator> <name>ml0</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* squeezing ML1 between ML0(original ML1) and ML2 */</comment>
                <expr_stmt><expr><name>ip</name> <operator>=</operator> <name>start0</name></expr>;</expr_stmt> <expr_stmt><expr><name>ref</name> <operator>=</operator> <name>ref0</name></expr>;</expr_stmt> <expr_stmt><expr><name>ml</name> <operator>=</operator> <name>ml0</name></expr>;</expr_stmt>  <comment type="block">/* restore initial ML1 */</comment>
        </block_content>}</block></if></if_stmt>   </block_content>}</block></if></if_stmt>

        <comment type="block">/* Here, start0==ip */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>start2</name> <operator>-</operator> <name>ip</name><operator>)</operator> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* First Match too small : removed */</comment>
            <expr_stmt><expr><name>ml</name> <operator>=</operator> <name>ml2</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ip</name> <operator>=</operator> <name>start2</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ref</name> <operator>=</operator><name>ref2</name></expr>;</expr_stmt>
            <goto>goto <name>_Search2</name>;</goto>
        </block_content>}</block></if></if_stmt>

<label><name>_Search3</name>:</label>
        <comment type="block">/* At this stage, we have :
        *  ml2 &gt; ml1, and
        *  ip1+3 &lt;= ip2 (usually &lt; ip1+ml1) */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>start2</name> <operator>-</operator> <name>ip</name><operator>)</operator> <operator>&lt;</operator> <name>OPTIMAL_ML</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>correction</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>new_ml</name> <init>= <expr><name>ml</name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>new_ml</name> <operator>&gt;</operator> <name>OPTIMAL_ML</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>new_ml</name> <operator>=</operator> <name>OPTIMAL_ML</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>ip</name><operator>+</operator><name>new_ml</name> <operator>&gt;</operator> <name>start2</name> <operator>+</operator> <name>ml2</name> <operator>-</operator> <name>MINMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>new_ml</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>start2</name> <operator>-</operator> <name>ip</name><operator>)</operator> <operator>+</operator> <name>ml2</name> <operator>-</operator> <name>MINMATCH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>correction</name> <operator>=</operator> <name>new_ml</name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>start2</name> <operator>-</operator> <name>ip</name><operator>)</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>correction</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>start2</name> <operator>+=</operator> <name>correction</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>ref2</name> <operator>+=</operator> <name>correction</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>ml2</name> <operator>-=</operator> <name>correction</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Now, we have start2 = ip+new_ml, with new_ml = min(ml, OPTIMAL_ML=18) */</comment>

        <if_stmt><if>if <condition>(<expr><name>start2</name> <operator>+</operator> <name>ml2</name> <operator>&lt;=</operator> <name>mflimit</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>ml3</name> <operator>=</operator> <call><name>LZ4HC_InsertAndGetWiderMatch</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>,
                            <argument><expr><name>start2</name> <operator>+</operator> <name>ml2</name> <operator>-</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><name>start2</name></expr></argument>, <argument><expr><name>matchlimit</name></expr></argument>, <argument><expr><name>ml2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ref3</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start3</name></expr></argument>,
                            <argument><expr><name>maxNbAttempts</name></expr></argument>, <argument><expr><name>patternAnalysis</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>favorCompressionRatio</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>ml3</name> <operator>=</operator> <name>ml2</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>ml3</name> <operator>==</operator> <name>ml2</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* No better match =&gt; encode ML1 and ML2 */</comment>
            <comment type="block">/* ip &amp; ref are known; Now for ml */</comment>
            <if_stmt><if>if <condition>(<expr><name>start2</name> <operator>&lt;</operator> <name>ip</name><operator>+</operator><name>ml</name></expr>)</condition><block type="pseudo"><block_content>  <expr_stmt><expr><name>ml</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>start2</name> <operator>-</operator> <name>ip</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <comment type="block">/* Now, encode 2 sequences */</comment>
            <expr_stmt><expr><name>optr</name> <operator>=</operator> <name>op</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>LZ4HC_encodeSequence</name><argument_list>(<argument><expr><call><name>UPDATABLE</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ml</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>_dest_overflow</name>;</goto></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>ip</name> <operator>=</operator> <name>start2</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>optr</name> <operator>=</operator> <name>op</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>LZ4HC_encodeSequence</name><argument_list>(<argument><expr><call><name>UPDATABLE</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ml2</name></expr></argument>, <argument><expr><name>ref2</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>ml</name>  <operator>=</operator> <name>ml2</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>ref</name> <operator>=</operator> <name>ref2</name></expr>;</expr_stmt>
                <goto>goto <name>_dest_overflow</name>;</goto>
            </block_content>}</block></if></if_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>start3</name> <operator>&lt;</operator> <name>ip</name><operator>+</operator><name>ml</name><operator>+</operator><literal type="number">3</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Not enough space for match 2 : remove it */</comment>
            <if_stmt><if>if <condition>(<expr><name>start3</name> <operator>&gt;=</operator> <operator>(</operator><name>ip</name><operator>+</operator><name>ml</name><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* can write Seq1 immediately ==&gt; Seq2 is removed, so Seq3 becomes Seq1 */</comment>
                <if_stmt><if>if <condition>(<expr><name>start2</name> <operator>&lt;</operator> <name>ip</name><operator>+</operator><name>ml</name></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type> <name>correction</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>ip</name><operator>+</operator><name>ml</name> <operator>-</operator> <name>start2</name><operator>)</operator></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>start2</name> <operator>+=</operator> <name>correction</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>ref2</name> <operator>+=</operator> <name>correction</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>ml2</name> <operator>-=</operator> <name>correction</name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>ml2</name> <operator>&lt;</operator> <name>MINMATCH</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>start2</name> <operator>=</operator> <name>start3</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>ref2</name> <operator>=</operator> <name>ref3</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>ml2</name> <operator>=</operator> <name>ml3</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name>optr</name> <operator>=</operator> <name>op</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>LZ4HC_encodeSequence</name><argument_list>(<argument><expr><call><name>UPDATABLE</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ml</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>_dest_overflow</name>;</goto></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>ip</name>  <operator>=</operator> <name>start3</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>ref</name> <operator>=</operator> <name>ref3</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>ml</name>  <operator>=</operator> <name>ml3</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>start0</name> <operator>=</operator> <name>start2</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>ref0</name> <operator>=</operator> <name>ref2</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>ml0</name> <operator>=</operator> <name>ml2</name></expr>;</expr_stmt>
                <goto>goto <name>_Search2</name>;</goto>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>start2</name> <operator>=</operator> <name>start3</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ref2</name> <operator>=</operator> <name>ref3</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ml2</name> <operator>=</operator> <name>ml3</name></expr>;</expr_stmt>
            <goto>goto <name>_Search3</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
        * OK, now we have 3 ascending matches;
        * let's write the first one ML1.
        * ip &amp; ref are known; Now decide ml.
        */</comment>
        <if_stmt><if>if <condition>(<expr><name>start2</name> <operator>&lt;</operator> <name>ip</name><operator>+</operator><name>ml</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>start2</name> <operator>-</operator> <name>ip</name><operator>)</operator> <operator>&lt;</operator> <name>OPTIMAL_ML</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>correction</name></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>ml</name> <operator>&gt;</operator> <name>OPTIMAL_ML</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ml</name> <operator>=</operator> <name>OPTIMAL_ML</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>ip</name> <operator>+</operator> <name>ml</name> <operator>&gt;</operator> <name>start2</name> <operator>+</operator> <name>ml2</name> <operator>-</operator> <name>MINMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ml</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>start2</name> <operator>-</operator> <name>ip</name><operator>)</operator> <operator>+</operator> <name>ml2</name> <operator>-</operator> <name>MINMATCH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>correction</name> <operator>=</operator> <name>ml</name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>start2</name> <operator>-</operator> <name>ip</name><operator>)</operator></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>correction</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>start2</name> <operator>+=</operator> <name>correction</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>ref2</name> <operator>+=</operator> <name>correction</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>ml2</name> <operator>-=</operator> <name>correction</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>ml</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>start2</name> <operator>-</operator> <name>ip</name><operator>)</operator></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>optr</name> <operator>=</operator> <name>op</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>LZ4HC_encodeSequence</name><argument_list>(<argument><expr><call><name>UPDATABLE</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ml</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>_dest_overflow</name>;</goto></block_content></block></if></if_stmt>

        <comment type="block">/* ML2 becomes ML1 */</comment>
        <expr_stmt><expr><name>ip</name> <operator>=</operator> <name>start2</name></expr>;</expr_stmt> <expr_stmt><expr><name>ref</name> <operator>=</operator> <name>ref2</name></expr>;</expr_stmt> <expr_stmt><expr><name>ml</name> <operator>=</operator> <name>ml2</name></expr>;</expr_stmt>

        <comment type="block">/* ML3 becomes ML2 */</comment>
        <expr_stmt><expr><name>start2</name> <operator>=</operator> <name>start3</name></expr>;</expr_stmt> <expr_stmt><expr><name>ref2</name> <operator>=</operator> <name>ref3</name></expr>;</expr_stmt> <expr_stmt><expr><name>ml2</name> <operator>=</operator> <name>ml3</name></expr>;</expr_stmt>

        <comment type="block">/* let's find a new ML3 */</comment>
        <goto>goto <name>_Search3</name>;</goto>
    </block_content>}</block></while>

<label><name>_last_literals</name>:</label>
    <comment type="block">/* Encode Last Literals */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name></type> <name>lastRunSize</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>iend</name> <operator>-</operator> <name>anchor</name><operator>)</operator></expr></init></decl>;</decl_stmt>  <comment type="block">/* literals */</comment>
        <decl_stmt><decl><type><name>size_t</name></type> <name>llAdd</name> <init>= <expr><operator>(</operator><name>lastRunSize</name> <operator>+</operator> <literal type="number">255</literal> <operator>-</operator> <name>RUN_MASK</name><operator>)</operator> <operator>/</operator> <literal type="number">255</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>totalSize</name> <init>= <expr><literal type="number">1</literal> <operator>+</operator> <name>llAdd</name> <operator>+</operator> <name>lastRunSize</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>limit</name> <operator>==</operator> <name>fillOutput</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>oend</name> <operator>+=</operator> <name>LASTLITERALS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* restore correct value */</comment>
        <if_stmt><if>if <condition>(<expr><name>limit</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>op</name> <operator>+</operator> <name>totalSize</name> <operator>&gt;</operator> <name>oend</name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>limit</name> <operator>==</operator> <name>limitedOutput</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            <comment type="block">/* adapt lastRunSize to fill 'dest' */</comment>
            <expr_stmt><expr><name>lastRunSize</name>  <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name> <operator>-</operator> <name>op</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr> <comment type="block">/*token*/</comment>;</expr_stmt>
            <expr_stmt><expr><name>llAdd</name> <operator>=</operator> <operator>(</operator><name>lastRunSize</name> <operator>+</operator> <literal type="number">256</literal> <operator>-</operator> <name>RUN_MASK</name><operator>)</operator> <operator>/</operator> <literal type="number">256</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>lastRunSize</name> <operator>-=</operator> <name>llAdd</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"Final literal run : %i literals"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>lastRunSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ip</name> <operator>=</operator> <name>anchor</name> <operator>+</operator> <name>lastRunSize</name></expr>;</expr_stmt>  <comment type="block">/* can be != iend if limit==fillOutput */</comment>

        <if_stmt><if>if <condition>(<expr><name>lastRunSize</name> <operator>&gt;=</operator> <name>RUN_MASK</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>size_t</name></type> <name>accumulator</name> <init>= <expr><name>lastRunSize</name> <operator>-</operator> <name>RUN_MASK</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><operator>*</operator><name>op</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>RUN_MASK</name> <operator>&lt;&lt;</operator> <name>ML_BITS</name><operator>)</operator></expr>;</expr_stmt>
            <for>for<control>(<init>;</init> <condition><expr><name>accumulator</name> <operator>&gt;=</operator> <literal type="number">255</literal></expr> ;</condition> <incr><expr><name>accumulator</name> <operator>-=</operator> <literal type="number">255</literal></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>op</name><operator>++</operator> <operator>=</operator> <literal type="number">255</literal></expr>;</expr_stmt></block_content></block></for>
            <expr_stmt><expr><operator>*</operator><name>op</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator> <name>accumulator</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>op</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><operator>(</operator><name>lastRunSize</name> <operator>&lt;&lt;</operator> <name>ML_BITS</name><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>lastRunSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>lastRunSize</name></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* End */</comment>
    <expr_stmt><expr><operator>*</operator><name>srcSizePtr</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>ip</name><operator>)</operator> <operator>-</operator> <name>source</name><operator>)</operator></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>op</name><operator>)</operator><operator>-</operator><name>dest</name><operator>)</operator></expr>;</return>

<label><name>_dest_overflow</name>:</label>
    <if_stmt><if>if <condition>(<expr><name>limit</name> <operator>==</operator> <name>fillOutput</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Assumption : ip, anchor, ml and ref must be set correctly */</comment>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>ll</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>anchor</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>ll_addbytes</name> <init>= <expr><operator>(</operator><name>ll</name> <operator>+</operator> <literal type="number">240</literal><operator>)</operator> <operator>/</operator> <literal type="number">255</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>ll_totalCost</name> <init>= <expr><literal type="number">1</literal> <operator>+</operator> <name>ll_addbytes</name> <operator>+</operator> <name>ll</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>maxLitPos</name> <init>= <expr><name>oend</name> <operator>-</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* 2 for offset, 1 for token */</comment>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"Last sequence overflowing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> <operator>=</operator> <name>optr</name></expr>;</expr_stmt>  <comment type="block">/* restore correct out pointer */</comment>
        <if_stmt><if>if <condition>(<expr><name>op</name> <operator>+</operator> <name>ll_totalCost</name> <operator>&lt;=</operator> <name>maxLitPos</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* ll validated; now adjust match length */</comment>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>bytesLeftForMl</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>maxLitPos</name> <operator>-</operator> <operator>(</operator><name>op</name><operator>+</operator><name>ll_totalCost</name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>maxMlSize</name> <init>= <expr><name>MINMATCH</name> <operator>+</operator> <operator>(</operator><name>ML_MASK</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>bytesLeftForMl</name> <operator>*</operator> <literal type="number">255</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>maxMlSize</name> <operator>&lt;</operator> <name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ml</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><name>ml</name> <operator>&gt;</operator> <name>maxMlSize</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ml</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>maxMlSize</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>oend</name> <operator>+</operator> <name>LASTLITERALS</name><operator>)</operator> <operator>-</operator> <operator>(</operator><name>op</name> <operator>+</operator> <name>ll_totalCost</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal> <operator>+</operator> <name>ml</name> <operator>&gt;=</operator> <name>MFLIMIT</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>LZ4HC_encodeSequence</name><argument_list>(<argument><expr><call><name>UPDATABLE</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ml</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>, <argument><expr><name>notLimited</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>   </block_content>}</block></if></if_stmt>
        <goto>goto <name>_last_literals</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* compression failed */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>LZ4HC_compress_optimal</name><parameter_list>( <parameter><decl><type><name>LZ4HC_CCtx_internal</name><modifier>*</modifier></type> <name>ctx</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>,
    <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>srcSizePtr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dstCapacity</name></decl></parameter>,
    <parameter><decl><type><name>int</name> <specifier>const</specifier></type> <name>nbSearches</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sufficient_len</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>limitedOutput_directive</name></type> <name>limit</name></decl></parameter>, <parameter><decl><type><name>int</name> <specifier>const</specifier></type> <name>fullUpdate</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>dictCtx_directive</name></type> <name>dict</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>HCfavor_e</name></type> <name>favorDecSpeed</name></decl></parameter>)</parameter_list>;</function_decl>


<function><type><name>LZ4_FORCE_INLINE</name> <name>int</name></type> <name>LZ4HC_compress_generic_internal</name> <parameter_list>(
    <parameter><decl><type><name>LZ4HC_CCtx_internal</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ctx</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>src</name></decl></parameter>,
    <parameter><decl><type><name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dst</name></decl></parameter>,
    <parameter><decl><type><name>int</name><modifier>*</modifier> <specifier>const</specifier></type> <name>srcSizePtr</name></decl></parameter>,
    <parameter><decl><type><name>int</name> <specifier>const</specifier></type> <name>dstCapacity</name></decl></parameter>,
    <parameter><decl><type><name>int</name></type> <name>cLevel</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>limitedOutput_directive</name></type> <name>limit</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>dictCtx_directive</name></type> <name>dict</name></decl></parameter>
    )</parameter_list>
<block>{<block_content>
    <typedef>typedef <type><enum>enum <block>{ <decl><name>lz4hc</name></decl>, <decl><name>lz4opt</name></decl> }</block></enum></type> <name>lz4hc_strat_e</name>;</typedef>
    <typedef>typedef <type><struct>struct <block>{
        <decl_stmt><decl><type><name>lz4hc_strat_e</name></type> <name>strat</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nbSearches</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name></type> <name>targetLength</name></decl>;</decl_stmt>
    }</block></struct></type> <name>cParams_t</name>;</typedef>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>cParams_t</name></type> <name><name>clTable</name><index>[<expr><name>LZ4HC_CLEVEL_MAX</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{
        <expr><block>{ <expr><name>lz4hc</name></expr>,     <expr><literal type="number">2</literal></expr>, <expr><literal type="number">16</literal></expr> }</block></expr>,  <comment type="block">/* 0, unused */</comment>
        <expr><block>{ <expr><name>lz4hc</name></expr>,     <expr><literal type="number">2</literal></expr>, <expr><literal type="number">16</literal></expr> }</block></expr>,  <comment type="block">/* 1, unused */</comment>
        <expr><block>{ <expr><name>lz4hc</name></expr>,     <expr><literal type="number">2</literal></expr>, <expr><literal type="number">16</literal></expr> }</block></expr>,  <comment type="block">/* 2, unused */</comment>
        <expr><block>{ <expr><name>lz4hc</name></expr>,     <expr><literal type="number">4</literal></expr>, <expr><literal type="number">16</literal></expr> }</block></expr>,  <comment type="block">/* 3 */</comment>
        <expr><block>{ <expr><name>lz4hc</name></expr>,     <expr><literal type="number">8</literal></expr>, <expr><literal type="number">16</literal></expr> }</block></expr>,  <comment type="block">/* 4 */</comment>
        <expr><block>{ <expr><name>lz4hc</name></expr>,    <expr><literal type="number">16</literal></expr>, <expr><literal type="number">16</literal></expr> }</block></expr>,  <comment type="block">/* 5 */</comment>
        <expr><block>{ <expr><name>lz4hc</name></expr>,    <expr><literal type="number">32</literal></expr>, <expr><literal type="number">16</literal></expr> }</block></expr>,  <comment type="block">/* 6 */</comment>
        <expr><block>{ <expr><name>lz4hc</name></expr>,    <expr><literal type="number">64</literal></expr>, <expr><literal type="number">16</literal></expr> }</block></expr>,  <comment type="block">/* 7 */</comment>
        <expr><block>{ <expr><name>lz4hc</name></expr>,   <expr><literal type="number">128</literal></expr>, <expr><literal type="number">16</literal></expr> }</block></expr>,  <comment type="block">/* 8 */</comment>
        <expr><block>{ <expr><name>lz4hc</name></expr>,   <expr><literal type="number">256</literal></expr>, <expr><literal type="number">16</literal></expr> }</block></expr>,  <comment type="block">/* 9 */</comment>
        <expr><block>{ <expr><name>lz4opt</name></expr>,   <expr><literal type="number">96</literal></expr>, <expr><literal type="number">64</literal></expr> }</block></expr>,  <comment type="block">/*10==LZ4HC_CLEVEL_OPT_MIN*/</comment>
        <expr><block>{ <expr><name>lz4opt</name></expr>,  <expr><literal type="number">512</literal></expr>,<expr><literal type="number">128</literal></expr> }</block></expr>,  <comment type="block">/*11 */</comment>
        <expr><block>{ <expr><name>lz4opt</name></expr>,<expr><literal type="number">16384</literal></expr>,<expr><name>LZ4_OPT_NUM</name></expr> }</block></expr>,  <comment type="block">/* 12==LZ4HC_CLEVEL_MAX */</comment>
    }</block></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"LZ4HC_compress_generic(ctx=%p, src=%p, srcSize=%d, limit=%d)"</literal></expr></argument>,
                <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>*</operator><name>srcSizePtr</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>limit</name> <operator>==</operator> <name>fillOutput</name> <operator>&amp;&amp;</operator> <name>dstCapacity</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* Impossible to store anything */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>U32</name><operator>)</operator><operator>*</operator><name>srcSizePtr</name> <operator>&gt;</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>LZ4_MAX_INPUT_SIZE</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>    <comment type="block">/* Unsupported input size (too large or negative) */</comment>

    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>end</name></name> <operator>+=</operator> <operator>*</operator><name>srcSizePtr</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>cLevel</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cLevel</name> <operator>=</operator> <name>LZ4HC_CLEVEL_DEFAULT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>   <comment type="block">/* note : convention is different from lz4frame, maybe something to review */</comment>
    <expr_stmt><expr><name>cLevel</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>LZ4HC_CLEVEL_MAX</name></expr></argument>, <argument><expr><name>cLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>cParams_t</name> <specifier>const</specifier></type> <name>cParam</name> <init>= <expr><name><name>clTable</name><index>[<expr><name>cLevel</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HCfavor_e</name> <specifier>const</specifier></type> <name>favor</name> <init>= <expr><ternary><condition><expr><name><name>ctx</name><operator>-&gt;</operator><name>favorDecSpeed</name></name></expr> ?</condition><then> <expr><name>favorDecompressionSpeed</name></expr> </then><else>: <expr><name>favorCompressionRatio</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>cParam</name><operator>.</operator><name>strat</name></name> <operator>==</operator> <name>lz4hc</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>LZ4HC_compress_hashChain</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>,
                                <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcSizePtr</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>,
                                <argument><expr><name><name>cParam</name><operator>.</operator><name>nbSearches</name></name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cParam</name><operator>.</operator><name>strat</name></name> <operator>==</operator> <name>lz4opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>LZ4HC_compress_optimal</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>,
                                <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcSizePtr</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>,
                                <argument><expr><name><name>cParam</name><operator>.</operator><name>nbSearches</name></name></expr></argument>, <argument><expr><name><name>cParam</name><operator>.</operator><name>targetLength</name></name></expr></argument>, <argument><expr><name>limit</name></expr></argument>,
                                <argument><expr><name>cLevel</name> <operator>==</operator> <name>LZ4HC_CLEVEL_MAX</name></expr></argument>,   <comment type="block">/* ultra mode */</comment>
                                <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>favor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>dirty</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>LZ4HC_setExternalDict</name><parameter_list>(<parameter><decl><type><name>LZ4HC_CCtx_internal</name><modifier>*</modifier></type> <name>ctxPtr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>newBlock</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>LZ4HC_compress_generic_noDictCtx</name> <parameter_list>(
        <parameter><decl><type><name>LZ4HC_CCtx_internal</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ctx</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>src</name></decl></parameter>,
        <parameter><decl><type><name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dst</name></decl></parameter>,
        <parameter><decl><type><name>int</name><modifier>*</modifier> <specifier>const</specifier></type> <name>srcSizePtr</name></decl></parameter>,
        <parameter><decl><type><name>int</name> <specifier>const</specifier></type> <name>dstCapacity</name></decl></parameter>,
        <parameter><decl><type><name>int</name></type> <name>cLevel</name></decl></parameter>,
        <parameter><decl><type><name>limitedOutput_directive</name></type> <name>limit</name></decl></parameter>
        )</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>dictCtx</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>LZ4HC_compress_generic_internal</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcSizePtr</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>cLevel</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><name>noDictCtx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>LZ4HC_compress_generic_dictCtx</name> <parameter_list>(
        <parameter><decl><type><name>LZ4HC_CCtx_internal</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ctx</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>src</name></decl></parameter>,
        <parameter><decl><type><name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dst</name></decl></parameter>,
        <parameter><decl><type><name>int</name><modifier>*</modifier> <specifier>const</specifier></type> <name>srcSizePtr</name></decl></parameter>,
        <parameter><decl><type><name>int</name> <specifier>const</specifier></type> <name>dstCapacity</name></decl></parameter>,
        <parameter><decl><type><name>int</name></type> <name>cLevel</name></decl></parameter>,
        <parameter><decl><type><name>limitedOutput_directive</name></type> <name>limit</name></decl></parameter>
        )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>position</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>ctx</name><operator>-&gt;</operator><name>base</name></name><operator>)</operator> <operator>-</operator> <name><name>ctx</name><operator>-&gt;</operator><name>lowLimit</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>dictCtx</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>position</name> <operator>&gt;=</operator> <literal type="number">64</literal> <name>KB</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>dictCtx</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <return>return <expr><call><name>LZ4HC_compress_generic_noDictCtx</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcSizePtr</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>cLevel</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>position</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>srcSizePtr</name> <operator>&gt;</operator> <literal type="number">4</literal> <name>KB</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>dictCtx</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LZ4HC_CCtx_internal</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LZ4HC_setExternalDict</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name> <operator>*</operator><operator>)</operator><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>compressionLevel</name></name> <operator>=</operator> <operator>(</operator><name>short</name><operator>)</operator><name>cLevel</name></expr>;</expr_stmt>
        <return>return <expr><call><name>LZ4HC_compress_generic_noDictCtx</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcSizePtr</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>cLevel</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><call><name>LZ4HC_compress_generic_internal</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcSizePtr</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>cLevel</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><name>usingDictCtxHc</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>LZ4HC_compress_generic</name> <parameter_list>(
        <parameter><decl><type><name>LZ4HC_CCtx_internal</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ctx</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>src</name></decl></parameter>,
        <parameter><decl><type><name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dst</name></decl></parameter>,
        <parameter><decl><type><name>int</name><modifier>*</modifier> <specifier>const</specifier></type> <name>srcSizePtr</name></decl></parameter>,
        <parameter><decl><type><name>int</name> <specifier>const</specifier></type> <name>dstCapacity</name></decl></parameter>,
        <parameter><decl><type><name>int</name></type> <name>cLevel</name></decl></parameter>,
        <parameter><decl><type><name>limitedOutput_directive</name></type> <name>limit</name></decl></parameter>
        )</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>dictCtx</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>LZ4HC_compress_generic_noDictCtx</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcSizePtr</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>cLevel</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><call><name>LZ4HC_compress_generic_dictCtx</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcSizePtr</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>cLevel</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>LZ4_sizeofStateHC</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>LZ4_streamHC_t</name></expr></argument>)</argument_list></sizeof></expr>;</return> </block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>LZ4_streamHC_t_alignment</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LZ4_ALIGN_TEST</name></expr></cpp:if>
    <typedef>typedef <type><struct>struct <block>{ <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>LZ4_streamHC_t</name></type> <name>t</name></decl>;</decl_stmt> }</block></struct></type> <name>t_a</name>;</typedef>
    <return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>t_a</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LZ4_streamHC_t</name></expr></argument>)</argument_list></sizeof></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr><literal type="number">1</literal></expr>;</return>  <comment type="block">/* effectively disabled */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/* state is presumed correctly initialized,
 * in which case its size and alignment have already been validate */</comment>
<function><type><name>int</name></type> <name>LZ4_compress_HC_extStateHC_fastReset</name> <parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>state</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dstCapacity</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compressionLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LZ4HC_CCtx_internal</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ctx</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>LZ4_streamHC_t</name><operator>*</operator><operator>)</operator><name>state</name><operator>)</operator><operator>-&gt;</operator><name>internal_donotuse</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>LZ4_isAligned</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>LZ4_streamHC_t_alignment</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>LZ4_resetStreamHC_fast</name><argument_list>(<argument><expr><operator>(</operator><name>LZ4_streamHC_t</name><operator>*</operator><operator>)</operator><name>state</name></expr></argument>, <argument><expr><name>compressionLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LZ4HC_init_internal</name> <argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>dstCapacity</name> <operator>&lt;</operator> <call><name>LZ4_compressBound</name><argument_list>(<argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>LZ4HC_compress_generic</name> <argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>srcSize</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>compressionLevel</name></expr></argument>, <argument><expr><name>limitedOutput</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><call><name>LZ4HC_compress_generic</name> <argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>srcSize</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>compressionLevel</name></expr></argument>, <argument><expr><name>notLimited</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>LZ4_compress_HC_extStateHC</name> <parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>state</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dstCapacity</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compressionLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LZ4_streamHC_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ctx</name> <init>= <expr><call><name>LZ4_initStreamHC</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>ctx</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* init failure */</comment>
    <return>return <expr><call><name>LZ4_compress_HC_extStateHC_fastReset</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>compressionLevel</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>LZ4_compress_HC</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dstCapacity</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compressionLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LZ4HC_HEAPMODE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>LZ4HC_HEAPMODE</name><operator>==</operator><literal type="number">1</literal></expr></cpp:if>
    <decl_stmt><decl><type><name>LZ4_streamHC_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>statePtr</name> <init>= <expr><operator>(</operator><name>LZ4_streamHC_t</name><operator>*</operator><operator>)</operator><call><name>ALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LZ4_streamHC_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>LZ4_streamHC_t</name></type> <name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LZ4_streamHC_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>statePtr</name> <init>= <expr><operator>&amp;</operator><name>state</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>cSize</name> <init>= <expr><call><name>LZ4_compress_HC_extStateHC</name><argument_list>(<argument><expr><name>statePtr</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>compressionLevel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LZ4HC_HEAPMODE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>LZ4HC_HEAPMODE</name><operator>==</operator><literal type="number">1</literal></expr></cpp:if>
    <expr_stmt><expr><call><name>FREEMEM</name><argument_list>(<argument><expr><name>statePtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>cSize</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* state is presumed sized correctly (&gt;= sizeof(LZ4_streamHC_t)) */</comment>
<function><type><name>int</name></type> <name>LZ4_compress_HC_destSize</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>state</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>sourceSizePtr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targetDestSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LZ4_streamHC_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ctx</name> <init>= <expr><call><name>LZ4_initStreamHC</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>ctx</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* init failure */</comment>
    <expr_stmt><expr><call><name>LZ4HC_init_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>internal_donotuse</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator> <name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LZ4_setCompressionLevel</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>cLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>LZ4HC_compress_generic</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>internal_donotuse</name></name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>sourceSizePtr</name></expr></argument>, <argument><expr><name>targetDestSize</name></expr></argument>, <argument><expr><name>cLevel</name></expr></argument>, <argument><expr><name>fillOutput</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/**************************************
*  Streaming Functions
**************************************/</comment>
<comment type="block">/* allocation */</comment>
<function><type><name>LZ4_streamHC_t</name><modifier>*</modifier></type> <name>LZ4_createStreamHC</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LZ4_streamHC_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>state</name> <init>=
        <expr><operator>(</operator><name>LZ4_streamHC_t</name><operator>*</operator><operator>)</operator><call><name>ALLOC_AND_ZERO</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LZ4_streamHC_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>LZ4_setCompressionLevel</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>LZ4HC_CLEVEL_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>LZ4_freeStreamHC</name> <parameter_list>(<parameter><decl><type><name>LZ4_streamHC_t</name><modifier>*</modifier></type> <name>LZ4_streamHCPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"LZ4_freeStreamHC(%p)"</literal></expr></argument>, <argument><expr><name>LZ4_streamHCPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>LZ4_streamHCPtr</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* support free on NULL */</comment>
    <expr_stmt><expr><call><name>FREEMEM</name><argument_list>(<argument><expr><name>LZ4_streamHCPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><name>LZ4_streamHC_t</name><modifier>*</modifier></type> <name>LZ4_initStreamHC</name> <parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LZ4_streamHC_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>LZ4_streamHCPtr</name> <init>= <expr><operator>(</operator><name>LZ4_streamHC_t</name><operator>*</operator><operator>)</operator><name>buffer</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* if compilation fails here, LZ4_STREAMHCSIZE must be increased */</comment>
    <expr_stmt><expr><call><name>LZ4_STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LZ4HC_CCtx_internal</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <name>LZ4_STREAMHCSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"LZ4_initStreamHC(%p, %u)"</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* check conditions */</comment>
    <if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LZ4_streamHC_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>LZ4_isAligned</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><call><name>LZ4_streamHC_t_alignment</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* init */</comment>
    <block>{<block_content> <decl_stmt><decl><type><name>LZ4HC_CCtx_internal</name><modifier>*</modifier> <specifier>const</specifier></type> <name>hcstate</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>LZ4_streamHCPtr</name><operator>-&gt;</operator><name>internal_donotuse</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>MEM_INIT</name><argument_list>(<argument><expr><name>hcstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>hcstate</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block>
    <expr_stmt><expr><call><name>LZ4_setCompressionLevel</name><argument_list>(<argument><expr><name>LZ4_streamHCPtr</name></expr></argument>, <argument><expr><name>LZ4HC_CLEVEL_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>LZ4_streamHCPtr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* just a stub */</comment>
<function><type><name>void</name></type> <name>LZ4_resetStreamHC</name> <parameter_list>(<parameter><decl><type><name>LZ4_streamHC_t</name><modifier>*</modifier></type> <name>LZ4_streamHCPtr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compressionLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LZ4_initStreamHC</name><argument_list>(<argument><expr><name>LZ4_streamHCPtr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>LZ4_streamHCPtr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LZ4_setCompressionLevel</name><argument_list>(<argument><expr><name>LZ4_streamHCPtr</name></expr></argument>, <argument><expr><name>compressionLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>LZ4_resetStreamHC_fast</name> <parameter_list>(<parameter><decl><type><name>LZ4_streamHC_t</name><modifier>*</modifier></type> <name>LZ4_streamHCPtr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compressionLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"LZ4_resetStreamHC_fast(%p, %d)"</literal></expr></argument>, <argument><expr><name>LZ4_streamHCPtr</name></expr></argument>, <argument><expr><name>compressionLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>LZ4_streamHCPtr</name><operator>-&gt;</operator><name>internal_donotuse</name><operator>.</operator><name>dirty</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>LZ4_initStreamHC</name><argument_list>(<argument><expr><name>LZ4_streamHCPtr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>LZ4_streamHCPtr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* preserve end - base : can trigger clearTable's threshold */</comment>
        <expr_stmt><expr><name><name>LZ4_streamHCPtr</name><operator>-&gt;</operator><name>internal_donotuse</name><operator>.</operator><name>end</name></name> <operator>-=</operator> <operator>(</operator><name>uptrval</name><operator>)</operator><name><name>LZ4_streamHCPtr</name><operator>-&gt;</operator><name>internal_donotuse</name><operator>.</operator><name>base</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>LZ4_streamHCPtr</name><operator>-&gt;</operator><name>internal_donotuse</name><operator>.</operator><name>base</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>LZ4_streamHCPtr</name><operator>-&gt;</operator><name>internal_donotuse</name><operator>.</operator><name>dictCtx</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>LZ4_setCompressionLevel</name><argument_list>(<argument><expr><name>LZ4_streamHCPtr</name></expr></argument>, <argument><expr><name>compressionLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>LZ4_setCompressionLevel</name><parameter_list>(<parameter><decl><type><name>LZ4_streamHC_t</name><modifier>*</modifier></type> <name>LZ4_streamHCPtr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compressionLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"LZ4_setCompressionLevel(%p, %d)"</literal></expr></argument>, <argument><expr><name>LZ4_streamHCPtr</name></expr></argument>, <argument><expr><name>compressionLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>compressionLevel</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>compressionLevel</name> <operator>=</operator> <name>LZ4HC_CLEVEL_DEFAULT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>compressionLevel</name> <operator>&gt;</operator> <name>LZ4HC_CLEVEL_MAX</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>compressionLevel</name> <operator>=</operator> <name>LZ4HC_CLEVEL_MAX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>LZ4_streamHCPtr</name><operator>-&gt;</operator><name>internal_donotuse</name><operator>.</operator><name>compressionLevel</name></name> <operator>=</operator> <operator>(</operator><name>short</name><operator>)</operator><name>compressionLevel</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>LZ4_favorDecompressionSpeed</name><parameter_list>(<parameter><decl><type><name>LZ4_streamHC_t</name><modifier>*</modifier></type> <name>LZ4_streamHCPtr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>favor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>LZ4_streamHCPtr</name><operator>-&gt;</operator><name>internal_donotuse</name><operator>.</operator><name>favorDecSpeed</name></name> <operator>=</operator> <operator>(</operator><name>favor</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* LZ4_loadDictHC() :
 * LZ4_streamHCPtr is presumed properly initialized */</comment>
<function><type><name>int</name></type> <name>LZ4_loadDictHC</name> <parameter_list>(<parameter><decl><type><name>LZ4_streamHC_t</name><modifier>*</modifier></type> <name>LZ4_streamHCPtr</name></decl></parameter>,
              <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>dictionary</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dictSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LZ4HC_CCtx_internal</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ctxPtr</name> <init>= <expr><operator>&amp;</operator><name><name>LZ4_streamHCPtr</name><operator>-&gt;</operator><name>internal_donotuse</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"LZ4_loadDictHC(ctx:%p, dict:%p, dictSize:%d)"</literal></expr></argument>, <argument><expr><name>LZ4_streamHCPtr</name></expr></argument>, <argument><expr><name>dictionary</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>LZ4_streamHCPtr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>dictSize</name> <operator>&gt;</operator> <literal type="number">64</literal> <name>KB</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>dictionary</name> <operator>+=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>dictSize</name> <operator>-</operator> <literal type="number">64</literal> <name>KB</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dictSize</name> <operator>=</operator> <literal type="number">64</literal> <name>KB</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* need a full initialization, there are bad side-effects when using resetFast() */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>cLevel</name> <init>= <expr><name><name>ctxPtr</name><operator>-&gt;</operator><name>compressionLevel</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>LZ4_initStreamHC</name><argument_list>(<argument><expr><name>LZ4_streamHCPtr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>LZ4_streamHCPtr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LZ4_setCompressionLevel</name><argument_list>(<argument><expr><name>LZ4_streamHCPtr</name></expr></argument>, <argument><expr><name>cLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>LZ4HC_init_internal</name> <argument_list>(<argument><expr><name>ctxPtr</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>dictionary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctxPtr</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>dictionary</name> <operator>+</operator> <name>dictSize</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>dictSize</name> <operator>&gt;=</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>LZ4HC_Insert</name> <argument_list>(<argument><expr><name>ctxPtr</name></expr></argument>, <argument><expr><name><name>ctxPtr</name><operator>-&gt;</operator><name>end</name></name><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>dictSize</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>LZ4_attach_HC_dictionary</name><parameter_list>(<parameter><decl><type><name>LZ4_streamHC_t</name> <modifier>*</modifier></type><name>working_stream</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LZ4_streamHC_t</name> <modifier>*</modifier></type><name>dictionary_stream</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>working_stream</name><operator>-&gt;</operator><name>internal_donotuse</name><operator>.</operator><name>dictCtx</name></name> <operator>=</operator> <ternary><condition><expr><name>dictionary_stream</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><operator>&amp;</operator><operator>(</operator><name><name>dictionary_stream</name><operator>-&gt;</operator><name>internal_donotuse</name></name><operator>)</operator></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* compression */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>LZ4HC_setExternalDict</name><parameter_list>(<parameter><decl><type><name>LZ4HC_CCtx_internal</name><modifier>*</modifier></type> <name>ctxPtr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>newBlock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"LZ4HC_setExternalDict(%p, %p)"</literal></expr></argument>, <argument><expr><name>ctxPtr</name></expr></argument>, <argument><expr><name>newBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ctxPtr</name><operator>-&gt;</operator><name>end</name></name> <operator>&gt;=</operator> <name><name>ctxPtr</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name><name>ctxPtr</name><operator>-&gt;</operator><name>dictLimit</name></name> <operator>+</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>LZ4HC_Insert</name> <argument_list>(<argument><expr><name>ctxPtr</name></expr></argument>, <argument><expr><name><name>ctxPtr</name><operator>-&gt;</operator><name>end</name></name><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>   <comment type="block">/* Referencing remaining dictionary content */</comment>

    <comment type="block">/* Only one memory segment for extDict, so any previous extDict is lost at this stage */</comment>
    <expr_stmt><expr><name><name>ctxPtr</name><operator>-&gt;</operator><name>lowLimit</name></name>  <operator>=</operator> <name><name>ctxPtr</name><operator>-&gt;</operator><name>dictLimit</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctxPtr</name><operator>-&gt;</operator><name>dictLimit</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name><name>ctxPtr</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>ctxPtr</name><operator>-&gt;</operator><name>base</name></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctxPtr</name><operator>-&gt;</operator><name>dictBase</name></name>  <operator>=</operator> <name><name>ctxPtr</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctxPtr</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name>newBlock</name> <operator>-</operator> <name><name>ctxPtr</name><operator>-&gt;</operator><name>dictLimit</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctxPtr</name><operator>-&gt;</operator><name>end</name></name>  <operator>=</operator> <name>newBlock</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctxPtr</name><operator>-&gt;</operator><name>nextToUpdate</name></name> <operator>=</operator> <name><name>ctxPtr</name><operator>-&gt;</operator><name>dictLimit</name></name></expr>;</expr_stmt>   <comment type="block">/* match referencing will resume from there */</comment>

    <comment type="block">/* cannot reference an extDict and a dictCtx at the same time */</comment>
    <expr_stmt><expr><name><name>ctxPtr</name><operator>-&gt;</operator><name>dictCtx</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>LZ4_compressHC_continue_generic</name> <parameter_list>(<parameter><decl><type><name>LZ4_streamHC_t</name><modifier>*</modifier></type> <name>LZ4_streamHCPtr</name></decl></parameter>,
                                 <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>,
                                 <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>srcSizePtr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dstCapacity</name></decl></parameter>,
                                 <parameter><decl><type><name>limitedOutput_directive</name></type> <name>limit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LZ4HC_CCtx_internal</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ctxPtr</name> <init>= <expr><operator>&amp;</operator><name><name>LZ4_streamHCPtr</name><operator>-&gt;</operator><name>internal_donotuse</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"LZ4_compressHC_continue_generic(ctx=%p, src=%p, srcSize=%d, limit=%d)"</literal></expr></argument>,
                <argument><expr><name>LZ4_streamHCPtr</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>*</operator><name>srcSizePtr</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ctxPtr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* auto-init if forgotten */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>ctxPtr</name><operator>-&gt;</operator><name>base</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>LZ4HC_init_internal</name> <argument_list>(<argument><expr><name>ctxPtr</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator> <name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Check overflow */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>ctxPtr</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>ctxPtr</name><operator>-&gt;</operator><name>base</name></name><operator>)</operator> <operator>&gt;</operator> <literal type="number">2</literal> <name>GB</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>dictSize</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>ctxPtr</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>ctxPtr</name><operator>-&gt;</operator><name>base</name></name><operator>)</operator> <operator>-</operator> <name><name>ctxPtr</name><operator>-&gt;</operator><name>dictLimit</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>dictSize</name> <operator>&gt;</operator> <literal type="number">64</literal> <name>KB</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dictSize</name> <operator>=</operator> <literal type="number">64</literal> <name>KB</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>LZ4_loadDictHC</name><argument_list>(<argument><expr><name>LZ4_streamHCPtr</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>ctxPtr</name><operator>-&gt;</operator><name>end</name></name><operator>)</operator> <operator>-</operator> <name>dictSize</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>dictSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check if blocks follow each other */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name> <operator>!=</operator> <name><name>ctxPtr</name><operator>-&gt;</operator><name>end</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>LZ4HC_setExternalDict</name><argument_list>(<argument><expr><name>ctxPtr</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Check overlapping input/dictionary space */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>sourceEnd</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator> <name>src</name> <operator>+</operator> <operator>*</operator><name>srcSizePtr</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictBegin</name> <init>= <expr><name><name>ctxPtr</name><operator>-&gt;</operator><name>dictBase</name></name> <operator>+</operator> <name><name>ctxPtr</name><operator>-&gt;</operator><name>lowLimit</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictEnd</name>   <init>= <expr><name><name>ctxPtr</name><operator>-&gt;</operator><name>dictBase</name></name> <operator>+</operator> <name><name>ctxPtr</name><operator>-&gt;</operator><name>dictLimit</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>sourceEnd</name> <operator>&gt;</operator> <name>dictBegin</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name> <operator>&lt;</operator> <name>dictEnd</name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>sourceEnd</name> <operator>&gt;</operator> <name>dictEnd</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>sourceEnd</name> <operator>=</operator> <name>dictEnd</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>ctxPtr</name><operator>-&gt;</operator><name>lowLimit</name></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name>sourceEnd</name> <operator>-</operator> <name><name>ctxPtr</name><operator>-&gt;</operator><name>dictBase</name></name><operator>)</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>ctxPtr</name><operator>-&gt;</operator><name>dictLimit</name></name> <operator>-</operator> <name><name>ctxPtr</name><operator>-&gt;</operator><name>lowLimit</name></name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ctxPtr</name><operator>-&gt;</operator><name>lowLimit</name></name> <operator>=</operator> <name><name>ctxPtr</name><operator>-&gt;</operator><name>dictLimit</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>   </block_content>}</block>

    <return>return <expr><call><name>LZ4HC_compress_generic</name> <argument_list>(<argument><expr><name>ctxPtr</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcSizePtr</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name><name>ctxPtr</name><operator>-&gt;</operator><name>compressionLevel</name></name></expr></argument>, <argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>LZ4_compress_HC_continue</name> <parameter_list>(<parameter><decl><type><name>LZ4_streamHC_t</name><modifier>*</modifier></type> <name>LZ4_streamHCPtr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dstCapacity</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>dstCapacity</name> <operator>&lt;</operator> <call><name>LZ4_compressBound</name><argument_list>(<argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>LZ4_compressHC_continue_generic</name> <argument_list>(<argument><expr><name>LZ4_streamHCPtr</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>srcSize</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>limitedOutput</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><call><name>LZ4_compressHC_continue_generic</name> <argument_list>(<argument><expr><name>LZ4_streamHCPtr</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>srcSize</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>notLimited</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>LZ4_compress_HC_continue_destSize</name> <parameter_list>(<parameter><decl><type><name>LZ4_streamHC_t</name><modifier>*</modifier></type> <name>LZ4_streamHCPtr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>srcSizePtr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targetDestSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>LZ4_compressHC_continue_generic</name><argument_list>(<argument><expr><name>LZ4_streamHCPtr</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcSizePtr</name></expr></argument>, <argument><expr><name>targetDestSize</name></expr></argument>, <argument><expr><name>fillOutput</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<comment type="block">/* LZ4_saveDictHC :
 * save history content
 * into a user-provided buffer
 * which is then used to continue compression
 */</comment>
<function><type><name>int</name></type> <name>LZ4_saveDictHC</name> <parameter_list>(<parameter><decl><type><name>LZ4_streamHC_t</name><modifier>*</modifier></type> <name>LZ4_streamHCPtr</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>safeBuffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dictSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LZ4HC_CCtx_internal</name><modifier>*</modifier> <specifier>const</specifier></type> <name>streamPtr</name> <init>= <expr><operator>&amp;</operator><name><name>LZ4_streamHCPtr</name><operator>-&gt;</operator><name>internal_donotuse</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>prefixSize</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>streamPtr</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <operator>(</operator><name><name>streamPtr</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name><name>streamPtr</name><operator>-&gt;</operator><name>dictLimit</name></name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"LZ4_saveDictHC(%p, %p, %d)"</literal></expr></argument>, <argument><expr><name>LZ4_streamHCPtr</name></expr></argument>, <argument><expr><name>safeBuffer</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>prefixSize</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>dictSize</name> <operator>&gt;</operator> <literal type="number">64</literal> <name>KB</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dictSize</name> <operator>=</operator> <literal type="number">64</literal> <name>KB</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>dictSize</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dictSize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>dictSize</name> <operator>&gt;</operator> <name>prefixSize</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dictSize</name> <operator>=</operator> <name>prefixSize</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>safeBuffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dictSize</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>dictSize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>safeBuffer</name></expr></argument>, <argument><expr><name><name>streamPtr</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name>dictSize</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>endIndex</name> <init>= <expr><operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name><name>streamPtr</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>streamPtr</name><operator>-&gt;</operator><name>base</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>streamPtr</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>safeBuffer</name> <operator>+</operator> <name>dictSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>streamPtr</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name><name>streamPtr</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name>endIndex</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>streamPtr</name><operator>-&gt;</operator><name>dictLimit</name></name> <operator>=</operator> <name>endIndex</name> <operator>-</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>dictSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>streamPtr</name><operator>-&gt;</operator><name>lowLimit</name></name> <operator>=</operator> <name>endIndex</name> <operator>-</operator> <operator>(</operator><name>U32</name><operator>)</operator><name>dictSize</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>streamPtr</name><operator>-&gt;</operator><name>nextToUpdate</name></name> <operator>&lt;</operator> <name><name>streamPtr</name><operator>-&gt;</operator><name>dictLimit</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>streamPtr</name><operator>-&gt;</operator><name>nextToUpdate</name></name> <operator>=</operator> <name><name>streamPtr</name><operator>-&gt;</operator><name>dictLimit</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>
    <return>return <expr><name>dictSize</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/***************************************************
*  Deprecated Functions
***************************************************/</comment>

<comment type="block">/* These functions currently generate deprecation warnings */</comment>

<comment type="block">/* Wrappers for deprecated compression functions */</comment>
<function><type><name>int</name></type> <name>LZ4_compressHC</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcSize</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>LZ4_compress_HC</name> <argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><call><name>LZ4_compressBound</name><argument_list>(<argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>int</name></type> <name>LZ4_compressHC_limitedOutput</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxDstSize</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>LZ4_compress_HC</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>int</name></type> <name>LZ4_compressHC2</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cLevel</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>LZ4_compress_HC</name> <argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><call><name>LZ4_compressBound</name><argument_list>(<argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cLevel</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>int</name></type> <name>LZ4_compressHC2_limitedOutput</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxDstSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cLevel</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>LZ4_compress_HC</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>, <argument><expr><name>cLevel</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>int</name></type> <name>LZ4_compressHC_withStateHC</name> <parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>state</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcSize</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>LZ4_compress_HC_extStateHC</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><call><name>LZ4_compressBound</name><argument_list>(<argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>int</name></type> <name>LZ4_compressHC_limitedOutput_withStateHC</name> <parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>state</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxDstSize</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>LZ4_compress_HC_extStateHC</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>int</name></type> <name>LZ4_compressHC2_withStateHC</name> <parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>state</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cLevel</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>LZ4_compress_HC_extStateHC</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><call><name>LZ4_compressBound</name><argument_list>(<argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cLevel</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>int</name></type> <name>LZ4_compressHC2_limitedOutput_withStateHC</name> <parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>state</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxDstSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cLevel</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>LZ4_compress_HC_extStateHC</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>, <argument><expr><name>cLevel</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>int</name></type> <name>LZ4_compressHC_continue</name> <parameter_list>(<parameter><decl><type><name>LZ4_streamHC_t</name><modifier>*</modifier></type> <name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcSize</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>LZ4_compress_HC_continue</name> <argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><call><name>LZ4_compressBound</name><argument_list>(<argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>int</name></type> <name>LZ4_compressHC_limitedOutput_continue</name> <parameter_list>(<parameter><decl><type><name>LZ4_streamHC_t</name><modifier>*</modifier></type> <name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxDstSize</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>LZ4_compress_HC_continue</name> <argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>


<comment type="block">/* Deprecated streaming functions */</comment>
<function><type><name>int</name></type> <name>LZ4_sizeofStreamStateHC</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>LZ4_STREAMHCSIZE</name></expr>;</return> </block_content>}</block></function>

<comment type="block">/* state is presumed correctly sized, aka &gt;= sizeof(LZ4_streamHC_t)
 * @return : 0 on success, !=0 if error */</comment>
<function><type><name>int</name></type> <name>LZ4_resetStreamStateHC</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>inputBuffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LZ4_streamHC_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>hc4</name> <init>= <expr><call><name>LZ4_initStreamHC</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>hc4</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>hc4</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* init failed */</comment>
    <expr_stmt><expr><call><name>LZ4HC_init_internal</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>hc4</name><operator>-&gt;</operator><name>internal_donotuse</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>inputBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>LZ4_createHC</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>inputBuffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LZ4_streamHC_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>hc4</name> <init>= <expr><call><name>LZ4_createStreamHC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>hc4</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* not enough memory */</comment>
    <expr_stmt><expr><call><name>LZ4HC_init_internal</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>hc4</name><operator>-&gt;</operator><name>internal_donotuse</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>inputBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>hc4</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>LZ4_freeHC</name> <parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>LZ4HC_Data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>LZ4HC_Data</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* support free on NULL */</comment>
    <expr_stmt><expr><call><name>FREEMEM</name><argument_list>(<argument><expr><name>LZ4HC_Data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>LZ4_compressHC2_continue</name> <parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>LZ4HC_Data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>LZ4HC_compress_generic</name> <argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>LZ4_streamHC_t</name><operator>*</operator><operator>)</operator><name>LZ4HC_Data</name><operator>)</operator><operator>-&gt;</operator><name>internal_donotuse</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>srcSize</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>cLevel</name></expr></argument>, <argument><expr><name>notLimited</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>LZ4_compressHC2_limitedOutput_continue</name> <parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>LZ4HC_Data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dstCapacity</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>LZ4HC_compress_generic</name> <argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>LZ4_streamHC_t</name><operator>*</operator><operator>)</operator><name>LZ4HC_Data</name><operator>)</operator><operator>-&gt;</operator><name>internal_donotuse</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>srcSize</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>cLevel</name></expr></argument>, <argument><expr><name>limitedOutput</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name><modifier>*</modifier></type> <name>LZ4_slideInputBufferHC</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>LZ4HC_Data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LZ4_streamHC_t</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>LZ4_streamHC_t</name><operator>*</operator><operator>)</operator><name>LZ4HC_Data</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name> <modifier>*</modifier></type><name>bufferStart</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>internal_donotuse</name><operator>.</operator><name>base</name></name> <operator>+</operator> <name><name>ctx</name><operator>-&gt;</operator><name>internal_donotuse</name><operator>.</operator><name>lowLimit</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>LZ4_resetStreamHC_fast</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>internal_donotuse</name><operator>.</operator><name>compressionLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* avoid const char * -&gt; char * conversion warning :( */</comment>
    <return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>uptrval</name><operator>)</operator><name>bufferStart</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ================================================
 *  LZ4 Optimal parser (levels [LZ4HC_CLEVEL_OPT_MIN - LZ4HC_CLEVEL_MAX])
 * ===============================================*/</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>price</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>off</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>mlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>litlen</name></decl>;</decl_stmt>
}</block></struct></type> <name>LZ4HC_optimal_t</name>;</typedef>

<comment type="block">/* price in bytes */</comment>
<function><type><name>LZ4_FORCE_INLINE</name> <name>int</name></type> <name>LZ4HC_literalsPrice</name><parameter_list>(<parameter><decl><type><name>int</name> <specifier>const</specifier></type> <name>litlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>price</name> <init>= <expr><name>litlen</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>litlen</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>litlen</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>RUN_MASK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>price</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><operator>(</operator><name>litlen</name><operator>-</operator><operator>(</operator><name>int</name><operator>)</operator><name>RUN_MASK</name><operator>)</operator> <operator>/</operator> <literal type="number">255</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>price</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* requires mlen &gt;= MINMATCH */</comment>
<function><type><name>LZ4_FORCE_INLINE</name> <name>int</name></type> <name>LZ4HC_sequencePrice</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>litlen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>price</name> <init>= <expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal></expr></init></decl> ;</decl_stmt> <comment type="block">/* token + 16-bit offset */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>litlen</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>mlen</name> <operator>&gt;=</operator> <name>MINMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>price</name> <operator>+=</operator> <call><name>LZ4HC_literalsPrice</name><argument_list>(<argument><expr><name>litlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>mlen</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>ML_MASK</name><operator>+</operator><name>MINMATCH</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>price</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><operator>(</operator><name>mlen</name><operator>-</operator><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>ML_MASK</name><operator>+</operator><name>MINMATCH</name><operator>)</operator><operator>)</operator> <operator>/</operator> <literal type="number">255</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>price</name></expr>;</return>
</block_content>}</block></function>


<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>off</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
}</block></struct></type> <name>LZ4HC_match_t</name>;</typedef>

<function><type><name>LZ4_FORCE_INLINE</name> <name>LZ4HC_match_t</name></type>
<name>LZ4HC_FindLongerMatch</name><parameter_list>(<parameter><decl><type><name>LZ4HC_CCtx_internal</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ctx</name></decl></parameter>,
                      <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iHighLimit</name></decl></parameter>,
                      <parameter><decl><type><name>int</name></type> <name>minLen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nbSearches</name></decl></parameter>,
                      <parameter><decl><type><specifier>const</specifier> <name>dictCtx_directive</name></type> <name>dict</name></decl></parameter>,
                      <parameter><decl><type><specifier>const</specifier> <name>HCfavor_e</name></type> <name>favorDecSpeed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LZ4HC_match_t</name></type> <name>match</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> , <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>matchPtr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* note : LZ4HC_InsertAndGetWiderMatch() is able to modify the starting position of a match (*startpos),
     * but this won't be the case here, as we define iLowLimit==ip,
     * so LZ4HC_InsertAndGetWiderMatch() won't be allowed to search past ip */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>matchLength</name> <init>= <expr><call><name>LZ4HC_InsertAndGetWiderMatch</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iHighLimit</name></expr></argument>, <argument><expr><name>minLen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>matchPtr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ip</name></expr></argument>, <argument><expr><name>nbSearches</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> <comment type="block">/*patternAnalysis*/</comment>, <argument><expr><literal type="number">1</literal></expr></argument> <comment type="block">/*chainSwap*/</comment>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>favorDecSpeed</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>matchLength</name> <operator>&lt;=</operator> <name>minLen</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>match</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>favorDecSpeed</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>matchLength</name><operator>&gt;</operator><literal type="number">18</literal><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>matchLength</name><operator>&lt;=</operator><literal type="number">36</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>matchLength</name><operator>=</operator><literal type="number">18</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>   <comment type="block">/* favor shortcut */</comment>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>match</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>matchLength</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>match</name><operator>.</operator><name>off</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>ip</name><operator>-</operator><name>matchPtr</name><operator>)</operator></expr>;</expr_stmt>
    <return>return <expr><name>match</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>LZ4HC_compress_optimal</name> <parameter_list>( <parameter><decl><type><name>LZ4HC_CCtx_internal</name><modifier>*</modifier></type> <name>ctx</name></decl></parameter>,
                                    <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>source</name></decl></parameter>,
                                    <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>,
                                    <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>srcSizePtr</name></decl></parameter>,
                                    <parameter><decl><type><name>int</name></type> <name>dstCapacity</name></decl></parameter>,
                                    <parameter><decl><type><name>int</name> <specifier>const</specifier></type> <name>nbSearches</name></decl></parameter>,
                                    <parameter><decl><type><name>size_t</name></type> <name>sufficient_len</name></decl></parameter>,
                                    <parameter><decl><type><specifier>const</specifier> <name>limitedOutput_directive</name></type> <name>limit</name></decl></parameter>,
                                    <parameter><decl><type><name>int</name> <specifier>const</specifier></type> <name>fullUpdate</name></decl></parameter>,
                                    <parameter><decl><type><specifier>const</specifier> <name>dictCtx_directive</name></type> <name>dict</name></decl></parameter>,
                                    <parameter><decl><type><specifier>const</specifier> <name>HCfavor_e</name></type> <name>favorDecSpeed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRAILING_LITERALS</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LZ4HC_HEAPMODE</name></cpp:ifdef>
    <decl_stmt><decl><type><name>LZ4HC_optimal_t</name><modifier>*</modifier> <specifier>const</specifier></type> <name>opt</name> <init>= <expr><operator>(</operator><name>LZ4HC_optimal_t</name><operator>*</operator><operator>)</operator><call><name>ALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LZ4HC_optimal_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>LZ4_OPT_NUM</name> <operator>+</operator> <name>TRAILING_LITERALS</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>LZ4HC_optimal_t</name></type> <name><name>opt</name><index>[<expr><name>LZ4_OPT_NUM</name> <operator>+</operator> <name>TRAILING_LITERALS</name></expr>]</index></name></decl>;</decl_stmt>   <comment type="block">/* ~64 KB, which is a bit large for stack... */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator> <name>source</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>anchor</name> <init>= <expr><name>ip</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name> <init>= <expr><name>ip</name> <operator>+</operator> <operator>*</operator><name>srcSizePtr</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>mflimit</name> <init>= <expr><name>iend</name> <operator>-</operator> <name>MFLIMIT</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>matchlimit</name> <init>= <expr><name>iend</name> <operator>-</operator> <name>LASTLITERALS</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator> <name>dst</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>opSaved</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator> <name>dst</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>oend</name> <init>= <expr><name>op</name> <operator>+</operator> <name>dstCapacity</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ovml</name> <init>= <expr><name>MINMATCH</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* overflow - last sequence */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ovref</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* init */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LZ4HC_HEAPMODE</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>opt</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>_return_label</name>;</goto></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"LZ4HC_compress_optimal(dst=%p, dstCapa=%u)"</literal></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>dstCapacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>srcSizePtr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>limit</name> <operator>==</operator> <name>fillOutput</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>oend</name> <operator>-=</operator> <name>LASTLITERALS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>   <comment type="block">/* Hack for support LZ4 format restriction */</comment>
    <if_stmt><if>if <condition>(<expr><name>sufficient_len</name> <operator>&gt;=</operator> <name>LZ4_OPT_NUM</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>sufficient_len</name> <operator>=</operator> <name>LZ4_OPT_NUM</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Main Loop */</comment>
    <while>while <condition>(<expr><name>ip</name> <operator>&lt;=</operator> <name>mflimit</name></expr>)</condition> <block>{<block_content>
         <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>llen</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>anchor</name><operator>)</operator></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>int</name></type> <name>best_mlen</name></decl>, <decl><type ref="prev"/><name>best_off</name></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>int</name></type> <name>cur</name></decl>, <decl><type ref="prev"/><name>last_match_pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

         <decl_stmt><decl><type><name>LZ4HC_match_t</name> <specifier>const</specifier></type> <name>firstMatch</name> <init>= <expr><call><name>LZ4HC_FindLongerMatch</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>matchlimit</name></expr></argument>, <argument><expr><name>MINMATCH</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>nbSearches</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>favorDecSpeed</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
         <if_stmt><if>if <condition>(<expr><name><name>firstMatch</name><operator>.</operator><name>len</name></name><operator>==</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>ip</name><operator>++</operator></expr>;</expr_stmt> <continue>continue;</continue> </block_content>}</block></if></if_stmt>

         <if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>firstMatch</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <name>sufficient_len</name></expr>)</condition> <block>{<block_content>
             <comment type="block">/* good enough solution : immediate encoding */</comment>
             <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>firstML</name> <init>= <expr><name><name>firstMatch</name><operator>.</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
             <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>matchPos</name> <init>= <expr><name>ip</name> <operator>-</operator> <name><name>firstMatch</name><operator>.</operator><name>off</name></name></expr></init></decl>;</decl_stmt>
             <expr_stmt><expr><name>opSaved</name> <operator>=</operator> <name>op</name></expr>;</expr_stmt>
             <if_stmt><if>if <condition>( <expr><call><name>LZ4HC_encodeSequence</name><argument_list>(<argument><expr><call><name>UPDATABLE</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>firstML</name></expr></argument>, <argument><expr><name>matchPos</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>)</argument_list></call></expr> )</condition> <block>{<block_content>  <comment type="block">/* updates ip, op and anchor */</comment>
                 <expr_stmt><expr><name>ovml</name> <operator>=</operator> <name>firstML</name></expr>;</expr_stmt>
                 <expr_stmt><expr><name>ovref</name> <operator>=</operator> <name>matchPos</name></expr>;</expr_stmt>
                 <goto>goto <name>_dest_overflow</name>;</goto>
             </block_content>}</block></if></if_stmt>
             <continue>continue;</continue>
         </block_content>}</block></if></if_stmt>

         <comment type="block">/* set prices for first positions (literals) */</comment>
         <block>{<block_content>   <decl_stmt><decl><type><name>int</name></type> <name>rPos</name></decl>;</decl_stmt>
             <for>for <control>(<init><expr><name>rPos</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>rPos</name> <operator>&lt;</operator> <name>MINMATCH</name></expr> ;</condition> <incr><expr><name>rPos</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                 <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>cost</name> <init>= <expr><call><name>LZ4HC_literalsPrice</name><argument_list>(<argument><expr><name>llen</name> <operator>+</operator> <name>rPos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                 <expr_stmt><expr><name><name>opt</name><index>[<expr><name>rPos</name></expr>]</index></name><operator>.</operator><name>mlen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                 <expr_stmt><expr><name><name>opt</name><index>[<expr><name>rPos</name></expr>]</index></name><operator>.</operator><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                 <expr_stmt><expr><name><name>opt</name><index>[<expr><name>rPos</name></expr>]</index></name><operator>.</operator><name>litlen</name> <operator>=</operator> <name>llen</name> <operator>+</operator> <name>rPos</name></expr>;</expr_stmt>
                 <expr_stmt><expr><name><name>opt</name><index>[<expr><name>rPos</name></expr>]</index></name><operator>.</operator><name>price</name> <operator>=</operator> <name>cost</name></expr>;</expr_stmt>
                 <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"rPos:%3i =&gt; price:%3i (litlen=%i) -- initial setup"</literal></expr></argument>,
                             <argument><expr><name>rPos</name></expr></argument>, <argument><expr><name>cost</name></expr></argument>, <argument><expr><name><name>opt</name><index>[<expr><name>rPos</name></expr>]</index></name><operator>.</operator><name>litlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         </block_content>}</block></for>   </block_content>}</block>
         <comment type="block">/* set prices using initial match */</comment>
         <block>{<block_content>   <decl_stmt><decl><type><name>int</name></type> <name>mlen</name> <init>= <expr><name>MINMATCH</name></expr></init></decl>;</decl_stmt>
             <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>matchML</name> <init>= <expr><name><name>firstMatch</name><operator>.</operator><name>len</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* necessarily &lt; sufficient_len &lt; LZ4_OPT_NUM */</comment>
             <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>offset</name> <init>= <expr><name><name>firstMatch</name><operator>.</operator><name>off</name></name></expr></init></decl>;</decl_stmt>
             <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>matchML</name> <operator>&lt;</operator> <name>LZ4_OPT_NUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
             <for>for <control>( <init>;</init> <condition><expr><name>mlen</name> <operator>&lt;=</operator> <name>matchML</name></expr> ;</condition> <incr><expr><name>mlen</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                 <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>cost</name> <init>= <expr><call><name>LZ4HC_sequencePrice</name><argument_list>(<argument><expr><name>llen</name></expr></argument>, <argument><expr><name>mlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                 <expr_stmt><expr><name><name>opt</name><index>[<expr><name>mlen</name></expr>]</index></name><operator>.</operator><name>mlen</name> <operator>=</operator> <name>mlen</name></expr>;</expr_stmt>
                 <expr_stmt><expr><name><name>opt</name><index>[<expr><name>mlen</name></expr>]</index></name><operator>.</operator><name>off</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
                 <expr_stmt><expr><name><name>opt</name><index>[<expr><name>mlen</name></expr>]</index></name><operator>.</operator><name>litlen</name> <operator>=</operator> <name>llen</name></expr>;</expr_stmt>
                 <expr_stmt><expr><name><name>opt</name><index>[<expr><name>mlen</name></expr>]</index></name><operator>.</operator><name>price</name> <operator>=</operator> <name>cost</name></expr>;</expr_stmt>
                 <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"rPos:%3i =&gt; price:%3i (matchlen=%i) -- initial setup"</literal></expr></argument>,
                             <argument><expr><name>mlen</name></expr></argument>, <argument><expr><name>cost</name></expr></argument>, <argument><expr><name>mlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         </block_content>}</block></for>   </block_content>}</block>
         <expr_stmt><expr><name>last_match_pos</name> <operator>=</operator> <name><name>firstMatch</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
         <block>{<block_content>   <decl_stmt><decl><type><name>int</name></type> <name>addLit</name></decl>;</decl_stmt>
             <for>for <control>(<init><expr><name>addLit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>addLit</name> <operator>&lt;=</operator> <name>TRAILING_LITERALS</name></expr>;</condition> <incr><expr><name>addLit</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
                 <expr_stmt><expr><name><name>opt</name><index>[<expr><name>last_match_pos</name><operator>+</operator><name>addLit</name></expr>]</index></name><operator>.</operator><name>mlen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* literal */</comment>
                 <expr_stmt><expr><name><name>opt</name><index>[<expr><name>last_match_pos</name><operator>+</operator><name>addLit</name></expr>]</index></name><operator>.</operator><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                 <expr_stmt><expr><name><name>opt</name><index>[<expr><name>last_match_pos</name><operator>+</operator><name>addLit</name></expr>]</index></name><operator>.</operator><name>litlen</name> <operator>=</operator> <name>addLit</name></expr>;</expr_stmt>
                 <expr_stmt><expr><name><name>opt</name><index>[<expr><name>last_match_pos</name><operator>+</operator><name>addLit</name></expr>]</index></name><operator>.</operator><name>price</name> <operator>=</operator> <name><name>opt</name><index>[<expr><name>last_match_pos</name></expr>]</index></name><operator>.</operator><name>price</name> <operator>+</operator> <call><name>LZ4HC_literalsPrice</name><argument_list>(<argument><expr><name>addLit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                 <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"rPos:%3i =&gt; price:%3i (litlen=%i) -- initial setup"</literal></expr></argument>,
                             <argument><expr><name>last_match_pos</name><operator>+</operator><name>addLit</name></expr></argument>, <argument><expr><name><name>opt</name><index>[<expr><name>last_match_pos</name><operator>+</operator><name>addLit</name></expr>]</index></name><operator>.</operator><name>price</name></expr></argument>, <argument><expr><name>addLit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         </block_content>}</block></for>   </block_content>}</block>

         <comment type="block">/* check further positions */</comment>
         <for>for <control>(<init><expr><name>cur</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>cur</name> <operator>&lt;</operator> <name>last_match_pos</name></expr>;</condition> <incr><expr><name>cur</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
             <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>curPtr</name> <init>= <expr><name>ip</name> <operator>+</operator> <name>cur</name></expr></init></decl>;</decl_stmt>
             <decl_stmt><decl><type><name>LZ4HC_match_t</name></type> <name>newMatch</name></decl>;</decl_stmt>

             <if_stmt><if>if <condition>(<expr><name>curPtr</name> <operator>&gt;</operator> <name>mflimit</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
             <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"rPos:%u[%u] vs [%u]%u"</literal></expr></argument>,
                     <argument><expr><name>cur</name></expr></argument>, <argument><expr><name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>price</name></expr></argument>, <argument><expr><name><name>opt</name><index>[<expr><name>cur</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>price</name></expr></argument>, <argument><expr><name>cur</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
             <if_stmt><if>if <condition>(<expr><name>fullUpdate</name></expr>)</condition> <block>{<block_content>
                 <comment type="block">/* not useful to search here if next position has same (or lower) cost */</comment>
                 <if_stmt><if>if <condition>( <expr><operator>(</operator><name><name>opt</name><index>[<expr><name>cur</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>price</name> <operator>&lt;=</operator> <name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>price</name><operator>)</operator>
                   <comment type="block">/* in some cases, next position has same cost, but cost rises sharply after, so a small match would still be beneficial */</comment>
                   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>opt</name><index>[<expr><name>cur</name><operator>+</operator><name>MINMATCH</name></expr>]</index></name><operator>.</operator><name>price</name> <operator>&lt;</operator> <name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>price</name> <operator>+</operator> <literal type="number">3</literal><comment type="block">/*min seq price*/</comment><operator>)</operator></expr> )</condition><block type="pseudo"><block_content>
                     <continue>continue;</continue></block_content></block></if></if_stmt>
             </block_content>}</block></if> <else>else <block>{<block_content>
                 <comment type="block">/* not useful to search here if next position has same (or lower) cost */</comment>
                 <if_stmt><if>if <condition>(<expr><name><name>opt</name><index>[<expr><name>cur</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>price</name> <operator>&lt;=</operator> <name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>price</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
             </block_content>}</block></else></if_stmt>

             <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"search at rPos:%u"</literal></expr></argument>, <argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
             <if_stmt><if>if <condition>(<expr><name>fullUpdate</name></expr>)</condition><block type="pseudo"><block_content>
                 <expr_stmt><expr><name>newMatch</name> <operator>=</operator> <call><name>LZ4HC_FindLongerMatch</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>curPtr</name></expr></argument>, <argument><expr><name>matchlimit</name></expr></argument>, <argument><expr><name>MINMATCH</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>nbSearches</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>favorDecSpeed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
             <else>else<block type="pseudo"><block_content>
                 <comment type="block">/* only test matches of minimum length; slightly faster, but misses a few bytes */</comment>
                 <expr_stmt><expr><name>newMatch</name> <operator>=</operator> <call><name>LZ4HC_FindLongerMatch</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>curPtr</name></expr></argument>, <argument><expr><name>matchlimit</name></expr></argument>, <argument><expr><name>last_match_pos</name> <operator>-</operator> <name>cur</name></expr></argument>, <argument><expr><name>nbSearches</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>favorDecSpeed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
             <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>newMatch</name><operator>.</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

             <if_stmt><if>if <condition>( <expr><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><name><name>newMatch</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <name>sufficient_len</name><operator>)</operator>
               <operator>||</operator> <operator>(</operator><name><name>newMatch</name><operator>.</operator><name>len</name></name> <operator>+</operator> <name>cur</name> <operator>&gt;=</operator> <name>LZ4_OPT_NUM</name><operator>)</operator></expr> )</condition> <block>{<block_content>
                 <comment type="block">/* immediate encoding */</comment>
                 <expr_stmt><expr><name>best_mlen</name> <operator>=</operator> <name><name>newMatch</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
                 <expr_stmt><expr><name>best_off</name> <operator>=</operator> <name><name>newMatch</name><operator>.</operator><name>off</name></name></expr>;</expr_stmt>
                 <expr_stmt><expr><name>last_match_pos</name> <operator>=</operator> <name>cur</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                 <goto>goto <name>encode</name>;</goto>
             </block_content>}</block></if></if_stmt>

             <comment type="block">/* before match : set price with literals at beginning */</comment>
             <block>{<block_content>   <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>baseLitlen</name> <init>= <expr><name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>litlen</name></expr></init></decl>;</decl_stmt>
                 <decl_stmt><decl><type><name>int</name></type> <name>litlen</name></decl>;</decl_stmt>
                 <for>for <control>(<init><expr><name>litlen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>litlen</name> <operator>&lt;</operator> <name>MINMATCH</name></expr>;</condition> <incr><expr><name>litlen</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                     <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>price</name> <init>= <expr><name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>price</name> <operator>-</operator> <call><name>LZ4HC_literalsPrice</name><argument_list>(<argument><expr><name>baseLitlen</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>LZ4HC_literalsPrice</name><argument_list>(<argument><expr><name>baseLitlen</name><operator>+</operator><name>litlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                     <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>pos</name> <init>= <expr><name>cur</name> <operator>+</operator> <name>litlen</name></expr></init></decl>;</decl_stmt>
                     <if_stmt><if>if <condition>(<expr><name>price</name> <operator>&lt;</operator> <name><name>opt</name><index>[<expr><name>pos</name></expr>]</index></name><operator>.</operator><name>price</name></expr>)</condition> <block>{<block_content>
                         <expr_stmt><expr><name><name>opt</name><index>[<expr><name>pos</name></expr>]</index></name><operator>.</operator><name>mlen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* literal */</comment>
                         <expr_stmt><expr><name><name>opt</name><index>[<expr><name>pos</name></expr>]</index></name><operator>.</operator><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                         <expr_stmt><expr><name><name>opt</name><index>[<expr><name>pos</name></expr>]</index></name><operator>.</operator><name>litlen</name> <operator>=</operator> <name>baseLitlen</name><operator>+</operator><name>litlen</name></expr>;</expr_stmt>
                         <expr_stmt><expr><name><name>opt</name><index>[<expr><name>pos</name></expr>]</index></name><operator>.</operator><name>price</name> <operator>=</operator> <name>price</name></expr>;</expr_stmt>
                         <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"rPos:%3i =&gt; price:%3i (litlen=%i)"</literal></expr></argument>,
                                     <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>price</name></expr></argument>, <argument><expr><name><name>opt</name><index>[<expr><name>pos</name></expr>]</index></name><operator>.</operator><name>litlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
             </block_content>}</block></if></if_stmt>   </block_content>}</block></for>   </block_content>}</block>

             <comment type="block">/* set prices using match at position = cur */</comment>
             <block>{<block_content>   <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>matchML</name> <init>= <expr><name><name>newMatch</name><operator>.</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
                 <decl_stmt><decl><type><name>int</name></type> <name>ml</name> <init>= <expr><name>MINMATCH</name></expr></init></decl>;</decl_stmt>

                 <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>cur</name> <operator>+</operator> <name><name>newMatch</name><operator>.</operator><name>len</name></name> <operator>&lt;</operator> <name>LZ4_OPT_NUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                 <for>for <control>( <init>;</init> <condition><expr><name>ml</name> <operator>&lt;=</operator> <name>matchML</name></expr> ;</condition> <incr><expr><name>ml</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                     <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>pos</name> <init>= <expr><name>cur</name> <operator>+</operator> <name>ml</name></expr></init></decl>;</decl_stmt>
                     <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>offset</name> <init>= <expr><name><name>newMatch</name><operator>.</operator><name>off</name></name></expr></init></decl>;</decl_stmt>
                     <decl_stmt><decl><type><name>int</name></type> <name>price</name></decl>;</decl_stmt>
                     <decl_stmt><decl><type><name>int</name></type> <name>ll</name></decl>;</decl_stmt>
                     <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"testing price rPos %i (last_match_pos=%i)"</literal></expr></argument>,
                                 <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>last_match_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <if_stmt><if>if <condition>(<expr><name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>mlen</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                         <expr_stmt><expr><name>ll</name> <operator>=</operator> <name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>litlen</name></expr>;</expr_stmt>
                         <expr_stmt><expr><name>price</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>cur</name> <operator>&gt;</operator> <name>ll</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>opt</name><index>[<expr><name>cur</name> <operator>-</operator> <name>ll</name></expr>]</index></name><operator>.</operator><name>price</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator>
                               <operator>+</operator> <call><name>LZ4HC_sequencePrice</name><argument_list>(<argument><expr><name>ll</name></expr></argument>, <argument><expr><name>ml</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     </block_content>}</block></if> <else>else <block>{<block_content>
                         <expr_stmt><expr><name>ll</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                         <expr_stmt><expr><name>price</name> <operator>=</operator> <name><name>opt</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name>price</name> <operator>+</operator> <call><name>LZ4HC_sequencePrice</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ml</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     </block_content>}</block></else></if_stmt>

                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>favorDecSpeed</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;</operator> <name>last_match_pos</name><operator>+</operator><name>TRAILING_LITERALS</name>
                      <operator>||</operator> <name>price</name> <operator>&lt;=</operator> <name><name>opt</name><index>[<expr><name>pos</name></expr>]</index></name><operator>.</operator><name>price</name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><name>favorDecSpeed</name></expr>)</condition> <block>{<block_content>
                         <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"rPos:%3i =&gt; price:%3i (matchlen=%i)"</literal></expr></argument>,
                                     <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>price</name></expr></argument>, <argument><expr><name>ml</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                         <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pos</name> <operator>&lt;</operator> <name>LZ4_OPT_NUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                         <if_stmt><if>if <condition>( <expr><operator>(</operator><name>ml</name> <operator>==</operator> <name>matchML</name><operator>)</operator>  <comment type="block">/* last pos of last match */</comment>
                           <operator>&amp;&amp;</operator> <operator>(</operator><name>last_match_pos</name> <operator>&lt;</operator> <name>pos</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content>
                             <expr_stmt><expr><name>last_match_pos</name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                         <expr_stmt><expr><name><name>opt</name><index>[<expr><name>pos</name></expr>]</index></name><operator>.</operator><name>mlen</name> <operator>=</operator> <name>ml</name></expr>;</expr_stmt>
                         <expr_stmt><expr><name><name>opt</name><index>[<expr><name>pos</name></expr>]</index></name><operator>.</operator><name>off</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
                         <expr_stmt><expr><name><name>opt</name><index>[<expr><name>pos</name></expr>]</index></name><operator>.</operator><name>litlen</name> <operator>=</operator> <name>ll</name></expr>;</expr_stmt>
                         <expr_stmt><expr><name><name>opt</name><index>[<expr><name>pos</name></expr>]</index></name><operator>.</operator><name>price</name> <operator>=</operator> <name>price</name></expr>;</expr_stmt>
             </block_content>}</block></if></if_stmt>   </block_content>}</block></for>   </block_content>}</block>
             <comment type="block">/* complete following positions with literals */</comment>
             <block>{<block_content>   <decl_stmt><decl><type><name>int</name></type> <name>addLit</name></decl>;</decl_stmt>
                 <for>for <control>(<init><expr><name>addLit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>addLit</name> <operator>&lt;=</operator> <name>TRAILING_LITERALS</name></expr>;</condition> <incr><expr><name>addLit</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
                     <expr_stmt><expr><name><name>opt</name><index>[<expr><name>last_match_pos</name><operator>+</operator><name>addLit</name></expr>]</index></name><operator>.</operator><name>mlen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* literal */</comment>
                     <expr_stmt><expr><name><name>opt</name><index>[<expr><name>last_match_pos</name><operator>+</operator><name>addLit</name></expr>]</index></name><operator>.</operator><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                     <expr_stmt><expr><name><name>opt</name><index>[<expr><name>last_match_pos</name><operator>+</operator><name>addLit</name></expr>]</index></name><operator>.</operator><name>litlen</name> <operator>=</operator> <name>addLit</name></expr>;</expr_stmt>
                     <expr_stmt><expr><name><name>opt</name><index>[<expr><name>last_match_pos</name><operator>+</operator><name>addLit</name></expr>]</index></name><operator>.</operator><name>price</name> <operator>=</operator> <name><name>opt</name><index>[<expr><name>last_match_pos</name></expr>]</index></name><operator>.</operator><name>price</name> <operator>+</operator> <call><name>LZ4HC_literalsPrice</name><argument_list>(<argument><expr><name>addLit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"rPos:%3i =&gt; price:%3i (litlen=%i)"</literal></expr></argument>, <argument><expr><name>last_match_pos</name><operator>+</operator><name>addLit</name></expr></argument>, <argument><expr><name><name>opt</name><index>[<expr><name>last_match_pos</name><operator>+</operator><name>addLit</name></expr>]</index></name><operator>.</operator><name>price</name></expr></argument>, <argument><expr><name>addLit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
             </block_content>}</block></for>   </block_content>}</block>
         </block_content>}</block></for>  <comment type="block">/* for (cur = 1; cur &lt;= last_match_pos; cur++) */</comment>

         <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>last_match_pos</name> <operator>&lt;</operator> <name>LZ4_OPT_NUM</name> <operator>+</operator> <name>TRAILING_LITERALS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <expr_stmt><expr><name>best_mlen</name> <operator>=</operator> <name><name>opt</name><index>[<expr><name>last_match_pos</name></expr>]</index></name><operator>.</operator><name>mlen</name></expr>;</expr_stmt>
         <expr_stmt><expr><name>best_off</name> <operator>=</operator> <name><name>opt</name><index>[<expr><name>last_match_pos</name></expr>]</index></name><operator>.</operator><name>off</name></expr>;</expr_stmt>
         <expr_stmt><expr><name>cur</name> <operator>=</operator> <name>last_match_pos</name> <operator>-</operator> <name>best_mlen</name></expr>;</expr_stmt>

<label><name>encode</name>:</label> <comment type="block">/* cur, last_match_pos, best_mlen, best_off must be set */</comment>
         <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>cur</name> <operator>&lt;</operator> <name>LZ4_OPT_NUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>last_match_pos</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* == 1 when only one candidate */</comment>
         <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"reverse traversal, looking for shortest path (last_match_pos=%i)"</literal></expr></argument>, <argument><expr><name>last_match_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <block>{<block_content>   <decl_stmt><decl><type><name>int</name></type> <name>candidate_pos</name> <init>= <expr><name>cur</name></expr></init></decl>;</decl_stmt>
             <decl_stmt><decl><type><name>int</name></type> <name>selected_matchLength</name> <init>= <expr><name>best_mlen</name></expr></init></decl>;</decl_stmt>
             <decl_stmt><decl><type><name>int</name></type> <name>selected_offset</name> <init>= <expr><name>best_off</name></expr></init></decl>;</decl_stmt>
             <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* from end to beginning */</comment>
                 <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>next_matchLength</name> <init>= <expr><name><name>opt</name><index>[<expr><name>candidate_pos</name></expr>]</index></name><operator>.</operator><name>mlen</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* can be 1, means literal */</comment>
                 <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>next_offset</name> <init>= <expr><name><name>opt</name><index>[<expr><name>candidate_pos</name></expr>]</index></name><operator>.</operator><name>off</name></expr></init></decl>;</decl_stmt>
                 <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"pos %i: sequence length %i"</literal></expr></argument>, <argument><expr><name>candidate_pos</name></expr></argument>, <argument><expr><name>selected_matchLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                 <expr_stmt><expr><name><name>opt</name><index>[<expr><name>candidate_pos</name></expr>]</index></name><operator>.</operator><name>mlen</name> <operator>=</operator> <name>selected_matchLength</name></expr>;</expr_stmt>
                 <expr_stmt><expr><name><name>opt</name><index>[<expr><name>candidate_pos</name></expr>]</index></name><operator>.</operator><name>off</name> <operator>=</operator> <name>selected_offset</name></expr>;</expr_stmt>
                 <expr_stmt><expr><name>selected_matchLength</name> <operator>=</operator> <name>next_matchLength</name></expr>;</expr_stmt>
                 <expr_stmt><expr><name>selected_offset</name> <operator>=</operator> <name>next_offset</name></expr>;</expr_stmt>
                 <if_stmt><if>if <condition>(<expr><name>next_matchLength</name> <operator>&gt;</operator> <name>candidate_pos</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt> <comment type="block">/* last match elected, first match to encode */</comment>
                 <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>next_matchLength</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* can be 1, means literal */</comment>
                 <expr_stmt><expr><name>candidate_pos</name> <operator>-=</operator> <name>next_matchLength</name></expr>;</expr_stmt>
         </block_content>}</block></while>   </block_content>}</block>

         <comment type="block">/* encode all recorded sequences in order */</comment>
         <block>{<block_content>   <decl_stmt><decl><type><name>int</name></type> <name>rPos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* relative position (to ip) */</comment>
             <while>while <condition>(<expr><name>rPos</name> <operator>&lt;</operator> <name>last_match_pos</name></expr>)</condition> <block>{<block_content>
                 <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>ml</name> <init>= <expr><name><name>opt</name><index>[<expr><name>rPos</name></expr>]</index></name><operator>.</operator><name>mlen</name></expr></init></decl>;</decl_stmt>
                 <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>offset</name> <init>= <expr><name><name>opt</name><index>[<expr><name>rPos</name></expr>]</index></name><operator>.</operator><name>off</name></expr></init></decl>;</decl_stmt>
                 <if_stmt><if>if <condition>(<expr><name>ml</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>ip</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>rPos</name><operator>++</operator></expr>;</expr_stmt> <continue>continue;</continue> </block_content>}</block></if></if_stmt>  <comment type="block">/* literal; note: can end up with several literals, in which case, skip them */</comment>
                 <expr_stmt><expr><name>rPos</name> <operator>+=</operator> <name>ml</name></expr>;</expr_stmt>
                 <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ml</name> <operator>&gt;=</operator> <name>MINMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                 <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>offset</name> <operator>&gt;=</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>offset</name> <operator>&lt;=</operator> <name>LZ4_DISTANCE_MAX</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                 <expr_stmt><expr><name>opSaved</name> <operator>=</operator> <name>op</name></expr>;</expr_stmt>
                 <if_stmt><if>if <condition>( <expr><call><name>LZ4HC_encodeSequence</name><argument_list>(<argument><expr><call><name>UPDATABLE</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ml</name></expr></argument>, <argument><expr><name>ip</name> <operator>-</operator> <name>offset</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>)</argument_list></call></expr> )</condition> <block>{<block_content>  <comment type="block">/* updates ip, op and anchor */</comment>
                     <expr_stmt><expr><name>ovml</name> <operator>=</operator> <name>ml</name></expr>;</expr_stmt>
                     <expr_stmt><expr><name>ovref</name> <operator>=</operator> <name>ip</name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>
                     <goto>goto <name>_dest_overflow</name>;</goto>
         </block_content>}</block></if></if_stmt>   </block_content>}</block></while>   </block_content>}</block>
     </block_content>}</block></while>  <comment type="block">/* while (ip &lt;= mflimit) */</comment>

<label><name>_last_literals</name>:</label>
     <comment type="block">/* Encode Last Literals */</comment>
     <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name></type> <name>lastRunSize</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>iend</name> <operator>-</operator> <name>anchor</name><operator>)</operator></expr></init></decl>;</decl_stmt>  <comment type="block">/* literals */</comment>
         <decl_stmt><decl><type><name>size_t</name></type> <name>llAdd</name> <init>= <expr><operator>(</operator><name>lastRunSize</name> <operator>+</operator> <literal type="number">255</literal> <operator>-</operator> <name>RUN_MASK</name><operator>)</operator> <operator>/</operator> <literal type="number">255</literal></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>totalSize</name> <init>= <expr><literal type="number">1</literal> <operator>+</operator> <name>llAdd</name> <operator>+</operator> <name>lastRunSize</name></expr></init></decl>;</decl_stmt>
         <if_stmt><if>if <condition>(<expr><name>limit</name> <operator>==</operator> <name>fillOutput</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>oend</name> <operator>+=</operator> <name>LASTLITERALS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* restore correct value */</comment>
         <if_stmt><if>if <condition>(<expr><name>limit</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>op</name> <operator>+</operator> <name>totalSize</name> <operator>&gt;</operator> <name>oend</name><operator>)</operator></expr>)</condition> <block>{<block_content>
             <if_stmt><if>if <condition>(<expr><name>limit</name> <operator>==</operator> <name>limitedOutput</name></expr>)</condition> <block>{<block_content> <comment type="block">/* Check output limit */</comment>
                <expr_stmt><expr><name>retval</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <goto>goto <name>_return_label</name>;</goto>
             </block_content>}</block></if></if_stmt>
             <comment type="block">/* adapt lastRunSize to fill 'dst' */</comment>
             <expr_stmt><expr><name>lastRunSize</name>  <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name> <operator>-</operator> <name>op</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr> <comment type="block">/*token*/</comment>;</expr_stmt>
             <expr_stmt><expr><name>llAdd</name> <operator>=</operator> <operator>(</operator><name>lastRunSize</name> <operator>+</operator> <literal type="number">256</literal> <operator>-</operator> <name>RUN_MASK</name><operator>)</operator> <operator>/</operator> <literal type="number">256</literal></expr>;</expr_stmt>
             <expr_stmt><expr><name>lastRunSize</name> <operator>-=</operator> <name>llAdd</name></expr>;</expr_stmt>
         </block_content>}</block></if></if_stmt>
         <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"Final literal run : %i literals"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>lastRunSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <expr_stmt><expr><name>ip</name> <operator>=</operator> <name>anchor</name> <operator>+</operator> <name>lastRunSize</name></expr>;</expr_stmt> <comment type="block">/* can be != iend if limit==fillOutput */</comment>

         <if_stmt><if>if <condition>(<expr><name>lastRunSize</name> <operator>&gt;=</operator> <name>RUN_MASK</name></expr>)</condition> <block>{<block_content>
             <decl_stmt><decl><type><name>size_t</name></type> <name>accumulator</name> <init>= <expr><name>lastRunSize</name> <operator>-</operator> <name>RUN_MASK</name></expr></init></decl>;</decl_stmt>
             <expr_stmt><expr><operator>*</operator><name>op</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>RUN_MASK</name> <operator>&lt;&lt;</operator> <name>ML_BITS</name><operator>)</operator></expr>;</expr_stmt>
             <for>for<control>(<init>;</init> <condition><expr><name>accumulator</name> <operator>&gt;=</operator> <literal type="number">255</literal></expr> ;</condition> <incr><expr><name>accumulator</name> <operator>-=</operator> <literal type="number">255</literal></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>op</name><operator>++</operator> <operator>=</operator> <literal type="number">255</literal></expr>;</expr_stmt></block_content></block></for>
             <expr_stmt><expr><operator>*</operator><name>op</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator> <name>accumulator</name></expr>;</expr_stmt>
         </block_content>}</block></if> <else>else <block>{<block_content>
             <expr_stmt><expr><operator>*</operator><name>op</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator><operator>(</operator><name>lastRunSize</name> <operator>&lt;&lt;</operator> <name>ML_BITS</name><operator>)</operator></expr>;</expr_stmt>
         </block_content>}</block></else></if_stmt>
         <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>lastRunSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>lastRunSize</name></expr>;</expr_stmt>
     </block_content>}</block>

     <comment type="block">/* End */</comment>
     <expr_stmt><expr><operator>*</operator><name>srcSizePtr</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>ip</name><operator>)</operator> <operator>-</operator> <name>source</name><operator>)</operator></expr>;</expr_stmt>
     <expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>op</name><operator>-</operator><name>dst</name><operator>)</operator></expr>;</expr_stmt>
     <goto>goto <name>_return_label</name>;</goto>

<label><name>_dest_overflow</name>:</label>
<if_stmt><if>if <condition>(<expr><name>limit</name> <operator>==</operator> <name>fillOutput</name></expr>)</condition> <block>{<block_content>
     <comment type="block">/* Assumption : ip, anchor, ovml and ovref must be set correctly */</comment>
     <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>ll</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>ip</name> <operator>-</operator> <name>anchor</name><operator>)</operator></expr></init></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>ll_addbytes</name> <init>= <expr><operator>(</operator><name>ll</name> <operator>+</operator> <literal type="number">240</literal><operator>)</operator> <operator>/</operator> <literal type="number">255</literal></expr></init></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>ll_totalCost</name> <init>= <expr><literal type="number">1</literal> <operator>+</operator> <name>ll_addbytes</name> <operator>+</operator> <name>ll</name></expr></init></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>maxLitPos</name> <init>= <expr><name>oend</name> <operator>-</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* 2 for offset, 1 for token */</comment>
     <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"Last sequence overflowing (only %i bytes remaining)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>oend</name><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>opSaved</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><name>op</name> <operator>=</operator> <name>opSaved</name></expr>;</expr_stmt>  <comment type="block">/* restore correct out pointer */</comment>
     <if_stmt><if>if <condition>(<expr><name>op</name> <operator>+</operator> <name>ll_totalCost</name> <operator>&lt;=</operator> <name>maxLitPos</name></expr>)</condition> <block>{<block_content>
         <comment type="block">/* ll validated; now adjust match length */</comment>
         <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>bytesLeftForMl</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>maxLitPos</name> <operator>-</operator> <operator>(</operator><name>op</name><operator>+</operator><name>ll_totalCost</name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>maxMlSize</name> <init>= <expr><name>MINMATCH</name> <operator>+</operator> <operator>(</operator><name>ML_MASK</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>bytesLeftForMl</name> <operator>*</operator> <literal type="number">255</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
         <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>maxMlSize</name> <operator>&lt;</operator> <name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ovml</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><name>ovml</name> <operator>&gt;</operator> <name>maxMlSize</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ovml</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>maxMlSize</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
         <if_stmt><if>if <condition>(<expr><operator>(</operator><name>oend</name> <operator>+</operator> <name>LASTLITERALS</name><operator>)</operator> <operator>-</operator> <operator>(</operator><name>op</name> <operator>+</operator> <name>ll_totalCost</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal> <operator>+</operator> <name>ovml</name> <operator>&gt;=</operator> <name>MFLIMIT</name></expr>)</condition> <block>{<block_content>
             <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"Space to end : %i + ml (%i)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>oend</name> <operator>+</operator> <name>LASTLITERALS</name><operator>)</operator> <operator>-</operator> <operator>(</operator><name>op</name> <operator>+</operator> <name>ll_totalCost</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>ovml</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
             <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"Before : ip = %p, anchor = %p"</literal></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
             <expr_stmt><expr><call><name>LZ4HC_encodeSequence</name><argument_list>(<argument><expr><call><name>UPDATABLE</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ovml</name></expr></argument>, <argument><expr><name>ovref</name></expr></argument>, <argument><expr><name>notLimited</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
             <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"After : ip = %p, anchor = %p"</literal></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     </block_content>}</block></if></if_stmt>   </block_content>}</block></if></if_stmt>
     <goto>goto <name>_last_literals</name>;</goto>
</block_content>}</block></if></if_stmt>
<label><name>_return_label</name>:</label>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LZ4HC_HEAPMODE</name></cpp:ifdef>
     <expr_stmt><expr><call><name>FREEMEM</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
     <return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>
</unit>
