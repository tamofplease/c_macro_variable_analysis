<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/GraphBLAS/@GrB/private/util/gb_get_shallow.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// gb_get_shallow: create a shallow copy of a built-in sparse matrix</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// A = gb_get_shallow (X) constructs a shallow GrB_Matrix from a built-in</comment>
<comment type="line">// mxArray, which can either be a built-in sparse matrix (double, complex, or</comment>
<comment type="line">// logical) or a built-in struct that contains a GraphBLAS matrix.</comment>

<comment type="line">// X must not be NULL, but it can be an empty matrix, as X = [ ] or even X = ''</comment>
<comment type="line">// (the empty string).  In this case, A is returned as NULL.  This is not an</comment>
<comment type="line">// error here, since the caller might be getting an optional input matrix, such</comment>
<comment type="line">// as Cin or the Mask.</comment>

<comment type="line">// For v4, iso is false, and the s component has length 9.</comment>
<comment type="line">// For v5, iso is present but false, and the s component has length 10.</comment>
<comment type="line">// For v5_1, iso is true/false, and the s component has length 10.</comment>
<comment type="line">// For v7_3: the same content as v5_1, except that Yp, Yi, and Yx are added.</comment>

<comment type="line">// mxGetData is used instead of the MATLAB-recommended mxGetDoubles, etc,</comment>
<comment type="line">// because mxGetData works best for Octave, and it works fine for MATLAB</comment>
<comment type="line">// since GraphBLAS requires R2018a with the interleaved complex data type.</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gb_interface.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_make_shallow.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IF</name><parameter_list>(<parameter><type><name>error</name></type></parameter>,<parameter><type><name>message</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>CHECK_ERROR (error, "invalid GraphBLAS struct (" message ")" ) ;</cpp:value></cpp:define>

<function><type><name>GrB_Matrix</name></type> <name>gb_get_shallow</name>   <comment type="line">// return a shallow copy of built-in sparse matrix</comment>
<parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>mxArray</name> <modifier>*</modifier></type><name>X</name></decl></parameter>
)</parameter_list>
<block>{<block_content>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check inputs</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>CHECK_ERROR</name> <argument_list>(<argument><expr><name>X</name> <operator>==</operator> <name>NULL</name></expr></argument>, <argument><expr><literal type="string">"matrix missing"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// construct the shallow GrB_Matrix</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GrB_Matrix</name></type> <name>A</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>Y</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>gb_mxarray_is_empty</name> <argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// matrix is empty</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// X is a 0-by-0 built-in matrix.  Create a new 0-by-0 matrix of the</comment>
        <comment type="line">// same type as X, with the default format.</comment>
        <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GrB_Matrix_new</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>A</name></expr></argument>, <argument><expr><call><name>gb_mxarray_type</name> <argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>mxIsStruct</name> <argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// construct a shallow GrB_Matrix copy from a built-in struct</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <decl_stmt><decl><type><name>bool</name></type> <name>GraphBLASv4</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>GraphBLASv3</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>

        <comment type="line">// get the type</comment>
        <decl_stmt><decl><type><name>mxArray</name> <modifier>*</modifier></type><name>mx_type</name> <init>= <expr><call><name>mxGetField</name> <argument_list>(<argument><expr><name>X</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"GraphBLASv7_3"</literal></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>mx_type</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// check if it is a GraphBLASv5_1 struct</comment>
            <expr_stmt><expr><name>mx_type</name> <operator>=</operator> <call><name>mxGetField</name> <argument_list>(<argument><expr><name>X</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"GraphBLASv5_1"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>mx_type</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// check if it is a GraphBLASv5 struct</comment>
            <expr_stmt><expr><name>mx_type</name> <operator>=</operator> <call><name>mxGetField</name> <argument_list>(<argument><expr><name>X</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"GraphBLASv5"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>mx_type</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// check if it is a GraphBLASv4 struct</comment>
            <expr_stmt><expr><name>mx_type</name> <operator>=</operator> <call><name>mxGetField</name> <argument_list>(<argument><expr><name>X</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"GraphBLASv4"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>GraphBLASv4</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>mx_type</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// check if it is a GraphBLASv3 struct</comment>
            <expr_stmt><expr><name>mx_type</name> <operator>=</operator> <call><name>mxGetField</name> <argument_list>(<argument><expr><name>X</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"GraphBLAS"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>GraphBLASv3</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>CHECK_ERROR</name> <argument_list>(<argument><expr><name>mx_type</name> <operator>==</operator> <name>NULL</name></expr></argument>, <argument><expr><literal type="string">"not a GraphBLAS struct"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <decl_stmt><decl><type><name>GrB_Type</name></type> <name>type</name> <init>= <expr><call><name>gb_mxstring_to_type</name> <argument_list>(<argument><expr><name>mx_type</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>type_size</name></decl> ;</decl_stmt>
        <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GxB_Type_size</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>type_size</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <comment type="line">// get the scalar info</comment>
        <decl_stmt><decl><type><name>mxArray</name> <modifier>*</modifier></type><name>opaque</name> <init>= <expr><call><name>mxGetField</name> <argument_list>(<argument><expr><name>X</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"s"</literal></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
        <expr_stmt><expr><call><name>IF</name> <argument_list>(<argument><expr><name>opaque</name> <operator>==</operator> <name>NULL</name></expr></argument>, <argument><expr><literal type="string">".s missing"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>IF</name> <argument_list>(<argument><expr><call><name>mxGetM</name> <argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">".s wrong size"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>s_size</name> <init>= <expr><call><name>mxGetN</name> <argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>GraphBLASv3</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>IF</name> <argument_list>(<argument><expr><name>s_size</name> <operator>!=</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">".s wrong size"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>GraphBLASv4</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>IF</name> <argument_list>(<argument><expr><name>s_size</name> <operator>!=</operator> <literal type="number">9</literal></expr></argument>, <argument><expr><literal type="string">".s wrong size"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>IF</name> <argument_list>(<argument><expr><name>s_size</name> <operator>!=</operator> <literal type="number">10</literal></expr></argument>, <argument><expr><literal type="string">".s wrong size"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>plen</name>          <init>= <expr><name><name>s</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>vlen</name>          <init>= <expr><name><name>s</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>vdim</name>          <init>= <expr><name><name>s</name> <index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>nvec</name>          <init>= <expr><name><name>s</name> <index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>nvec_nonempty</name> <init>= <expr><name><name>s</name> <index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>    <name>by_col</name>        <init>= <expr><operator>(</operator><name>bool</name><operator>)</operator> <operator>(</operator><name><name>s</name> <index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>)</operator></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>nzmax</name>         <init>= <expr><name><name>s</name> <index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></init></decl> ;</decl_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>sparsity_status</name></decl>, <decl><type ref="prev"/><name>sparsity_control</name></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>nvals</name></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>iso</name></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>GraphBLASv3</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// GraphBLASv3 struct: sparse or hypersparse only</comment>
            <expr_stmt><expr><name>sparsity_control</name> <operator>=</operator> <name>GxB_AUTO_SPARSITY</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name>nvals</name>            <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
            <expr_stmt><expr><name>iso</name>              <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="line">// GraphBLASv4 or v5 struct: sparse, hypersparse, bitmap, or full</comment>
            <expr_stmt><expr><name>sparsity_control</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name><name>s</name> <index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>)</operator></expr> ;</expr_stmt>
            <expr_stmt><expr><name>nvals</name>            <operator>=</operator> <name><name>s</name> <index>[<expr><literal type="number">8</literal></expr>]</index></name></expr> ;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>GraphBLASv4</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// GraphBLASv4: iso is always false</comment>
                <expr_stmt><expr><name>iso</name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="line">// GraphBLASv5 and GraphBLASv5_1: iso is present as s [9]</comment>
                <comment type="line">// GraphBLASv5: iso is present as s [9] but always false</comment>
                <expr_stmt><expr><name>iso</name> <operator>=</operator> <operator>(</operator><name>bool</name><operator>)</operator> <name><name>s</name> <index>[<expr><literal type="number">9</literal></expr>]</index></name></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>nfields</name> <init>= <expr><call><name>mxGetNumberOfFields</name> <argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
        <switch>switch <condition>(<expr><name>nfields</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><literal type="number">3</literal></expr> :</case>
                <comment type="line">// A is full, with 3 fields: GraphBLAS*, s, x</comment>
                <expr_stmt><expr><name>sparsity_status</name> <operator>=</operator> <name>GxB_FULL</name></expr> ;</expr_stmt>
                <break>break ;</break>

            <case>case <expr><literal type="number">5</literal></expr> :</case>
                <comment type="line">// A is sparse, with 5 fields: GraphBLAS*, s, x, p, i</comment>
                <expr_stmt><expr><name>sparsity_status</name> <operator>=</operator> <name>GxB_SPARSE</name></expr> ;</expr_stmt>
                <break>break ;</break>

            <case>case <expr><literal type="number">6</literal></expr> :</case>
            <case>case <expr><literal type="number">9</literal></expr> :</case>
                <comment type="line">// A is hypersparse, with 6 fields: GraphBLAS*, s, x, p, i, h</comment>
                <comment type="line">// or with 9 fields: Yp, Yi, and Yx added.</comment>
                <expr_stmt><expr><name>sparsity_status</name> <operator>=</operator> <name>GxB_HYPERSPARSE</name></expr> ;</expr_stmt>
                <break>break ;</break>

            <case>case <expr><literal type="number">4</literal></expr> :</case>
                <comment type="line">// A is bitmap, with 4 fields: GraphBLAS*, s, x, b</comment>
                <expr_stmt><expr><name>sparsity_status</name> <operator>=</operator> <name>GxB_BITMAP</name></expr> ;</expr_stmt>
                <break>break ;</break>

            <default>default :</default> <expr_stmt><expr><call><name>ERROR</name> <argument_list>(<argument><expr><literal type="string">"invalid GraphBLAS struct"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></switch>

        <comment type="line">// each component</comment>
        <decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>Ap</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Ap_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>Ah</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Ah_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int8_t</name>   <modifier>*</modifier></type><name>Ab</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Ab_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>Ai</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Ai_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>void</name>     <modifier>*</modifier></type><name>Ax</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Ax_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt> 
        <decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>Yp</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Yp_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>Yi</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Yi_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>void</name>     <modifier>*</modifier></type><name>Yx</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Yx_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>yvdim</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt> 

        <if_stmt><if>if <condition>(<expr><name>sparsity_status</name> <operator>==</operator> <name>GxB_HYPERSPARSE</name> <operator>||</operator> <name>sparsity_status</name> <operator>==</operator> <name>GxB_SPARSE</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// A is hypersparse or sparse</comment>

            <comment type="line">// get Ap</comment>
            <decl_stmt><decl><type><name>mxArray</name> <modifier>*</modifier></type><name>Ap_mx</name> <init>= <expr><call><name>mxGetField</name> <argument_list>(<argument><expr><name>X</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"p"</literal></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
            <expr_stmt><expr><call><name>IF</name> <argument_list>(<argument><expr><name>Ap_mx</name> <operator>==</operator> <name>NULL</name></expr></argument>, <argument><expr><literal type="string">".p missing"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>IF</name> <argument_list>(<argument><expr><call><name>mxGetM</name> <argument_list>(<argument><expr><name>Ap_mx</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">".p wrong size"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>Ap</name> <operator>=</operator> <operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>Ap_mx</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>Ap_size</name> <operator>=</operator> <call><name>mxGetN</name> <argument_list>(<argument><expr><name>Ap_mx</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr> ;</expr_stmt>

            <comment type="line">// get Ai</comment>
            <decl_stmt><decl><type><name>mxArray</name> <modifier>*</modifier></type><name>Ai_mx</name> <init>= <expr><call><name>mxGetField</name> <argument_list>(<argument><expr><name>X</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"i"</literal></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
            <expr_stmt><expr><call><name>IF</name> <argument_list>(<argument><expr><name>Ai_mx</name> <operator>==</operator> <name>NULL</name></expr></argument>, <argument><expr><literal type="string">".i missing"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>IF</name> <argument_list>(<argument><expr><call><name>mxGetM</name> <argument_list>(<argument><expr><name>Ai_mx</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">".i wrong size"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>Ai_size</name> <operator>=</operator> <call><name>mxGetN</name> <argument_list>(<argument><expr><name>Ai_mx</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr> ;</expr_stmt>
            <expr_stmt><expr><name>Ai</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>Ai_size</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>Ai_mx</name></expr></argument>)</argument_list></call><operator>)</operator></expr></else></ternary></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// get the values</comment>
        <decl_stmt><decl><type><name>mxArray</name> <modifier>*</modifier></type><name>Ax_mx</name> <init>= <expr><call><name>mxGetField</name> <argument_list>(<argument><expr><name>X</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"x"</literal></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
        <expr_stmt><expr><call><name>IF</name> <argument_list>(<argument><expr><name>Ax_mx</name> <operator>==</operator> <name>NULL</name></expr></argument>, <argument><expr><literal type="string">".x missing"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>IF</name> <argument_list>(<argument><expr><call><name>mxGetM</name> <argument_list>(<argument><expr><name>Ax_mx</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">".x wrong size"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name>Ax_size</name> <operator>=</operator> <call><name>mxGetN</name> <argument_list>(<argument><expr><name>Ax_mx</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name>Ax</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>Ax_size</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>Ax_mx</name></expr></argument>)</argument_list></call><operator>)</operator></expr></else></ternary></expr> ;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>sparsity_status</name> <operator>==</operator> <name>GxB_HYPERSPARSE</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// A is hypersparse</comment>
            <comment type="line">// get the hyperlist</comment>
            <decl_stmt><decl><type><name>mxArray</name> <modifier>*</modifier></type><name>Ah_mx</name> <init>= <expr><call><name>mxGetField</name> <argument_list>(<argument><expr><name>X</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"h"</literal></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
            <expr_stmt><expr><call><name>IF</name> <argument_list>(<argument><expr><name>Ah_mx</name> <operator>==</operator> <name>NULL</name></expr></argument>, <argument><expr><literal type="string">".h missing"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>IF</name> <argument_list>(<argument><expr><call><name>mxGetM</name> <argument_list>(<argument><expr><name>Ah_mx</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">".h wrong size"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>Ah_size</name> <operator>=</operator> <call><name>mxGetN</name> <argument_list>(<argument><expr><name>Ah_mx</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr> ;</expr_stmt>
            <expr_stmt><expr><name>Ah</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>Ah_size</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>Ah_mx</name></expr></argument>)</argument_list></call><operator>)</operator></expr></else></ternary></expr> ;</expr_stmt>

            <comment type="line">// get the A-&gt;Y hyper_hash, if it exists</comment>

            <if_stmt><if>if <condition>(<expr><name>nfields</name> <operator>==</operator> <literal type="number">9</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// get Yp, Yi, and Yx</comment>

                <comment type="line">// Yp must be 1-by-(yvdim+1)</comment>
                <decl_stmt><decl><type><name>mxArray</name> <modifier>*</modifier></type><name>Yp_mx</name> <init>= <expr><call><name>mxGetField</name> <argument_list>(<argument><expr><name>X</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"Yp"</literal></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                <expr_stmt><expr><call><name>IF</name> <argument_list>(<argument><expr><name>Yp_mx</name> <operator>==</operator> <name>NULL</name></expr></argument>, <argument><expr><literal type="string">".Yp missing"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>IF</name> <argument_list>(<argument><expr><call><name>mxGetM</name> <argument_list>(<argument><expr><name>Yp_mx</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">".Yp wrong size"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><name>yvdim</name> <operator>=</operator> <call><name>mxGetN</name> <argument_list>(<argument><expr><name>Yp_mx</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
                <expr_stmt><expr><name>Yp_size</name> <operator>=</operator> <call><name>mxGetN</name> <argument_list>(<argument><expr><name>Yp_mx</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr> ;</expr_stmt>
                <expr_stmt><expr><name>Yp</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>Yp_size</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>Yp_mx</name></expr></argument>)</argument_list></call><operator>)</operator></expr></else></ternary></expr> ;</expr_stmt>

                <comment type="line">// Yi must be 1-by-nvec</comment>
                <decl_stmt><decl><type><name>mxArray</name> <modifier>*</modifier></type><name>Yi_mx</name> <init>= <expr><call><name>mxGetField</name> <argument_list>(<argument><expr><name>X</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"Yi"</literal></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                <expr_stmt><expr><call><name>IF</name> <argument_list>(<argument><expr><name>Yi_mx</name> <operator>==</operator> <name>NULL</name></expr></argument>, <argument><expr><literal type="string">".Yi missing"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>IF</name> <argument_list>(<argument><expr><call><name>mxGetM</name> <argument_list>(<argument><expr><name>Yi_mx</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">".Yi wrong size"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>IF</name> <argument_list>(<argument><expr><call><name>mxGetN</name> <argument_list>(<argument><expr><name>Yi_mx</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>nvec</name></expr></argument>, <argument><expr><literal type="string">".Yi wrong size"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><name>Yi_size</name> <operator>=</operator> <call><name>mxGetN</name> <argument_list>(<argument><expr><name>Yi_mx</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr> ;</expr_stmt>
                <expr_stmt><expr><name>Yi</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>Yi_size</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>Yi_mx</name></expr></argument>)</argument_list></call><operator>)</operator></expr></else></ternary></expr> ;</expr_stmt>

                <comment type="line">// Yx must be 1-by-nvec</comment>
                <decl_stmt><decl><type><name>mxArray</name> <modifier>*</modifier></type><name>Yx_mx</name> <init>= <expr><call><name>mxGetField</name> <argument_list>(<argument><expr><name>X</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"Yx"</literal></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                <expr_stmt><expr><call><name>IF</name> <argument_list>(<argument><expr><name>Yx_mx</name> <operator>==</operator> <name>NULL</name></expr></argument>, <argument><expr><literal type="string">".Yx missing"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>IF</name> <argument_list>(<argument><expr><call><name>mxGetM</name> <argument_list>(<argument><expr><name>Yx_mx</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">".Yx wrong size"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>IF</name> <argument_list>(<argument><expr><call><name>mxGetN</name> <argument_list>(<argument><expr><name>Yx_mx</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>nvec</name></expr></argument>, <argument><expr><literal type="string">".Yx wrong size"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><name>Yx_size</name> <operator>=</operator> <call><name>mxGetN</name> <argument_list>(<argument><expr><name>Yx_mx</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr> ;</expr_stmt>
                <expr_stmt><expr><name>Yx</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>Yx_size</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>Yx_mx</name></expr></argument>)</argument_list></call><operator>)</operator></expr></else></ternary></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>sparsity_status</name> <operator>==</operator> <name>GxB_BITMAP</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// A is bitmap</comment>
            <comment type="line">// get the bitmap</comment>
            <decl_stmt><decl><type><name>mxArray</name> <modifier>*</modifier></type><name>Ab_mx</name> <init>= <expr><call><name>mxGetField</name> <argument_list>(<argument><expr><name>X</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"b"</literal></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
            <expr_stmt><expr><call><name>IF</name> <argument_list>(<argument><expr><name>Ab_mx</name> <operator>==</operator> <name>NULL</name></expr></argument>, <argument><expr><literal type="string">".b missing"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>IF</name> <argument_list>(<argument><expr><call><name>mxGetM</name> <argument_list>(<argument><expr><name>Ab_mx</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">".b wrong size"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>Ab_size</name> <operator>=</operator> <call><name>mxGetN</name> <argument_list>(<argument><expr><name>Ab_mx</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>Ab</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>Ab_size</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>Ab_mx</name></expr></argument>)</argument_list></call><operator>)</operator></expr></else></ternary></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// import the matrix</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <decl_stmt><decl><type><name>int64_t</name></type> <name>nrows</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>by_col</name><operator>)</operator></expr> ?</condition><then> <expr><name>vlen</name></expr> </then><else>: <expr><name>vdim</name></expr></else></ternary></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>ncols</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>by_col</name><operator>)</operator></expr> ?</condition><then> <expr><name>vdim</name></expr> </then><else>: <expr><name>vlen</name></expr></else></ternary></expr></init></decl> ;</decl_stmt>
        <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GrB_Matrix_new</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>A</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>nrows</name></expr></argument>, <argument><expr><name>ncols</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <switch>switch <condition>(<expr><name>sparsity_status</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>GxB_FULL</name></expr> :</case>
                <if_stmt><if>if <condition>(<expr><name>by_col</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GxB_Matrix_pack_FullC</name> <argument_list>(<argument><expr><name>A</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>Ax</name></expr></argument>, <argument><expr><name>Ax_size</name></expr></argument>, <argument><expr><name>iso</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GxB_Matrix_pack_FullR</name> <argument_list>(<argument><expr><name>A</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>Ax</name></expr></argument>, <argument><expr><name>Ax_size</name></expr></argument>, <argument><expr><name>iso</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <break>break ;</break>

            <case>case <expr><name>GxB_SPARSE</name></expr> :</case>
                <if_stmt><if>if <condition>(<expr><name>by_col</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GxB_Matrix_pack_CSC</name> <argument_list>(<argument><expr><name>A</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>Ap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ai</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ax</name></expr></argument>, <argument><expr><name>Ap_size</name></expr></argument>, <argument><expr><name>Ai_size</name></expr></argument>, <argument><expr><name>Ax_size</name></expr></argument>, <argument><expr><name>iso</name></expr></argument>,
                        <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GxB_Matrix_pack_CSR</name> <argument_list>(<argument><expr><name>A</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>Ap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ai</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ax</name></expr></argument>, <argument><expr><name>Ap_size</name></expr></argument>, <argument><expr><name>Ai_size</name></expr></argument>, <argument><expr><name>Ax_size</name></expr></argument>, <argument><expr><name>iso</name></expr></argument>,
                        <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <break>break ;</break>

            <case>case <expr><name>GxB_HYPERSPARSE</name></expr> :</case>
                <if_stmt><if>if <condition>(<expr><name>by_col</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GxB_Matrix_pack_HyperCSC</name> <argument_list>(<argument><expr><name>A</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>Ap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ah</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ai</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ax</name></expr></argument>,
                        <argument><expr><name>Ap_size</name></expr></argument>, <argument><expr><name>Ah_size</name></expr></argument>, <argument><expr><name>Ai_size</name></expr></argument>, <argument><expr><name>Ax_size</name></expr></argument>, <argument><expr><name>iso</name></expr></argument>,
                        <argument><expr><name>nvec</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GxB_Matrix_pack_HyperCSR</name> <argument_list>(<argument><expr><name>A</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>Ap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ah</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ai</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ax</name></expr></argument>,
                        <argument><expr><name>Ap_size</name></expr></argument>, <argument><expr><name>Ah_size</name></expr></argument>, <argument><expr><name>Ai_size</name></expr></argument>, <argument><expr><name>Ax_size</name></expr></argument>, <argument><expr><name>iso</name></expr></argument>,
                        <argument><expr><name>nvec</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <break>break ;</break>

            <case>case <expr><name>GxB_BITMAP</name></expr> :</case>
                <if_stmt><if>if <condition>(<expr><name>by_col</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GxB_Matrix_pack_BitmapC</name> <argument_list>(<argument><expr><name>A</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>Ab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ax</name></expr></argument>, <argument><expr><name>Ab_size</name></expr></argument>, <argument><expr><name>Ax_size</name></expr></argument>, <argument><expr><name>iso</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GxB_Matrix_pack_BitmapR</name> <argument_list>(<argument><expr><name>A</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>Ab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ax</name></expr></argument>, <argument><expr><name>Ab_size</name></expr></argument>, <argument><expr><name>Ax_size</name></expr></argument>, <argument><expr><name>iso</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <break>break ;</break>

            <default>default:</default> <empty_stmt>;</empty_stmt>
        </block_content>}</block></switch>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// import the A-&gt;Y hyper_hash</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <if_stmt><if>if <condition>(<expr><name>yvdim</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// A-&gt;Y is sparse, uint64, (A-&gt;vdim)-by-yvdim, held by column</comment>
            <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GrB_Matrix_new</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Y</name></expr></argument>, <argument><expr><name>GrB_UINT64</name></expr></argument>, <argument><expr><name>vdim</name></expr></argument>, <argument><expr><name>yvdim</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GxB_Matrix_Option_set</name> <argument_list>(<argument><expr><name>Y</name></expr></argument>, <argument><expr><name>GxB_FORMAT</name></expr></argument>, <argument><expr><name>GxB_BY_COL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GxB_Matrix_pack_CSC</name> <argument_list>(<argument><expr><name>Y</name></expr></argument>,
                <argument><expr><operator>&amp;</operator><name>Yp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Yi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Yx</name></expr></argument>, <argument><expr><name>Yp_size</name></expr></argument>, <argument><expr><name>Yi_size</name></expr></argument>, <argument><expr><name>Yx_size</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GxB_Matrix_Option_set</name> <argument_list>(<argument><expr><name>Y</name></expr></argument>, <argument><expr><name>GxB_SPARSITY_CONTROL</name></expr></argument>, <argument><expr><name>GxB_SPARSE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GxB_pack_HyperHash</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Y</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// tell GraphBLAS the matrix is shallow</comment>
        <function_decl><type><name>GB</name></type> (<name>make_shallow</name>) <parameter_list>(<parameter><decl><type><name>A</name></type></decl></parameter>)</parameter_list> ;</function_decl>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// construct a shallow GrB_Matrix copy of a built-in matrix</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// get the type and dimensions</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>X_is_sparse</name> <init>= <expr><call><name>mxIsSparse</name> <argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

        <decl_stmt><decl><type><name>GrB_Type</name></type> <name>type</name> <init>= <expr><call><name>gb_mxarray_type</name> <argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>GrB_Index</name></type> <name>nrows</name> <init>= <expr><operator>(</operator><name>GrB_Index</name><operator>)</operator> <call><name>mxGetM</name> <argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>GrB_Index</name></type> <name>ncols</name> <init>= <expr><operator>(</operator><name>GrB_Index</name><operator>)</operator> <call><name>mxGetN</name> <argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
        <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GrB_Matrix_new</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>A</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>nrows</name></expr></argument>, <argument><expr><name>ncols</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <comment type="line">// get Xp, Xi, nzmax, or create them</comment>
        <decl_stmt><decl><type><name>GrB_Index</name> <modifier>*</modifier></type><name>Xp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>Xi</name></decl>, <decl><type ref="prev"/><name>nzmax</name></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>X_is_sparse</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// get the nzmax, Xp, and Xi from the built-in sparse matrix X</comment>
            <expr_stmt><expr><name>nzmax</name> <operator>=</operator> <operator>(</operator><name>GrB_Index</name><operator>)</operator> <call><name>mxGetNzmax</name> <argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>Xp</name> <operator>=</operator> <operator>(</operator><name>GrB_Index</name> <operator>*</operator><operator>)</operator> <call><name>mxGetJc</name> <argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>Xi</name> <operator>=</operator> <operator>(</operator><name>GrB_Index</name> <operator>*</operator><operator>)</operator> <call><name>mxGetIr</name> <argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content> 
            <comment type="line">// X is a built-in full matrix; so is the GrB_Matrix</comment>
            <expr_stmt><expr><name>nzmax</name> <operator>=</operator> <name>nrows</name> <operator>*</operator> <name>ncols</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name>Xp</name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name>Xi</name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="line">// get the numeric data</comment>
        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>Xx</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>type_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>GrB_FP64</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// built-in sparse or full double matrix</comment>
            <expr_stmt><expr><name>Xx</name> <operator>=</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>type_size</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>GxB_FC64</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// built-in sparse or full double complex matrix</comment>
            <expr_stmt><expr><name>Xx</name> <operator>=</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>type_size</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>GrB_BOOL</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// built-in sparse or full logical matrix</comment>
            <expr_stmt><expr><name>Xx</name> <operator>=</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>type_size</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>X_is_sparse</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Built-in sparse matrices do not support any other kinds</comment>
            <expr_stmt><expr><call><name>ERROR</name> <argument_list>(<argument><expr><literal type="string">"unsupported type"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>GrB_INT8</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// full int8 matrix</comment>
            <expr_stmt><expr><name>Xx</name> <operator>=</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>type_size</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int8_t</name></expr></argument>)</argument_list></sizeof></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>GrB_INT16</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// full int16 matrix</comment>
            <expr_stmt><expr><name>Xx</name> <operator>=</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>type_size</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int16_t</name></expr></argument>)</argument_list></sizeof></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>GrB_INT32</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// full int32 matrix</comment>
            <expr_stmt><expr><name>Xx</name> <operator>=</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>type_size</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int32_t</name></expr></argument>)</argument_list></sizeof></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>GrB_INT64</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// full int64 matrix</comment>
            <expr_stmt><expr><name>Xx</name> <operator>=</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>type_size</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>GrB_UINT8</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// full uint8 matrix</comment>
            <expr_stmt><expr><name>Xx</name> <operator>=</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>type_size</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint8_t</name></expr></argument>)</argument_list></sizeof></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>GrB_UINT16</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// full uint16 matrix</comment>
            <expr_stmt><expr><name>Xx</name> <operator>=</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>type_size</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint16_t</name></expr></argument>)</argument_list></sizeof></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>GrB_UINT32</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// full uint32 matrix</comment>
            <expr_stmt><expr><name>Xx</name> <operator>=</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>type_size</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>GrB_UINT64</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// full uint64 matrix</comment>
            <expr_stmt><expr><name>Xx</name> <operator>=</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>type_size</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>GrB_FP32</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// full single matrix</comment>
            <expr_stmt><expr><name>Xx</name> <operator>=</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>type_size</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>GxB_FC32</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// full single complex matrix</comment>
            <expr_stmt><expr><name>Xx</name> <operator>=</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>type_size</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ERROR</name> <argument_list>(<argument><expr><literal type="string">"unsupported type"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>X_is_sparse</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// import the matrix in CSC format.  This sets Xp, Xi, and Xx to</comment>
            <comment type="line">// NULL, but it does not change the built-in matrix they came from.</comment>
            <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GxB_Matrix_pack_CSC</name> <argument_list>(<argument><expr><name>A</name></expr></argument>,
                <argument><expr><operator>&amp;</operator><name>Xp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Xi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Xx</name></expr></argument>,
                <argument><expr><operator>(</operator><name>ncols</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                <argument><expr><name>nzmax</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                <argument><expr><name>nzmax</name> <operator>*</operator> <name>type_size</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content> 
            <comment type="line">// import a full matrix</comment>
            <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GxB_Matrix_pack_FullC</name> <argument_list>(<argument><expr><name>A</name></expr></argument>,
                <argument><expr><operator>&amp;</operator><name>Xx</name></expr></argument>, <argument><expr><name>nzmax</name> <operator>*</operator> <name>type_size</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="line">// tell GraphBLAS the matrix is shallow</comment>
        <function_decl><type><name>GB</name></type> (<name>make_shallow</name>) <parameter_list>(<parameter><decl><type><name>A</name></type></decl></parameter>)</parameter_list> ;</function_decl>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// return the result</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <return>return <expr><operator>(</operator><name>A</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

</unit>
