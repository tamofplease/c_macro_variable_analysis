<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/GraphBLAS/@GrB/private/mexfunctions/gbbuild.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// gbbuild: build a GraphBLAS matrix or a built-in sparse matrix</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// Usage:</comment>

<comment type="line">// A = gbbuild (I, J, X)</comment>
<comment type="line">// A = gbbuild (I, J, X, desc)</comment>
<comment type="line">// A = gbbuild (I, J, X, m, desc)</comment>
<comment type="line">// A = gbbuild (I, J, X, m, n, desc)</comment>
<comment type="line">// A = gbbuild (I, J, X, m, n, dup, desc) ;</comment>
<comment type="line">// A = gbbuild (I, J, X, m, n, dup, type, desc) ;</comment>

<comment type="line">// X and either I or J may be a scalars, in which case they are effectively</comment>
<comment type="line">// expanded so that they all have the same length.  X is only implicitly</comment>
<comment type="line">// expanded if A is built as an iso matrix.</comment>

<comment type="line">// m and n default to the largest index in I and J, respectively.</comment>

<comment type="line">// dup is a string that defaults to 'plus.xtype' where xtype is the type of X.</comment>
<comment type="line">// If dup is given by without a type,  type of dup defaults to the type of X.</comment>

<comment type="line">// If dup is the empty string '' then any duplicates result in an error.</comment>
<comment type="line">// If dup is the string 'ignore' then duplicates are ignored.</comment>

<comment type="line">// type is a string that defines is the type of A, which defaults to the type</comment>
<comment type="line">// of X.</comment>

<comment type="line">// If X is a scalar, and dup is '1st', '2nd', 'any', 'min', 'max',</comment>
<comment type="line">// 'pair' (same as 'oneb'),</comment>
<comment type="line">// 'or', 'and', 'bitor', or 'bitand', then GxB_Matrix_build_Scalar is used and</comment>
<comment type="line">// A is built as an iso matrix.  X is not explicitly expanded. This is</comment>
<comment type="line">// much faster than when using the default dup.</comment>

<comment type="line">// The descriptor is optional; if present, it must be the last input parameter.</comment>
<comment type="line">// desc.kind is the only part used from the descriptor, and it defaults to</comment>
<comment type="line">// desc.kind = 'GrB'.</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gb_interface.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USAGE</name></cpp:macro> <cpp:value>"usage: A = GrB.build (I, J, X, m, n, dup, type, desc)"</cpp:value></cpp:define>

<function><type><name>void</name></type> <name>mexFunction</name>
<parameter_list>(
    <parameter><decl><type><name>int</name></type> <name>nargout</name></decl></parameter>,
    <parameter><decl><type><name>mxArray</name> <modifier>*</modifier></type><name><name>pargout</name> <index>[ ]</index></name></decl></parameter>,
    <parameter><decl><type><name>int</name></type> <name>nargin</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>mxArray</name> <modifier>*</modifier></type><name><name>pargin</name> <index>[ ]</index></name></decl></parameter>
)</parameter_list>
<block>{<block_content>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check inputs</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>gb_usage</name> <argument_list>(<argument><expr><name>nargin</name> <operator>&gt;=</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <name>nargin</name> <operator>&lt;=</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <name>nargout</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>USAGE</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// get the descriptor</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>base_enum_t</name></type> <name>base</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>kind_enum_t</name></type> <name>kind</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GxB_Format_Value</name></type> <name>fmt</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>sparsity</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Descriptor</name></type> <name>desc</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>gb_mxarray_to_descriptor</name> <argument_list>(<argument><expr><name><name>pargin</name> <index>[<expr><name>nargin</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>kind</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fmt</name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name>sparsity</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>base</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// if present, remove the descriptor from consideration</comment>
    <if_stmt><if>if <condition>(<expr><name>desc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nargin</name><operator>--</operator></expr> ;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GrB_Descriptor_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>desc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// get I and J</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GrB_Index</name></type> <name>ni</name></decl>, <decl><type ref="prev"/><name>nj</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>I_allocated</name></decl>, <decl><type ref="prev"/><name>J_allocated</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>Imax</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>Jmax</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl> ;</decl_stmt>

    <decl_stmt><decl><type><name>GrB_Index</name> <modifier>*</modifier></type><name>I</name> <init>= <expr><operator>(</operator><name>GrB_Index</name> <operator>*</operator><operator>)</operator> <call><name>gb_mxarray_to_list</name> <argument_list>(<argument><expr><name><name>pargin</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>base</name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name>I_allocated</name></expr></argument>, <argument><expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>ni</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Imax</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

    <decl_stmt><decl><type><name>GrB_Index</name> <modifier>*</modifier></type><name>J</name> <init>= <expr><operator>(</operator><name>GrB_Index</name> <operator>*</operator><operator>)</operator> <call><name>gb_mxarray_to_list</name> <argument_list>(<argument><expr><name><name>pargin</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>base</name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name>J_allocated</name></expr></argument>, <argument><expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>nj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Jmax</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// get X</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><specifier>const</specifier> <name>mxArray</name> <modifier>*</modifier></type><name>Xm</name> <init>= <expr><name><name>pargin</name> <index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Type</name></type> <name>xtype</name> <init>= <expr><call><name>gb_mxarray_type</name> <argument_list>(<argument><expr><name>Xm</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Index</name></type> <name>nx</name> <init>= <expr><call><name>mxGetNumberOfElements</name> <argument_list>(<argument><expr><name>Xm</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check the sizes of I, J, and X, and the type of X</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GrB_Index</name></type> <name>nvals</name> <init>= <expr><call><name>MAX</name> <argument_list>(<argument><expr><name>ni</name></expr></argument>, <argument><expr><name>nj</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><name>nvals</name> <operator>=</operator> <call><name>MAX</name> <argument_list>(<argument><expr><name>nvals</name></expr></argument>, <argument><expr><name>nx</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>ni</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <name>ni</name> <operator>==</operator> <name>nvals</name><operator>)</operator> <operator>||</operator>
        <operator>!</operator><operator>(</operator><name>nj</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <name>nj</name> <operator>==</operator> <name>nvals</name><operator>)</operator> <operator>||</operator>
        <operator>!</operator><operator>(</operator><name>nx</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <name>nx</name> <operator>==</operator> <name>nvals</name><operator>)</operator></expr>)</condition>
    <block>{<block_content> 
        <expr_stmt><expr><call><name>ERROR</name> <argument_list>(<argument><expr><literal type="string">"I, J, and X must have the same length"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>CHECK_ERROR</name> <argument_list>(<argument><expr><operator>!</operator><operator>(</operator><call><name>mxIsNumeric</name> <argument_list>(<argument><expr><name>Xm</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>mxIsLogical</name> <argument_list>(<argument><expr><name>Xm</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>,
        <argument><expr><literal type="string">"X must be a numeric or logical array"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_ERROR</name> <argument_list>(<argument><expr><call><name>mxIsSparse</name> <argument_list>(<argument><expr><name>Xm</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"X cannot be sparse"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// expand any scalars in I and J (but not X)</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>ni</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>ni</name> <operator>&lt;</operator> <name>nvals</name></expr>)</condition>
    <block>{<block_content> 
        <decl_stmt><decl><type><name>GrB_Index</name> <modifier>*</modifier></type><name>I2</name> <init>= <expr><operator>(</operator><name>GrB_Index</name> <operator>*</operator><operator>)</operator> <call><name>mxMalloc</name> <argument_list>(<argument><expr><name>nvals</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>GrB_Index</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
        <expr_stmt><expr><call><name>GB_helper8</name> <argument_list>(<argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name>I2</name></expr></argument>, <argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name>I</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GrB_Index</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>I_allocated</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>gb_mxfree</name> <argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>I</name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>I_allocated</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>I</name> <operator>=</operator> <name>I2</name></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>nj</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>nj</name> <operator>&lt;</operator> <name>nvals</name></expr>)</condition>
    <block>{<block_content> 
        <decl_stmt><decl><type><name>GrB_Index</name> <modifier>*</modifier></type><name>J2</name> <init>= <expr><operator>(</operator><name>GrB_Index</name> <operator>*</operator><operator>)</operator> <call><name>mxMalloc</name> <argument_list>(<argument><expr><name>nvals</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>GrB_Index</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
        <expr_stmt><expr><call><name>GB_helper8</name> <argument_list>(<argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name>J2</name></expr></argument>, <argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name>J</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GrB_Index</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>J_allocated</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>gb_mxfree</name> <argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>J</name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>J_allocated</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>J</name> <operator>=</operator> <name>J2</name></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// get m and n if present</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GrB_Index</name></type> <name>nrows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>ncols</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>nargin</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// nrows = max entry in I + 1</comment>
        <if_stmt><if>if <condition>(<expr><name>Imax</name> <operator>&gt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// Imax already computed</comment>
            <expr_stmt><expr><name>nrows</name> <operator>=</operator> <name>Imax</name></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content> 
            <comment type="line">// nrows = max entry in I+1</comment>
            <decl_stmt><decl><type><name>bool</name></type> <name>ok</name> <init>= <expr><call><name>GB_helper4</name> <argument_list>(<argument><expr><name>I</name></expr></argument>, <argument><expr><name>ni</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nrows</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
            <expr_stmt><expr><call><name>CHECK_ERROR</name> <argument_list>(<argument><expr><operator>!</operator><name>ok</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content> 
        <comment type="line">// m is provided on input</comment>
        <expr_stmt><expr><name>nrows</name> <operator>=</operator> <call><name>gb_mxget_uint64_scalar</name> <argument_list>(<argument><expr><name><name>pargin</name> <index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"m"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>nargin</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>Jmax</name> <operator>&gt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// Jmax already computed</comment>
            <expr_stmt><expr><name>ncols</name> <operator>=</operator> <name>Jmax</name></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content> 
            <comment type="line">// ncols = max entry in J+1</comment>
            <decl_stmt><decl><type><name>bool</name></type> <name>ok</name> <init>= <expr><call><name>GB_helper4</name> <argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>nj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ncols</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
            <expr_stmt><expr><call><name>CHECK_ERROR</name> <argument_list>(<argument><expr><operator>!</operator><name>ok</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content> 
        <comment type="line">// n is provided on input</comment>
        <expr_stmt><expr><name>ncols</name> <operator>=</operator> <call><name>gb_mxget_uint64_scalar</name> <argument_list>(<argument><expr><name><name>pargin</name> <index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"n"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// get the dup operator</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// default_dup: if dup does not appear as a parameter</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>default_dup</name> <init>= <expr><operator>(</operator><name>nargin</name> <operator>&lt;</operator> <literal type="number">6</literal><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_BinaryOp</name></type> <name>dup</name> <init>= <expr><name>GxB_IGNORE_DUP</name></expr></init></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>default_dup</name></expr>)</condition>
    <block>{<block_content> 
        <expr_stmt><expr><name>dup</name> <operator>=</operator> <call><name>gb_mxstring_to_binop</name> <argument_list>(<argument><expr><name><name>pargin</name> <index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>, <argument><expr><name>xtype</name></expr></argument>, <argument><expr><name>xtype</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// if dup defaults to plus.xtype, below, or GrB_LOR for boolean</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>nice_iso_dup</name></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>default_dup</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// dup will be GrB_LOR which is nice for an iso build.  For all other</comment>
        <comment type="line">// types, the dup is plus, which is not nice.</comment>
        <expr_stmt><expr><name>nice_iso_dup</name> <operator>=</operator> <operator>(</operator><name>xtype</name> <operator>==</operator> <name>GrB_BOOL</name><operator>)</operator></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>dup</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>dup</name> <operator>==</operator> <name>GxB_IGNORE_DUP</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// if X is a scalar and dup is '' (NULL) or 'ignore' (GxB_IGNORE_DUP),</comment>
        <comment type="line">// then dup is a nice iso dup.</comment>
        <expr_stmt><expr><name>nice_iso_dup</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="line">// parse dup to see if it will build an iso matrix if X is a scalar</comment>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEN</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>
        <decl_stmt><decl><type><name>char</name></type> <name><name>sdup</name> <index>[<expr><name>LEN</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></decl> ;</decl_stmt>
        <expr_stmt><expr><call><name>gb_mxstring_to_string</name> <argument_list>(<argument><expr><name>sdup</name></expr></argument>, <argument><expr><name>LEN</name></expr></argument>, <argument><expr><name><name>pargin</name> <index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"dup"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <decl_stmt><decl><type><name>int32_t</name></type> <name><name>position</name> <index>[<expr><literal type="number">2</literal></expr>]</index></name></decl> ;</decl_stmt>
        <expr_stmt><expr><call><name>gb_find_dot</name> <argument_list>(<argument><expr><name>position</name></expr></argument>, <argument><expr><name>sdup</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>position</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>sdup</name> <index>[<expr><name><name>position</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr> ;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>nice_iso_dup</name> <operator>=</operator>
            <call><name>MATCH</name> <argument_list>(<argument><expr><name>sdup</name></expr></argument>, <argument><expr><literal type="string">"1st"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>MATCH</name> <argument_list>(<argument><expr><name>sdup</name></expr></argument>, <argument><expr><literal type="string">"first"</literal></expr></argument> )</argument_list></call> <operator>||</operator>
            <call><name>MATCH</name> <argument_list>(<argument><expr><name>sdup</name></expr></argument>, <argument><expr><literal type="string">"2nd"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>MATCH</name> <argument_list>(<argument><expr><name>sdup</name></expr></argument>, <argument><expr><literal type="string">"second"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
            <call><name>MATCH</name> <argument_list>(<argument><expr><name>sdup</name></expr></argument>, <argument><expr><literal type="string">"any"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
            <call><name>MATCH</name> <argument_list>(<argument><expr><name>sdup</name></expr></argument>, <argument><expr><literal type="string">"min"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>MATCH</name> <argument_list>(<argument><expr><name>sdup</name></expr></argument>, <argument><expr><literal type="string">"max"</literal></expr></argument>   )</argument_list></call> <operator>||</operator>
            <call><name>MATCH</name> <argument_list>(<argument><expr><name>sdup</name></expr></argument>, <argument><expr><literal type="string">"||"</literal></expr></argument> )</argument_list></call> <operator>||</operator> <call><name>MATCH</name> <argument_list>(<argument><expr><name>sdup</name></expr></argument>, <argument><expr><literal type="string">"|"</literal></expr></argument>     )</argument_list></call> <operator>||</operator>
            <call><name>MATCH</name> <argument_list>(<argument><expr><name>sdup</name></expr></argument>, <argument><expr><literal type="string">"&amp;&amp;"</literal></expr></argument> )</argument_list></call> <operator>||</operator> <call><name>MATCH</name> <argument_list>(<argument><expr><name>sdup</name></expr></argument>, <argument><expr><literal type="string">"&amp;"</literal></expr></argument>     )</argument_list></call> <operator>||</operator>
            <call><name>MATCH</name> <argument_list>(<argument><expr><name>sdup</name></expr></argument>, <argument><expr><literal type="string">"or"</literal></expr></argument> )</argument_list></call> <operator>||</operator> <call><name>MATCH</name> <argument_list>(<argument><expr><name>sdup</name></expr></argument>, <argument><expr><literal type="string">"bitor"</literal></expr></argument> )</argument_list></call> <operator>||</operator>
            <call><name>MATCH</name> <argument_list>(<argument><expr><name>sdup</name></expr></argument>, <argument><expr><literal type="string">"and"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>MATCH</name> <argument_list>(<argument><expr><name>sdup</name></expr></argument>, <argument><expr><literal type="string">"bitand"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
            <call><name>MATCH</name> <argument_list>(<argument><expr><name>sdup</name></expr></argument>, <argument><expr><literal type="string">"lor"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>MATCH</name> <argument_list>(<argument><expr><name>sdup</name></expr></argument>, <argument><expr><literal type="string">"land"</literal></expr></argument>  )</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// get the output matrix type</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GrB_Type</name></type> <name>type</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>nargin</name> <operator>&gt;</operator> <literal type="number">6</literal></expr>)</condition>
    <block>{<block_content> 
        <expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>gb_mxstring_to_type</name> <argument_list>(<argument><expr><name><name>pargin</name> <index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>CHECK_ERROR</name> <argument_list>(<argument><expr><name>type</name> <operator>==</operator> <name>NULL</name></expr></argument>, <argument><expr><literal type="string">"unknown type"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content> 
        <expr_stmt><expr><name>type</name> <operator>=</operator> <name>xtype</name></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// build the matrix</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><name>fmt</name> <operator>=</operator> <call><name>gb_get_format</name> <argument_list>(<argument><expr><name>nrows</name></expr></argument>, <argument><expr><name>ncols</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><name>sparsity</name> <operator>=</operator> <call><name>gb_get_sparsity</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sparsity</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <decl_stmt><decl><type><name>GrB_Matrix</name></type> <name>A</name> <init>= <expr><call><name>gb_new</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>nrows</name></expr></argument>, <argument><expr><name>ncols</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>sparsity</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>X2</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>X_is_scalar</name> <init>= <expr><operator>(</operator><name>nx</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>nx</name> <operator>&lt;</operator> <name>nvals</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>iso_build</name> <init>= <expr><name>X_is_scalar</name> <operator>&amp;&amp;</operator> <name>nice_iso_dup</name></expr></init></decl> ;</decl_stmt>

    <comment type="line">// mxGetData is used instead of the MATLAB-recommended mxGetDoubles, etc,</comment>
    <comment type="line">// because mxGetData works best for Octave, and it works fine for MATLAB</comment>
    <comment type="line">// since GraphBLAS requires R2018a with the interleaved complex data type.</comment>

    <if_stmt><if>if <condition>(<expr><name>iso_build</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// build an iso matrix, with no dup operator (dup is GxB_IGNORE_DUP)</comment>
        <decl_stmt><decl><type><name>GrB_Scalar</name></type> <name>x_scalar</name> <init>= <expr><operator>(</operator><name>GrB_Scalar</name><operator>)</operator> <call><name>gb_get_shallow</name> <argument_list>(<argument><expr><name>Xm</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
        <expr_stmt><expr><call><name>OK1</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>GxB_Matrix_build_Scalar</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>I</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>x_scalar</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>OK</name> <argument_list>(<argument><expr><call><name>GrB_Scalar_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>x_scalar</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>xtype</name> <operator>==</operator> <name>GrB_BOOL</name></expr>)</condition>
    <block>{<block_content> 
        <decl_stmt><decl><type><name>bool</name></type> <name>empty</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>X</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>nvals</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>&amp;</operator><name>empty</name></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>Xm</name></expr></argument>)</argument_list></call><operator>)</operator></expr></else></ternary></expr></init></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>default_dup</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dup</name> <operator>=</operator> <name>GrB_LOR</name></expr> ;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>X_is_scalar</name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><name>X2</name> <operator>=</operator> <call><name>mxMalloc</name> <argument_list>(<argument><expr><name>nvals</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_helper8</name> <argument_list>(<argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name>X2</name></expr></argument>, <argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name>X</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>X</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <name>X2</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>OK1</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>GrB_Matrix_build_BOOL</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>I</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>X</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>xtype</name> <operator>==</operator> <name>GrB_INT8</name></expr>)</condition>
    <block>{<block_content> 
        <decl_stmt><decl><type><name>int8_t</name></type> <name>empty</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int8_t</name> <modifier>*</modifier></type><name>X</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>nvals</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>&amp;</operator><name>empty</name></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>Xm</name></expr></argument>)</argument_list></call><operator>)</operator></expr></else></ternary></expr></init></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>default_dup</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dup</name> <operator>=</operator> <name>GrB_PLUS_INT8</name></expr> ;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>X_is_scalar</name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><name>X2</name> <operator>=</operator> <call><name>mxMalloc</name> <argument_list>(<argument><expr><name>nvals</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int8_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_helper8</name> <argument_list>(<argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name>X2</name></expr></argument>, <argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name>X</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>int8_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>X</name> <operator>=</operator> <operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator> <name>X2</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>OK1</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>GrB_Matrix_build_INT8</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>I</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>X</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>xtype</name> <operator>==</operator> <name>GrB_INT16</name></expr>)</condition>
    <block>{<block_content> 
        <decl_stmt><decl><type><name>int16_t</name></type> <name>empty</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>X</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>nvals</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>&amp;</operator><name>empty</name></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><name>int16_t</name> <operator>*</operator><operator>)</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>Xm</name></expr></argument>)</argument_list></call><operator>)</operator></expr></else></ternary></expr></init></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>default_dup</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dup</name> <operator>=</operator> <name>GrB_PLUS_INT16</name></expr> ;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>X_is_scalar</name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><name>X2</name> <operator>=</operator> <call><name>mxMalloc</name> <argument_list>(<argument><expr><name>nvals</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int16_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_helper8</name> <argument_list>(<argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name>X2</name></expr></argument>, <argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name>X</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>int16_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>X</name> <operator>=</operator> <operator>(</operator><name>int16_t</name> <operator>*</operator><operator>)</operator> <name>X2</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>OK1</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>GrB_Matrix_build_INT16</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>I</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>X</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>xtype</name> <operator>==</operator> <name>GrB_INT32</name></expr>)</condition>
    <block>{<block_content> 
        <decl_stmt><decl><type><name>int32_t</name></type> <name>empty</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>X</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>nvals</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>&amp;</operator><name>empty</name></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>Xm</name></expr></argument>)</argument_list></call><operator>)</operator></expr></else></ternary></expr></init></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>default_dup</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dup</name> <operator>=</operator> <name>GrB_PLUS_INT32</name></expr> ;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>X_is_scalar</name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><name>X2</name> <operator>=</operator> <call><name>mxMalloc</name> <argument_list>(<argument><expr><name>nvals</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_helper8</name> <argument_list>(<argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name>X2</name></expr></argument>, <argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name>X</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>int32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>X</name> <operator>=</operator> <operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator> <name>X2</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>OK1</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>GrB_Matrix_build_INT32</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>I</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>X</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>xtype</name> <operator>==</operator> <name>GrB_INT64</name></expr>)</condition>
    <block>{<block_content> 
        <decl_stmt><decl><type><name>int64_t</name></type> <name>empty</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>X</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>nvals</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>&amp;</operator><name>empty</name></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>Xm</name></expr></argument>)</argument_list></call><operator>)</operator></expr></else></ternary></expr></init></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>default_dup</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dup</name> <operator>=</operator> <name>GrB_PLUS_INT64</name></expr> ;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>X_is_scalar</name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><name>X2</name> <operator>=</operator> <call><name>mxMalloc</name> <argument_list>(<argument><expr><name>nvals</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_helper8</name> <argument_list>(<argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name>X2</name></expr></argument>, <argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name>X</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>X</name> <operator>=</operator> <operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator> <name>X2</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>OK1</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>GrB_Matrix_build_INT64</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>I</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>X</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>xtype</name> <operator>==</operator> <name>GrB_UINT8</name></expr>)</condition>
    <block>{<block_content> 
        <decl_stmt><decl><type><name>uint8_t</name></type> <name>empty</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>X</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>nvals</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>&amp;</operator><name>empty</name></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>Xm</name></expr></argument>)</argument_list></call><operator>)</operator></expr></else></ternary></expr></init></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>default_dup</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dup</name> <operator>=</operator> <name>GrB_PLUS_UINT8</name></expr> ;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>X_is_scalar</name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><name>X2</name> <operator>=</operator> <call><name>mxMalloc</name> <argument_list>(<argument><expr><name>nvals</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint8_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_helper8</name> <argument_list>(<argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name>X2</name></expr></argument>, <argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name>X</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint8_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>X</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator> <name>X2</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>OK1</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>GrB_Matrix_build_UINT8</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>I</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>X</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>xtype</name> <operator>==</operator> <name>GrB_UINT16</name></expr>)</condition>
    <block>{<block_content> 
        <decl_stmt><decl><type><name>uint16_t</name></type> <name>empty</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>X</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>nvals</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>&amp;</operator><name>empty</name></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>Xm</name></expr></argument>)</argument_list></call><operator>)</operator></expr></else></ternary></expr></init></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>default_dup</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dup</name> <operator>=</operator> <name>GrB_PLUS_UINT16</name></expr> ;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>X_is_scalar</name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><name>X2</name> <operator>=</operator> <call><name>mxMalloc</name> <argument_list>(<argument><expr><name>nvals</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint16_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_helper8</name> <argument_list>(<argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name>X2</name></expr></argument>, <argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name>X</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>X</name> <operator>=</operator> <operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator> <name>X2</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>OK1</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>GrB_Matrix_build_UINT16</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>I</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>X</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>xtype</name> <operator>==</operator> <name>GrB_UINT32</name></expr>)</condition>
    <block>{<block_content> 
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>empty</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>X</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>nvals</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>&amp;</operator><name>empty</name></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>Xm</name></expr></argument>)</argument_list></call><operator>)</operator></expr></else></ternary></expr></init></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>default_dup</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dup</name> <operator>=</operator> <name>GrB_PLUS_UINT32</name></expr> ;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>X_is_scalar</name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><name>X2</name> <operator>=</operator> <call><name>mxMalloc</name> <argument_list>(<argument><expr><name>nvals</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_helper8</name> <argument_list>(<argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name>X2</name></expr></argument>, <argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name>X</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>X</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator> <name>X2</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>OK1</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>GrB_Matrix_build_UINT32</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>I</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>X</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>xtype</name> <operator>==</operator> <name>GrB_UINT64</name></expr>)</condition>
    <block>{<block_content> 
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>empty</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>X</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>nvals</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>&amp;</operator><name>empty</name></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>Xm</name></expr></argument>)</argument_list></call><operator>)</operator></expr></else></ternary></expr></init></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>default_dup</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dup</name> <operator>=</operator> <name>GrB_PLUS_UINT64</name></expr> ;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>X_is_scalar</name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><name>X2</name> <operator>=</operator> <call><name>mxMalloc</name> <argument_list>(<argument><expr><name>nvals</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_helper8</name> <argument_list>(<argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name>X2</name></expr></argument>, <argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name>X</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>X</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator> <name>X2</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>OK1</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>GrB_Matrix_build_UINT64</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>I</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>X</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>xtype</name> <operator>==</operator> <name>GrB_FP32</name></expr>)</condition>
    <block>{<block_content> 
        <decl_stmt><decl><type><name>float</name></type> <name>empty</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>X</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>nvals</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>&amp;</operator><name>empty</name></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>Xm</name></expr></argument>)</argument_list></call><operator>)</operator></expr></else></ternary></expr></init></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>default_dup</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dup</name> <operator>=</operator> <name>GrB_PLUS_FP32</name></expr> ;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>X_is_scalar</name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><name>X2</name> <operator>=</operator> <call><name>mxMalloc</name> <argument_list>(<argument><expr><name>nvals</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_helper8</name> <argument_list>(<argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name>X2</name></expr></argument>, <argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name>X</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>X</name> <operator>=</operator> <operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator> <name>X2</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>OK1</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>GrB_Matrix_build_FP32</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>I</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>X</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>xtype</name> <operator>==</operator> <name>GrB_FP64</name></expr>)</condition>
    <block>{<block_content> 
        <decl_stmt><decl><type><name>double</name></type> <name>empty</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>X</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>nvals</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>&amp;</operator><name>empty</name></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>Xm</name></expr></argument>)</argument_list></call><operator>)</operator></expr></else></ternary></expr></init></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>default_dup</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dup</name> <operator>=</operator> <name>GrB_PLUS_FP64</name></expr> ;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>X_is_scalar</name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><name>X2</name> <operator>=</operator> <call><name>mxMalloc</name> <argument_list>(<argument><expr><name>nvals</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_helper8</name> <argument_list>(<argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name>X2</name></expr></argument>, <argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name>X</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>X</name> <operator>=</operator> <operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator> <name>X2</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>OK1</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>GrB_Matrix_build_FP64</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>I</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>X</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>xtype</name> <operator>==</operator> <name>GxB_FC32</name></expr>)</condition>
    <block>{<block_content> 
        <decl_stmt><decl><type><name>GxB_FC32_t</name></type> <name>empty</name> <init>= <expr><call><name>GxB_CMPLXF</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>GxB_FC32_t</name> <modifier>*</modifier></type><name>X</name> <init>= <expr><operator>&amp;</operator><name>empty</name></expr></init></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>nvals</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>X</name> <operator>=</operator> <operator>(</operator><name>GxB_FC32_t</name> <operator>*</operator><operator>)</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>Xm</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>default_dup</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dup</name> <operator>=</operator> <name>GxB_PLUS_FC32</name></expr> ;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>X_is_scalar</name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><name>X2</name> <operator>=</operator> <call><name>mxMalloc</name> <argument_list>(<argument><expr><name>nvals</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>GxB_FC32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_helper8</name> <argument_list>(<argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name>X2</name></expr></argument>, <argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name>X</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>,
                <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GxB_FC32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>X</name> <operator>=</operator> <operator>(</operator><name>GxB_FC32_t</name> <operator>*</operator><operator>)</operator> <name>X2</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>OK1</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>GxB_Matrix_build_FC32</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>I</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>X</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>xtype</name> <operator>==</operator> <name>GxB_FC64</name></expr>)</condition>
    <block>{<block_content> 
        <decl_stmt><decl><type><name>GxB_FC64_t</name></type> <name>empty</name> <init>= <expr><call><name>GxB_CMPLX</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>GxB_FC64_t</name> <modifier>*</modifier></type><name>X</name> <init>= <expr><operator>&amp;</operator><name>empty</name></expr></init></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>nvals</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>X</name> <operator>=</operator> <operator>(</operator><name>GxB_FC64_t</name> <operator>*</operator><operator>)</operator> <call><name>mxGetData</name> <argument_list>(<argument><expr><name>Xm</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>default_dup</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dup</name> <operator>=</operator> <name>GxB_PLUS_FC64</name></expr> ;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>X_is_scalar</name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><name>X2</name> <operator>=</operator> <call><name>mxMalloc</name> <argument_list>(<argument><expr><name>nvals</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>GxB_FC64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_helper8</name> <argument_list>(<argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name>X2</name></expr></argument>, <argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name>X</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>,
                <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GxB_FC64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>X</name> <operator>=</operator> <operator>(</operator><name>GxB_FC64_t</name> <operator>*</operator><operator>)</operator> <name>X2</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>OK1</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>GxB_Matrix_build_FC64</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>I</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>X</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>ERROR</name> <argument_list>(<argument><expr><literal type="string">"unsupported type"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// free workspace</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>X2</name> <operator>!=</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>gb_mxfree</name> <argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>X2</name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>I_allocated</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>gb_mxfree</name> <argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>I</name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>J_allocated</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>gb_mxfree</name> <argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>J</name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// export the output matrix A</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><name><name>pargout</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>gb_export</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>A</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>pargout</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>mxCreateDoubleScalar</name> <argument_list>(<argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><name>GB_WRAPUP</name></expr> ;</expr_stmt>
</block_content>}</block></function>

</unit>
