# 0 "/libmdbx/src/alloy.c"
# 1 "/libmdbx/build//"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 0 "<command-line>" 2
# 1 "/libmdbx/src/alloy.c"
# 15 "/libmdbx/src/alloy.c"
# 1 "/libmdbx/src/internals.h" 1
# 14 "/libmdbx/src/internals.h"
       

# 1 "/libmdbx/build/config.h" 1
# 17 "/libmdbx/src/internals.h" 2
# 130 "/libmdbx/src/internals.h"
# 1 "/libmdbx/src/../mdbx.h" 1
# 68 "/libmdbx/src/../mdbx.h"
       
# 172 "/libmdbx/src/../mdbx.h"
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stdarg.h" 3 4

# 40 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 99 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stdarg.h" 3 4
typedef __gnuc_va_list va_list;
# 173 "/libmdbx/src/../mdbx.h" 2
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 143 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 209 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 321 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 3 4
typedef unsigned int wchar_t;
# 415 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 426 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 3 4
} max_align_t;
# 174 "/libmdbx/src/../mdbx.h" 2
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 33 "/usr/include/aarch64-linux-gnu/bits/libc-header-start.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 392 "/usr/include/features.h" 3 4
# 1 "/usr/include/features-time64.h" 1 3 4
# 20 "/usr/include/features-time64.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/wordsize.h" 1 3 4
# 21 "/usr/include/features-time64.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/timesize.h" 1 3 4
# 22 "/usr/include/features-time64.h" 2 3 4
# 393 "/usr/include/features.h" 2 3 4
# 486 "/usr/include/features.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/sys/cdefs.h" 1 3 4
# 559 "/usr/include/aarch64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/wordsize.h" 1 3 4
# 560 "/usr/include/aarch64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/long-double.h" 1 3 4
# 561 "/usr/include/aarch64-linux-gnu/sys/cdefs.h" 2 3 4
# 487 "/usr/include/features.h" 2 3 4
# 510 "/usr/include/features.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/gnu/stubs.h" 1 3 4




# 1 "/usr/include/aarch64-linux-gnu/bits/wordsize.h" 1 3 4
# 6 "/usr/include/aarch64-linux-gnu/gnu/stubs.h" 2 3 4


# 1 "/usr/include/aarch64-linux-gnu/gnu/stubs-lp64.h" 1 3 4
# 9 "/usr/include/aarch64-linux-gnu/gnu/stubs.h" 2 3 4
# 511 "/usr/include/features.h" 2 3 4
# 34 "/usr/include/aarch64-linux-gnu/bits/libc-header-start.h" 2 3 4
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/aarch64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/timesize.h" 1 3 4
# 29 "/usr/include/aarch64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/aarch64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/typesizes.h" 1 3 4
# 142 "/usr/include/aarch64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/time64.h" 1 3 4
# 143 "/usr/include/aarch64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef long int __suseconds64_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 28 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/wchar.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4




# 1 "/usr/include/aarch64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 35 "/usr/include/stdint.h" 2 3 4


# 1 "/usr/include/aarch64-linux-gnu/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4





typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;


typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;





typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 71 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 87 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 101 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 10 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stdint.h" 2 3 4
# 175 "/libmdbx/src/../mdbx.h" 2
# 191 "/libmdbx/src/../mdbx.h"
# 1 "/usr/include/errno.h" 1 3 4
# 28 "/usr/include/errno.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/errno.h" 1 3 4
# 26 "/usr/include/aarch64-linux-gnu/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/aarch64-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4




# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 6 "/usr/include/asm-generic/errno.h" 2 3 4
# 2 "/usr/include/aarch64-linux-gnu/asm/errno.h" 2 3 4
# 2 "/usr/include/linux/errno.h" 2 3 4
# 27 "/usr/include/aarch64-linux-gnu/bits/errno.h" 2 3 4
# 29 "/usr/include/errno.h" 2 3 4








extern int *__errno_location (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));







extern char *program_invocation_name;
extern char *program_invocation_short_name;

# 1 "/usr/include/aarch64-linux-gnu/bits/types/error_t.h" 1 3 4
# 22 "/usr/include/aarch64-linux-gnu/bits/types/error_t.h" 3 4
typedef int error_t;
# 49 "/usr/include/errno.h" 2 3 4




# 192 "/libmdbx/src/../mdbx.h" 2
# 1 "/usr/include/pthread.h" 1 3 4
# 22 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 29 "/usr/include/sched.h" 3 4
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 30 "/usr/include/sched.h" 2 3 4

# 1 "/usr/include/aarch64-linux-gnu/bits/types/time_t.h" 1 3 4
# 10 "/usr/include/aarch64-linux-gnu/bits/types/time_t.h" 3 4
typedef __time_t time_t;
# 32 "/usr/include/sched.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/struct_timespec.h" 1 3 4





# 1 "/usr/include/aarch64-linux-gnu/bits/endian.h" 1 3 4
# 35 "/usr/include/aarch64-linux-gnu/bits/endian.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/endianness.h" 1 3 4
# 36 "/usr/include/aarch64-linux-gnu/bits/endian.h" 2 3 4
# 7 "/usr/include/aarch64-linux-gnu/bits/types/struct_timespec.h" 2 3 4




struct timespec
{



  __time_t tv_sec;




  __syscall_slong_t tv_nsec;
# 31 "/usr/include/aarch64-linux-gnu/bits/types/struct_timespec.h" 3 4
};
# 33 "/usr/include/sched.h" 2 3 4





typedef __pid_t pid_t;




# 1 "/usr/include/aarch64-linux-gnu/bits/sched.h" 1 3 4
# 76 "/usr/include/aarch64-linux-gnu/bits/sched.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/struct_sched_param.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/bits/types/struct_sched_param.h" 3 4
struct sched_param
{
  int sched_priority;
};
# 77 "/usr/include/aarch64-linux-gnu/bits/sched.h" 2 3 4





extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) __attribute__ ((__nothrow__ , __leaf__));


extern int unshare (int __flags) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_getcpu (void) __attribute__ ((__nothrow__ , __leaf__));


extern int getcpu (unsigned int *, unsigned int *) __attribute__ ((__nothrow__ , __leaf__));


extern int setns (int __fd, int __nstype) __attribute__ ((__nothrow__ , __leaf__));



# 44 "/usr/include/sched.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/cpu-set.h" 1 3 4
# 32 "/usr/include/aarch64-linux-gnu/bits/cpu-set.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 115 "/usr/include/aarch64-linux-gnu/bits/cpu-set.h" 3 4


extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
     __attribute__ ((__nothrow__ , __leaf__));
extern cpu_set_t *__sched_cpualloc (size_t __count) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
extern void __sched_cpufree (cpu_set_t *__set) __attribute__ ((__nothrow__ , __leaf__));


# 45 "/usr/include/sched.h" 2 3 4









extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     __attribute__ ((__nothrow__ , __leaf__));


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_getscheduler (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_yield (void) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_get_priority_max (int __algorithm) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_get_priority_min (int __algorithm) __attribute__ ((__nothrow__ , __leaf__));



extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) __attribute__ ((__nothrow__ , __leaf__));
# 130 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         const cpu_set_t *__cpuset) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) __attribute__ ((__nothrow__ , __leaf__));



# 23 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 30 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/aarch64-linux-gnu/bits/time.h" 1 3 4
# 73 "/usr/include/aarch64-linux-gnu/bits/time.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/timex.h" 1 3 4
# 22 "/usr/include/aarch64-linux-gnu/bits/timex.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{




  __time_t tv_sec;
  __suseconds_t tv_usec;

};
# 23 "/usr/include/aarch64-linux-gnu/bits/timex.h" 2 3 4



struct timex
{
# 58 "/usr/include/aarch64-linux-gnu/bits/timex.h" 3 4
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;

};
# 74 "/usr/include/aarch64-linux-gnu/bits/time.h" 2 3 4




extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) __attribute__ ((__nothrow__ , __leaf__));
# 90 "/usr/include/aarch64-linux-gnu/bits/time.h" 3 4

# 34 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/aarch64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 38 "/usr/include/time.h" 2 3 4

# 1 "/usr/include/aarch64-linux-gnu/bits/types/struct_tm.h" 1 3 4






struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};
# 40 "/usr/include/time.h" 2 3 4






# 1 "/usr/include/aarch64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 47 "/usr/include/time.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 48 "/usr/include/time.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/struct_itimerspec.h" 1 3 4







struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };
# 49 "/usr/include/time.h" 2 3 4
struct sigevent;
# 60 "/usr/include/time.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/aarch64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/aarch64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 61 "/usr/include/time.h" 2 3 4











extern clock_t clock (void) __attribute__ ((__nothrow__ , __leaf__));



extern time_t time (time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));


extern double difftime (time_t __time1, time_t __time0)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));
# 100 "/usr/include/time.h" 3 4
extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));




extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     __attribute__ ((__nothrow__ , __leaf__));






extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));






extern struct tm *gmtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));
# 154 "/usr/include/time.h" 3 4
extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));
# 179 "/usr/include/time.h" 3 4
extern char *asctime (const struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));



extern char *ctime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));
# 197 "/usr/include/time.h" 3 4
extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));
# 217 "/usr/include/time.h" 3 4
extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) __attribute__ ((__nothrow__ , __leaf__));



extern int daylight;
extern long int timezone;
# 249 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));

extern time_t timelocal (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));
# 262 "/usr/include/time.h" 3 4
extern int dysize (int __year) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 272 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);


extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     __attribute__ ((__nothrow__ , __leaf__));
# 311 "/usr/include/time.h" 3 4
extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);
# 326 "/usr/include/time.h" 3 4
extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __attribute__ ((__nothrow__ , __leaf__));




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_delete (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));



extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     __attribute__ ((__nothrow__ , __leaf__));
# 364 "/usr/include/time.h" 3 4
extern int timer_getoverrun (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));






extern int timespec_get (struct timespec *__ts, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 387 "/usr/include/time.h" 3 4
extern int timespec_getres (struct timespec *__ts, int __base)
     __attribute__ ((__nothrow__ , __leaf__));
# 413 "/usr/include/time.h" 3 4
extern int getdate_err;
# 422 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 436 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);



# 24 "/usr/include/pthread.h" 2 3 4


# 1 "/usr/include/aarch64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 44 "/usr/include/aarch64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 45 "/usr/include/aarch64-linux-gnu/bits/thread-shared-types.h" 2 3 4

# 1 "/usr/include/aarch64-linux-gnu/bits/atomic_wide_counter.h" 1 3 4
# 25 "/usr/include/aarch64-linux-gnu/bits/atomic_wide_counter.h" 3 4
typedef union
{
  __extension__ unsigned long long int __value64;
  struct
  {
    unsigned int __low;
    unsigned int __high;
  } __value32;
} __atomic_wide_counter;
# 47 "/usr/include/aarch64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
# 76 "/usr/include/aarch64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/struct_mutex.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/bits/struct_mutex.h" 3 4
struct __pthread_mutex_s
{
  int __lock ;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;
# 58 "/usr/include/aarch64-linux-gnu/bits/struct_mutex.h" 3 4
  int __kind;




  int __spins;
  __pthread_list_t __list;
# 74 "/usr/include/aarch64-linux-gnu/bits/struct_mutex.h" 3 4
};
# 77 "/usr/include/aarch64-linux-gnu/bits/thread-shared-types.h" 2 3 4
# 89 "/usr/include/aarch64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/struct_rwlock.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/bits/struct_rwlock.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;
  int __cur_writer;
  int __shared;
  unsigned long int __pad1;
  unsigned long int __pad2;
  unsigned int __flags;
};
# 90 "/usr/include/aarch64-linux-gnu/bits/thread-shared-types.h" 2 3 4




struct __pthread_cond_s
{
  __atomic_wide_counter __wseq;
  __atomic_wide_counter __g1_start;
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};

typedef unsigned int __tss_t;
typedef unsigned long int __thrd_t;

typedef struct
{
  int __data ;
} __once_flag;
# 24 "/usr/include/aarch64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[8];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[8];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[64];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[48];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[8];
  int __align;
} pthread_barrierattr_t;
# 27 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/setjmp.h" 1 3 4
# 30 "/usr/include/aarch64-linux-gnu/bits/setjmp.h" 3 4
__extension__ typedef unsigned long long __jmp_buf [22];
# 28 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/pthread.h" 2 3 4

# 1 "/usr/include/aarch64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 31 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/struct___jmp_buf_tag.h" 1 3 4
# 26 "/usr/include/aarch64-linux-gnu/bits/types/struct___jmp_buf_tag.h" 3 4
struct __jmp_buf_tag
  {




    __jmp_buf __jmpbuf;
    int __mask_was_saved;
    __sigset_t __saved_mask;
  };
# 32 "/usr/include/pthread.h" 2 3 4

# 1 "/usr/include/aarch64-linux-gnu/bits/pthread_stack_min-dynamic.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/bits/pthread_stack_min-dynamic.h" 3 4

extern long int __sysconf (int __name) __attribute__ ((__nothrow__ , __leaf__));

# 34 "/usr/include/pthread.h" 2 3 4



enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 104 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 124 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 159 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 197 "/usr/include/pthread.h" 3 4





extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) __attribute__ ((__nothrow__ , __leaf__));
# 233 "/usr/include/pthread.h" 3 4
extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     const struct timespec *__abstime);
# 243 "/usr/include/pthread.h" 3 4
extern int pthread_clockjoin_np (pthread_t __th, void **__thread_return,
                                 clockid_t __clockid,
     const struct timespec *__abstime);
# 269 "/usr/include/pthread.h" 3 4
extern int pthread_detach (pthread_t __th) __attribute__ ((__nothrow__ , __leaf__));



extern pthread_t pthread_self (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));







extern int pthread_attr_init (pthread_attr_t *__attr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     const cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));


extern int pthread_getattr_default_np (pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_setsigmask_np (pthread_attr_t *__attr,
           const __sigset_t *sigmask);




extern int pthread_attr_getsigmask_np (const pthread_attr_t *__attr,
           __sigset_t *sigmask);







extern int pthread_setattr_default_np (const pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     __attribute__ ((__nothrow__ , __leaf__));




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) __attribute__ ((__nothrow__ , __leaf__));


extern int pthread_setconcurrency (int __level) __attribute__ ((__nothrow__ , __leaf__));



extern int pthread_yield (void) __attribute__ ((__nothrow__ , __leaf__));

extern int pthread_yield (void) __asm__ ("" "sched_yield") __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__deprecated__ ("pthread_yield is deprecated, use sched_yield instead")))
                                                      ;







extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       const cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
# 509 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 521 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




struct __cancel_jmp_buf_tag
{
  __jmp_buf __cancel_jmp_buf;
  int __mask_was_saved;
};

typedef struct
{
  struct __cancel_jmp_buf_tag __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 557 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};
# 624 "/usr/include/pthread.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) void
__pthread_cleanup_routine (struct __pthread_cleanup_frame *__frame)
{
  if (__frame->__do_it)
    __frame->__cancel_routine (__frame->__cancel_arg);
}
# 766 "/usr/include/pthread.h" 3 4
extern int __sigsetjmp_cancel (struct __cancel_jmp_buf_tag __env[1], int __savemask) __asm__ ("" "__sigsetjmp") __attribute__ ((__nothrow__))


                     __attribute__ ((__returns_twice__));
# 781 "/usr/include/pthread.h" 3 4
extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));




extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
# 817 "/usr/include/pthread.h" 3 4
extern int pthread_mutex_clocklock (pthread_mutex_t *__restrict __mutex,
        clockid_t __clockid,
        const struct timespec *__restrict
        __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3)));
# 835 "/usr/include/pthread.h" 3 4
extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_consistent_np (pthread_mutex_t *) __asm__ ("" "pthread_mutex_consistent") __attribute__ ((__nothrow__ , __leaf__))
                                __attribute__ ((__nonnull__ (1)))
  __attribute__ ((__deprecated__ ("pthread_mutex_consistent_np is deprecated, use pthread_mutex_consistent")))
                                                                         ;
# 874 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_getrobust_np (pthread_mutexattr_t *, int *) __asm__ ("" "pthread_mutexattr_getrobust") __attribute__ ((__nothrow__ , __leaf__))

                                   __attribute__ ((__nonnull__ (1)))
  __attribute__ ((__deprecated__ ("pthread_mutexattr_getrobust_np is deprecated, use pthread_mutexattr_getrobust")))
                                                                               ;






extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *, int) __asm__ ("" "pthread_mutexattr_setrobust") __attribute__ ((__nothrow__ , __leaf__))

                                   __attribute__ ((__nonnull__ (1)))
  __attribute__ ((__deprecated__ ("pthread_mutexattr_setrobust_np is deprecated, use pthread_mutexattr_setrobust")))
                                                                               ;
# 967 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));




extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
# 1004 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_clockrdlock (pthread_rwlock_t *__restrict __rwlock,
           clockid_t __clockid,
           const struct timespec *__restrict
           __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3)));
# 1023 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));




extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
# 1051 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_clockwrlock (pthread_rwlock_t *__restrict __rwlock,
           clockid_t __clockid,
           const struct timespec *__restrict
           __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3)));
# 1071 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 1145 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));
# 1171 "/usr/include/pthread.h" 3 4
extern int pthread_cond_clockwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       __clockid_t __clock_id,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 4)));
# 1194 "/usr/include/pthread.h" 3 4
extern int pthread_condattr_init (pthread_condattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 1230 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 1297 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) __attribute__ ((__nothrow__ , __leaf__));


extern void *pthread_getspecific (pthread_key_t __key) __attribute__ ((__nothrow__ , __leaf__));


extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__access__ (__none__, 2)));




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
# 1332 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) __attribute__ ((__nothrow__ , __leaf__));




extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) pthread_equal (pthread_t __thread1, pthread_t __thread2)
{
  return __thread1 == __thread2;
}



# 193 "/libmdbx/src/../mdbx.h" 2
# 1 "/usr/include/aarch64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/sys/types.h" 3 4






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;


typedef __loff_t loff_t;






typedef __ino64_t ino_t;




typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;







typedef __off64_t off_t;




typedef __off64_t off64_t;
# 103 "/usr/include/aarch64-linux-gnu/sys/types.h" 3 4
typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 134 "/usr/include/aarch64-linux-gnu/sys/types.h" 3 4
typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 145 "/usr/include/aarch64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;







typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;


typedef int register_t __attribute__ ((__mode__ (__word__)));
# 176 "/usr/include/aarch64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 35 "/usr/include/endian.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/byteswap.h" 1 3 4
# 33 "/usr/include/aarch64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{

  return __builtin_bswap16 (__bsx);



}






static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{

  return __builtin_bswap32 (__bsx);



}
# 69 "/usr/include/aarch64-linux-gnu/bits/byteswap.h" 3 4
__extension__ static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{

  return __builtin_bswap64 (__bsx);



}
# 36 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/aarch64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 37 "/usr/include/endian.h" 2 3 4
# 177 "/usr/include/aarch64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/aarch64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/aarch64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/select.h" 1 3 4
# 31 "/usr/include/aarch64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/aarch64-linux-gnu/bits/types/sigset_t.h" 1 3 4






typedef __sigset_t sigset_t;
# 34 "/usr/include/aarch64-linux-gnu/sys/select.h" 2 3 4
# 49 "/usr/include/aarch64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/aarch64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/aarch64-linux-gnu/sys/select.h" 3 4

# 102 "/usr/include/aarch64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 127 "/usr/include/aarch64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 150 "/usr/include/aarch64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/select2.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/select2.h" 3 4
extern long int __fdelt_chk (long int __d);
extern long int __fdelt_warn (long int __d)
  __attribute__((__warning__ ("bit outside of fd_set selected")));
# 151 "/usr/include/aarch64-linux-gnu/sys/select.h" 2 3 4



# 180 "/usr/include/aarch64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;
# 205 "/usr/include/aarch64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt_t;



typedef __fsblkcnt64_t fsblkcnt_t;



typedef __fsfilcnt64_t fsfilcnt_t;





typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;
# 230 "/usr/include/aarch64-linux-gnu/sys/types.h" 3 4

# 194 "/libmdbx/src/../mdbx.h" 2
# 1 "/usr/include/aarch64-linux-gnu/sys/uio.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/sys/uio.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/struct_iovec.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/bits/types/struct_iovec.h" 3 4
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/types/struct_iovec.h" 2 3 4


struct iovec
  {
    void *iov_base;
    size_t iov_len;
  };
# 24 "/usr/include/aarch64-linux-gnu/sys/uio.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/uio_lim.h" 1 3 4
# 25 "/usr/include/aarch64-linux-gnu/sys/uio.h" 2 3 4







# 41 "/usr/include/aarch64-linux-gnu/sys/uio.h" 3 4
extern ssize_t readv (int __fd, const struct iovec *__iovec, int __count)
  __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__read_only__, 2, 3)));
# 52 "/usr/include/aarch64-linux-gnu/sys/uio.h" 3 4
extern ssize_t writev (int __fd, const struct iovec *__iovec, int __count)
  __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__read_only__, 2, 3)));
# 86 "/usr/include/aarch64-linux-gnu/sys/uio.h" 3 4
extern ssize_t preadv (int __fd, const struct iovec *__iovec, int __count, __off64_t __offset) __asm__ ("" "preadv64")


  __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__read_only__, 2, 3)));
extern ssize_t pwritev (int __fd, const struct iovec *__iovec, int __count, __off64_t __offset) __asm__ ("" "pwritev64")


  __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__read_only__, 2, 3)));
# 110 "/usr/include/aarch64-linux-gnu/sys/uio.h" 3 4
extern ssize_t preadv64 (int __fd, const struct iovec *__iovec, int __count,
    __off64_t __offset)
  __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__read_only__, 2, 3)));
# 123 "/usr/include/aarch64-linux-gnu/sys/uio.h" 3 4
extern ssize_t pwritev64 (int __fd, const struct iovec *__iovec, int __count,
     __off64_t __offset)
  __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__read_only__, 2, 3)));
# 143 "/usr/include/aarch64-linux-gnu/sys/uio.h" 3 4
extern ssize_t pwritev2 (int __fd, const struct iovec *__iovec, int __count, __off64_t __offset, int __flags) __asm__ ("" "pwritev64v2")



  __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__read_only__, 2, 3)));
extern ssize_t preadv2 (int __fd, const struct iovec *__iovec, int __count, __off64_t __offset, int __flags) __asm__ ("" "preadv64v2")



  __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__read_only__, 2, 3)));
# 161 "/usr/include/aarch64-linux-gnu/sys/uio.h" 3 4
extern ssize_t preadv64v2 (int __fp, const struct iovec *__iovec,
      int __count, __off64_t __offset,
      int ___flags)
  __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__read_only__, 2, 3)));


extern ssize_t pwritev64v2 (int __fd, const struct iovec *__iodev,
       int __count, __off64_t __offset,
       int __flags)
  __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__read_only__, 2, 3)));








# 1 "/usr/include/aarch64-linux-gnu/bits/uio-ext.h" 1 3 4
# 26 "/usr/include/aarch64-linux-gnu/bits/uio-ext.h" 3 4



extern ssize_t process_vm_readv (pid_t __pid, const struct iovec *__lvec,
     unsigned long int __liovcnt,
     const struct iovec *__rvec,
     unsigned long int __riovcnt,
     unsigned long int __flags)
  __attribute__ ((__nothrow__ , __leaf__));


extern ssize_t process_vm_writev (pid_t __pid, const struct iovec *__lvec,
      unsigned long int __liovcnt,
      const struct iovec *__rvec,
      unsigned long int __riovcnt,
      unsigned long int __flags)
  __attribute__ ((__nothrow__ , __leaf__));
# 51 "/usr/include/aarch64-linux-gnu/bits/uio-ext.h" 3 4

# 180 "/usr/include/aarch64-linux-gnu/sys/uio.h" 2 3 4
# 195 "/libmdbx/src/../mdbx.h" 2


# 196 "/libmdbx/src/../mdbx.h"
typedef int mdbx_filehandle_t;
typedef pid_t mdbx_pid_t;
typedef pthread_t mdbx_tid_t;
typedef mode_t mdbx_mode_t;
# 613 "/libmdbx/src/../mdbx.h"
extern __attribute__((__visibility__("default"))) const struct MDBX_version_info {
  uint8_t major;
  uint8_t minor;
  uint16_t release;
  uint32_t revision;
  struct {
    const char *datetime;
    const char *tree;
    const char *commit;
    const char *describe;
  } git;
  const char *sourcery;
} mdbx_version;




extern __attribute__((__visibility__("default"))) const struct MDBX_build_info {
  const char *datetime;
  const char *target;
  const char *options;
  const char *compiler;
  const char *flags;
} mdbx_build;
# 692 "/libmdbx/src/../mdbx.h"
typedef struct MDBX_env MDBX_env;
# 703 "/libmdbx/src/../mdbx.h"
typedef struct MDBX_txn MDBX_txn;
# 715 "/libmdbx/src/../mdbx.h"
typedef uint32_t MDBX_dbi;






typedef struct MDBX_cursor MDBX_cursor;
# 760 "/libmdbx/src/../mdbx.h"
typedef struct iovec MDBX_val;


enum MDBX_constants {

  MDBX_MAX_DBI = 32765U,


  MDBX_MAXDATASIZE = 0x7fff0000U,


  MDBX_MIN_PAGESIZE = 256,


  MDBX_MAX_PAGESIZE = 65536,
};
# 797 "/libmdbx/src/../mdbx.h"
enum MDBX_log_level_t {



  MDBX_LOG_FATAL = 0,





  MDBX_LOG_ERROR = 1,





  MDBX_LOG_WARN = 2,





  MDBX_LOG_NOTICE = 3,




  MDBX_LOG_VERBOSE = 4,




  MDBX_LOG_DEBUG = 5,




  MDBX_LOG_TRACE = 6,




  MDBX_LOG_EXTRA = 7,






  MDBX_LOG_DONTCHANGE = -1
};

typedef enum MDBX_log_level_t MDBX_log_level_t;







enum MDBX_debug_flags_t {
  MDBX_DBG_NONE = 0,




  MDBX_DBG_ASSERT = 1,



  MDBX_DBG_AUDIT = 2,



  MDBX_DBG_JITTER = 4,



  MDBX_DBG_DUMP = 8,


  MDBX_DBG_LEGACY_MULTIOPEN = 16,


  MDBX_DBG_LEGACY_OVERLAP = 32,




  MDBX_DBG_DONT_UPGRADE = 64,







  MDBX_DBG_DONTCHANGE = -1
};

typedef enum MDBX_debug_flags_t MDBX_debug_flags_t;
# 908 "/libmdbx/src/../mdbx.h"
typedef void MDBX_debug_func(MDBX_log_level_t loglevel, const char *function,
                             int line, const char *fmt,
                             va_list args) ;







__attribute__((__visibility__("default"))) int mdbx_setup_debug(MDBX_log_level_t log_level,
                                 MDBX_debug_flags_t debug_flags,
                                 MDBX_debug_func *logger);







typedef void MDBX_assert_func(const MDBX_env *env, const char *msg,
                              const char *function,
                              unsigned line) ;
# 941 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_env_set_assert(MDBX_env *env, MDBX_assert_func *func);
# 952 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) const char *mdbx_dump_val(const MDBX_val *key, char *const buf,
                                      const size_t bufsize);


__attribute__((__visibility__("default"))) void mdbx_panic(const char *fmt, ...) __attribute__((__format__(__printf__, 1, 2)));







enum MDBX_env_flags_t {
  MDBX_ENV_DEFAULTS = 0,
# 983 "/libmdbx/src/../mdbx.h"
  MDBX_NOSUBDIR = 0x4000U,
# 1001 "/libmdbx/src/../mdbx.h"
  MDBX_RDONLY = 0x20000U,
# 1031 "/libmdbx/src/../mdbx.h"
  MDBX_EXCLUSIVE = 0x400000U,
# 1046 "/libmdbx/src/../mdbx.h"
  MDBX_ACCEDE = 0x40000000U,
# 1077 "/libmdbx/src/../mdbx.h"
  MDBX_WRITEMAP = 0x80000U,
# 1100 "/libmdbx/src/../mdbx.h"
  MDBX_NOTLS = 0x200000U,
# 1121 "/libmdbx/src/../mdbx.h"
  MDBX_NORDAHEAD = 0x800000U,
# 1144 "/libmdbx/src/../mdbx.h"
  MDBX_NOMEMINIT = 0x1000000U,
# 1156 "/libmdbx/src/../mdbx.h"
  MDBX_COALESCE = 0x2000000U,
# 1180 "/libmdbx/src/../mdbx.h"
  MDBX_LIFORECLAIM = 0x4000000U,


  MDBX_PAGEPERTURB = 0x8000000U,
# 1237 "/libmdbx/src/../mdbx.h"
  MDBX_SYNC_DURABLE = 0,
# 1255 "/libmdbx/src/../mdbx.h"
  MDBX_NOMETASYNC = 0x40000U,
# 1306 "/libmdbx/src/../mdbx.h"
  MDBX_SAFE_NOSYNC = 0x10000U,






  MDBX_MAPASYNC = MDBX_SAFE_NOSYNC,
# 1356 "/libmdbx/src/../mdbx.h"
  MDBX_UTTERLY_NOSYNC = MDBX_SAFE_NOSYNC | 0x100000U,


};


typedef enum MDBX_env_flags_t MDBX_env_flags_t;
# 1371 "/libmdbx/src/../mdbx.h"
enum MDBX_txn_flags_t {




  MDBX_TXN_READWRITE = 0,





  MDBX_TXN_RDONLY = MDBX_RDONLY,
# 1391 "/libmdbx/src/../mdbx.h"
  MDBX_TXN_RDONLY_PREPARE = MDBX_RDONLY | MDBX_NOMEMINIT,





  MDBX_TXN_TRY = 0x10000000U,



  MDBX_TXN_NOMETASYNC = MDBX_NOMETASYNC,



  MDBX_TXN_NOSYNC = MDBX_SAFE_NOSYNC
};

typedef enum MDBX_txn_flags_t MDBX_txn_flags_t;
# 1417 "/libmdbx/src/../mdbx.h"
enum MDBX_db_flags_t {

  MDBX_DB_DEFAULTS = 0,


  MDBX_REVERSEKEY = 0x02U,


  MDBX_DUPSORT = 0x04U,






  MDBX_INTEGERKEY = 0x08U,



  MDBX_DUPFIXED = 0x10U,




  MDBX_INTEGERDUP = 0x20U,


  MDBX_REVERSEDUP = 0x40U,


  MDBX_CREATE = 0x40000U,
# 1459 "/libmdbx/src/../mdbx.h"
  MDBX_DB_ACCEDE = MDBX_ACCEDE
};


typedef enum MDBX_db_flags_t MDBX_db_flags_t;
# 1472 "/libmdbx/src/../mdbx.h"
enum MDBX_put_flags_t {

  MDBX_UPSERT = 0,


  MDBX_NOOVERWRITE = 0x10U,




  MDBX_NODUPDATA = 0x20U,





  MDBX_CURRENT = 0x40U,




  MDBX_ALLDUPS = 0x80U,



  MDBX_RESERVE = 0x10000U,



  MDBX_APPEND = 0x20000U,




  MDBX_APPENDDUP = 0x40000U,



  MDBX_MULTIPLE = 0x80000U
};


typedef enum MDBX_put_flags_t MDBX_put_flags_t;







enum MDBX_copy_flags_t {
  MDBX_CP_DEFAULTS = 0,



  MDBX_CP_COMPACT = 1u,


  MDBX_CP_FORCE_DYNAMIC_SIZE = 2u
};


typedef enum MDBX_copy_flags_t MDBX_copy_flags_t;
# 1543 "/libmdbx/src/../mdbx.h"
enum MDBX_cursor_op {

  MDBX_FIRST,


  MDBX_FIRST_DUP,


  MDBX_GET_BOTH,



  MDBX_GET_BOTH_RANGE,


  MDBX_GET_CURRENT,




  MDBX_GET_MULTIPLE,


  MDBX_LAST,


  MDBX_LAST_DUP,


  MDBX_NEXT,


  MDBX_NEXT_DUP,




  MDBX_NEXT_MULTIPLE,


  MDBX_NEXT_NODUP,


  MDBX_PREV,


  MDBX_PREV_DUP,


  MDBX_PREV_NODUP,


  MDBX_SET,


  MDBX_SET_KEY,


  MDBX_SET_RANGE,



  MDBX_PREV_MULTIPLE,
# 1619 "/libmdbx/src/../mdbx.h"
  MDBX_SET_LOWERBOUND,
# 1633 "/libmdbx/src/../mdbx.h"
  MDBX_SET_UPPERBOUND
};


typedef enum MDBX_cursor_op MDBX_cursor_op;







enum MDBX_error_t {

  MDBX_SUCCESS = 0,


  MDBX_RESULT_FALSE = MDBX_SUCCESS,


  MDBX_RESULT_TRUE = -1,


  MDBX_KEYEXIST = -30799,


  MDBX_FIRST_LMDB_ERRCODE = MDBX_KEYEXIST,


  MDBX_NOTFOUND = -30798,


  MDBX_PAGE_NOTFOUND = -30797,


  MDBX_CORRUPTED = -30796,



  MDBX_PANIC = -30795,


  MDBX_VERSION_MISMATCH = -30794,


  MDBX_INVALID = -30793,


  MDBX_MAP_FULL = -30792,


  MDBX_DBS_FULL = -30791,


  MDBX_READERS_FULL = -30790,


  MDBX_TXN_FULL = -30788,



  MDBX_CURSOR_FULL = -30787,


  MDBX_PAGE_FULL = -30786,
# 1706 "/libmdbx/src/../mdbx.h"
  MDBX_UNABLE_EXTEND_MAPSIZE = -30785,
# 1716 "/libmdbx/src/../mdbx.h"
  MDBX_INCOMPATIBLE = -30784,



  MDBX_BAD_RSLOT = -30783,



  MDBX_BAD_TXN = -30782,



  MDBX_BAD_VALSIZE = -30781,



  MDBX_BAD_DBI = -30780,


  MDBX_PROBLEM = -30779,


  MDBX_LAST_LMDB_ERRCODE = MDBX_PROBLEM,



  MDBX_BUSY = -30778,


  MDBX_FIRST_ADDED_ERRCODE = MDBX_BUSY,


  MDBX_EMULTIVAL = -30421,




  MDBX_EBADSIGN = -30420,



  MDBX_WANNA_RECOVERY = -30419,


  MDBX_EKEYMISMATCH = -30418,



  MDBX_TOO_LARGE = -30417,



  MDBX_THREAD_MISMATCH = -30416,


  MDBX_TXN_OVERLAPPING = -30415,


  MDBX_LAST_ADDED_ERRCODE = MDBX_TXN_OVERLAPPING,
# 1790 "/libmdbx/src/../mdbx.h"
  MDBX_ENODATA = 
# 1790 "/libmdbx/src/../mdbx.h" 3 4
                61
# 1790 "/libmdbx/src/../mdbx.h"
                       ,



  MDBX_EINVAL = 
# 1794 "/libmdbx/src/../mdbx.h" 3 4
               22
# 1794 "/libmdbx/src/../mdbx.h"
                     ,
  MDBX_EACCESS = 
# 1795 "/libmdbx/src/../mdbx.h" 3 4
                13
# 1795 "/libmdbx/src/../mdbx.h"
                      ,
  MDBX_ENOMEM = 
# 1796 "/libmdbx/src/../mdbx.h" 3 4
               12
# 1796 "/libmdbx/src/../mdbx.h"
                     ,
  MDBX_EROFS = 
# 1797 "/libmdbx/src/../mdbx.h" 3 4
              30
# 1797 "/libmdbx/src/../mdbx.h"
                   ,
  MDBX_ENOSYS = 
# 1798 "/libmdbx/src/../mdbx.h" 3 4
               38
# 1798 "/libmdbx/src/../mdbx.h"
                     ,
  MDBX_EIO = 
# 1799 "/libmdbx/src/../mdbx.h" 3 4
            5
# 1799 "/libmdbx/src/../mdbx.h"
               ,
  MDBX_EPERM = 
# 1800 "/libmdbx/src/../mdbx.h" 3 4
              1
# 1800 "/libmdbx/src/../mdbx.h"
                   ,
  MDBX_EINTR = 
# 1801 "/libmdbx/src/../mdbx.h" 3 4
              4
# 1801 "/libmdbx/src/../mdbx.h"
                   ,
  MDBX_ENOFILE = 
# 1802 "/libmdbx/src/../mdbx.h" 3 4
                2
# 1802 "/libmdbx/src/../mdbx.h"
                      ,
  MDBX_EREMOTE = 
# 1803 "/libmdbx/src/../mdbx.h" 3 4
                15


# 1805 "/libmdbx/src/../mdbx.h"
};


typedef enum MDBX_error_t MDBX_error_t;






__attribute__((__deprecated__)) static __inline int MDBX_MAP_RESIZED_is_deprecated() {
  return MDBX_UNABLE_EXTEND_MAPSIZE;
}
# 1838 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) const char *mdbx_strerror(int errnum);
# 1864 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) const char *mdbx_strerror_r(int errnum, char *buf, size_t buflen);
__attribute__((__pure__, __nothrow__)) __attribute__((__visibility__("default"))) const char *mdbx_liberr2str(int errnum);
# 1896 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_env_create(MDBX_env **penv);


enum MDBX_option_t {
# 1908 "/libmdbx/src/../mdbx.h"
  MDBX_opt_max_db,
# 1924 "/libmdbx/src/../mdbx.h"
  MDBX_opt_max_readers,





  MDBX_opt_sync_bytes,





  MDBX_opt_sync_period,
# 1955 "/libmdbx/src/../mdbx.h"
  MDBX_opt_rp_augment_limit,
# 1968 "/libmdbx/src/../mdbx.h"
  MDBX_opt_loose_limit,
# 1982 "/libmdbx/src/../mdbx.h"
  MDBX_opt_dp_reserve_limit,
# 1996 "/libmdbx/src/../mdbx.h"
  MDBX_opt_txn_dp_limit,



  MDBX_opt_txn_dp_initial,
# 2016 "/libmdbx/src/../mdbx.h"
  MDBX_opt_spill_max_denominator,
# 2032 "/libmdbx/src/../mdbx.h"
  MDBX_opt_spill_min_denominator,
# 2055 "/libmdbx/src/../mdbx.h"
  MDBX_opt_spill_parent4child_denominator,
# 2066 "/libmdbx/src/../mdbx.h"
  MDBX_opt_merge_threshold_16dot16_percent,
};


typedef enum MDBX_option_t MDBX_option_t;
# 2083 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_env_set_option(MDBX_env *env, const MDBX_option_t option,
                                    uint64_t value);
# 2096 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_env_get_option(const MDBX_env *env,
                                    const MDBX_option_t option,
                                    uint64_t *pvalue);
# 2171 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_env_open(MDBX_env *env, const char *pathname,
                              MDBX_env_flags_t flags, mdbx_mode_t mode);




enum MDBX_env_delete_mode_t {






  MDBX_ENV_JUST_DELETE = 0,


  MDBX_ENV_ENSURE_UNUSED = 1,


  MDBX_ENV_WAIT_FOR_UNUSED = 2,
};


typedef enum MDBX_env_delete_mode_t MDBX_env_delete_mode_t;
# 2214 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_env_delete(const char *pathname,
                                MDBX_env_delete_mode_t mode);
# 2248 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_env_copy(MDBX_env *env, const char *dest,
                              MDBX_copy_flags_t flags);
# 2274 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_env_copy2fd(MDBX_env *env, mdbx_filehandle_t fd,
                                 MDBX_copy_flags_t flags);




struct MDBX_stat {
  uint32_t ms_psize;

  uint32_t ms_depth;
  uint64_t ms_branch_pages;
  uint64_t ms_leaf_pages;
  uint64_t ms_overflow_pages;
  uint64_t ms_entries;
  uint64_t ms_mod_txnid;
};


typedef struct MDBX_stat MDBX_stat;
# 2314 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_env_stat_ex(const MDBX_env *env, const MDBX_txn *txn,
                                 MDBX_stat *stat, size_t bytes);




__attribute__((__deprecated__)) __attribute__((__visibility__("default"))) int mdbx_env_stat (const MDBX_env *env, MDBX_stat *stat, size_t bytes); static __inline int __inline_mdbx_env_stat (const MDBX_env *env, MDBX_stat *stat, size_t bytes)

                                                   {
  return mdbx_env_stat_ex(env, 
# 2323 "/libmdbx/src/../mdbx.h" 3 4
                              ((void *)0)
# 2323 "/libmdbx/src/../mdbx.h"
                                  , stat, bytes);
}




struct MDBX_envinfo {
  struct {
    uint64_t lower;
    uint64_t upper;
    uint64_t current;
    uint64_t shrink;
    uint64_t grow;
  } mi_geo;
  uint64_t mi_mapsize;
  uint64_t mi_last_pgno;
  uint64_t mi_recent_txnid;
  uint64_t mi_latter_reader_txnid;
  uint64_t mi_self_latter_reader_txnid;

  uint64_t mi_meta0_txnid, mi_meta0_sign;
  uint64_t mi_meta1_txnid, mi_meta1_sign;
  uint64_t mi_meta2_txnid, mi_meta2_sign;
  uint32_t mi_maxreaders;
  uint32_t mi_numreaders;
  uint32_t mi_dxb_pagesize;
  uint32_t mi_sys_pagesize;
# 2359 "/libmdbx/src/../mdbx.h"
  struct {
    struct {
      uint64_t x, y;
    } current, meta0, meta1, meta2;
  } mi_bootid;


  uint64_t mi_unsync_volume;

  uint64_t mi_autosync_threshold;

  uint32_t mi_since_sync_seconds16dot16;


  uint32_t mi_autosync_period_seconds16dot16;


  uint32_t mi_since_reader_check_seconds16dot16;


  uint32_t mi_mode;






  struct {
    uint64_t newly;
    uint64_t cow;
    uint64_t clone;

    uint64_t split;
    uint64_t merge;
    uint64_t spill;
    uint64_t unspill;
    uint64_t wops;

  } mi_pgop_stat;
};


typedef struct MDBX_envinfo MDBX_envinfo;
# 2423 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_env_info_ex(const MDBX_env *env, const MDBX_txn *txn,
                                 MDBX_envinfo *info, size_t bytes);



__attribute__((__deprecated__)) __attribute__((__visibility__("default"))) int mdbx_env_info (const MDBX_env *env, MDBX_envinfo *info, size_t bytes); static __inline int __inline_mdbx_env_info (const MDBX_env *env, MDBX_envinfo *info, size_t bytes)

                                                   {
  return mdbx_env_info_ex(env, 
# 2431 "/libmdbx/src/../mdbx.h" 3 4
                              ((void *)0)
# 2431 "/libmdbx/src/../mdbx.h"
                                  , info, bytes);
}
# 2469 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_env_sync_ex(MDBX_env *env, _Bool force, _Bool nonblock);




__attribute__((__visibility__("default"))) int mdbx_env_sync (MDBX_env * env); static __inline int __inline_mdbx_env_sync (MDBX_env * env) {
  return mdbx_env_sync_ex(env, (1), (0));
}




__attribute__((__visibility__("default"))) int mdbx_env_sync_poll (MDBX_env * env); static __inline int __inline_mdbx_env_sync_poll (MDBX_env * env) {
  return mdbx_env_sync_ex(env, (0), (1));
}
# 2508 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_env_set_syncbytes (MDBX_env * env, size_t threshold); static __inline int __inline_mdbx_env_set_syncbytes (MDBX_env * env, size_t threshold)
                                                       {
  return mdbx_env_set_option(env, MDBX_opt_sync_bytes, threshold);
}
# 2527 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_env_get_syncbytes (const MDBX_env *env, size_t *threshold); static __inline int __inline_mdbx_env_get_syncbytes (const MDBX_env *env, size_t *threshold)
                                                             {
  int rc = MDBX_EINVAL;
  if (threshold) {
    uint64_t proxy = 0;
    rc = mdbx_env_get_option(env, MDBX_opt_sync_bytes, &proxy);



    *threshold = (size_t)proxy;
  }
  return rc;
}
# 2571 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_env_set_syncperiod (MDBX_env * env, unsigned seconds_16dot16); static __inline int __inline_mdbx_env_set_syncperiod (MDBX_env * env, unsigned seconds_16dot16)
                                                               {
  return mdbx_env_set_option(env, MDBX_opt_sync_period, seconds_16dot16);
}
# 2592 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_env_get_syncperiod (const MDBX_env *env, unsigned *period_seconds_16dot16); static __inline int __inline_mdbx_env_get_syncperiod (const MDBX_env *env, unsigned *period_seconds_16dot16)
                                                                            {
  int rc = MDBX_EINVAL;
  if (period_seconds_16dot16) {
    uint64_t proxy = 0;
    rc = mdbx_env_get_option(env, MDBX_opt_sync_period, &proxy);



    *period_seconds_16dot16 = (unsigned)proxy;
  }
  return rc;
}
# 2644 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_env_close_ex(MDBX_env *env, _Bool dont_sync);




__attribute__((__visibility__("default"))) int mdbx_env_close (MDBX_env * env); static __inline int __inline_mdbx_env_close (MDBX_env * env) {
  return mdbx_env_close_ex(env, (0));
}
# 2673 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_env_set_flags(MDBX_env *env, MDBX_env_flags_t flags,
                                   _Bool onoff);
# 2686 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_env_get_flags(const MDBX_env *env, unsigned *flags);
# 2699 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_env_get_path(const MDBX_env *env, const char **dest);
# 2713 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_env_get_fd(const MDBX_env *env, mdbx_filehandle_t *fd);
# 2909 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_env_set_geometry(MDBX_env *env, intptr_t size_lower,
                                      intptr_t size_now, intptr_t size_upper,
                                      intptr_t growth_step,
                                      intptr_t shrink_threshold,
                                      intptr_t pagesize);



__attribute__((__deprecated__)) __attribute__((__visibility__("default"))) int mdbx_env_set_mapsize (MDBX_env * env, size_t size); static __inline int __inline_mdbx_env_set_mapsize (MDBX_env * env, size_t size)
                                                                  {
  return mdbx_env_set_geometry(env, size, size, size, -1, -1, -1);
}
# 2937 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_is_readahead_reasonable(size_t volume,
                                             intptr_t redundancy);



__attribute__((__const__, __nothrow__)) __attribute__((__visibility__("default"))) intptr_t mdbx_limits_pgsize_min (void); static __inline intptr_t __inline_mdbx_limits_pgsize_min (void)
                                                       {
  return MDBX_MIN_PAGESIZE;
}



__attribute__((__const__, __nothrow__)) __attribute__((__visibility__("default"))) intptr_t mdbx_limits_pgsize_max (void); static __inline intptr_t __inline_mdbx_limits_pgsize_max (void)
                                                       {
  return MDBX_MAX_PAGESIZE;
}




__attribute__((__const__, __nothrow__)) __attribute__((__visibility__("default"))) intptr_t
mdbx_limits_dbsize_min(intptr_t pagesize);




__attribute__((__const__, __nothrow__)) __attribute__((__visibility__("default"))) intptr_t
mdbx_limits_dbsize_max(intptr_t pagesize);





__attribute__((__const__, __nothrow__)) __attribute__((__visibility__("default"))) intptr_t
mdbx_limits_keysize_max(intptr_t pagesize, MDBX_db_flags_t flags);





__attribute__((__const__, __nothrow__)) __attribute__((__visibility__("default"))) intptr_t
mdbx_limits_valsize_max(intptr_t pagesize, MDBX_db_flags_t flags);




__attribute__((__const__, __nothrow__)) __attribute__((__visibility__("default"))) intptr_t
mdbx_limits_txnsize_max(intptr_t pagesize);
# 3009 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_env_set_maxreaders (MDBX_env * env, unsigned readers); static __inline int __inline_mdbx_env_set_maxreaders (MDBX_env * env, unsigned readers)
                                                       {
  return mdbx_env_set_option(env, MDBX_opt_max_readers, readers);
}
# 3025 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_env_get_maxreaders (const MDBX_env *env, unsigned *readers); static __inline int __inline_mdbx_env_get_maxreaders (const MDBX_env *env, unsigned *readers)
                                                             {
  int rc = MDBX_EINVAL;
  if (readers) {
    uint64_t proxy = 0;
    rc = mdbx_env_get_option(env, MDBX_opt_max_readers, &proxy);
    *readers = (unsigned)proxy;
  }
  return rc;
}
# 3057 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_env_set_maxdbs (MDBX_env * env, MDBX_dbi dbs); static __inline int __inline_mdbx_env_set_maxdbs (MDBX_env * env, MDBX_dbi dbs) {
  return mdbx_env_set_option(env, MDBX_opt_max_db, dbs);
}
# 3071 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_env_get_maxdbs (const MDBX_env *env, MDBX_dbi *dbs); static __inline int __inline_mdbx_env_get_maxdbs (const MDBX_env *env, MDBX_dbi *dbs)
                                                         {
  int rc = MDBX_EINVAL;
  if (dbs) {
    uint64_t proxy = 0;
    rc = mdbx_env_get_option(env, MDBX_opt_max_db, &proxy);
    *dbs = (MDBX_dbi)proxy;
  }
  return rc;
}





__attribute__((__pure__, __nothrow__)) __attribute__((__visibility__("default"))) size_t mdbx_default_pagesize(void);
# 3102 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_get_sysraminfo(intptr_t *page_size, intptr_t *total_pages,
                                    intptr_t *avail_pages);
# 3114 "/libmdbx/src/../mdbx.h"
__attribute__((__pure__, __nothrow__)) __attribute__((__visibility__("default"))) int
mdbx_env_get_maxkeysize_ex(const MDBX_env *env, MDBX_db_flags_t flags);
# 3126 "/libmdbx/src/../mdbx.h"
__attribute__((__pure__, __nothrow__)) __attribute__((__visibility__("default"))) int
mdbx_env_get_maxvalsize_ex(const MDBX_env *env, MDBX_db_flags_t flags);




__attribute__((__pure__, __nothrow__)) __attribute__((__deprecated__)) __attribute__((__visibility__("default"))) int
mdbx_env_get_maxkeysize(const MDBX_env *env);
# 3144 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_env_set_userctx(MDBX_env *env, void *ctx);
# 3154 "/libmdbx/src/../mdbx.h"
__attribute__((__pure__, __nothrow__)) __attribute__((__visibility__("default"))) void *
mdbx_env_get_userctx(const MDBX_env *env);
# 3216 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_txn_begin_ex(MDBX_env *env, MDBX_txn *parent,
                                  MDBX_txn_flags_t flags, MDBX_txn **txn,
                                  void *context);
# 3274 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_txn_begin (MDBX_env * env, MDBX_txn *parent, MDBX_txn_flags_t flags, MDBX_txn **txn); static __inline int __inline_mdbx_txn_begin (MDBX_env * env, MDBX_txn *parent, MDBX_txn_flags_t flags, MDBX_txn **txn)

                                     {
  return mdbx_txn_begin_ex(env, parent, flags, txn, 
# 3277 "/libmdbx/src/../mdbx.h" 3 4
                                                   ((void *)0)
# 3277 "/libmdbx/src/../mdbx.h"
                                                       );
}
# 3290 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_txn_set_userctx(MDBX_txn *txn, void *ctx);
# 3302 "/libmdbx/src/../mdbx.h"
__attribute__((__pure__, __nothrow__)) __attribute__((__visibility__("default"))) void *
mdbx_txn_get_userctx(const MDBX_txn *txn);




struct MDBX_txn_info {


  uint64_t txn_id;





  uint64_t txn_reader_lag;



  uint64_t txn_space_used;


  uint64_t txn_space_limit_soft;



  uint64_t txn_space_limit_hard;







  uint64_t txn_space_retired;






  uint64_t txn_space_leftover;






  uint64_t txn_space_dirty;
};


typedef struct MDBX_txn_info MDBX_txn_info;
# 3370 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_txn_info(const MDBX_txn *txn, MDBX_txn_info *info,
                              _Bool scan_rlt);





__attribute__((__pure__, __nothrow__)) __attribute__((__visibility__("default"))) MDBX_env *
mdbx_txn_env(const MDBX_txn *txn);
# 3389 "/libmdbx/src/../mdbx.h"
__attribute__((__pure__, __nothrow__)) __attribute__((__visibility__("default"))) int mdbx_txn_flags(const MDBX_txn *txn);
# 3402 "/libmdbx/src/../mdbx.h"
__attribute__((__pure__, __nothrow__)) __attribute__((__visibility__("default"))) uint64_t
mdbx_txn_id(const MDBX_txn *txn);




struct MDBX_commit_latency {


  uint32_t preparation;

  uint32_t gc;

  uint32_t audit;


  uint32_t write;


  uint32_t sync;

  uint32_t ending;

  uint32_t whole;
};


typedef struct MDBX_commit_latency MDBX_commit_latency;







__attribute__((__visibility__("default"))) int mdbx_txn_commit_ex(MDBX_txn *txn, MDBX_commit_latency *latency);
# 3476 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_txn_commit (MDBX_txn * txn); static __inline int __inline_mdbx_txn_commit (MDBX_txn * txn) {
  return mdbx_txn_commit_ex(txn, 
# 3477 "/libmdbx/src/../mdbx.h" 3 4
                                ((void *)0)
# 3477 "/libmdbx/src/../mdbx.h"
                                    );
}
# 3513 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_txn_abort(MDBX_txn *txn);
# 3526 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_txn_break(MDBX_txn *txn);
# 3560 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_txn_reset(MDBX_txn *txn);
# 3582 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_txn_renew(MDBX_txn *txn);
# 3594 "/libmdbx/src/../mdbx.h"
struct MDBX_canary {
  uint64_t x, y, z, v;
};


typedef struct MDBX_canary MDBX_canary;
# 3620 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_canary_put(MDBX_txn *txn, const MDBX_canary *canary);
# 3632 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_canary_get(const MDBX_txn *txn, MDBX_canary *canary);
# 3654 "/libmdbx/src/../mdbx.h"
typedef int(MDBX_cmp_func)(const MDBX_val *a,
                           const MDBX_val *b) ;
# 3746 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_dbi_open(MDBX_txn *txn, const char *name,
                              MDBX_db_flags_t flags, MDBX_dbi *dbi);
# 3764 "/libmdbx/src/../mdbx.h"
__attribute__((__deprecated__)) __attribute__((__visibility__("default"))) int
mdbx_dbi_open_ex(MDBX_txn *txn, const char *name, MDBX_db_flags_t flags,
                 MDBX_dbi *dbi, MDBX_cmp_func *keycmp, MDBX_cmp_func *datacmp);
# 3779 "/libmdbx/src/../mdbx.h"
__attribute__((__const__, __nothrow__)) __attribute__((__visibility__("default"))) uint64_t
mdbx_key_from_jsonInteger(const int64_t json_integer);

__attribute__((__const__, __nothrow__)) __attribute__((__visibility__("default"))) uint64_t
mdbx_key_from_double(const double ieee754_64bit);

__attribute__((__pure__, __nothrow__)) __attribute__((__visibility__("default"))) uint64_t
mdbx_key_from_ptrdouble(const double *const ieee754_64bit);

__attribute__((__const__, __nothrow__)) __attribute__((__visibility__("default"))) uint32_t
mdbx_key_from_float(const float ieee754_32bit);

__attribute__((__pure__, __nothrow__)) __attribute__((__visibility__("default"))) uint32_t
mdbx_key_from_ptrfloat(const float *const ieee754_32bit);

__attribute__((__const__, __nothrow__)) __attribute__((__visibility__("default"))) uint64_t mdbx_key_from_int64 (const int64_t i64); static __inline uint64_t __inline_mdbx_key_from_int64 (const int64_t i64)
                                                                    {
  return 0x8000000000000000UL + i64;
}

__attribute__((__const__, __nothrow__)) __attribute__((__visibility__("default"))) uint32_t mdbx_key_from_int32 (const int32_t i32); static __inline uint32_t __inline_mdbx_key_from_int32 (const int32_t i32)
                                                                    {
  return 0x80000000U + i32;
}







__attribute__((__pure__, __nothrow__)) __attribute__((__visibility__("default"))) int64_t
mdbx_jsonInteger_from_key(const MDBX_val);

__attribute__((__pure__, __nothrow__)) __attribute__((__visibility__("default"))) double
mdbx_double_from_key(const MDBX_val);

__attribute__((__pure__, __nothrow__)) __attribute__((__visibility__("default"))) float
mdbx_float_from_key(const MDBX_val);

__attribute__((__pure__, __nothrow__)) __attribute__((__visibility__("default"))) int32_t
mdbx_int32_from_key(const MDBX_val);

__attribute__((__pure__, __nothrow__)) __attribute__((__visibility__("default"))) int64_t
mdbx_int64_from_key(const MDBX_val);
# 3840 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_dbi_stat(MDBX_txn *txn, MDBX_dbi dbi, MDBX_stat *stat,
                              size_t bytes);
# 3858 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_dbi_dupsort_depthmask(MDBX_txn *txn, MDBX_dbi dbi,
                                           uint32_t *mask);




enum MDBX_dbi_state_t {

  MDBX_DBI_DIRTY = 0x01,

  MDBX_DBI_STALE = 0x02,

  MDBX_DBI_FRESH = 0x04,

  MDBX_DBI_CREAT = 0x08,
};


typedef enum MDBX_dbi_state_t MDBX_dbi_state_t;
# 3890 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_dbi_flags_ex(MDBX_txn *txn, MDBX_dbi dbi, unsigned *flags,
                                  unsigned *state);



__attribute__((__visibility__("default"))) int mdbx_dbi_flags (MDBX_txn * txn, MDBX_dbi dbi, unsigned *flags); static __inline int __inline_mdbx_dbi_flags (MDBX_txn * txn, MDBX_dbi dbi, unsigned *flags)
                                                                    {
  unsigned state;
  return mdbx_dbi_flags_ex(txn, dbi, flags, &state);
}
# 3923 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_dbi_close(MDBX_env *env, MDBX_dbi dbi);
# 3936 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_drop(MDBX_txn *txn, MDBX_dbi dbi, _Bool del);
# 3967 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_get(MDBX_txn *txn, MDBX_dbi dbi, const MDBX_val *key,
                         MDBX_val *data);
# 4000 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_get_ex(MDBX_txn *txn, MDBX_dbi dbi, MDBX_val *key,
                            MDBX_val *data, size_t *values_count);
# 4031 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_get_equal_or_great(MDBX_txn *txn, MDBX_dbi dbi,
                                        MDBX_val *key, MDBX_val *data);
# 4115 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_put(MDBX_txn *txn, MDBX_dbi dbi, const MDBX_val *key,
                         MDBX_val *data, MDBX_put_flags_t flags);
# 4161 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_replace(MDBX_txn *txn, MDBX_dbi dbi, const MDBX_val *key,
                             MDBX_val *new_data, MDBX_val *old_data,
                             MDBX_put_flags_t flags);

typedef int (*MDBX_preserve_func)(void *context, MDBX_val *target,
                                  const void *src, size_t bytes);
__attribute__((__visibility__("default"))) int mdbx_replace_ex(MDBX_txn *txn, MDBX_dbi dbi,
                                const MDBX_val *key, MDBX_val *new_data,
                                MDBX_val *old_data, MDBX_put_flags_t flags,
                                MDBX_preserve_func preserver,
                                void *preserver_context);
# 4198 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_del(MDBX_txn *txn, MDBX_dbi dbi, const MDBX_val *key,
                         const MDBX_val *data);
# 4223 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) MDBX_cursor *mdbx_cursor_create(void *context);
# 4234 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_cursor_set_userctx(MDBX_cursor *cursor, void *ctx);
# 4245 "/libmdbx/src/../mdbx.h"
__attribute__((__pure__, __nothrow__)) __attribute__((__visibility__("default"))) void *
mdbx_cursor_get_userctx(const MDBX_cursor *cursor);
# 4273 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_cursor_bind(MDBX_txn *txn, MDBX_cursor *cursor,
                                 MDBX_dbi dbi);
# 4306 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_cursor_open(MDBX_txn *txn, MDBX_dbi dbi,
                                 MDBX_cursor **cursor);
# 4323 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) void mdbx_cursor_close(MDBX_cursor *cursor);
# 4348 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_cursor_renew(MDBX_txn *txn, MDBX_cursor *cursor);





__attribute__((__pure__, __nothrow__)) __attribute__((__visibility__("default"))) MDBX_txn *
mdbx_cursor_txn(const MDBX_cursor *cursor);





__attribute__((__visibility__("default"))) MDBX_dbi mdbx_cursor_dbi(const MDBX_cursor *cursor);
# 4373 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_cursor_copy(const MDBX_cursor *src, MDBX_cursor *dest);
# 4396 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_cursor_get(MDBX_cursor *cursor, MDBX_val *key,
                                MDBX_val *data, MDBX_cursor_op op);
# 4432 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_cursor_get_batch(MDBX_cursor *cursor, size_t *count,
                                      MDBX_val *pairs, size_t limit,
                                      MDBX_cursor_op op);
# 4516 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_cursor_put(MDBX_cursor *cursor, const MDBX_val *key,
                                MDBX_val *data, MDBX_put_flags_t flags);
# 4549 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_cursor_del(MDBX_cursor *cursor, MDBX_put_flags_t flags);
# 4566 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_cursor_count(const MDBX_cursor *cursor, size_t *pcount);
# 4580 "/libmdbx/src/../mdbx.h"
__attribute__((__pure__, __nothrow__)) __attribute__((__visibility__("default"))) int
mdbx_cursor_eof(const MDBX_cursor *cursor);
# 4594 "/libmdbx/src/../mdbx.h"
__attribute__((__pure__, __nothrow__)) __attribute__((__visibility__("default"))) int
mdbx_cursor_on_first(const MDBX_cursor *cursor);
# 4608 "/libmdbx/src/../mdbx.h"
__attribute__((__pure__, __nothrow__)) __attribute__((__visibility__("default"))) int
mdbx_cursor_on_last(const MDBX_cursor *cursor);
# 4655 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_estimate_distance(const MDBX_cursor *first,
                                       const MDBX_cursor *last,
                                       ptrdiff_t *distance_items);
# 4679 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_estimate_move(const MDBX_cursor *cursor, MDBX_val *key,
                                   MDBX_val *data, MDBX_cursor_op move_op,
                                   ptrdiff_t *distance_items);
# 4707 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_estimate_range(MDBX_txn *txn, MDBX_dbi dbi,
                                    MDBX_val *begin_key, MDBX_val *begin_data,
                                    MDBX_val *end_key, MDBX_val *end_data,
                                    ptrdiff_t *distance_items);
# 4749 "/libmdbx/src/../mdbx.h"
__attribute__((__pure__, __nothrow__)) __attribute__((__visibility__("default"))) int mdbx_is_dirty(const MDBX_txn *txn,
                                                         const void *ptr);
# 4773 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_dbi_sequence(MDBX_txn *txn, MDBX_dbi dbi, uint64_t *result,
                                  uint64_t increment);
# 4791 "/libmdbx/src/../mdbx.h"
__attribute__((__pure__, __nothrow__)) __attribute__((__visibility__("default"))) int mdbx_cmp(const MDBX_txn *txn,
                                                    MDBX_dbi dbi,
                                                    const MDBX_val *a,
                                                    const MDBX_val *b);



__attribute__((__const__, __nothrow__)) __attribute__((__visibility__("default"))) MDBX_cmp_func *
mdbx_get_keycmp(MDBX_db_flags_t flags);
# 4816 "/libmdbx/src/../mdbx.h"
__attribute__((__pure__, __nothrow__)) __attribute__((__visibility__("default"))) int mdbx_dcmp(const MDBX_txn *txn,
                                                     MDBX_dbi dbi,
                                                     const MDBX_val *a,
                                                     const MDBX_val *b);



__attribute__((__const__, __nothrow__)) __attribute__((__visibility__("default"))) MDBX_cmp_func *
mdbx_get_datacmp(MDBX_db_flags_t flags);
# 4851 "/libmdbx/src/../mdbx.h"
typedef int(MDBX_reader_list_func)(void *ctx, int num, int slot, mdbx_pid_t pid,
                                   mdbx_tid_t thread, uint64_t txnid,
                                   uint64_t lag, size_t bytes_used,
                                   size_t bytes_retained) ;
# 4867 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_reader_list(const MDBX_env *env,
                                 MDBX_reader_list_func *func, void *ctx);
# 4878 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_reader_check(MDBX_env *env, int *dead);
# 4892 "/libmdbx/src/../mdbx.h"
__attribute__((__deprecated__)) __attribute__((__visibility__("default"))) int mdbx_txn_straggler(const MDBX_txn *txn,
                                                   int *percent);
# 4913 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_thread_register(const MDBX_env *env);
# 4928 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_thread_unregister(const MDBX_env *env);
# 5001 "/libmdbx/src/../mdbx.h"
typedef int(MDBX_hsr_func)(const MDBX_env *env, const MDBX_txn *txn,
                           mdbx_pid_t pid, mdbx_tid_t tid, uint64_t laggard,
                           unsigned gap, size_t space,
                           int retry) ;
# 5023 "/libmdbx/src/../mdbx.h"
__attribute__((__visibility__("default"))) int mdbx_env_set_hsr(MDBX_env *env, MDBX_hsr_func *hsr_callback);
# 5036 "/libmdbx/src/../mdbx.h"
__attribute__((__pure__, __nothrow__)) __attribute__((__visibility__("default"))) MDBX_hsr_func *
mdbx_env_get_hsr(const MDBX_env *env);
# 5047 "/libmdbx/src/../mdbx.h"
enum MDBX_page_type_t {
  MDBX_page_broken,
  MDBX_page_meta,
  MDBX_page_large,
  MDBX_page_branch,
  MDBX_page_leaf,
  MDBX_page_dupfixed_leaf,
  MDBX_subpage_leaf,
  MDBX_subpage_dupfixed_leaf,
  MDBX_subpage_broken,
};

typedef enum MDBX_page_type_t MDBX_page_type_t;
# 5070 "/libmdbx/src/../mdbx.h"
typedef int MDBX_pgvisitor_func(
    const uint64_t pgno, const unsigned number, void *const ctx, const int deep,
    const char *const dbi, const size_t page_size, const MDBX_page_type_t type,
    const MDBX_error_t err, const size_t nentries, const size_t payload_bytes,
    const size_t header_bytes, const size_t unused_bytes) ;


__attribute__((__visibility__("default"))) int mdbx_env_pgwalk(MDBX_txn *txn, MDBX_pgvisitor_func *visitor,
                                void *ctx, _Bool dont_check_keys_ordering);







__attribute__((__visibility__("default"))) int mdbx_env_open_for_recovery(MDBX_env *env, const char *pathname,
                                           unsigned target_meta,
                                           _Bool writeable);






__attribute__((__visibility__("default"))) int mdbx_env_turn_for_recovery(MDBX_env *env, unsigned target_meta);
# 131 "/libmdbx/src/internals.h" 2
# 1 "/libmdbx/src/defs.h" 1
# 15 "/libmdbx/src/defs.h"
       
# 256 "/libmdbx/src/defs.h"
    __attribute__((__unused__)) __attribute__((__pure__)) static __inline const void*
        __Wpedantic_format_voidptr(const void* ptr) {return ptr;}
# 132 "/libmdbx/src/internals.h" 2
# 201 "/libmdbx/src/internals.h"
# 1 "/libmdbx/src/osal.h" 1
# 17 "/libmdbx/src/osal.h"
       
# 47 "/libmdbx/src/osal.h"
# 1 "/usr/include/inttypes.h" 1 3 4
# 34 "/usr/include/inttypes.h" 3 4

# 34 "/usr/include/inttypes.h" 3 4
typedef unsigned int __gwchar_t;
# 266 "/usr/include/inttypes.h" 3 4





typedef struct
  {
    long int quot;
    long int rem;
  } imaxdiv_t;
# 290 "/usr/include/inttypes.h" 3 4
extern intmax_t imaxabs (intmax_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern imaxdiv_t imaxdiv (intmax_t __numer, intmax_t __denom)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern intmax_t strtoimax (const char *__restrict __nptr,
      char **__restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__));


extern uintmax_t strtoumax (const char *__restrict __nptr,
       char ** __restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__));


extern intmax_t wcstoimax (const __gwchar_t *__restrict __nptr,
      __gwchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));


extern uintmax_t wcstoumax (const __gwchar_t *__restrict __nptr,
       __gwchar_t ** __restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));


# 48 "/libmdbx/src/osal.h" 2
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 49 "/libmdbx/src/osal.h" 2

# 1 "/usr/include/stdlib.h" 1 3 4
# 26 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 33 "/usr/include/stdlib.h" 2 3 4







# 1 "/usr/include/aarch64-linux-gnu/bits/waitflags.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/waitstatus.h" 1 3 4
# 42 "/usr/include/stdlib.h" 2 3 4
# 56 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/floatn.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/long-double.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/floatn.h" 2 3 4
# 95 "/usr/include/aarch64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/aarch64-linux-gnu/bits/floatn-common.h" 2 3 4
# 96 "/usr/include/aarch64-linux-gnu/bits/floatn.h" 2 3 4
# 57 "/usr/include/stdlib.h" 2 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 98 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));



extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 141 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32 (const char *__restrict __nptr,
     char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float64 strtof64 (const char *__restrict __nptr,
     char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float128 strtof128 (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float32x strtof32x (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float64x strtof64x (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 177 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int strfromd (char *__dest, size_t __size, const char *__format,
       double __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));

extern int strfromf (char *__dest, size_t __size, const char *__format,
       float __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));

extern int strfroml (char *__dest, size_t __size, const char *__format,
       long double __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
# 233 "/usr/include/stdlib.h" 3 4
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
         _Float32 __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf64 (char *__dest, size_t __size, const char * __format,
         _Float64 __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf128 (char *__dest, size_t __size, const char * __format,
   _Float128 __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf32x (char *__dest, size_t __size, const char * __format,
   _Float32x __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf64x (char *__dest, size_t __size, const char * __format,
   _Float64x __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
# 275 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     locale_t __loc) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));
# 317 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64 strtof64_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float128 strtof128_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float32x strtof32x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64x strtof64x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));
# 361 "/usr/include/stdlib.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) atoi (const char *__nptr)
{
  return (int) strtol (__nptr, (char **) ((void *)0), 10);
}
extern __inline __attribute__ ((__gnu_inline__)) long int
__attribute__ ((__nothrow__ , __leaf__)) atol (const char *__nptr)
{
  return strtol (__nptr, (char **) ((void *)0), 10);
}


__extension__ extern __inline __attribute__ ((__gnu_inline__)) long long int
__attribute__ ((__nothrow__ , __leaf__)) atoll (const char *__nptr)
{
  return strtoll (__nptr, (char **) ((void *)0), 10);
}
# 386 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 402 "/usr/include/stdlib.h" 3 4
extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));



extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__));







extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) __attribute__ ((__warn_unused_result__));

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (1, 2))) __attribute__ ((__warn_unused_result__));






extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__)) __attribute__ ((__alloc_size__ (2)));


extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__))
     __attribute__ ((__alloc_size__ (2, 3)))
    __attribute__ ((__malloc__ (__builtin_free, 1)));


extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__ (reallocarray, 1)));



# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__));






# 575 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) __attribute__ ((__warn_unused_result__));




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));




extern void *aligned_alloc (size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_align__ (1)))
     __attribute__ ((__alloc_size__ (2))) __attribute__ ((__warn_unused_result__));



extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));




extern char *secure_getenv (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));






extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));
# 682 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 698 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __asm__ ("" "mkstemp64")
     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));





extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 720 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __asm__ ("" "mkstemps64")
                     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));





extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 738 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 752 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __asm__ ("" "mkostemp64")
     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));





extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 773 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags) __asm__ ("" "mkostemps64")

     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));





extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 791 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) __attribute__ ((__warn_unused_result__));





extern char *canonicalize_file_name (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__malloc__))
     __attribute__ ((__malloc__ (__builtin_free, 1))) __attribute__ ((__warn_unused_result__));
# 808 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);




extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) __attribute__ ((__warn_unused_result__));


# 1 "/usr/include/aarch64-linux-gnu/bits/stdlib-bsearch.h" 1 3 4
# 19 "/usr/include/aarch64-linux-gnu/bits/stdlib-bsearch.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) void *
bsearch (const void *__key, const void *__base, size_t __nmemb, size_t __size,
  __compar_fn_t __compar)
{
  size_t __l, __u, __idx;
  const void *__p;
  int __comparison;

  __l = 0;
  __u = __nmemb;
  while (__l < __u)
    {
      __idx = (__l + __u) / 2;
      __p = (const void *) (((const char *) __base) + (__idx * __size));
      __comparison = (*__compar) (__key, __p);
      if (__comparison < 0)
 __u = __idx;
      else if (__comparison > 0)
 __l = __idx + 1;
      else
 {

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-qual"

   return (void *) __p;

#pragma GCC diagnostic pop

 }
    }

  return ((void *)0);
}
# 834 "/usr/include/stdlib.h" 2 3 4




extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));


__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));






extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
# 880 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) __attribute__ ((__warn_unused_result__));




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) __attribute__ ((__warn_unused_result__));




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__))
    __attribute__ ((__access__ (__read_only__, 2)));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__access__ (__write_only__, 1, 3)))
  __attribute__ ((__access__ (__read_only__, 2)));






extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 967 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3))) __attribute__ ((__warn_unused_result__));







extern int posix_openpt (int __oflag) __attribute__ ((__warn_unused_result__));







extern int grantpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int unlockpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));




extern char *ptsname (int __fd) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 2, 3)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 1023 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/stdlib-float.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) double
__attribute__ ((__nothrow__ , __leaf__)) atof (const char *__nptr)
{
  return strtod (__nptr, (char **) ((void *)0));
}
# 1024 "/usr/include/stdlib.h" 2 3 4



# 1 "/usr/include/aarch64-linux-gnu/bits/stdlib.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/bits/stdlib.h" 3 4
extern char *__realpath_chk (const char *__restrict __name,
        char *__restrict __resolved,
        size_t __resolvedlen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
extern char *__realpath_alias (const char *__restrict __name, char *__restrict __resolved) __asm__ ("" "realpath") __attribute__ ((__nothrow__ , __leaf__))

                                                 __attribute__ ((__warn_unused_result__));
extern char *__realpath_chk_warn (const char *__restrict __name, char *__restrict __resolved, size_t __resolvedlen) __asm__ ("" "__realpath_chk") __attribute__ ((__nothrow__ , __leaf__))


                                                __attribute__ ((__warn_unused_result__))
     __attribute__((__warning__ ("second argument of realpath must be either NULL or at " "least PATH_MAX bytes long buffer")))
                                      ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) char *
__attribute__ ((__nothrow__ , __leaf__)) realpath (const char *__restrict __name, char *__restrict __resolved)
{
  size_t sz = __builtin_object_size (__resolved, 2 > 1);

  if (sz == (size_t) -1)
    return __realpath_alias (__name, __resolved);





  return __realpath_chk (__name, __resolved, sz);
}


extern int __ptsname_r_chk (int __fd, char *__buf, size_t __buflen,
       size_t __nreal) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)))
    __attribute__ ((__access__ (__write_only__, 2, 3)));
extern int __ptsname_r_alias (int __fd, char *__buf, size_t __buflen) __asm__ ("" "ptsname_r") __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 2, 3)));
extern int __ptsname_r_chk_warn (int __fd, char *__buf, size_t __buflen, size_t __nreal) __asm__ ("" "__ptsname_r_chk") __attribute__ ((__nothrow__ , __leaf__))


     __attribute__ ((__nonnull__ (2))) __attribute__((__warning__ ("ptsname_r called with buflen bigger than " "size of buf")))
                   ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) ptsname_r (int __fd, char *__buf, size_t __buflen)
{
  return ((((__typeof (__buflen)) 0 < (__typeof (__buflen)) -1 || (__builtin_constant_p (__buflen) && (__buflen) > 0)) && __builtin_constant_p ((((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && (((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __ptsname_r_alias (__fd, __buf, __buflen) : ((((__typeof (__buflen)) 0 < (__typeof (__buflen)) -1 || (__builtin_constant_p (__buflen) && (__buflen) > 0)) && __builtin_constant_p ((((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && !(((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __ptsname_r_chk_warn (__fd, __buf, __buflen, __builtin_object_size (__buf, 2 > 1)) : __ptsname_r_chk (__fd, __buf, __buflen, __builtin_object_size (__buf, 2 > 1))))

                           ;
}


extern int __wctomb_chk (char *__s, wchar_t __wchar, size_t __buflen)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
extern int __wctomb_alias (char *__s, wchar_t __wchar) __asm__ ("" "wctomb") __attribute__ ((__nothrow__ , __leaf__))
              __attribute__ ((__warn_unused_result__));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) int
__attribute__ ((__nothrow__ , __leaf__)) wctomb (char *__s, wchar_t __wchar)
{







  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1
      && 16 > __builtin_object_size (__s, 2 > 1))
    return __wctomb_chk (__s, __wchar, __builtin_object_size (__s, 2 > 1));
  return __wctomb_alias (__s, __wchar);
}


extern size_t __mbstowcs_chk (wchar_t *__restrict __dst,
         const char *__restrict __src,
         size_t __len, size_t __dstlen) __attribute__ ((__nothrow__ , __leaf__))
    __attribute__ ((__access__ (__write_only__, 1, 3))) __attribute__ ((__access__ (__read_only__, 2)));
extern size_t __mbstowcs_alias (wchar_t *__restrict __dst, const char *__restrict __src, size_t __len) __asm__ ("" "mbstowcs") __attribute__ ((__nothrow__ , __leaf__))



    __attribute__ ((__access__ (__write_only__, 1, 3))) __attribute__ ((__access__ (__read_only__, 2)));
extern size_t __mbstowcs_chk_warn (wchar_t *__restrict __dst, const char *__restrict __src, size_t __len, size_t __dstlen) __asm__ ("" "__mbstowcs_chk") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__((__warning__ ("mbstowcs called with dst buffer smaller than len " "* sizeof (wchar_t)")))
                        ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) size_t
__attribute__ ((__nothrow__ , __leaf__)) mbstowcs (wchar_t *__restrict __dst, const char *__restrict __src, size_t __len)

{
  return ((((__typeof (__len)) 0 < (__typeof (__len)) -1 || (__builtin_constant_p (__len) && (__len) > 0)) && __builtin_constant_p ((((long unsigned int) (__len)) <= (__builtin_object_size (__dst, 2 > 1)) / (sizeof (wchar_t)))) && (((long unsigned int) (__len)) <= (__builtin_object_size (__dst, 2 > 1)) / (sizeof (wchar_t)))) ? __mbstowcs_alias (__dst, __src, __len) : ((((__typeof (__len)) 0 < (__typeof (__len)) -1 || (__builtin_constant_p (__len) && (__len) > 0)) && __builtin_constant_p ((((long unsigned int) (__len)) <= (__builtin_object_size (__dst, 2 > 1)) / (sizeof (wchar_t)))) && !(((long unsigned int) (__len)) <= (__builtin_object_size (__dst, 2 > 1)) / (sizeof (wchar_t)))) ? __mbstowcs_chk_warn (__dst, __src, __len, (__builtin_object_size (__dst, 2 > 1)) / (sizeof (wchar_t))) : __mbstowcs_chk (__dst, __src, __len, (__builtin_object_size (__dst, 2 > 1)) / (sizeof (wchar_t)))))

                           ;
}


extern size_t __wcstombs_chk (char *__restrict __dst,
         const wchar_t *__restrict __src,
         size_t __len, size_t __dstlen) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__access__ (__write_only__, 1, 3))) __attribute__ ((__access__ (__read_only__, 2)));
extern size_t __wcstombs_alias (char *__restrict __dst, const wchar_t *__restrict __src, size_t __len) __asm__ ("" "wcstombs") __attribute__ ((__nothrow__ , __leaf__))



  __attribute__ ((__access__ (__write_only__, 1, 3))) __attribute__ ((__access__ (__read_only__, 2)));
extern size_t __wcstombs_chk_warn (char *__restrict __dst, const wchar_t *__restrict __src, size_t __len, size_t __dstlen) __asm__ ("" "__wcstombs_chk") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__((__warning__ ("wcstombs called with dst buffer smaller than len")));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) size_t
__attribute__ ((__nothrow__ , __leaf__)) wcstombs (char *__restrict __dst, const wchar_t *__restrict __src, size_t __len)

{
  return ((((__typeof (__len)) 0 < (__typeof (__len)) -1 || (__builtin_constant_p (__len) && (__len) > 0)) && __builtin_constant_p ((((long unsigned int) (__len)) <= (__builtin_object_size (__dst, 2 > 1)) / (sizeof (char)))) && (((long unsigned int) (__len)) <= (__builtin_object_size (__dst, 2 > 1)) / (sizeof (char)))) ? __wcstombs_alias (__dst, __src, __len) : ((((__typeof (__len)) 0 < (__typeof (__len)) -1 || (__builtin_constant_p (__len) && (__len) > 0)) && __builtin_constant_p ((((long unsigned int) (__len)) <= (__builtin_object_size (__dst, 2 > 1)) / (sizeof (char)))) && !(((long unsigned int) (__len)) <= (__builtin_object_size (__dst, 2 > 1)) / (sizeof (char)))) ? __wcstombs_chk_warn (__dst, __src, __len, __builtin_object_size (__dst, 2 > 1)) : __wcstombs_chk (__dst, __src, __len, __builtin_object_size (__dst, 2 > 1))))

                         ;
}
# 1028 "/usr/include/stdlib.h" 2 3 4








# 51 "/libmdbx/src/osal.h" 2

# 1 "/usr/include/assert.h" 1 3 4
# 53 "/libmdbx/src/osal.h" 2
# 1 "/usr/include/fcntl.h" 1 3 4
# 28 "/usr/include/fcntl.h" 3 4







# 1 "/usr/include/aarch64-linux-gnu/bits/fcntl.h" 1 3 4
# 40 "/usr/include/aarch64-linux-gnu/bits/fcntl.h" 3 4
struct flock
  {
    short int l_type;
    short int l_whence;
    __off_t l_start;
    __off_t l_len;
    __pid_t l_pid;
  };


struct flock64
  {
    short int l_type;
    short int l_whence;
    __off64_t l_start;
    __off64_t l_len;
    __pid_t l_pid;
  };



# 1 "/usr/include/aarch64-linux-gnu/bits/fcntl-linux.h" 1 3 4
# 265 "/usr/include/aarch64-linux-gnu/bits/fcntl-linux.h" 3 4
enum __pid_type
  {
    F_OWNER_TID = 0,
    F_OWNER_PID,
    F_OWNER_PGRP,
    F_OWNER_GID = F_OWNER_PGRP
  };


struct f_owner_ex
  {
    enum __pid_type type;
    __pid_t pid;
  };
# 354 "/usr/include/aarch64-linux-gnu/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/linux/falloc.h" 1 3 4
# 355 "/usr/include/aarch64-linux-gnu/bits/fcntl-linux.h" 2 3 4



struct file_handle
{
  unsigned int handle_bytes;
  int handle_type;

  unsigned char f_handle[0];
};
# 393 "/usr/include/aarch64-linux-gnu/bits/fcntl-linux.h" 3 4





extern __ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
    __attribute__ ((__nothrow__ , __leaf__));






extern int sync_file_range (int __fd, __off64_t __offset, __off64_t __count,
       unsigned int __flags);






extern __ssize_t vmsplice (int __fdout, const struct iovec *__iov,
      size_t __count, unsigned int __flags);





extern __ssize_t splice (int __fdin, __off64_t *__offin, int __fdout,
    __off64_t *__offout, size_t __len,
    unsigned int __flags);





extern __ssize_t tee (int __fdin, int __fdout, size_t __len,
        unsigned int __flags);
# 440 "/usr/include/aarch64-linux-gnu/bits/fcntl-linux.h" 3 4
extern int fallocate (int __fd, int __mode, __off64_t __offset, __off64_t __len) __asm__ ("" "fallocate64")

                     ;





extern int fallocate64 (int __fd, int __mode, __off64_t __offset,
   __off64_t __len);




extern int name_to_handle_at (int __dfd, const char *__name,
         struct file_handle *__handle, int *__mnt_id,
         int __flags) __attribute__ ((__nothrow__ , __leaf__));





extern int open_by_handle_at (int __mountdirfd, struct file_handle *__handle,
         int __flags);




# 62 "/usr/include/aarch64-linux-gnu/bits/fcntl.h" 2 3 4
# 36 "/usr/include/fcntl.h" 2 3 4
# 78 "/usr/include/fcntl.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/stat.h" 1 3 4
# 25 "/usr/include/aarch64-linux-gnu/bits/stat.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/struct_stat.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/bits/struct_stat.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/aarch64-linux-gnu/bits/struct_stat.h" 2 3 4
# 44 "/usr/include/aarch64-linux-gnu/bits/struct_stat.h" 3 4
struct stat
  {
    __dev_t st_dev;
    __ino64_t st_ino;
    __mode_t st_mode;
    __nlink_t st_nlink;
    __uid_t st_uid;
    __gid_t st_gid;
    __dev_t st_rdev;
    __dev_t __pad1;
    __off64_t st_size;
    __blksize_t st_blksize;
    int __pad2;
    __blkcnt64_t st_blocks;







    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 79 "/usr/include/aarch64-linux-gnu/bits/struct_stat.h" 3 4
    int __glibc_reserved[2];
  };




struct stat64
  {
    __dev_t st_dev;
    __ino64_t st_ino;
    __mode_t st_mode;
    __nlink_t st_nlink;
    __uid_t st_uid;
    __gid_t st_gid;
    __dev_t st_rdev;
    __dev_t __pad1;
    __off64_t st_size;
    __blksize_t st_blksize;
    int __pad2;
    __blkcnt64_t st_blocks;







    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 117 "/usr/include/aarch64-linux-gnu/bits/struct_stat.h" 3 4
    int __glibc_reserved[2];
  };
# 26 "/usr/include/aarch64-linux-gnu/bits/stat.h" 2 3 4
# 79 "/usr/include/fcntl.h" 2 3 4
# 152 "/usr/include/fcntl.h" 3 4
extern int fcntl (int __fd, int __cmd, ...) __asm__ ("" "fcntl64");





extern int fcntl64 (int __fd, int __cmd, ...);
# 184 "/usr/include/fcntl.h" 3 4
extern int open (const char *__file, int __oflag, ...) __asm__ ("" "open64")
     __attribute__ ((__nonnull__ (1)));





extern int open64 (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 209 "/usr/include/fcntl.h" 3 4
extern int openat (int __fd, const char *__file, int __oflag, ...) __asm__ ("" "openat64")
                    __attribute__ ((__nonnull__ (2)));





extern int openat64 (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 230 "/usr/include/fcntl.h" 3 4
extern int creat (const char *__file, mode_t __mode) __asm__ ("" "creat64")
                  __attribute__ ((__nonnull__ (1)));





extern int creat64 (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 259 "/usr/include/fcntl.h" 3 4
extern int lockf (int __fd, int __cmd, __off64_t __len) __asm__ ("" "lockf64");





extern int lockf64 (int __fd, int __cmd, off64_t __len);
# 277 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise (int __fd, __off64_t __offset, __off64_t __len, int __advise) __asm__ ("" "posix_fadvise64") __attribute__ ((__nothrow__ , __leaf__))

                      ;





extern int posix_fadvise64 (int __fd, off64_t __offset, off64_t __len,
       int __advise) __attribute__ ((__nothrow__ , __leaf__));
# 298 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate (int __fd, __off64_t __offset, __off64_t __len) __asm__ ("" "posix_fallocate64")

                           ;





extern int posix_fallocate64 (int __fd, off64_t __offset, off64_t __len);







# 1 "/usr/include/aarch64-linux-gnu/bits/fcntl2.h" 1 3 4
# 30 "/usr/include/aarch64-linux-gnu/bits/fcntl2.h" 3 4
extern int __open_2 (const char *__path, int __oflag) __asm__ ("" "__open64_2")
                     __attribute__ ((__nonnull__ (1)));
extern int __open_alias (const char *__path, int __oflag, ...) __asm__ ("" "open64")
                 __attribute__ ((__nonnull__ (1)));

extern void __open_too_many_args (void) __attribute__((__error__ ("open can be called either with 2 or 3 arguments, not more")))
                                                                  ;
extern void __open_missing_mode (void) __attribute__((__error__ ("open with O_CREAT or O_TMPFILE in second argument needs 3 arguments")))
                                                                            ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
open (const char *__path, int __oflag, ...)
{
  if (__builtin_va_arg_pack_len () > 1)
    __open_too_many_args ();

  if (__builtin_constant_p (__oflag))
    {
      if ((((__oflag) & 0100) != 0 || ((__oflag) & (020000000 | 040000)) == (020000000 | 040000)) && __builtin_va_arg_pack_len () < 1)
 {
   __open_missing_mode ();
   return __open_2 (__path, __oflag);
 }
      return __open_alias (__path, __oflag, __builtin_va_arg_pack ());
    }

  if (__builtin_va_arg_pack_len () < 1)
    return __open_2 (__path, __oflag);

  return __open_alias (__path, __oflag, __builtin_va_arg_pack ());
}



extern int __open64_2 (const char *__path, int __oflag) __attribute__ ((__nonnull__ (1)));
extern int __open64_alias (const char *__path, int __oflag, ...) __asm__ ("" "open64")
                   __attribute__ ((__nonnull__ (1)));
extern void __open64_too_many_args (void) __attribute__((__error__ ("open64 can be called either with 2 or 3 arguments, not more")))
                                                                    ;
extern void __open64_missing_mode (void) __attribute__((__error__ ("open64 with O_CREAT or O_TMPFILE in second argument needs 3 arguments")))
                                                                              ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
open64 (const char *__path, int __oflag, ...)
{
  if (__builtin_va_arg_pack_len () > 1)
    __open64_too_many_args ();

  if (__builtin_constant_p (__oflag))
    {
      if ((((__oflag) & 0100) != 0 || ((__oflag) & (020000000 | 040000)) == (020000000 | 040000)) && __builtin_va_arg_pack_len () < 1)
 {
   __open64_missing_mode ();
   return __open64_2 (__path, __oflag);
 }
      return __open64_alias (__path, __oflag, __builtin_va_arg_pack ());
    }

  if (__builtin_va_arg_pack_len () < 1)
    return __open64_2 (__path, __oflag);

  return __open64_alias (__path, __oflag, __builtin_va_arg_pack ());
}
# 104 "/usr/include/aarch64-linux-gnu/bits/fcntl2.h" 3 4
extern int __openat_2 (int __fd, const char *__path, int __oflag) __asm__ ("" "__openat64_2")

     __attribute__ ((__nonnull__ (2)));
extern int __openat_alias (int __fd, const char *__path, int __oflag, ...) __asm__ ("" "openat64")

     __attribute__ ((__nonnull__ (2)));

extern void __openat_too_many_args (void) __attribute__((__error__ ("openat can be called either with 3 or 4 arguments, not more")))
                                                                    ;
extern void __openat_missing_mode (void) __attribute__((__error__ ("openat with O_CREAT or O_TMPFILE in third argument needs 4 arguments")))
                                                                             ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
openat (int __fd, const char *__path, int __oflag, ...)
{
  if (__builtin_va_arg_pack_len () > 1)
    __openat_too_many_args ();

  if (__builtin_constant_p (__oflag))
    {
      if ((((__oflag) & 0100) != 0 || ((__oflag) & (020000000 | 040000)) == (020000000 | 040000)) && __builtin_va_arg_pack_len () < 1)
 {
   __openat_missing_mode ();
   return __openat_2 (__fd, __path, __oflag);
 }
      return __openat_alias (__fd, __path, __oflag, __builtin_va_arg_pack ());
    }

  if (__builtin_va_arg_pack_len () < 1)
    return __openat_2 (__fd, __path, __oflag);

  return __openat_alias (__fd, __path, __oflag, __builtin_va_arg_pack ());
}



extern int __openat64_2 (int __fd, const char *__path, int __oflag)
     __attribute__ ((__nonnull__ (2)));
extern int __openat64_alias (int __fd, const char *__path, int __oflag, ...) __asm__ ("" "openat64")

     __attribute__ ((__nonnull__ (2)));
extern void __openat64_too_many_args (void) __attribute__((__error__ ("openat64 can be called either with 3 or 4 arguments, not more")))
                                                                      ;
extern void __openat64_missing_mode (void) __attribute__((__error__ ("openat64 with O_CREAT or O_TMPFILE in third argument needs 4 arguments")))
                                                                               ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
openat64 (int __fd, const char *__path, int __oflag, ...)
{
  if (__builtin_va_arg_pack_len () > 1)
    __openat64_too_many_args ();

  if (__builtin_constant_p (__oflag))
    {
      if ((((__oflag) & 0100) != 0 || ((__oflag) & (020000000 | 040000)) == (020000000 | 040000)) && __builtin_va_arg_pack_len () < 1)
 {
   __openat64_missing_mode ();
   return __openat64_2 (__fd, __path, __oflag);
 }
      return __openat64_alias (__fd, __path, __oflag, __builtin_va_arg_pack ());
    }

  if (__builtin_va_arg_pack_len () < 1)
    return __openat64_2 (__fd, __path, __oflag);

  return __openat64_alias (__fd, __path, __oflag, __builtin_va_arg_pack ());
}
# 315 "/usr/include/fcntl.h" 2 3 4



# 54 "/libmdbx/src/osal.h" 2
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/limits.h" 1 3 4
# 34 "/usr/lib/gcc/aarch64-linux-gnu/11/include/limits.h" 3 4
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/limits.h" 1 3 4
# 203 "/usr/lib/gcc/aarch64-linux-gnu/11/include/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 26 "/usr/include/limits.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/limits.h" 2 3 4
# 195 "/usr/include/limits.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/aarch64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 161 "/usr/include/aarch64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/local_lim.h" 1 3 4
# 38 "/usr/include/aarch64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/aarch64-linux-gnu/bits/local_lim.h" 2 3 4
# 162 "/usr/include/aarch64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 196 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/aarch64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 200 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/aarch64-linux-gnu/bits/xopen_lim.h" 1 3 4
# 204 "/usr/include/limits.h" 2 3 4
# 204 "/usr/lib/gcc/aarch64-linux-gnu/11/include/limits.h" 2 3 4
# 8 "/usr/lib/gcc/aarch64-linux-gnu/11/include/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/aarch64-linux-gnu/11/include/limits.h" 2 3 4
# 55 "/libmdbx/src/osal.h" 2
# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/include/aarch64-linux-gnu/bits/types/__fpos_t.h" 1 3 4




# 1 "/usr/include/aarch64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/aarch64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 6 "/usr/include/aarch64-linux-gnu/bits/types/__fpos_t.h" 2 3 4




typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 40 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/aarch64-linux-gnu/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 41 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 42 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 43 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/aarch64-linux-gnu/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 44 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/aarch64-linux-gnu/bits/types/cookie_io_functions_t.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/bits/types/cookie_io_functions_t.h" 3 4
typedef __ssize_t cookie_read_function_t (void *__cookie, char *__buf,
                                          size_t __nbytes);







typedef __ssize_t cookie_write_function_t (void *__cookie, const char *__buf,
                                           size_t __nbytes);







typedef int cookie_seek_function_t (void *__cookie, __off64_t *__pos, int __w);


typedef int cookie_close_function_t (void *__cookie);






typedef struct _IO_cookie_io_functions_t
{
  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
# 47 "/usr/include/stdio.h" 2 3 4
# 86 "/usr/include/stdio.h" 3 4
typedef __fpos64_t fpos_t;


typedef __fpos64_t fpos64_t;
# 133 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 134 "/usr/include/stdio.h" 2 3 4
# 143 "/usr/include/stdio.h" 3 4
extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));
# 170 "/usr/include/stdio.h" 3 4
extern int renameat2 (int __oldfd, const char *__old, int __newfd,
        const char *__new, unsigned int __flags) __attribute__ ((__nothrow__ , __leaf__));






extern int fclose (FILE *__stream);
# 192 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile (void) __asm__ ("" "tmpfile64")
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) __attribute__ ((__warn_unused_result__));






extern FILE *tmpfile64 (void)
   __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) __attribute__ ((__warn_unused_result__));



extern char *tmpnam (char[20]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern char *tmpnam_r (char __s[20]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
# 222 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
   __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__)) __attribute__ ((__malloc__ (__builtin_free, 1)));






extern int fflush (FILE *__stream);
# 239 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 249 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 270 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename, const char *__restrict __modes) __asm__ ("" "fopen64")

  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) __attribute__ ((__warn_unused_result__));
extern FILE *freopen (const char *__restrict __filename, const char *__restrict __modes, FILE *__restrict __stream) __asm__ ("" "freopen64")


  __attribute__ ((__warn_unused_result__));






extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) __attribute__ ((__warn_unused_result__));
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));




extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) __attribute__ ((__warn_unused_result__));





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     cookie_io_functions_t __io_funcs) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) __attribute__ ((__warn_unused_result__));




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) __attribute__ ((__warn_unused_result__));




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) __attribute__ ((__warn_unused_result__));
# 328 "/usr/include/stdio.h" 3 4
extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));





extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0))) __attribute__ ((__warn_unused_result__));
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) __attribute__ ((__warn_unused_result__));
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) __attribute__ ((__warn_unused_result__));




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) __attribute__ ((__warn_unused_result__));




extern int scanf (const char *__restrict __format, ...) __attribute__ ((__warn_unused_result__));

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));
# 434 "/usr/include/stdio.h" 3 4
extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                          __attribute__ ((__warn_unused_result__));
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                         __attribute__ ((__warn_unused_result__));
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ , __leaf__))

                      ;
# 459 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) __attribute__ ((__warn_unused_result__));





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) __attribute__ ((__warn_unused_result__));


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));





extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) __attribute__ ((__warn_unused_result__));
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) __attribute__ ((__warn_unused_result__));
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 513 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);






extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 538 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 549 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 565 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 1, 2)));
# 615 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__))
    __attribute__ ((__access__ (__write_only__, 1, 2)));
# 632 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));







extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 691 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 702 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) __attribute__ ((__warn_unused_result__));




extern void rewind (FILE *__stream);
# 744 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off64_t __off, int __whence) __asm__ ("" "fseeko64")

                  ;
extern __off64_t ftello (FILE *__stream) __asm__ ("" "ftello64");
# 768 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos) __asm__ ("" "fgetpos64")
                                          ;
extern int fsetpos (FILE *__stream, const fpos_t *__pos) __asm__ ("" "fsetpos64")
                                                          ;







extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) __attribute__ ((__warn_unused_result__));
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);



extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));



extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));







extern void perror (const char *__s);




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
# 823 "/usr/include/stdio.h" 3 4
extern int pclose (FILE *__stream);





extern FILE *popen (const char *__command, const char *__modes)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (pclose, 1))) __attribute__ ((__warn_unused_result__));






extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__access__ (__write_only__, 1)));





extern char *cuserid (char *__s)
  __attribute__ ((__access__ (__write_only__, 1)));




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 885 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);




# 1 "/usr/include/aarch64-linux-gnu/bits/stdio.h" 1 3 4
# 46 "/usr/include/aarch64-linux-gnu/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
getchar (void)
{
  return getc (stdin);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fgetc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}





extern __inline __attribute__ ((__gnu_inline__)) int
getc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}


extern __inline __attribute__ ((__gnu_inline__)) int
getchar_unlocked (void)
{
  return (__builtin_expect (((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end), 0) ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
}




extern __inline __attribute__ ((__gnu_inline__)) int
putchar (int __c)
{
  return putc (__c, stdout);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fputc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) int
putc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}


extern __inline __attribute__ ((__gnu_inline__)) int
putchar_unlocked (int __c)
{
  return (__builtin_expect (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end), 0) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) __ssize_t
getline (char **__lineptr, size_t *__n, FILE *__stream)
{
  return __getdelim (__lineptr, __n, '\n', __stream);
}





extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) feof_unlocked (FILE *__stream)
{
  return (((__stream)->_flags & 0x0010) != 0);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) ferror_unlocked (FILE *__stream)
{
  return (((__stream)->_flags & 0x0020) != 0);
}
# 892 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/aarch64-linux-gnu/bits/stdio2.h" 1 3 4
# 26 "/usr/include/aarch64-linux-gnu/bits/stdio2.h" 3 4
extern int __sprintf_chk (char *__restrict __s, int __flag, size_t __slen,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__))
    __attribute__ ((__access__ (__write_only__, 1, 3)));
extern int __vsprintf_chk (char *__restrict __s, int __flag, size_t __slen,
      const char *__restrict __format,
      __gnuc_va_list __ap) __attribute__ ((__nothrow__ , __leaf__))
    __attribute__ ((__access__ (__write_only__, 1, 3)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) sprintf (char *__restrict __s, const char *__restrict __fmt, ...)
{
  return __builtin___sprintf_chk (__s, 2 - 1,
      __builtin_object_size (__s, 2 > 1), __fmt,
      __builtin_va_arg_pack ());
}






extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) vsprintf (char *__restrict __s, const char *__restrict __fmt, __gnuc_va_list __ap)

{
  return __builtin___vsprintf_chk (__s, 2 - 1,
       __builtin_object_size (__s, 2 > 1), __fmt, __ap);
}



extern int __snprintf_chk (char *__restrict __s, size_t __n, int __flag,
      size_t __slen, const char *__restrict __format,
      ...) __attribute__ ((__nothrow__ , __leaf__))
    __attribute__ ((__access__ (__write_only__, 1, 2)));
extern int __vsnprintf_chk (char *__restrict __s, size_t __n, int __flag,
       size_t __slen, const char *__restrict __format,
       __gnuc_va_list __ap) __attribute__ ((__nothrow__ , __leaf__));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) snprintf (char *__restrict __s, size_t __n, const char *__restrict __fmt, ...)

{
  return __builtin___snprintf_chk (__s, __n, 2 - 1,
       __builtin_object_size (__s, 2 > 1), __fmt,
       __builtin_va_arg_pack ());
}






extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) vsnprintf (char *__restrict __s, size_t __n, const char *__restrict __fmt, __gnuc_va_list __ap)

{
  return __builtin___vsnprintf_chk (__s, __n, 2 - 1,
        __builtin_object_size (__s, 2 > 1), __fmt, __ap);
}





extern int __fprintf_chk (FILE *__restrict __stream, int __flag,
     const char *__restrict __format, ...);
extern int __printf_chk (int __flag, const char *__restrict __format, ...);
extern int __vfprintf_chk (FILE *__restrict __stream, int __flag,
      const char *__restrict __format, __gnuc_va_list __ap);
extern int __vprintf_chk (int __flag, const char *__restrict __format,
     __gnuc_va_list __ap);


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
fprintf (FILE *__restrict __stream, const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, 2 - 1, __fmt,
   __builtin_va_arg_pack ());
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
printf (const char *__restrict __fmt, ...)
{
  return __printf_chk (2 - 1, __fmt, __builtin_va_arg_pack ());
}







extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
vprintf (const char *__restrict __fmt, __gnuc_va_list __ap)
{

  return __vfprintf_chk (stdout, 2 - 1, __fmt, __ap);



}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
vfprintf (FILE *__restrict __stream,
   const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vfprintf_chk (__stream, 2 - 1, __fmt, __ap);
}


extern int __dprintf_chk (int __fd, int __flag, const char *__restrict __fmt,
     ...) __attribute__ ((__format__ (__printf__, 3, 4)));
extern int __vdprintf_chk (int __fd, int __flag,
      const char *__restrict __fmt, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 3, 0)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
dprintf (int __fd, const char *__restrict __fmt, ...)
{
  return __dprintf_chk (__fd, 2 - 1, __fmt,
   __builtin_va_arg_pack ());
}





extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
vdprintf (int __fd, const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vdprintf_chk (__fd, 2 - 1, __fmt, __ap);
}




extern int __asprintf_chk (char **__restrict __ptr, int __flag,
      const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__printf__, 3, 4))) __attribute__ ((__warn_unused_result__));
extern int __vasprintf_chk (char **__restrict __ptr, int __flag,
       const char *__restrict __fmt, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__printf__, 3, 0))) __attribute__ ((__warn_unused_result__));
extern int __obstack_printf_chk (struct obstack *__restrict __obstack,
     int __flag, const char *__restrict __format,
     ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__printf__, 3, 4)));
extern int __obstack_vprintf_chk (struct obstack *__restrict __obstack,
      int __flag,
      const char *__restrict __format,
      __gnuc_va_list __args)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__printf__, 3, 0)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) asprintf (char **__restrict __ptr, const char *__restrict __fmt, ...)
{
  return __asprintf_chk (__ptr, 2 - 1, __fmt,
    __builtin_va_arg_pack ());
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) __asprintf (char **__restrict __ptr, const char *__restrict __fmt, ...)

{
  return __asprintf_chk (__ptr, 2 - 1, __fmt,
    __builtin_va_arg_pack ());
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) obstack_printf (struct obstack *__restrict __obstack, const char *__restrict __fmt, ...)

{
  return __obstack_printf_chk (__obstack, 2 - 1, __fmt,
          __builtin_va_arg_pack ());
}
# 214 "/usr/include/aarch64-linux-gnu/bits/stdio2.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) vasprintf (char **__restrict __ptr, const char *__restrict __fmt, __gnuc_va_list __ap)

{
  return __vasprintf_chk (__ptr, 2 - 1, __fmt, __ap);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) obstack_vprintf (struct obstack *__restrict __obstack, const char *__restrict __fmt, __gnuc_va_list __ap)

{
  return __obstack_vprintf_chk (__obstack, 2 - 1, __fmt,
    __ap);
}
# 248 "/usr/include/aarch64-linux-gnu/bits/stdio2.h" 3 4
extern char *__fgets_chk (char *__restrict __s, size_t __size, int __n,
     FILE *__restrict __stream)
    __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 1, 3)));
extern char *__fgets_alias (char *__restrict __s, int __n, FILE *__restrict __stream) __asm__ ("" "fgets")


    __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 1, 2)));
extern char *__fgets_chk_warn (char *__restrict __s, size_t __size, int __n, FILE *__restrict __stream) __asm__ ("" "__fgets_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fgets called with bigger size than length " "of destination buffer")))
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 1, 2))) char *
fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
{
  size_t sz = __builtin_object_size (__s, 2 > 1);
  if ((((__typeof (__n)) 0 < (__typeof (__n)) -1 || (__builtin_constant_p (__n) && (__n) > 0)) && __builtin_constant_p ((((long unsigned int) (__n)) <= (sz) / (sizeof (char)))) && (((long unsigned int) (__n)) <= (sz) / (sizeof (char)))))
    return __fgets_alias (__s, __n, __stream);
  if ((((__typeof (__n)) 0 < (__typeof (__n)) -1 || (__builtin_constant_p (__n) && (__n) > 0)) && __builtin_constant_p ((((long unsigned int) (__n)) <= (sz) / (sizeof (char)))) && !(((long unsigned int) (__n)) <= (sz) / (sizeof (char)))))
    return __fgets_chk_warn (__s, sz, __n, __stream);
  return __fgets_chk (__s, sz, __n, __stream);
}

extern size_t __fread_chk (void *__restrict __ptr, size_t __ptrlen,
      size_t __size, size_t __n,
      FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern size_t __fread_alias (void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "fread")


            __attribute__ ((__warn_unused_result__));
extern size_t __fread_chk_warn (void *__restrict __ptr, size_t __ptrlen, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "__fread_chk")




     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fread called with bigger size * nmemb than length " "of destination buffer")))
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) size_t
fread (void *__restrict __ptr, size_t __size, size_t __n,
       FILE *__restrict __stream)
{
  size_t sz = __builtin_object_size (__ptr, 0);
  if ((((__typeof (__n)) 0 < (__typeof (__n)) -1 || (__builtin_constant_p (__n) && (__n) > 0)) && __builtin_constant_p ((((long unsigned int) (__n)) <= (sz) / (__size))) && (((long unsigned int) (__n)) <= (sz) / (__size))))
    return __fread_alias (__ptr, __size, __n, __stream);
  if ((((__typeof (__n)) 0 < (__typeof (__n)) -1 || (__builtin_constant_p (__n) && (__n) > 0)) && __builtin_constant_p ((((long unsigned int) (__n)) <= (sz) / (__size))) && !(((long unsigned int) (__n)) <= (sz) / (__size))))
    return __fread_chk_warn (__ptr, sz, __size, __n, __stream);
  return __fread_chk (__ptr, sz, __size, __n, __stream);
}


extern char *__fgets_unlocked_chk (char *__restrict __s, size_t __size,
       int __n, FILE *__restrict __stream)
    __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 1, 3)));
extern char *__fgets_unlocked_alias (char *__restrict __s, int __n, FILE *__restrict __stream) __asm__ ("" "fgets_unlocked")


    __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 1, 2)));
extern char *__fgets_unlocked_chk_warn (char *__restrict __s, size_t __size, int __n, FILE *__restrict __stream) __asm__ ("" "__fgets_unlocked_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fgets_unlocked called with bigger size than length " "of destination buffer")))
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 1, 2))) char *
fgets_unlocked (char *__restrict __s, int __n, FILE *__restrict __stream)
{
  size_t sz = __builtin_object_size (__s, 2 > 1);
  if ((((__typeof (__n)) 0 < (__typeof (__n)) -1 || (__builtin_constant_p (__n) && (__n) > 0)) && __builtin_constant_p ((((long unsigned int) (__n)) <= (sz) / (sizeof (char)))) && (((long unsigned int) (__n)) <= (sz) / (sizeof (char)))))
    return __fgets_unlocked_alias (__s, __n, __stream);
  if ((((__typeof (__n)) 0 < (__typeof (__n)) -1 || (__builtin_constant_p (__n) && (__n) > 0)) && __builtin_constant_p ((((long unsigned int) (__n)) <= (sz) / (sizeof (char)))) && !(((long unsigned int) (__n)) <= (sz) / (sizeof (char)))))
    return __fgets_unlocked_chk_warn (__s, sz, __n, __stream);
  return __fgets_unlocked_chk (__s, sz, __n, __stream);
}




extern size_t __fread_unlocked_chk (void *__restrict __ptr, size_t __ptrlen,
        size_t __size, size_t __n,
        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern size_t __fread_unlocked_alias (void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "fread_unlocked")


                     __attribute__ ((__warn_unused_result__));
extern size_t __fread_unlocked_chk_warn (void *__restrict __ptr, size_t __ptrlen, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "__fread_unlocked_chk")




     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fread_unlocked called with bigger size * nmemb than " "length of destination buffer")))
                                        ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) size_t
fread_unlocked (void *__restrict __ptr, size_t __size, size_t __n,
  FILE *__restrict __stream)
{
  size_t sz = __builtin_object_size (__ptr, 0);
  if ((((__typeof (__n)) 0 < (__typeof (__n)) -1 || (__builtin_constant_p (__n) && (__n) > 0)) && __builtin_constant_p ((((long unsigned int) (__n)) <= (sz) / (__size))) && (((long unsigned int) (__n)) <= (sz) / (__size))))
    {

      if (__builtin_constant_p (__size)
   && __builtin_constant_p (__n)
   && (__size | __n) < (((size_t) 1) << (8 * sizeof (size_t) / 2))
   && __size * __n <= 8)
 {
   size_t __cnt = __size * __n;
   char *__cptr = (char *) __ptr;
   if (__cnt == 0)
     return 0;

   for (; __cnt > 0; --__cnt)
     {
       int __c = getc_unlocked (__stream);
       if (__c == (-1))
  break;
       *__cptr++ = __c;
     }
   return (__cptr - (char *) __ptr) / __size;
 }

      return __fread_unlocked_alias (__ptr, __size, __n, __stream);
    }
  if ((((__typeof (__n)) 0 < (__typeof (__n)) -1 || (__builtin_constant_p (__n) && (__n) > 0)) && __builtin_constant_p ((((long unsigned int) (__n)) <= (sz) / (__size))) && !(((long unsigned int) (__n)) <= (sz) / (__size))))
    return __fread_unlocked_chk_warn (__ptr, sz, __size, __n, __stream);
  return __fread_unlocked_chk (__ptr, sz, __size, __n, __stream);

}
# 895 "/usr/include/stdio.h" 2 3 4








# 56 "/libmdbx/src/osal.h" 2
# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4






# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4
# 43 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
    __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__access__ (__write_only__, 1, 4)));




extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 80 "/usr/include/string.h" 3 4
extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 107 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 120 "/usr/include/string.h" 3 4
extern void *rawmemchr (const void *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 133 "/usr/include/string.h" 3 4
extern void *memrchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)))
      __attribute__ ((__access__ (__read_only__, 1, 3)));





extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
    __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 1, 3)));






extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)))
     __attribute__ ((__access__ (__write_only__, 1, 3)));





extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 246 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 273 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 286 "/usr/include/string.h" 3 4
extern char *strchrnul (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 323 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 350 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 380 "/usr/include/string.h" 3 4
extern char *strcasestr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));







extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)))
    __attribute__ ((__access__ (__read_only__, 1, 2)))
    __attribute__ ((__access__ (__read_only__, 3, 4)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));
# 444 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 2, 3)));




extern const char *strerrordesc_np (int __err) __attribute__ ((__nothrow__ , __leaf__));

extern const char *strerrorname_np (int __err) __attribute__ ((__nothrow__ , __leaf__));





extern char *strerror_l (int __errnum, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4










extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 68 "/usr/include/strings.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 96 "/usr/include/strings.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int ffsl (long int __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));








# 1 "/usr/include/aarch64-linux-gnu/bits/strings_fortified.h" 1 3 4
# 22 "/usr/include/aarch64-linux-gnu/bits/strings_fortified.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void
__attribute__ ((__nothrow__ , __leaf__)) bcopy (const void *__src, void *__dest, size_t __len)
{
  (void) __builtin___memmove_chk (__dest, __src, __len,
      __builtin_object_size (__dest, 0));
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void
__attribute__ ((__nothrow__ , __leaf__)) bzero (void *__dest, size_t __len)
{
  (void) __builtin___memset_chk (__dest, '\0', __len,
     __builtin_object_size (__dest, 0));
}
# 145 "/usr/include/strings.h" 2 3 4
# 463 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__write_only__, 1, 2)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));



extern const char *sigabbrev_np (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern const char *sigdescr_np (int __sig) __attribute__ ((__nothrow__ , __leaf__));



extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__read_write__, 1, 2)));
# 527 "/usr/include/string.h" 3 4
extern char *basename (const char *__filename) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







# 1 "/usr/include/aarch64-linux-gnu/bits/string_fortified.h" 1 3 4
# 25 "/usr/include/aarch64-linux-gnu/bits/string_fortified.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void *
__attribute__ ((__nothrow__ , __leaf__)) memcpy (void *__restrict __dest, const void *__restrict __src, size_t __len)

{
  return __builtin___memcpy_chk (__dest, __src, __len,
     __builtin_object_size (__dest, 0));
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void *
__attribute__ ((__nothrow__ , __leaf__)) memmove (void *__dest, const void *__src, size_t __len)
{
  return __builtin___memmove_chk (__dest, __src, __len,
      __builtin_object_size (__dest, 0));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void *
__attribute__ ((__nothrow__ , __leaf__)) mempcpy (void *__restrict __dest, const void *__restrict __src, size_t __len)

{
  return __builtin___mempcpy_chk (__dest, __src, __len,
      __builtin_object_size (__dest, 0));
}
# 56 "/usr/include/aarch64-linux-gnu/bits/string_fortified.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void *
__attribute__ ((__nothrow__ , __leaf__)) memset (void *__dest, int __ch, size_t __len)
{
  return __builtin___memset_chk (__dest, __ch, __len,
     __builtin_object_size (__dest, 0));
}




void __explicit_bzero_chk (void *__dest, size_t __len, size_t __destlen)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__access__ (__write_only__, 1, 2)));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void
__attribute__ ((__nothrow__ , __leaf__)) explicit_bzero (void *__dest, size_t __len)
{
  __explicit_bzero_chk (__dest, __len, __builtin_object_size (__dest, 0));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strcpy (char *__restrict __dest, const char *__restrict __src)
{
  return __builtin___strcpy_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) stpcpy (char *__restrict __dest, const char *__restrict __src)
{
  return __builtin___stpcpy_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
}



extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strncpy (char *__restrict __dest, const char *__restrict __src, size_t __len)

{
  return __builtin___strncpy_chk (__dest, __src, __len,
      __builtin_object_size (__dest, 2 > 1));
}



extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) stpncpy (char *__dest, const char *__src, size_t __n)
{
  return __builtin___stpncpy_chk (__dest, __src, __n,
      __builtin_object_size (__dest, 2 > 1));
}
# 127 "/usr/include/aarch64-linux-gnu/bits/string_fortified.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strcat (char *__restrict __dest, const char *__restrict __src)
{
  return __builtin___strcat_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strncat (char *__restrict __dest, const char *__restrict __src, size_t __len)

{
  return __builtin___strncat_chk (__dest, __src, __len,
      __builtin_object_size (__dest, 2 > 1));
}
# 536 "/usr/include/string.h" 2 3 4




# 57 "/libmdbx/src/osal.h" 2




# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stdalign.h" 1 3 4
# 62 "/libmdbx/src/osal.h" 2
# 100 "/libmdbx/src/osal.h"
# 1 "/usr/include/malloc.h" 1 3 4
# 24 "/usr/include/malloc.h" 3 4
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 25 "/usr/include/malloc.h" 2 3 4
# 36 "/usr/include/malloc.h" 3 4



extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) __attribute__ ((__warn_unused_result__));


extern void *calloc (size_t __nmemb, size_t __size)
__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (1, 2))) __attribute__ ((__warn_unused_result__));






extern void *realloc (void *__ptr, size_t __size)
__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__)) __attribute__ ((__alloc_size__ (2)));






extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__)) __attribute__ ((__alloc_size__ (2, 3)))
  __attribute__ ((__malloc__ (__builtin_free, 1)));


extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));


extern void *memalign (size_t __alignment, size_t __size)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_align__ (1)))
  __attribute__ ((__alloc_size__ (2))) __attribute__ ((__warn_unused_result__)) __attribute__ ((__malloc__ (__builtin_free, 1)));


extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) __attribute__ ((__warn_unused_result__)) __attribute__ ((__malloc__ (__builtin_free, 1)));



extern void *pvalloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
  __attribute__ ((__warn_unused_result__)) __attribute__ ((__malloc__ (__builtin_free, 1)));



struct mallinfo
{
  int arena;
  int ordblks;
  int smblks;
  int hblks;
  int hblkhd;
  int usmblks;
  int fsmblks;
  int uordblks;
  int fordblks;
  int keepcost;
};




struct mallinfo2
{
  size_t arena;
  size_t ordblks;
  size_t smblks;
  size_t hblks;
  size_t hblkhd;
  size_t usmblks;
  size_t fsmblks;
  size_t uordblks;
  size_t fordblks;
  size_t keepcost;
};


extern struct mallinfo mallinfo (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));


extern struct mallinfo2 mallinfo2 (void) __attribute__ ((__nothrow__ , __leaf__));
# 144 "/usr/include/malloc.h" 3 4
extern int mallopt (int __param, int __val) __attribute__ ((__nothrow__ , __leaf__));



extern int malloc_trim (size_t __pad) __attribute__ ((__nothrow__ , __leaf__));



extern size_t malloc_usable_size (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));


extern void malloc_stats (void) __attribute__ ((__nothrow__ , __leaf__));


extern int malloc_info (int __options, FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));


# 101 "/libmdbx/src/osal.h" 2


# 1 "/usr/include/mntent.h" 1 3 4
# 23 "/usr/include/mntent.h" 3 4
# 1 "/usr/include/paths.h" 1 3 4
# 24 "/usr/include/mntent.h" 2 3 4
# 48 "/usr/include/mntent.h" 3 4



struct mntent
  {
    char *mnt_fsname;
    char *mnt_dir;
    char *mnt_type;
    char *mnt_opts;
    int mnt_freq;
    int mnt_passno;
  };




extern FILE *setmntent (const char *__file, const char *__mode) __attribute__ ((__nothrow__ , __leaf__));




extern struct mntent *getmntent (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern struct mntent *getmntent_r (FILE *__restrict __stream,
       struct mntent *__restrict __result,
       char *__restrict __buffer,
       int __bufsize) __attribute__ ((__nothrow__ , __leaf__));




extern int addmntent (FILE *__restrict __stream,
        const struct mntent *__restrict __mnt) __attribute__ ((__nothrow__ , __leaf__));


extern int endmntent (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern char *hasmntopt (const struct mntent *__mnt,
   const char *__opt) __attribute__ ((__nothrow__ , __leaf__));



# 104 "/libmdbx/src/osal.h" 2
# 124 "/libmdbx/src/osal.h"
# 1 "/usr/include/aarch64-linux-gnu/sys/sendfile.h" 1 3 4
# 25 "/usr/include/aarch64-linux-gnu/sys/sendfile.h" 3 4

# 37 "/usr/include/aarch64-linux-gnu/sys/sendfile.h" 3 4
extern ssize_t sendfile (int __out_fd, int __in_fd, __off64_t *__offset, size_t __count) __asm__ ("" "sendfile64") __attribute__ ((__nothrow__ , __leaf__))

                                ;





extern ssize_t sendfile64 (int __out_fd, int __in_fd, __off64_t *__offset,
      size_t __count) __attribute__ ((__nothrow__ , __leaf__));



# 125 "/libmdbx/src/osal.h" 2
# 1 "/usr/include/aarch64-linux-gnu/sys/statfs.h" 1 3 4
# 25 "/usr/include/aarch64-linux-gnu/sys/statfs.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/statfs.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/statfs.h" 3 4
struct statfs
  {
    __fsword_t f_type;
    __fsword_t f_bsize;







    __fsblkcnt64_t f_blocks;
    __fsblkcnt64_t f_bfree;
    __fsblkcnt64_t f_bavail;
    __fsfilcnt64_t f_files;
    __fsfilcnt64_t f_ffree;

    __fsid_t f_fsid;
    __fsword_t f_namelen;
    __fsword_t f_frsize;
    __fsword_t f_flags;
    __fsword_t f_spare[4];
  };


struct statfs64
  {
    __fsword_t f_type;
    __fsword_t f_bsize;
    __fsblkcnt64_t f_blocks;
    __fsblkcnt64_t f_bfree;
    __fsblkcnt64_t f_bavail;
    __fsfilcnt64_t f_files;
    __fsfilcnt64_t f_ffree;
    __fsid_t f_fsid;
    __fsword_t f_namelen;
    __fsword_t f_frsize;
    __fsword_t f_flags;
    __fsword_t f_spare[4];
  };
# 26 "/usr/include/aarch64-linux-gnu/sys/statfs.h" 2 3 4









extern int statfs (const char *__file, struct statfs *__buf) __asm__ ("" "statfs64") __attribute__ ((__nothrow__ , __leaf__))

                __attribute__ ((__nonnull__ (1, 2)));





extern int statfs64 (const char *__file, struct statfs64 *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 54 "/usr/include/aarch64-linux-gnu/sys/statfs.h" 3 4
extern int fstatfs (int __fildes, struct statfs *__buf) __asm__ ("" "fstatfs64") __attribute__ ((__nothrow__ , __leaf__))
                 __attribute__ ((__nonnull__ (2)));





extern int fstatfs64 (int __fildes, struct statfs64 *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



# 126 "/libmdbx/src/osal.h" 2
# 135 "/libmdbx/src/osal.h"
# 1 "/usr/include/utmpx.h" 1 3 4
# 22 "/usr/include/utmpx.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/sys/time.h" 1 3 4
# 34 "/usr/include/aarch64-linux-gnu/sys/time.h" 3 4

# 52 "/usr/include/aarch64-linux-gnu/sys/time.h" 3 4
struct timezone
  {
    int tz_minuteswest;
    int tz_dsttime;
  };
# 67 "/usr/include/aarch64-linux-gnu/sys/time.h" 3 4
extern int gettimeofday (struct timeval *__restrict __tv,
    void *__restrict __tz) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 86 "/usr/include/aarch64-linux-gnu/sys/time.h" 3 4
extern int settimeofday (const struct timeval *__tv,
    const struct timezone *__tz)
     __attribute__ ((__nothrow__ , __leaf__));





extern int adjtime (const struct timeval *__delta,
      struct timeval *__olddelta) __attribute__ ((__nothrow__ , __leaf__));
# 114 "/usr/include/aarch64-linux-gnu/sys/time.h" 3 4
enum __itimer_which
  {

    ITIMER_REAL = 0,


    ITIMER_VIRTUAL = 1,



    ITIMER_PROF = 2

  };



struct itimerval
  {

    struct timeval it_interval;

    struct timeval it_value;
  };




typedef enum __itimer_which __itimer_which_t;







extern int getitimer (__itimer_which_t __which,
        struct itimerval *__value) __attribute__ ((__nothrow__ , __leaf__));




extern int setitimer (__itimer_which_t __which,
        const struct itimerval *__restrict __new,
        struct itimerval *__restrict __old) __attribute__ ((__nothrow__ , __leaf__));




extern int utimes (const char *__file, const struct timeval __tvp[2])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 189 "/usr/include/aarch64-linux-gnu/sys/time.h" 3 4
extern int lutimes (const char *__file, const struct timeval __tvp[2])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int futimes (int __fd, const struct timeval __tvp[2]) __attribute__ ((__nothrow__ , __leaf__));
# 214 "/usr/include/aarch64-linux-gnu/sys/time.h" 3 4
extern int futimesat (int __fd, const char *__file,
        const struct timeval __tvp[2]) __attribute__ ((__nothrow__ , __leaf__));
# 258 "/usr/include/aarch64-linux-gnu/sys/time.h" 3 4

# 23 "/usr/include/utmpx.h" 2 3 4
# 31 "/usr/include/utmpx.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/utmpx.h" 1 3 4
# 25 "/usr/include/aarch64-linux-gnu/bits/utmpx.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/wordsize.h" 1 3 4
# 26 "/usr/include/aarch64-linux-gnu/bits/utmpx.h" 2 3 4
# 42 "/usr/include/aarch64-linux-gnu/bits/utmpx.h" 3 4
struct __exit_status
  {

    short int e_termination;
    short int e_exit;




  };



struct utmpx
{
  short int ut_type;
  __pid_t ut_pid;
  char ut_line[32]
    __attribute__ ((__nonstring__));
  char ut_id[4]
    __attribute__ ((__nonstring__));
  char ut_user[32]
    __attribute__ ((__nonstring__));
  char ut_host[256]
    __attribute__ ((__nonstring__));
  struct __exit_status ut_exit;
# 81 "/usr/include/aarch64-linux-gnu/bits/utmpx.h" 3 4
  long int ut_session;
  struct timeval ut_tv;

  __int32_t ut_addr_v6[4];
  char __glibc_reserved[20];
};
# 32 "/usr/include/utmpx.h" 2 3 4
# 43 "/usr/include/utmpx.h" 3 4
struct utmp;









extern void setutxent (void);





extern void endutxent (void);





extern struct utmpx *getutxent (void);





extern struct utmpx *getutxid (const struct utmpx *__id);





extern struct utmpx *getutxline (const struct utmpx *__line);





extern struct utmpx *pututxline (const struct utmpx *__utmpx);
# 93 "/usr/include/utmpx.h" 3 4
extern int utmpxname (const char *__file);







extern void updwtmpx (const char *__wtmpx_file,
        const struct utmpx *__utmpx);
# 111 "/usr/include/utmpx.h" 3 4
extern void getutmp (const struct utmpx *__utmpx,
       struct utmp *__utmp);







extern void getutmpx (const struct utmp *__utmp, struct utmpx *__utmpx);



# 136 "/libmdbx/src/osal.h" 2
# 232 "/libmdbx/src/osal.h"
# 1 "/usr/include/unistd.h" 1 3 4
# 27 "/usr/include/unistd.h" 3 4

# 202 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/posix_opt.h" 1 3 4
# 203 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/aarch64-linux-gnu/bits/environments.h" 1 3 4
# 22 "/usr/include/aarch64-linux-gnu/bits/environments.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/bits/environments.h" 2 3 4
# 207 "/usr/include/unistd.h" 2 3 4
# 226 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 227 "/usr/include/unistd.h" 2 3 4
# 274 "/usr/include/unistd.h" 3 4
typedef __socklen_t socklen_t;
# 287 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int euidaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int eaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int execveat (int __fd, const char *__path, char *const __argv[],
                     char *const __envp[], int __flags)
    __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));






extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) __attribute__ ((__warn_unused_result__));
# 342 "/usr/include/unistd.h" 3 4
extern __off64_t lseek (int __fd, __off64_t __offset, int __whence) __asm__ ("" "lseek64") __attribute__ ((__nothrow__ , __leaf__))

             ;





extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     __attribute__ ((__nothrow__ , __leaf__));






extern int close (int __fd);




extern void closefrom (int __lowfd) __attribute__ ((__nothrow__ , __leaf__));







extern ssize_t read (int __fd, void *__buf, size_t __nbytes) __attribute__ ((__warn_unused_result__))
    __attribute__ ((__access__ (__write_only__, 2, 3)));





extern ssize_t write (int __fd, const void *__buf, size_t __n) __attribute__ ((__warn_unused_result__))
    __attribute__ ((__access__ (__read_only__, 2, 3)));
# 404 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes, __off64_t __offset) __asm__ ("" "pread64")

               __attribute__ ((__warn_unused_result__))
    __attribute__ ((__access__ (__write_only__, 2, 3)));
extern ssize_t pwrite (int __fd, const void *__buf, size_t __nbytes, __off64_t __offset) __asm__ ("" "pwrite64")

                __attribute__ ((__warn_unused_result__))
    __attribute__ ((__access__ (__read_only__, 2, 3)));
# 422 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) __attribute__ ((__warn_unused_result__))
    __attribute__ ((__access__ (__write_only__, 2, 3)));


extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset) __attribute__ ((__warn_unused_result__))
    __attribute__ ((__access__ (__read_only__, 2, 3)));







extern int pipe (int __pipedes[2]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern int pipe2 (int __pipedes[2], int __flags) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
# 452 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) __attribute__ ((__nothrow__ , __leaf__));
# 464 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     __attribute__ ((__nothrow__ , __leaf__));






extern int usleep (__useconds_t __useconds);
# 489 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) __attribute__ ((__warn_unused_result__));



extern int chdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



extern int fchdir (int __fd) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
# 531 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));





extern char *get_current_dir_name (void) __attribute__ ((__nothrow__ , __leaf__));







extern char *getwd (char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) __attribute__ ((__warn_unused_result__))
    __attribute__ ((__access__ (__write_only__, 1)));




extern int dup (int __fd) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));


extern int dup2 (int __fd, int __fd2) __attribute__ ((__nothrow__ , __leaf__));




extern int dup3 (int __fd, int __fd2, int __flags) __attribute__ ((__nothrow__ , __leaf__));



extern char **__environ;

extern char **environ;





extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/aarch64-linux-gnu/bits/confname.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT,


    _SC_MINSIGSTKSZ,


    _SC_SIGSTKSZ

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 631 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) __attribute__ ((__nothrow__ , __leaf__));


extern long int sysconf (int __name) __attribute__ ((__nothrow__ , __leaf__));



extern size_t confstr (int __name, char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__))
    __attribute__ ((__access__ (__write_only__, 2, 3)));




extern __pid_t getpid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getppid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getpgrp (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t __getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));

extern __pid_t getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));






extern int setpgid (__pid_t __pid, __pid_t __pgid) __attribute__ ((__nothrow__ , __leaf__));
# 682 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) __attribute__ ((__nothrow__ , __leaf__));






extern __pid_t setsid (void) __attribute__ ((__nothrow__ , __leaf__));



extern __pid_t getsid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));



extern __uid_t getuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __uid_t geteuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getgid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getegid (void) __attribute__ ((__nothrow__ , __leaf__));




extern int getgroups (int __size, __gid_t __list[]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__))
    __attribute__ ((__access__ (__write_only__, 2, 1)));


extern int group_member (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__));






extern int setuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern int setreuid (__uid_t __ruid, __uid_t __euid) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern int seteuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));






extern int setgid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern int setregid (__gid_t __rgid, __gid_t __egid) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern int setegid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     __attribute__ ((__nothrow__ , __leaf__));



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     __attribute__ ((__nothrow__ , __leaf__));



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));






extern __pid_t fork (void) __attribute__ ((__nothrow__));







extern __pid_t vfork (void) __attribute__ ((__nothrow__ , __leaf__));






extern __pid_t _Fork (void) __attribute__ ((__nothrow__ , __leaf__));





extern char *ttyname (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) __attribute__ ((__warn_unused_result__))
     __attribute__ ((__access__ (__write_only__, 2, 3)));



extern int isatty (int __fd) __attribute__ ((__nothrow__ , __leaf__));




extern int ttyslot (void) __attribute__ ((__nothrow__ , __leaf__));




extern int link (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__));




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4))) __attribute__ ((__warn_unused_result__));




extern int symlink (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__));




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__))
     __attribute__ ((__access__ (__write_only__, 2, 3)));





extern int symlinkat (const char *__from, int __tofd,
        const char *__to) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3))) __attribute__ ((__warn_unused_result__));


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__))
     __attribute__ ((__access__ (__write_only__, 3, 4)));



extern int unlink (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) __attribute__ ((__nothrow__ , __leaf__));


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __attribute__ ((__nothrow__ , __leaf__));






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__write_only__, 1, 2)));




extern int setlogin (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







# 1 "/usr/include/aarch64-linux-gnu/bits/getopt_posix.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/bits/getopt_posix.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/getopt_core.h" 1 3 4
# 28 "/usr/include/aarch64-linux-gnu/bits/getopt_core.h" 3 4








extern char *optarg;
# 50 "/usr/include/aarch64-linux-gnu/bits/getopt_core.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 91 "/usr/include/aarch64-linux-gnu/bits/getopt_core.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));


# 28 "/usr/include/aarch64-linux-gnu/bits/getopt_posix.h" 2 3 4


# 49 "/usr/include/aarch64-linux-gnu/bits/getopt_posix.h" 3 4

# 904 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__write_only__, 1, 2)));






extern int sethostname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__read_only__, 1, 2)));



extern int sethostid (long int __id) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));





extern int getdomainname (char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__))
     __attribute__ ((__access__ (__write_only__, 1, 2)));
extern int setdomainname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__read_only__, 1, 2)));




extern int vhangup (void) __attribute__ ((__nothrow__ , __leaf__));


extern int revoke (const char *__file) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) __attribute__ ((__nothrow__ , __leaf__));



extern char *getusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void endusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void setusershell (void) __attribute__ ((__nothrow__ , __leaf__));





extern int daemon (int __nochdir, int __noclose) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));






extern int chroot (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);





extern int syncfs (int __fd) __attribute__ ((__nothrow__ , __leaf__));






extern long int gethostid (void);


extern void sync (void) __attribute__ ((__nothrow__ , __leaf__));





extern int getpagesize (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int getdtablesize (void) __attribute__ ((__nothrow__ , __leaf__));
# 1030 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off64_t __length) __asm__ ("" "truncate64") __attribute__ ((__nothrow__ , __leaf__))

                  __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));





extern int truncate64 (const char *__file, __off64_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 1052 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off64_t __length) __asm__ ("" "ftruncate64") __attribute__ ((__nothrow__ , __leaf__))
                   __attribute__ ((__warn_unused_result__));





extern int ftruncate64 (int __fd, __off64_t __length) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
# 1070 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));





extern void *sbrk (intptr_t __delta) __attribute__ ((__nothrow__ , __leaf__));
# 1091 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) __attribute__ ((__nothrow__ , __leaf__));
# 1142 "/usr/include/unistd.h" 3 4
ssize_t copy_file_range (int __infd, __off64_t *__pinoff,
    int __outfd, __off64_t *__poutoff,
    size_t __length, unsigned int __flags);





extern int fdatasync (int __fildes);
# 1159 "/usr/include/unistd.h" 3 4
extern char *crypt (const char *__key, const char *__salt)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));







extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)))
    __attribute__ ((__access__ (__read_only__, 1, 3)))
    __attribute__ ((__access__ (__write_only__, 2, 3)));
# 1198 "/usr/include/unistd.h" 3 4
int getentropy (void *__buffer, size_t __length) __attribute__ ((__warn_unused_result__))
    __attribute__ ((__access__ (__write_only__, 1, 2)));
# 1208 "/usr/include/unistd.h" 3 4
extern int close_range (unsigned int __fd, unsigned int __max_fd,
   int __flags) __attribute__ ((__nothrow__ , __leaf__));




# 1 "/usr/include/aarch64-linux-gnu/bits/unistd.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/bits/unistd.h" 3 4
extern ssize_t __read_chk (int __fd, void *__buf, size_t __nbytes,
      size_t __buflen)
  __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 2, 3)));
extern ssize_t __read_alias (int __fd, void *__buf, size_t __nbytes) __asm__ ("" "read")

  __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 2, 3)));
extern ssize_t __read_chk_warn (int __fd, void *__buf, size_t __nbytes, size_t __buflen) __asm__ ("" "__read_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("read called with bigger length than size of " "the destination buffer")))
                                  ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) ssize_t
read (int __fd, void *__buf, size_t __nbytes)
{
  return ((((__typeof (__nbytes)) 0 < (__typeof (__nbytes)) -1 || (__builtin_constant_p (__nbytes) && (__nbytes) > 0)) && __builtin_constant_p ((((long unsigned int) (__nbytes)) <= (__builtin_object_size (__buf, 0)) / (sizeof (char)))) && (((long unsigned int) (__nbytes)) <= (__builtin_object_size (__buf, 0)) / (sizeof (char)))) ? __read_alias (__fd, __buf, __nbytes) : ((((__typeof (__nbytes)) 0 < (__typeof (__nbytes)) -1 || (__builtin_constant_p (__nbytes) && (__nbytes) > 0)) && __builtin_constant_p ((((long unsigned int) (__nbytes)) <= (__builtin_object_size (__buf, 0)) / (sizeof (char)))) && !(((long unsigned int) (__nbytes)) <= (__builtin_object_size (__buf, 0)) / (sizeof (char)))) ? __read_chk_warn (__fd, __buf, __nbytes, __builtin_object_size (__buf, 0)) : __read_chk (__fd, __buf, __nbytes, __builtin_object_size (__buf, 0))))

                           ;
}


extern ssize_t __pread_chk (int __fd, void *__buf, size_t __nbytes,
       __off_t __offset, size_t __bufsize)
  __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 2, 3)));
extern ssize_t __pread64_chk (int __fd, void *__buf, size_t __nbytes,
         __off64_t __offset, size_t __bufsize)
  __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 2, 3)));
extern ssize_t __pread_alias (int __fd, void *__buf, size_t __nbytes, __off_t __offset) __asm__ ("" "pread")


  __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 2, 3)));
extern ssize_t __pread64_alias (int __fd, void *__buf, size_t __nbytes, __off64_t __offset) __asm__ ("" "pread64")


  __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 2, 3)));
extern ssize_t __pread_chk_warn (int __fd, void *__buf, size_t __nbytes, __off_t __offset, size_t __bufsize) __asm__ ("" "__pread_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("pread called with bigger length than size of " "the destination buffer")))
                                  ;
extern ssize_t __pread64_chk_warn (int __fd, void *__buf, size_t __nbytes, __off64_t __offset, size_t __bufsize) __asm__ ("" "__pread64_chk")



     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("pread64 called with bigger length than size of " "the destination buffer")))
                                  ;
# 79 "/usr/include/aarch64-linux-gnu/bits/unistd.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) ssize_t
pread (int __fd, void *__buf, size_t __nbytes, __off64_t __offset)
{
  return ((((__typeof (__nbytes)) 0 < (__typeof (__nbytes)) -1 || (__builtin_constant_p (__nbytes) && (__nbytes) > 0)) && __builtin_constant_p ((((long unsigned int) (__nbytes)) <= (__builtin_object_size (__buf, 0)) / (sizeof (char)))) && (((long unsigned int) (__nbytes)) <= (__builtin_object_size (__buf, 0)) / (sizeof (char)))) ? __pread64_alias (__fd, __buf, __nbytes, __offset) : ((((__typeof (__nbytes)) 0 < (__typeof (__nbytes)) -1 || (__builtin_constant_p (__nbytes) && (__nbytes) > 0)) && __builtin_constant_p ((((long unsigned int) (__nbytes)) <= (__builtin_object_size (__buf, 0)) / (sizeof (char)))) && !(((long unsigned int) (__nbytes)) <= (__builtin_object_size (__buf, 0)) / (sizeof (char)))) ? __pread64_chk_warn (__fd, __buf, __nbytes, __offset, __builtin_object_size (__buf, 0)) : __pread64_chk (__fd, __buf, __nbytes, __offset, __builtin_object_size (__buf, 0))))

                                     ;
}



extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) ssize_t
pread64 (int __fd, void *__buf, size_t __nbytes, __off64_t __offset)
{
  return ((((__typeof (__nbytes)) 0 < (__typeof (__nbytes)) -1 || (__builtin_constant_p (__nbytes) && (__nbytes) > 0)) && __builtin_constant_p ((((long unsigned int) (__nbytes)) <= (__builtin_object_size (__buf, 0)) / (sizeof (char)))) && (((long unsigned int) (__nbytes)) <= (__builtin_object_size (__buf, 0)) / (sizeof (char)))) ? __pread64_alias (__fd, __buf, __nbytes, __offset) : ((((__typeof (__nbytes)) 0 < (__typeof (__nbytes)) -1 || (__builtin_constant_p (__nbytes) && (__nbytes) > 0)) && __builtin_constant_p ((((long unsigned int) (__nbytes)) <= (__builtin_object_size (__buf, 0)) / (sizeof (char)))) && !(((long unsigned int) (__nbytes)) <= (__builtin_object_size (__buf, 0)) / (sizeof (char)))) ? __pread64_chk_warn (__fd, __buf, __nbytes, __offset, __builtin_object_size (__buf, 0)) : __pread64_chk (__fd, __buf, __nbytes, __offset, __builtin_object_size (__buf, 0))))

                                     ;
}




extern ssize_t __readlink_chk (const char *__restrict __path,
          char *__restrict __buf, size_t __len,
          size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 2, 3)));
extern ssize_t __readlink_alias (const char *__restrict __path, char *__restrict __buf, size_t __len) __asm__ ("" "readlink") __attribute__ ((__nothrow__ , __leaf__))


     __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 2, 3)));
extern ssize_t __readlink_chk_warn (const char *__restrict __path, char *__restrict __buf, size_t __len, size_t __buflen) __asm__ ("" "__readlink_chk") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("readlink called with bigger length " "than size of destination buffer")))
                                         ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__)) ssize_t
__attribute__ ((__nothrow__ , __leaf__)) readlink (const char *__restrict __path, char *__restrict __buf, size_t __len)

{
  return ((((__typeof (__len)) 0 < (__typeof (__len)) -1 || (__builtin_constant_p (__len) && (__len) > 0)) && __builtin_constant_p ((((long unsigned int) (__len)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && (((long unsigned int) (__len)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __readlink_alias (__path, __buf, __len) : ((((__typeof (__len)) 0 < (__typeof (__len)) -1 || (__builtin_constant_p (__len) && (__len) > 0)) && __builtin_constant_p ((((long unsigned int) (__len)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && !(((long unsigned int) (__len)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __readlink_chk_warn (__path, __buf, __len, __builtin_object_size (__buf, 2 > 1)) : __readlink_chk (__path, __buf, __len, __builtin_object_size (__buf, 2 > 1))))

                          ;
}



extern ssize_t __readlinkat_chk (int __fd, const char *__restrict __path,
     char *__restrict __buf, size_t __len,
     size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 3, 4)));
extern ssize_t __readlinkat_alias (int __fd, const char *__restrict __path, char *__restrict __buf, size_t __len) __asm__ ("" "readlinkat") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 3, 4)));
extern ssize_t __readlinkat_chk_warn (int __fd, const char *__restrict __path, char *__restrict __buf, size_t __len, size_t __buflen) __asm__ ("" "__readlinkat_chk") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("readlinkat called with bigger " "length than size of destination " "buffer")))

                ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__)) ssize_t
__attribute__ ((__nothrow__ , __leaf__)) readlinkat (int __fd, const char *__restrict __path, char *__restrict __buf, size_t __len)

{
  return ((((__typeof (__len)) 0 < (__typeof (__len)) -1 || (__builtin_constant_p (__len) && (__len) > 0)) && __builtin_constant_p ((((long unsigned int) (__len)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && (((long unsigned int) (__len)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __readlinkat_alias (__fd, __path, __buf, __len) : ((((__typeof (__len)) 0 < (__typeof (__len)) -1 || (__builtin_constant_p (__len) && (__len) > 0)) && __builtin_constant_p ((((long unsigned int) (__len)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && !(((long unsigned int) (__len)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __readlinkat_chk_warn (__fd, __path, __buf, __len, __builtin_object_size (__buf, 2 > 1)) : __readlinkat_chk (__fd, __path, __buf, __len, __builtin_object_size (__buf, 2 > 1))))

                                ;
}


extern char *__getcwd_chk (char *__buf, size_t __size, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
extern char *__getcwd_alias (char *__buf, size_t __size) __asm__ ("" "getcwd") __attribute__ ((__nothrow__ , __leaf__))
                                              __attribute__ ((__warn_unused_result__));
extern char *__getcwd_chk_warn (char *__buf, size_t __size, size_t __buflen) __asm__ ("" "__getcwd_chk") __attribute__ ((__nothrow__ , __leaf__))


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("getcwd caller with bigger length than size of " "destination buffer")))
                              ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) char *
__attribute__ ((__nothrow__ , __leaf__)) getcwd (char *__buf, size_t __size)
{
  return ((((__typeof (__size)) 0 < (__typeof (__size)) -1 || (__builtin_constant_p (__size) && (__size) > 0)) && __builtin_constant_p ((((long unsigned int) (__size)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && (((long unsigned int) (__size)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __getcwd_alias (__buf, __size) : ((((__typeof (__size)) 0 < (__typeof (__size)) -1 || (__builtin_constant_p (__size) && (__size) > 0)) && __builtin_constant_p ((((long unsigned int) (__size)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && !(((long unsigned int) (__size)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __getcwd_chk_warn (__buf, __size, __builtin_object_size (__buf, 2 > 1)) : __getcwd_chk (__buf, __size, __builtin_object_size (__buf, 2 > 1))))

                   ;
}


extern char *__getwd_chk (char *__buf, size_t buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 1, 2)));
extern char *__getwd_warn (char *__buf) __asm__ ("" "getwd") __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("please use getcwd instead, as getwd " "doesn't specify buffer size")))
                                         ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) __attribute__ ((__warn_unused_result__)) char *
__attribute__ ((__nothrow__ , __leaf__)) getwd (char *__buf)
{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    return __getwd_chk (__buf, __builtin_object_size (__buf, 2 > 1));
  return __getwd_warn (__buf);
}


extern size_t __confstr_chk (int __name, char *__buf, size_t __len,
        size_t __buflen) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__access__ (__write_only__, 2, 3)));
extern size_t __confstr_alias (int __name, char *__buf, size_t __len) __asm__ ("" "confstr") __attribute__ ((__nothrow__ , __leaf__))

   __attribute__ ((__access__ (__write_only__, 2, 3)));
extern size_t __confstr_chk_warn (int __name, char *__buf, size_t __len, size_t __buflen) __asm__ ("" "__confstr_chk") __attribute__ ((__nothrow__ , __leaf__))


     __attribute__((__warning__ ("confstr called with bigger length than size of destination " "buffer")))
            ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) size_t
__attribute__ ((__nothrow__ , __leaf__)) confstr (int __name, char *__buf, size_t __len)
{
  return ((((__typeof (__len)) 0 < (__typeof (__len)) -1 || (__builtin_constant_p (__len) && (__len) > 0)) && __builtin_constant_p ((((long unsigned int) (__len)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && (((long unsigned int) (__len)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __confstr_alias (__name, __buf, __len) : ((((__typeof (__len)) 0 < (__typeof (__len)) -1 || (__builtin_constant_p (__len) && (__len) > 0)) && __builtin_constant_p ((((long unsigned int) (__len)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && !(((long unsigned int) (__len)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __confstr_chk_warn (__name, __buf, __len, __builtin_object_size (__buf, 2 > 1)) : __confstr_chk (__name, __buf, __len, __builtin_object_size (__buf, 2 > 1))))

                          ;
}


extern int __getgroups_chk (int __size, __gid_t __list[], size_t __listlen)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 2, 1)));
extern int __getgroups_alias (int __size, __gid_t __list[]) __asm__ ("" "getgroups") __attribute__ ((__nothrow__ , __leaf__))
                 __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 2, 1)));
extern int __getgroups_chk_warn (int __size, __gid_t __list[], size_t __listlen) __asm__ ("" "__getgroups_chk") __attribute__ ((__nothrow__ , __leaf__))


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("getgroups called with bigger group count than what " "can fit into destination buffer")))
                                           ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) getgroups (int __size, __gid_t __list[])
{
  return ((((__typeof (__size)) 0 < (__typeof (__size)) -1 || (__builtin_constant_p (__size) && (__size) > 0)) && __builtin_constant_p ((((long unsigned int) (__size)) <= (__builtin_object_size (__list, 2 > 1)) / (sizeof (__gid_t)))) && (((long unsigned int) (__size)) <= (__builtin_object_size (__list, 2 > 1)) / (sizeof (__gid_t)))) ? __getgroups_alias (__size, __list) : ((((__typeof (__size)) 0 < (__typeof (__size)) -1 || (__builtin_constant_p (__size) && (__size) > 0)) && __builtin_constant_p ((((long unsigned int) (__size)) <= (__builtin_object_size (__list, 2 > 1)) / (sizeof (__gid_t)))) && !(((long unsigned int) (__size)) <= (__builtin_object_size (__list, 2 > 1)) / (sizeof (__gid_t)))) ? __getgroups_chk_warn (__size, __list, __builtin_object_size (__list, 2 > 1)) : __getgroups_chk (__size, __list, __builtin_object_size (__list, 2 > 1))))

                    ;
}


extern int __ttyname_r_chk (int __fd, char *__buf, size_t __buflen,
       size_t __nreal) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)))
   __attribute__ ((__access__ (__write_only__, 2, 3)));
extern int __ttyname_r_alias (int __fd, char *__buf, size_t __buflen) __asm__ ("" "ttyname_r") __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__nonnull__ (2)));
extern int __ttyname_r_chk_warn (int __fd, char *__buf, size_t __buflen, size_t __nreal) __asm__ ("" "__ttyname_r_chk") __attribute__ ((__nothrow__ , __leaf__))


     __attribute__ ((__nonnull__ (2))) __attribute__((__warning__ ("ttyname_r called with bigger buflen than " "size of destination buffer")))
                                  ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) ttyname_r (int __fd, char *__buf, size_t __buflen)
{
  return ((((__typeof (__buflen)) 0 < (__typeof (__buflen)) -1 || (__builtin_constant_p (__buflen) && (__buflen) > 0)) && __builtin_constant_p ((((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && (((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __ttyname_r_alias (__fd, __buf, __buflen) : ((((__typeof (__buflen)) 0 < (__typeof (__buflen)) -1 || (__builtin_constant_p (__buflen) && (__buflen) > 0)) && __builtin_constant_p ((((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && !(((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __ttyname_r_chk_warn (__fd, __buf, __buflen, __builtin_object_size (__buf, 2 > 1)) : __ttyname_r_chk (__fd, __buf, __buflen, __builtin_object_size (__buf, 2 > 1))))

                           ;
}



extern int __getlogin_r_chk (char *__buf, size_t __buflen, size_t __nreal)
     __attribute__ ((__nonnull__ (1))) __attribute__ ((__access__ (__write_only__, 1, 2)));
extern int __getlogin_r_alias (char *__buf, size_t __buflen) __asm__ ("" "getlogin_r")
                     __attribute__ ((__nonnull__ (1)));
extern int __getlogin_r_chk_warn (char *__buf, size_t __buflen, size_t __nreal) __asm__ ("" "__getlogin_r_chk")


     __attribute__ ((__nonnull__ (1))) __attribute__((__warning__ ("getlogin_r called with bigger buflen than " "size of destination buffer")))
                                  ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
getlogin_r (char *__buf, size_t __buflen)
{
  return ((((__typeof (__buflen)) 0 < (__typeof (__buflen)) -1 || (__builtin_constant_p (__buflen) && (__buflen) > 0)) && __builtin_constant_p ((((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && (((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __getlogin_r_alias (__buf, __buflen) : ((((__typeof (__buflen)) 0 < (__typeof (__buflen)) -1 || (__builtin_constant_p (__buflen) && (__buflen) > 0)) && __builtin_constant_p ((((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && !(((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __getlogin_r_chk_warn (__buf, __buflen, __builtin_object_size (__buf, 2 > 1)) : __getlogin_r_chk (__buf, __buflen, __builtin_object_size (__buf, 2 > 1))))

                     ;
}




extern int __gethostname_chk (char *__buf, size_t __buflen, size_t __nreal)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__access__ (__write_only__, 1, 2)));
extern int __gethostname_alias (char *__buf, size_t __buflen) __asm__ ("" "gethostname") __attribute__ ((__nothrow__ , __leaf__))

  __attribute__ ((__nonnull__ (1))) __attribute__ ((__access__ (__write_only__, 1, 2)));
extern int __gethostname_chk_warn (char *__buf, size_t __buflen, size_t __nreal) __asm__ ("" "__gethostname_chk") __attribute__ ((__nothrow__ , __leaf__))


     __attribute__ ((__nonnull__ (1))) __attribute__((__warning__ ("gethostname called with bigger buflen than " "size of destination buffer")))
                                  ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) gethostname (char *__buf, size_t __buflen)
{
  return ((((__typeof (__buflen)) 0 < (__typeof (__buflen)) -1 || (__builtin_constant_p (__buflen) && (__buflen) > 0)) && __builtin_constant_p ((((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && (((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __gethostname_alias (__buf, __buflen) : ((((__typeof (__buflen)) 0 < (__typeof (__buflen)) -1 || (__builtin_constant_p (__buflen) && (__buflen) > 0)) && __builtin_constant_p ((((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && !(((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __gethostname_chk_warn (__buf, __buflen, __builtin_object_size (__buf, 2 > 1)) : __gethostname_chk (__buf, __buflen, __builtin_object_size (__buf, 2 > 1))))

                     ;
}




extern int __getdomainname_chk (char *__buf, size_t __buflen, size_t __nreal)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 1, 2)));
extern int __getdomainname_alias (char *__buf, size_t __buflen) __asm__ ("" "getdomainname") __attribute__ ((__nothrow__ , __leaf__))

                     __attribute__ ((__nonnull__ (1)))
  __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 1, 2)));
extern int __getdomainname_chk_warn (char *__buf, size_t __buflen, size_t __nreal) __asm__ ("" "__getdomainname_chk") __attribute__ ((__nothrow__ , __leaf__))


     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("getdomainname called with bigger " "buflen than size of destination " "buffer")))

                    ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) getdomainname (char *__buf, size_t __buflen)
{
  return ((((__typeof (__buflen)) 0 < (__typeof (__buflen)) -1 || (__builtin_constant_p (__buflen) && (__buflen) > 0)) && __builtin_constant_p ((((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && (((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __getdomainname_alias (__buf, __buflen) : ((((__typeof (__buflen)) 0 < (__typeof (__buflen)) -1 || (__builtin_constant_p (__buflen) && (__buflen) > 0)) && __builtin_constant_p ((((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && !(((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __getdomainname_chk_warn (__buf, __buflen, __builtin_object_size (__buf, 2 > 1)) : __getdomainname_chk (__buf, __buflen, __builtin_object_size (__buf, 2 > 1))))

                     ;
}
# 1215 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/aarch64-linux-gnu/bits/unistd_ext.h" 1 3 4
# 34 "/usr/include/aarch64-linux-gnu/bits/unistd_ext.h" 3 4
extern __pid_t gettid (void) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/linux/close_range.h" 1 3 4
# 39 "/usr/include/aarch64-linux-gnu/bits/unistd_ext.h" 2 3 4
# 1219 "/usr/include/unistd.h" 2 3 4


# 233 "/libmdbx/src/osal.h" 2





# 1 "/usr/include/semaphore.h" 1 3 4
# 28 "/usr/include/semaphore.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/semaphore.h" 1 3 4
# 35 "/usr/include/aarch64-linux-gnu/bits/semaphore.h" 3 4
typedef union
{
  char __size[32];
  long long int __align;
} sem_t;
# 29 "/usr/include/semaphore.h" 2 3 4






extern int sem_init (sem_t *__sem, int __pshared, unsigned int __value)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sem_destroy (sem_t *__sem) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern sem_t *sem_open (const char *__name, int __oflag, ...)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sem_close (sem_t *__sem) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sem_unlink (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int sem_wait (sem_t *__sem) __attribute__ ((__nonnull__ (1)));







extern int sem_timedwait (sem_t *__restrict __sem,
     const struct timespec *__restrict __abstime)
  __attribute__ ((__nonnull__ (1, 2)));
# 81 "/usr/include/semaphore.h" 3 4
extern int sem_clockwait (sem_t *__restrict __sem,
     clockid_t clock,
     const struct timespec *__restrict __abstime)
  __attribute__ ((__nonnull__ (1, 3)));
# 100 "/usr/include/semaphore.h" 3 4
extern int sem_trywait (sem_t *__sem) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int sem_post (sem_t *__sem) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int sem_getvalue (sem_t *__restrict __sem, int *__restrict __sval)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



# 239 "/libmdbx/src/osal.h" 2
# 1 "/usr/include/signal.h" 1 3 4
# 27 "/usr/include/signal.h" 3 4



# 1 "/usr/include/aarch64-linux-gnu/bits/signum-generic.h" 1 3 4
# 76 "/usr/include/aarch64-linux-gnu/bits/signum-generic.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/signum-arch.h" 1 3 4
# 77 "/usr/include/aarch64-linux-gnu/bits/signum-generic.h" 2 3 4
# 31 "/usr/include/signal.h" 2 3 4

# 1 "/usr/include/aarch64-linux-gnu/bits/types/sig_atomic_t.h" 1 3 4







typedef __sig_atomic_t sig_atomic_t;
# 33 "/usr/include/signal.h" 2 3 4
# 57 "/usr/include/signal.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/siginfo_t.h" 1 3 4



# 1 "/usr/include/aarch64-linux-gnu/bits/wordsize.h" 1 3 4
# 5 "/usr/include/aarch64-linux-gnu/bits/types/siginfo_t.h" 2 3 4

# 1 "/usr/include/aarch64-linux-gnu/bits/types/__sigval_t.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/types/__sigval_t.h" 3 4
union sigval
{
  int sival_int;
  void *sival_ptr;
};

typedef union sigval __sigval_t;
# 7 "/usr/include/aarch64-linux-gnu/bits/types/siginfo_t.h" 2 3 4
# 16 "/usr/include/aarch64-linux-gnu/bits/types/siginfo_t.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/siginfo-arch.h" 1 3 4
# 17 "/usr/include/aarch64-linux-gnu/bits/types/siginfo_t.h" 2 3 4
# 36 "/usr/include/aarch64-linux-gnu/bits/types/siginfo_t.h" 3 4
typedef struct
  {
    int si_signo;

    int si_errno;

    int si_code;





    int __pad0;


    union
      {
 int _pad[((128 / sizeof (int)) - 4)];


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
   } _kill;


 struct
   {
     int si_tid;
     int si_overrun;
     __sigval_t si_sigval;
   } _timer;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     __sigval_t si_sigval;
   } _rt;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     int si_status;
     __clock_t si_utime;
     __clock_t si_stime;
   } _sigchld;


 struct
   {
     void *si_addr;
    
     short int si_addr_lsb;
     union
       {

  struct
    {
      void *_lower;
      void *_upper;
    } _addr_bnd;

  __uint32_t _pkey;
       } _bounds;
   } _sigfault;


 struct
   {
     long int si_band;
     int si_fd;
   } _sigpoll;



 struct
   {
     void *_call_addr;
     int _syscall;
     unsigned int _arch;
   } _sigsys;

      } _sifields;
  } siginfo_t ;
# 58 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/siginfo-consts.h" 1 3 4
# 35 "/usr/include/aarch64-linux-gnu/bits/siginfo-consts.h" 3 4
enum
{
  SI_ASYNCNL = -60,
  SI_DETHREAD = -7,

  SI_TKILL,
  SI_SIGIO,

  SI_ASYNCIO,
  SI_MESGQ,
  SI_TIMER,





  SI_QUEUE,
  SI_USER,
  SI_KERNEL = 0x80
# 66 "/usr/include/aarch64-linux-gnu/bits/siginfo-consts.h" 3 4
};




enum
{
  ILL_ILLOPC = 1,

  ILL_ILLOPN,

  ILL_ILLADR,

  ILL_ILLTRP,

  ILL_PRVOPC,

  ILL_PRVREG,

  ILL_COPROC,

  ILL_BADSTK,

  ILL_BADIADDR

};


enum
{
  FPE_INTDIV = 1,

  FPE_INTOVF,

  FPE_FLTDIV,

  FPE_FLTOVF,

  FPE_FLTUND,

  FPE_FLTRES,

  FPE_FLTINV,

  FPE_FLTSUB,

  FPE_FLTUNK = 14,

  FPE_CONDTRAP

};


enum
{
  SEGV_MAPERR = 1,

  SEGV_ACCERR,

  SEGV_BNDERR,

  SEGV_PKUERR,

  SEGV_ACCADI,

  SEGV_ADIDERR,

  SEGV_ADIPERR,

  SEGV_MTEAERR,

  SEGV_MTESERR

};


enum
{
  BUS_ADRALN = 1,

  BUS_ADRERR,

  BUS_OBJERR,

  BUS_MCEERR_AR,

  BUS_MCEERR_AO

};




enum
{
  TRAP_BRKPT = 1,

  TRAP_TRACE,

  TRAP_BRANCH,

  TRAP_HWBKPT,

  TRAP_UNK

};




enum
{
  CLD_EXITED = 1,

  CLD_KILLED,

  CLD_DUMPED,

  CLD_TRAPPED,

  CLD_STOPPED,

  CLD_CONTINUED

};


enum
{
  POLL_IN = 1,

  POLL_OUT,

  POLL_MSG,

  POLL_ERR,

  POLL_PRI,

  POLL_HUP

};





# 1 "/usr/include/aarch64-linux-gnu/bits/siginfo-consts-arch.h" 1 3 4
# 214 "/usr/include/aarch64-linux-gnu/bits/siginfo-consts.h" 2 3 4
# 59 "/usr/include/signal.h" 2 3 4



# 1 "/usr/include/aarch64-linux-gnu/bits/types/sigval_t.h" 1 3 4
# 16 "/usr/include/aarch64-linux-gnu/bits/types/sigval_t.h" 3 4
typedef __sigval_t sigval_t;
# 63 "/usr/include/signal.h" 2 3 4



# 1 "/usr/include/aarch64-linux-gnu/bits/types/sigevent_t.h" 1 3 4



# 1 "/usr/include/aarch64-linux-gnu/bits/wordsize.h" 1 3 4
# 5 "/usr/include/aarch64-linux-gnu/bits/types/sigevent_t.h" 2 3 4
# 22 "/usr/include/aarch64-linux-gnu/bits/types/sigevent_t.h" 3 4
typedef struct sigevent
  {
    __sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;

    union
      {
 int _pad[((64 / sizeof (int)) - 4)];



 __pid_t _tid;

 struct
   {
     void (*_function) (__sigval_t);
     pthread_attr_t *_attribute;
   } _sigev_thread;
      } _sigev_un;
  } sigevent_t;
# 67 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/sigevent-consts.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/bits/sigevent-consts.h" 3 4
enum
{
  SIGEV_SIGNAL = 0,

  SIGEV_NONE,

  SIGEV_THREAD,


  SIGEV_THREAD_ID = 4


};
# 68 "/usr/include/signal.h" 2 3 4




typedef void (*__sighandler_t) (int);




extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));

extern __sighandler_t sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));






extern __sighandler_t signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));
# 112 "/usr/include/signal.h" 3 4
extern int kill (__pid_t __pid, int __sig) __attribute__ ((__nothrow__ , __leaf__));






extern int killpg (__pid_t __pgrp, int __sig) __attribute__ ((__nothrow__ , __leaf__));



extern int raise (int __sig) __attribute__ ((__nothrow__ , __leaf__));



extern __sighandler_t ssignal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));
extern int gsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));




extern void psignal (int __sig, const char *__s);


extern void psiginfo (const siginfo_t *__pinfo, const char *__s);
# 151 "/usr/include/signal.h" 3 4
extern int sigpause (int __sig) __asm__ ("__xpg_sigpause")
  __attribute__ ((__deprecated__ ("Use the sigsuspend function instead")));
# 173 "/usr/include/signal.h" 3 4
extern int sigblock (int __mask) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));


extern int sigsetmask (int __mask) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));


extern int siggetmask (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
# 188 "/usr/include/signal.h" 3 4
typedef __sighandler_t sighandler_t;




typedef __sighandler_t sig_t;





extern int sigemptyset (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigfillset (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigaddset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigdelset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigismember (const sigset_t *__set, int __signo)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int sigisemptyset (const sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigandset (sigset_t *__set, const sigset_t *__left,
        const sigset_t *__right) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern int sigorset (sigset_t *__set, const sigset_t *__left,
       const sigset_t *__right) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3)));




# 1 "/usr/include/aarch64-linux-gnu/bits/sigaction.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/bits/sigaction.h" 3 4
struct sigaction
  {


    union
      {

 __sighandler_t sa_handler;

 void (*sa_sigaction) (int, siginfo_t *, void *);
      }
    __sigaction_handler;







    __sigset_t sa_mask;


    int sa_flags;


    void (*sa_restorer) (void);
  };
# 230 "/usr/include/signal.h" 2 3 4


extern int sigprocmask (int __how, const sigset_t *__restrict __set,
   sigset_t *__restrict __oset) __attribute__ ((__nothrow__ , __leaf__));






extern int sigsuspend (const sigset_t *__set) __attribute__ ((__nonnull__ (1)));


extern int sigaction (int __sig, const struct sigaction *__restrict __act,
        struct sigaction *__restrict __oact) __attribute__ ((__nothrow__ , __leaf__));


extern int sigpending (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int sigwait (const sigset_t *__restrict __set, int *__restrict __sig)
     __attribute__ ((__nonnull__ (1, 2)));







extern int sigwaitinfo (const sigset_t *__restrict __set,
   siginfo_t *__restrict __info) __attribute__ ((__nonnull__ (1)));







extern int sigtimedwait (const sigset_t *__restrict __set,
    siginfo_t *__restrict __info,
    const struct timespec *__restrict __timeout)
     __attribute__ ((__nonnull__ (1)));
# 292 "/usr/include/signal.h" 3 4
extern int sigqueue (__pid_t __pid, int __sig, const union sigval __val)
     __attribute__ ((__nothrow__ , __leaf__));







# 1 "/usr/include/aarch64-linux-gnu/bits/sigcontext.h" 1 3 4
# 30 "/usr/include/aarch64-linux-gnu/bits/sigcontext.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/asm/sigcontext.h" 1 3 4
# 22 "/usr/include/aarch64-linux-gnu/asm/sigcontext.h" 3 4
# 1 "/usr/include/linux/types.h" 1 3 4




# 1 "/usr/include/aarch64-linux-gnu/asm/types.h" 1 3 4
# 1 "/usr/include/asm-generic/types.h" 1 3 4






# 1 "/usr/include/asm-generic/int-ll64.h" 1 3 4
# 12 "/usr/include/asm-generic/int-ll64.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/asm/bitsperlong.h" 1 3 4
# 22 "/usr/include/aarch64-linux-gnu/asm/bitsperlong.h" 3 4
# 1 "/usr/include/asm-generic/bitsperlong.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/asm/bitsperlong.h" 2 3 4
# 13 "/usr/include/asm-generic/int-ll64.h" 2 3 4







typedef __signed__ char __s8;
typedef unsigned char __u8;

typedef __signed__ short __s16;
typedef unsigned short __u16;

typedef __signed__ int __s32;
typedef unsigned int __u32;


__extension__ typedef __signed__ long long __s64;
__extension__ typedef unsigned long long __u64;
# 8 "/usr/include/asm-generic/types.h" 2 3 4
# 2 "/usr/include/aarch64-linux-gnu/asm/types.h" 2 3 4
# 6 "/usr/include/linux/types.h" 2 3 4



# 1 "/usr/include/linux/posix_types.h" 1 3 4




# 1 "/usr/include/linux/stddef.h" 1 3 4
# 6 "/usr/include/linux/posix_types.h" 2 3 4
# 25 "/usr/include/linux/posix_types.h" 3 4
typedef struct {
 unsigned long fds_bits[1024 / (8 * sizeof(long))];
} __kernel_fd_set;


typedef void (*__kernel_sighandler_t)(int);


typedef int __kernel_key_t;
typedef int __kernel_mqd_t;

# 1 "/usr/include/aarch64-linux-gnu/asm/posix_types.h" 1 3 4




typedef unsigned short __kernel_old_uid_t;
typedef unsigned short __kernel_old_gid_t;


# 1 "/usr/include/asm-generic/posix_types.h" 1 3 4
# 15 "/usr/include/asm-generic/posix_types.h" 3 4
typedef long __kernel_long_t;
typedef unsigned long __kernel_ulong_t;



typedef __kernel_ulong_t __kernel_ino_t;



typedef unsigned int __kernel_mode_t;



typedef int __kernel_pid_t;



typedef int __kernel_ipc_pid_t;



typedef unsigned int __kernel_uid_t;
typedef unsigned int __kernel_gid_t;



typedef __kernel_long_t __kernel_suseconds_t;



typedef int __kernel_daddr_t;



typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;
# 59 "/usr/include/asm-generic/posix_types.h" 3 4
typedef unsigned int __kernel_old_dev_t;
# 72 "/usr/include/asm-generic/posix_types.h" 3 4
typedef __kernel_ulong_t __kernel_size_t;
typedef __kernel_long_t __kernel_ssize_t;
typedef __kernel_long_t __kernel_ptrdiff_t;




typedef struct {
 int val[2];
} __kernel_fsid_t;





typedef __kernel_long_t __kernel_off_t;
typedef long long __kernel_loff_t;
typedef __kernel_long_t __kernel_old_time_t;
typedef __kernel_long_t __kernel_time_t;
typedef long long __kernel_time64_t;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef char * __kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;
# 10 "/usr/include/aarch64-linux-gnu/asm/posix_types.h" 2 3 4
# 37 "/usr/include/linux/posix_types.h" 2 3 4
# 10 "/usr/include/linux/types.h" 2 3 4
# 24 "/usr/include/linux/types.h" 3 4
typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;
typedef __u64 __be64;

typedef __u16 __sum16;
typedef __u32 __wsum;
# 47 "/usr/include/linux/types.h" 3 4
typedef unsigned __poll_t;
# 23 "/usr/include/aarch64-linux-gnu/asm/sigcontext.h" 2 3 4





struct sigcontext {
 __u64 fault_address;

 __u64 regs[31];
 __u64 sp;
 __u64 pc;
 __u64 pstate;

 __u8 __reserved[4096] __attribute__((__aligned__(16)));
};
# 66 "/usr/include/aarch64-linux-gnu/asm/sigcontext.h" 3 4
struct _aarch64_ctx {
 __u32 magic;
 __u32 size;
};



struct fpsimd_context {
 struct _aarch64_ctx head;
 __u32 fpsr;
 __u32 fpcr;
 __uint128_t vregs[32];
};
# 92 "/usr/include/aarch64-linux-gnu/asm/sigcontext.h" 3 4
struct esr_context {
 struct _aarch64_ctx head;
 __u64 esr;
};
# 125 "/usr/include/aarch64-linux-gnu/asm/sigcontext.h" 3 4
struct extra_context {
 struct _aarch64_ctx head;
 __u64 datap;
 __u32 size;
 __u32 __reserved[3];
};



struct sve_context {
 struct _aarch64_ctx head;
 __u16 vl;
 __u16 __reserved[3];
};



# 1 "/usr/include/aarch64-linux-gnu/asm/sve_context.h" 1 3 4
# 143 "/usr/include/aarch64-linux-gnu/asm/sigcontext.h" 2 3 4
# 31 "/usr/include/aarch64-linux-gnu/bits/sigcontext.h" 2 3 4



# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 35 "/usr/include/aarch64-linux-gnu/bits/sigcontext.h" 2 3 4
# 302 "/usr/include/signal.h" 2 3 4


extern int sigreturn (struct sigcontext *__scp) __attribute__ ((__nothrow__ , __leaf__));






# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 312 "/usr/include/signal.h" 2 3 4

# 1 "/usr/include/aarch64-linux-gnu/bits/types/stack_t.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/bits/types/stack_t.h" 3 4
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/types/stack_t.h" 2 3 4


typedef struct
  {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
  } stack_t;
# 314 "/usr/include/signal.h" 2 3 4


# 1 "/usr/include/aarch64-linux-gnu/sys/ucontext.h" 1 3 4
# 36 "/usr/include/aarch64-linux-gnu/sys/ucontext.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/sys/procfs.h" 1 3 4
# 35 "/usr/include/aarch64-linux-gnu/sys/procfs.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/sys/user.h" 1 3 4
# 22 "/usr/include/aarch64-linux-gnu/sys/user.h" 3 4
struct user_regs_struct
{
  unsigned long long regs[31];
  unsigned long long sp;
  unsigned long long pc;
  unsigned long long pstate;
};

struct user_fpsimd_struct
{
  __uint128_t vregs[32];
  unsigned int fpsr;
  unsigned int fpcr;
};
# 36 "/usr/include/aarch64-linux-gnu/sys/procfs.h" 2 3 4




# 1 "/usr/include/aarch64-linux-gnu/bits/procfs.h" 1 3 4
# 25 "/usr/include/aarch64-linux-gnu/bits/procfs.h" 3 4
typedef __uint64_t elf_greg_t;






typedef elf_greg_t elf_gregset_t[(sizeof (struct user_regs_struct) / sizeof (elf_greg_t))];


typedef struct user_fpsimd_struct elf_fpregset_t;
# 41 "/usr/include/aarch64-linux-gnu/sys/procfs.h" 2 3 4



# 1 "/usr/include/aarch64-linux-gnu/bits/procfs-id.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/procfs-id.h" 3 4
typedef unsigned int __pr_uid_t;
typedef unsigned int __pr_gid_t;
# 45 "/usr/include/aarch64-linux-gnu/sys/procfs.h" 2 3 4




struct elf_siginfo
  {
    int si_signo;
    int si_code;
    int si_errno;
  };
# 63 "/usr/include/aarch64-linux-gnu/sys/procfs.h" 3 4
struct elf_prstatus
  {
    struct elf_siginfo pr_info;
    short int pr_cursig;
    unsigned long int pr_sigpend;
    unsigned long int pr_sighold;
    __pid_t pr_pid;
    __pid_t pr_ppid;
    __pid_t pr_pgrp;
    __pid_t pr_sid;
    struct timeval pr_utime;
    struct timeval pr_stime;
    struct timeval pr_cutime;
    struct timeval pr_cstime;
    elf_gregset_t pr_reg;
    int pr_fpvalid;
  };




struct elf_prpsinfo
  {
    char pr_state;
    char pr_sname;
    char pr_zomb;
    char pr_nice;
    unsigned long int pr_flag;
    __pr_uid_t pr_uid;
    __pr_gid_t pr_gid;
    int pr_pid, pr_ppid, pr_pgrp, pr_sid;

    char pr_fname[16];
    char pr_psargs[(80)];
  };






typedef void *psaddr_t;

# 1 "/usr/include/aarch64-linux-gnu/bits/procfs-prregset.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/procfs-prregset.h" 3 4
typedef elf_gregset_t __prgregset_t;
typedef elf_fpregset_t __prfpregset_t;
# 107 "/usr/include/aarch64-linux-gnu/sys/procfs.h" 2 3 4


typedef __prgregset_t prgregset_t;
typedef __prfpregset_t prfpregset_t;



typedef __pid_t lwpid_t;


typedef struct elf_prstatus prstatus_t;
typedef struct elf_prpsinfo prpsinfo_t;





# 1 "/usr/include/aarch64-linux-gnu/bits/procfs-extra.h" 1 3 4
# 125 "/usr/include/aarch64-linux-gnu/sys/procfs.h" 2 3 4
# 37 "/usr/include/aarch64-linux-gnu/sys/ucontext.h" 2 3 4


typedef elf_greg_t greg_t;


typedef elf_gregset_t gregset_t;


typedef elf_fpregset_t fpregset_t;






typedef struct
  {
    unsigned long long int fault_address;
    unsigned long long int regs[31];
    unsigned long long int sp;
    unsigned long long int pc;
    unsigned long long int pstate;




    unsigned char __reserved[4096] __attribute__ ((__aligned__ (16)));
  } mcontext_t;


typedef struct ucontext_t
  {
    unsigned long uc_flags;
    struct ucontext_t *uc_link;
    stack_t uc_stack;
    sigset_t uc_sigmask;
    mcontext_t uc_mcontext;
  } ucontext_t;
# 317 "/usr/include/signal.h" 2 3 4







extern int siginterrupt (int __sig, int __interrupt) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__deprecated__ ("Use sigaction with SA_RESTART instead")));

# 1 "/usr/include/aarch64-linux-gnu/bits/sigstack.h" 1 3 4
# 328 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/sigstksz.h" 1 3 4
# 329 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/ss_flags.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/bits/ss_flags.h" 3 4
enum
{
  SS_ONSTACK = 1,

  SS_DISABLE

};
# 330 "/usr/include/signal.h" 2 3 4



extern int sigaltstack (const stack_t *__restrict __ss,
   stack_t *__restrict __oss) __attribute__ ((__nothrow__ , __leaf__));




# 1 "/usr/include/aarch64-linux-gnu/bits/types/struct_sigstack.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/bits/types/struct_sigstack.h" 3 4
struct sigstack
  {
    void *ss_sp;
    int ss_onstack;
  };
# 340 "/usr/include/signal.h" 2 3 4







extern int sigstack (struct sigstack *__ss, struct sigstack *__oss)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));






extern int sighold (int __sig) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__deprecated__ ("Use the sigprocmask function instead")));


extern int sigrelse (int __sig) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__deprecated__ ("Use the sigprocmask function instead")));


extern int sigignore (int __sig) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__deprecated__ ("Use the signal function instead")));


extern __sighandler_t sigset (int __sig, __sighandler_t __disp) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__deprecated__ ("Use the signal and sigprocmask functions instead")))
                                                        ;






# 1 "/usr/include/aarch64-linux-gnu/bits/sigthread.h" 1 3 4
# 31 "/usr/include/aarch64-linux-gnu/bits/sigthread.h" 3 4
extern int pthread_sigmask (int __how,
       const __sigset_t *__restrict __newmask,
       __sigset_t *__restrict __oldmask)__attribute__ ((__nothrow__ , __leaf__));


extern int pthread_kill (pthread_t __threadid, int __signo) __attribute__ ((__nothrow__ , __leaf__));



extern int pthread_sigqueue (pthread_t __threadid, int __signo,
        const union sigval __value) __attribute__ ((__nothrow__ , __leaf__));
# 377 "/usr/include/signal.h" 2 3 4






extern int __libc_current_sigrtmin (void) __attribute__ ((__nothrow__ , __leaf__));

extern int __libc_current_sigrtmax (void) __attribute__ ((__nothrow__ , __leaf__));





# 1 "/usr/include/aarch64-linux-gnu/bits/signal_ext.h" 1 3 4
# 29 "/usr/include/aarch64-linux-gnu/bits/signal_ext.h" 3 4
extern int tgkill (__pid_t __tgid, __pid_t __tid, int __signal);
# 392 "/usr/include/signal.h" 2 3 4


# 240 "/libmdbx/src/osal.h" 2
# 1 "/usr/include/aarch64-linux-gnu/sys/file.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/sys/file.h" 3 4

# 50 "/usr/include/aarch64-linux-gnu/sys/file.h" 3 4
extern int flock (int __fd, int __operation) __attribute__ ((__nothrow__ , __leaf__));



# 241 "/libmdbx/src/osal.h" 2
# 1 "/usr/include/aarch64-linux-gnu/sys/ipc.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/sys/ipc.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/ipctypes.h" 1 3 4
# 32 "/usr/include/aarch64-linux-gnu/bits/ipctypes.h" 3 4
typedef int __ipc_pid_t;
# 25 "/usr/include/aarch64-linux-gnu/sys/ipc.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/ipc.h" 1 3 4
# 40 "/usr/include/aarch64-linux-gnu/bits/ipc.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/ipc-perm.h" 1 3 4
# 28 "/usr/include/aarch64-linux-gnu/bits/ipc-perm.h" 3 4
struct ipc_perm
{
  __key_t __key;
  __uid_t uid;
  __gid_t gid;
  __uid_t cuid;
  __gid_t cgid;
  __mode_t mode;
  unsigned short int __seq;
  unsigned short int __pad2;
  __syscall_ulong_t __glibc_reserved1;
  __syscall_ulong_t __glibc_reserved2;
};
# 41 "/usr/include/aarch64-linux-gnu/bits/ipc.h" 2 3 4
# 26 "/usr/include/aarch64-linux-gnu/sys/ipc.h" 2 3 4
# 47 "/usr/include/aarch64-linux-gnu/sys/ipc.h" 3 4



extern key_t ftok (const char *__pathname, int __proj_id) __attribute__ ((__nothrow__ , __leaf__));


# 242 "/libmdbx/src/osal.h" 2
# 1 "/usr/include/aarch64-linux-gnu/sys/mman.h" 1 3 4
# 25 "/usr/include/aarch64-linux-gnu/sys/mman.h" 3 4
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 26 "/usr/include/aarch64-linux-gnu/sys/mman.h" 2 3 4
# 41 "/usr/include/aarch64-linux-gnu/sys/mman.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/mman.h" 1 3 4
# 29 "/usr/include/aarch64-linux-gnu/bits/mman.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/mman-map-flags-generic.h" 1 3 4
# 30 "/usr/include/aarch64-linux-gnu/bits/mman.h" 2 3 4


# 1 "/usr/include/aarch64-linux-gnu/bits/mman-linux.h" 1 3 4
# 117 "/usr/include/aarch64-linux-gnu/bits/mman-linux.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/mman-shared.h" 1 3 4
# 47 "/usr/include/aarch64-linux-gnu/bits/mman-shared.h" 3 4




int memfd_create (const char *__name, unsigned int __flags) __attribute__ ((__nothrow__ , __leaf__));



int mlock2 (const void *__addr, size_t __length, unsigned int __flags) __attribute__ ((__nothrow__ , __leaf__));





int pkey_alloc (unsigned int __flags, unsigned int __access_rights) __attribute__ ((__nothrow__ , __leaf__));



int pkey_set (int __key, unsigned int __access_rights) __attribute__ ((__nothrow__ , __leaf__));



int pkey_get (int __key) __attribute__ ((__nothrow__ , __leaf__));



int pkey_free (int __key) __attribute__ ((__nothrow__ , __leaf__));



int pkey_mprotect (void *__addr, size_t __len, int __prot, int __pkey) __attribute__ ((__nothrow__ , __leaf__));


# 118 "/usr/include/aarch64-linux-gnu/bits/mman-linux.h" 2 3 4
# 33 "/usr/include/aarch64-linux-gnu/bits/mman.h" 2 3 4
# 42 "/usr/include/aarch64-linux-gnu/sys/mman.h" 2 3 4





# 61 "/usr/include/aarch64-linux-gnu/sys/mman.h" 3 4
extern void * mmap (void *__addr, size_t __len, int __prot, int __flags, int __fd, __off64_t __offset) __asm__ ("" "mmap64") __attribute__ ((__nothrow__ , __leaf__))


                ;





extern void *mmap64 (void *__addr, size_t __len, int __prot,
       int __flags, int __fd, __off64_t __offset) __attribute__ ((__nothrow__ , __leaf__));




extern int munmap (void *__addr, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern int mprotect (void *__addr, size_t __len, int __prot) __attribute__ ((__nothrow__ , __leaf__));







extern int msync (void *__addr, size_t __len, int __flags);




extern int madvise (void *__addr, size_t __len, int __advice) __attribute__ ((__nothrow__ , __leaf__));



extern int posix_madvise (void *__addr, size_t __len, int __advice) __attribute__ ((__nothrow__ , __leaf__));




extern int mlock (const void *__addr, size_t __len) __attribute__ ((__nothrow__ , __leaf__));


extern int munlock (const void *__addr, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern int mlockall (int __flags) __attribute__ ((__nothrow__ , __leaf__));



extern int munlockall (void) __attribute__ ((__nothrow__ , __leaf__));







extern int mincore (void *__start, size_t __len, unsigned char *__vec)
     __attribute__ ((__nothrow__ , __leaf__));
# 133 "/usr/include/aarch64-linux-gnu/sys/mman.h" 3 4
extern void *mremap (void *__addr, size_t __old_len, size_t __new_len,
       int __flags, ...) __attribute__ ((__nothrow__ , __leaf__));



extern int remap_file_pages (void *__start, size_t __size, int __prot,
        size_t __pgoff, int __flags) __attribute__ ((__nothrow__ , __leaf__));




extern int shm_open (const char *__name, int __oflag, mode_t __mode);


extern int shm_unlink (const char *__name);


# 243 "/libmdbx/src/osal.h" 2
# 1 "/usr/include/aarch64-linux-gnu/sys/param.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/sys/param.h" 3 4
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/sys/param.h" 2 3 4


# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/limits.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/sys/param.h" 2 3 4




# 1 "/usr/include/aarch64-linux-gnu/bits/param.h" 1 3 4
# 28 "/usr/include/aarch64-linux-gnu/bits/param.h" 3 4
# 1 "/usr/include/linux/param.h" 1 3 4




# 1 "/usr/include/aarch64-linux-gnu/asm/param.h" 1 3 4
# 22 "/usr/include/aarch64-linux-gnu/asm/param.h" 3 4
# 1 "/usr/include/asm-generic/param.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/asm/param.h" 2 3 4
# 6 "/usr/include/linux/param.h" 2 3 4
# 29 "/usr/include/aarch64-linux-gnu/bits/param.h" 2 3 4
# 32 "/usr/include/aarch64-linux-gnu/sys/param.h" 2 3 4
# 244 "/libmdbx/src/osal.h" 2
# 1 "/usr/include/aarch64-linux-gnu/sys/stat.h" 1 3 4
# 99 "/usr/include/aarch64-linux-gnu/sys/stat.h" 3 4


# 1 "/usr/include/aarch64-linux-gnu/bits/stat.h" 1 3 4
# 102 "/usr/include/aarch64-linux-gnu/sys/stat.h" 2 3 4
# 227 "/usr/include/aarch64-linux-gnu/sys/stat.h" 3 4
extern int stat (const char *__restrict __file, struct stat *__restrict __buf) __asm__ ("" "stat64") __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__nonnull__ (1, 2)));
extern int fstat (int __fd, struct stat *__buf) __asm__ ("" "fstat64") __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__nonnull__ (2)));
# 240 "/usr/include/aarch64-linux-gnu/sys/stat.h" 3 4
extern int stat64 (const char *__restrict __file,
     struct stat64 *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int fstat64 (int __fd, struct stat64 *__buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
# 279 "/usr/include/aarch64-linux-gnu/sys/stat.h" 3 4
extern int fstatat (int __fd, const char *__restrict __file, struct stat *__restrict __buf, int __flag) __asm__ ("" "fstatat64") __attribute__ ((__nothrow__ , __leaf__))


                 __attribute__ ((__nonnull__ (2, 3)));
# 291 "/usr/include/aarch64-linux-gnu/sys/stat.h" 3 4
extern int fstatat64 (int __fd, const char *__restrict __file,
        struct stat64 *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 327 "/usr/include/aarch64-linux-gnu/sys/stat.h" 3 4
extern int lstat (const char *__restrict __file, struct stat *__restrict __buf) __asm__ ("" "lstat64") __attribute__ ((__nothrow__ , __leaf__))


     __attribute__ ((__nonnull__ (1, 2)));







extern int lstat64 (const char *__restrict __file,
      struct stat64 *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 352 "/usr/include/aarch64-linux-gnu/sys/stat.h" 3 4
extern int chmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int lchmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int fchmod (int __fd, __mode_t __mode) __attribute__ ((__nothrow__ , __leaf__));





extern int fchmodat (int __fd, const char *__file, __mode_t __mode,
       int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) __attribute__ ((__warn_unused_result__));






extern __mode_t umask (__mode_t __mask) __attribute__ ((__nothrow__ , __leaf__));




extern __mode_t getumask (void) __attribute__ ((__nothrow__ , __leaf__));



extern int mkdir (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mkdirat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));






extern int mknod (const char *__path, __mode_t __mode, __dev_t __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mknodat (int __fd, const char *__path, __mode_t __mode,
      __dev_t __dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));





extern int mkfifo (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mkfifoat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));






extern int utimensat (int __fd, const char *__path,
        const struct timespec __times[2],
        int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
# 452 "/usr/include/aarch64-linux-gnu/sys/stat.h" 3 4
extern int futimens (int __fd, const struct timespec __times[2]) __attribute__ ((__nothrow__ , __leaf__));
# 465 "/usr/include/aarch64-linux-gnu/sys/stat.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/statx.h" 1 3 4
# 31 "/usr/include/aarch64-linux-gnu/bits/statx.h" 3 4
# 1 "/usr/include/linux/stat.h" 1 3 4
# 56 "/usr/include/linux/stat.h" 3 4
struct statx_timestamp {
 __s64 tv_sec;
 __u32 tv_nsec;
 __s32 __reserved;
};
# 99 "/usr/include/linux/stat.h" 3 4
struct statx {

 __u32 stx_mask;
 __u32 stx_blksize;
 __u64 stx_attributes;

 __u32 stx_nlink;
 __u32 stx_uid;
 __u32 stx_gid;
 __u16 stx_mode;
 __u16 __spare0[1];

 __u64 stx_ino;
 __u64 stx_size;
 __u64 stx_blocks;
 __u64 stx_attributes_mask;

 struct statx_timestamp stx_atime;
 struct statx_timestamp stx_btime;
 struct statx_timestamp stx_ctime;
 struct statx_timestamp stx_mtime;

 __u32 stx_rdev_major;
 __u32 stx_rdev_minor;
 __u32 stx_dev_major;
 __u32 stx_dev_minor;

 __u64 stx_mnt_id;
 __u64 __spare2;

 __u64 __spare3[12];

};
# 32 "/usr/include/aarch64-linux-gnu/bits/statx.h" 2 3 4







# 1 "/usr/include/aarch64-linux-gnu/bits/statx-generic.h" 1 3 4
# 25 "/usr/include/aarch64-linux-gnu/bits/statx-generic.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/struct_statx_timestamp.h" 1 3 4
# 26 "/usr/include/aarch64-linux-gnu/bits/statx-generic.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/struct_statx.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/bits/statx-generic.h" 2 3 4
# 57 "/usr/include/aarch64-linux-gnu/bits/statx-generic.h" 3 4



int statx (int __dirfd, const char *__restrict __path, int __flags,
           unsigned int __mask, struct statx *__restrict __buf)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 5)));


# 40 "/usr/include/aarch64-linux-gnu/bits/statx.h" 2 3 4
# 466 "/usr/include/aarch64-linux-gnu/sys/stat.h" 2 3 4



# 245 "/libmdbx/src/osal.h" 2
# 1 "/usr/include/aarch64-linux-gnu/sys/statvfs.h" 1 3 4
# 25 "/usr/include/aarch64-linux-gnu/sys/statvfs.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/statvfs.h" 1 3 4
# 29 "/usr/include/aarch64-linux-gnu/bits/statvfs.h" 3 4
struct statvfs
  {
    unsigned long int f_bsize;
    unsigned long int f_frsize;
# 41 "/usr/include/aarch64-linux-gnu/bits/statvfs.h" 3 4
    __fsblkcnt64_t f_blocks;
    __fsblkcnt64_t f_bfree;
    __fsblkcnt64_t f_bavail;
    __fsfilcnt64_t f_files;
    __fsfilcnt64_t f_ffree;
    __fsfilcnt64_t f_favail;

    unsigned long int f_fsid;



    unsigned long int f_flag;
    unsigned long int f_namemax;
    int __f_spare[6];
  };


struct statvfs64
  {
    unsigned long int f_bsize;
    unsigned long int f_frsize;
    __fsblkcnt64_t f_blocks;
    __fsblkcnt64_t f_bfree;
    __fsblkcnt64_t f_bavail;
    __fsfilcnt64_t f_files;
    __fsfilcnt64_t f_ffree;
    __fsfilcnt64_t f_favail;
    unsigned long int f_fsid;



    unsigned long int f_flag;
    unsigned long int f_namemax;
    int __f_spare[6];
  };




enum
{
  ST_RDONLY = 1,

  ST_NOSUID = 2


  ,
  ST_NODEV = 4,

  ST_NOEXEC = 8,

  ST_SYNCHRONOUS = 16,

  ST_MANDLOCK = 64,

  ST_WRITE = 128,

  ST_APPEND = 256,

  ST_IMMUTABLE = 512,

  ST_NOATIME = 1024,

  ST_NODIRATIME = 2048,

  ST_RELATIME = 4096


};
# 26 "/usr/include/aarch64-linux-gnu/sys/statvfs.h" 2 3 4
# 47 "/usr/include/aarch64-linux-gnu/sys/statvfs.h" 3 4

# 56 "/usr/include/aarch64-linux-gnu/sys/statvfs.h" 3 4
extern int statvfs (const char *__restrict __file, struct statvfs *__restrict __buf) __asm__ ("" "statvfs64") __attribute__ ((__nothrow__ , __leaf__))


     __attribute__ ((__nonnull__ (1, 2)));





extern int statvfs64 (const char *__restrict __file,
        struct statvfs64 *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 77 "/usr/include/aarch64-linux-gnu/sys/statvfs.h" 3 4
extern int fstatvfs (int __fildes, struct statvfs *__buf) __asm__ ("" "fstatvfs64") __attribute__ ((__nothrow__ , __leaf__))
                  __attribute__ ((__nonnull__ (2)));





extern int fstatvfs64 (int __fildes, struct statvfs64 *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



# 246 "/libmdbx/src/osal.h" 2


# 247 "/libmdbx/src/osal.h"
typedef pthread_t mdbx_thread_t;
typedef pthread_key_t mdbx_thread_key_t;



typedef struct {
  pthread_mutex_t mutex;
  pthread_cond_t cond[2];
} mdbx_condpair_t;
typedef pthread_mutex_t mdbx_fastmutex_t;
# 444 "/libmdbx/src/osal.h"
__attribute__((__unused__)) __attribute__((__const__, __nothrow__)) static __inline size_t
mdbx_syspagesize(void) {





  return sysconf(
# 451 "/libmdbx/src/osal.h" 3 4
                _SC_PAGESIZE
# 451 "/libmdbx/src/osal.h"
                             );

}

typedef struct mdbx_mmap_param {
  union {
    void *address;
    uint8_t *dxb;
    struct MDBX_lockinfo *lck;
  };
  mdbx_filehandle_t fd;
  size_t limit;
  size_t current;
  uint64_t filesize ;



} mdbx_mmap_t;

typedef union bin128 {
  __extension__ struct { uint64_t x, y; };
  __extension__ struct { uint32_t a, b, c, d; };
} bin128_t;
# 487 "/libmdbx/src/osal.h"
__attribute__((__unused__)) static void mdbx_osal_jitter(_Bool tiny);
__attribute__((__unused__)) static __inline void mdbx_jitter4testing(_Bool tiny);
# 501 "/libmdbx/src/osal.h"
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stdatomic.h" 1 3 4
# 29 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stdatomic.h" 3 4

# 29 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stdatomic.h" 3 4
typedef enum
  {
    memory_order_relaxed = 0,
    memory_order_consume = 1,
    memory_order_acquire = 2,
    memory_order_release = 3,
    memory_order_acq_rel = 4,
    memory_order_seq_cst = 5
  } memory_order;


typedef _Atomic _Bool atomic_bool;
typedef _Atomic char atomic_char;
typedef _Atomic signed char atomic_schar;
typedef _Atomic unsigned char atomic_uchar;
typedef _Atomic short atomic_short;
typedef _Atomic unsigned short atomic_ushort;
typedef _Atomic int atomic_int;
typedef _Atomic unsigned int atomic_uint;
typedef _Atomic long atomic_long;
typedef _Atomic unsigned long atomic_ulong;
typedef _Atomic long long atomic_llong;
typedef _Atomic unsigned long long atomic_ullong;
typedef _Atomic short unsigned int atomic_char16_t;
typedef _Atomic unsigned int atomic_char32_t;
typedef _Atomic unsigned int atomic_wchar_t;
typedef _Atomic signed char atomic_int_least8_t;
typedef _Atomic unsigned char atomic_uint_least8_t;
typedef _Atomic short int atomic_int_least16_t;
typedef _Atomic short unsigned int atomic_uint_least16_t;
typedef _Atomic int atomic_int_least32_t;
typedef _Atomic unsigned int atomic_uint_least32_t;
typedef _Atomic long int atomic_int_least64_t;
typedef _Atomic long unsigned int atomic_uint_least64_t;
typedef _Atomic signed char atomic_int_fast8_t;
typedef _Atomic unsigned char atomic_uint_fast8_t;
typedef _Atomic long int atomic_int_fast16_t;
typedef _Atomic long unsigned int atomic_uint_fast16_t;
typedef _Atomic long int atomic_int_fast32_t;
typedef _Atomic long unsigned int atomic_uint_fast32_t;
typedef _Atomic long int atomic_int_fast64_t;
typedef _Atomic long unsigned int atomic_uint_fast64_t;
typedef _Atomic long int atomic_intptr_t;
typedef _Atomic long unsigned int atomic_uintptr_t;
typedef _Atomic long unsigned int atomic_size_t;
typedef _Atomic long int atomic_ptrdiff_t;
typedef _Atomic long int atomic_intmax_t;
typedef _Atomic long unsigned int atomic_uintmax_t;
# 92 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stdatomic.h" 3 4
extern void atomic_thread_fence (memory_order);

extern void atomic_signal_fence (memory_order);
# 218 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stdatomic.h" 3 4
typedef _Atomic struct
{

  _Bool __val;



} atomic_flag;




extern _Bool atomic_flag_test_and_set (volatile atomic_flag *);


extern _Bool atomic_flag_test_and_set_explicit (volatile atomic_flag *,
      memory_order);



extern void atomic_flag_clear (volatile atomic_flag *);

extern void atomic_flag_clear_explicit (volatile atomic_flag *, memory_order);
# 502 "/libmdbx/src/osal.h" 2
# 532 "/libmdbx/src/osal.h"

# 532 "/libmdbx/src/osal.h"
__attribute__((__unused__)) static __inline void mdbx_compiler_barrier(void) {

  __asm__ __volatile__("" ::: "memory");
# 550 "/libmdbx/src/osal.h"
}

__attribute__((__unused__)) static __inline void mdbx_memory_barrier(void) {

  
# 554 "/libmdbx/src/osal.h" 3 4
 __atomic_thread_fence (
# 554 "/libmdbx/src/osal.h"
 memory_order_seq_cst
# 554 "/libmdbx/src/osal.h" 3 4
 )
# 554 "/libmdbx/src/osal.h"
                                          ;
# 582 "/libmdbx/src/osal.h"
}
# 592 "/libmdbx/src/osal.h"
__attribute__((__unused__)) static
    __attribute__((__format__(__printf__, 2, 3))) int mdbx_asprintf(char **strp, const char *fmt, ...);
static int mdbx_vasprintf(char **strp, const char *fmt, va_list ap);
# 608 "/libmdbx/src/osal.h"
static uint32_t mdbx_linux_kernel_version;
static _Bool mdbx_RunningOnWSL1 ;






__attribute__((__unused__)) static __inline int mdbx_get_errno(void) {



  int rc = 
# 620 "/libmdbx/src/osal.h" 3 4
          (*__errno_location ())
# 620 "/libmdbx/src/osal.h"
               ;

  return rc;
}


static int mdbx_memalign_alloc(size_t alignment, size_t bytes,
                                           void **result);


static void mdbx_memalign_free(void *ptr);


static int mdbx_condpair_init(mdbx_condpair_t *condpair);
static int mdbx_condpair_lock(mdbx_condpair_t *condpair);
static int mdbx_condpair_unlock(mdbx_condpair_t *condpair);
static int mdbx_condpair_signal(mdbx_condpair_t *condpair,
                                            _Bool part);
static int mdbx_condpair_wait(mdbx_condpair_t *condpair, _Bool part);
static int mdbx_condpair_destroy(mdbx_condpair_t *condpair);

static int mdbx_fastmutex_init(mdbx_fastmutex_t *fastmutex);
static int mdbx_fastmutex_acquire(mdbx_fastmutex_t *fastmutex);
static int mdbx_fastmutex_release(mdbx_fastmutex_t *fastmutex);
static int mdbx_fastmutex_destroy(mdbx_fastmutex_t *fastmutex);

static int mdbx_pwritev(mdbx_filehandle_t fd, struct iovec *iov,
                                    int iovcnt, uint64_t offset,
                                    size_t expected_written);
static int mdbx_pread(mdbx_filehandle_t fd, void *buf, size_t count,
                                  uint64_t offset);
static int mdbx_pwrite(mdbx_filehandle_t fd, const void *buf,
                                   size_t count, uint64_t offset);
static int mdbx_write(mdbx_filehandle_t fd, const void *buf,
                                  size_t count);

static int
mdbx_thread_create(mdbx_thread_t *thread,
                   void *( *start_routine)(void *),
                   void *arg);
static int mdbx_thread_join(mdbx_thread_t thread);

enum mdbx_syncmode_bits {
  MDBX_SYNC_NONE = 0,
  MDBX_SYNC_DATA = 1,
  MDBX_SYNC_SIZE = 2,
  MDBX_SYNC_IODQ = 4
};

static int mdbx_fsync(mdbx_filehandle_t fd,
                                  const enum mdbx_syncmode_bits mode_bits);
static int mdbx_ftruncate(mdbx_filehandle_t fd, uint64_t length);
static int mdbx_fseek(mdbx_filehandle_t fd, uint64_t pos);
static int mdbx_filesize(mdbx_filehandle_t fd, uint64_t *length);

enum mdbx_openfile_purpose {
  MDBX_OPEN_DXB_READ = 0,
  MDBX_OPEN_DXB_LAZY = 1,
  MDBX_OPEN_DXB_DSYNC = 2,
  MDBX_OPEN_LCK = 3,
  MDBX_OPEN_COPY = 4,
  MDBX_OPEN_DELETE = 5
};

static int mdbx_openfile(const enum mdbx_openfile_purpose purpose,
                                     const MDBX_env *env, const char *pathname,
                                     mdbx_filehandle_t *fd,
                                     mdbx_mode_t unix_mode_bits);
static int mdbx_closefile(mdbx_filehandle_t fd);
static int mdbx_removefile(const char *pathname);
static int mdbx_removedirectory(const char *pathname);
static int mdbx_is_pipe(mdbx_filehandle_t fd);
static int mdbx_lockfile(mdbx_filehandle_t fd, _Bool wait);



static int mdbx_mmap(const int flags, mdbx_mmap_t *map,
                                 const size_t must, const size_t limit,
                                 const unsigned options);
static int mdbx_munmap(mdbx_mmap_t *map);


static int mdbx_mresize(const int flags, mdbx_mmap_t *map,
                                    size_t size, size_t limit);
# 714 "/libmdbx/src/osal.h"
static int mdbx_msync(mdbx_mmap_t *map, size_t offset,
                                  size_t length,
                                  enum mdbx_syncmode_bits mode_bits);
static int mdbx_check_fs_rdonly(mdbx_filehandle_t handle,
                                            const char *pathname, int err);

__attribute__((__unused__)) static __inline uint32_t mdbx_getpid(void) {
  _Static_assert(sizeof(mdbx_pid_t) <= sizeof(uint32_t), "sizeof(mdbx_pid_t) <= sizeof(uint32_t)");



  return getpid();

}

__attribute__((__unused__)) static __inline uintptr_t mdbx_thread_self(void) {
  mdbx_tid_t thunk;
  _Static_assert(sizeof(uintptr_t) >= sizeof(thunk), "sizeof(uintptr_t) >= sizeof(thunk)");



  thunk = pthread_self();

  return (uintptr_t)thunk;
}

static uint64_t mdbx_osal_monotime(void);
static uint64_t
mdbx_osal_16dot16_to_monotime(uint32_t seconds_16dot16);
static uint32_t mdbx_osal_monotime_to_16dot16(uint64_t monotime);

static bin128_t mdbx_osal_bootid(void);
# 761 "/libmdbx/src/osal.h"
static int mdbx_lck_init(MDBX_env *env,
                                     MDBX_env *inprocess_neighbor,
                                     int global_uniqueness_flag);
# 782 "/libmdbx/src/osal.h"
static int mdbx_lck_destroy(MDBX_env *env,
                                        MDBX_env *inprocess_neighbor);
# 797 "/libmdbx/src/osal.h"
static int mdbx_lck_seize(MDBX_env *env);
# 810 "/libmdbx/src/osal.h"
static int mdbx_lck_downgrade(MDBX_env *env);



static int mdbx_rdt_lock(MDBX_env *env);


static void mdbx_rdt_unlock(MDBX_env *env);





__attribute__((__visibility__("default"))) int mdbx_txn_lock(MDBX_env *env, _Bool dont_wait);




__attribute__((__visibility__("default"))) void mdbx_txn_unlock(MDBX_env *env);





static int mdbx_rpid_set(MDBX_env *env);





static int mdbx_rpid_clear(MDBX_env *env);
# 850 "/libmdbx/src/osal.h"
static int mdbx_rpid_check(MDBX_env *env, uint32_t pid);
# 202 "/libmdbx/src/internals.h" 2






# 1 "/libmdbx/src/options.h" 1
# 209 "/libmdbx/src/internals.h" 2
# 218 "/libmdbx/src/internals.h"
enum MDBX_memory_order {
  mo_Relaxed,
  mo_AcquireRelease,
  mo_SequentialConsistency
};

typedef union {
  volatile uint32_t weak;

  volatile _Atomic uint32_t c11a;

} MDBX_atomic_uint32_t;

typedef union {
  volatile uint64_t weak;

  volatile _Atomic uint64_t c11a;
# 247 "/libmdbx/src/internals.h"
} MDBX_atomic_uint64_t;
# 263 "/libmdbx/src/internals.h"
static 
# 263 "/libmdbx/src/internals.h" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 263 "/libmdbx/src/internals.h"
                      memory_order mo_c11_store(enum MDBX_memory_order fence) {
  switch (fence) {
  default:
    
# 266 "/libmdbx/src/internals.h" 3 4
   ((void) (0))
# 266 "/libmdbx/src/internals.h"
                ;
    __builtin_unreachable();
  case mo_Relaxed:
    return memory_order_relaxed;
  case mo_AcquireRelease:
    return memory_order_release;
  case mo_SequentialConsistency:
    return memory_order_seq_cst;
  }
}

static 
# 277 "/libmdbx/src/internals.h" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 277 "/libmdbx/src/internals.h"
                      memory_order mo_c11_load(enum MDBX_memory_order fence) {
  switch (fence) {
  default:
    
# 280 "/libmdbx/src/internals.h" 3 4
   ((void) (0))
# 280 "/libmdbx/src/internals.h"
                ;
    __builtin_unreachable();
  case mo_Relaxed:
    return memory_order_relaxed;
  case mo_AcquireRelease:
    return memory_order_acquire;
  case mo_SequentialConsistency:
    return memory_order_seq_cst;
  }
}




__attribute__((__unused__)) static 
# 294 "/libmdbx/src/internals.h" 3 4
                        __inline __attribute__ ((__always_inline__)) 
# 294 "/libmdbx/src/internals.h"
                                        void
mdbx_memory_fence(enum MDBX_memory_order order, _Bool write) {

  
# 297 "/libmdbx/src/internals.h" 3 4
 __atomic_thread_fence (
# 297 "/libmdbx/src/internals.h"
 write ? mo_c11_store(order) : mo_c11_load(order)
# 297 "/libmdbx/src/internals.h" 3 4
 )
# 297 "/libmdbx/src/internals.h"
                                                                      ;






}

__attribute__((__unused__)) static 
# 306 "/libmdbx/src/internals.h" 3 4
                        __inline __attribute__ ((__always_inline__)) 
# 306 "/libmdbx/src/internals.h"
                                        uint32_t
atomic_store32(MDBX_atomic_uint32_t *p, const uint32_t value,
               enum MDBX_memory_order order) {
  _Static_assert(sizeof(MDBX_atomic_uint32_t) == 4, "sizeof(MDBX_atomic_uint32_t) == 4");

  
# 311 "/libmdbx/src/internals.h" 3 4
 ((void) (0))
# 311 "/libmdbx/src/internals.h"
                                                       ;
  
# 312 "/libmdbx/src/internals.h" 3 4
 __extension__ ({ __auto_type __atomic_store_ptr = (
# 312 "/libmdbx/src/internals.h"
 (&(p)->c11a)
# 312 "/libmdbx/src/internals.h" 3 4
 ); __typeof__ ((void)0, *__atomic_store_ptr) __atomic_store_tmp = (
# 312 "/libmdbx/src/internals.h"
 value
# 312 "/libmdbx/src/internals.h" 3 4
 ); __atomic_store (__atomic_store_ptr, &__atomic_store_tmp, (
# 312 "/libmdbx/src/internals.h"
 mo_c11_store(order)
# 312 "/libmdbx/src/internals.h" 3 4
 )); })
# 312 "/libmdbx/src/internals.h"
                                                                             ;






  return value;
}

__attribute__((__unused__)) static 
# 322 "/libmdbx/src/internals.h" 3 4
                        __inline __attribute__ ((__always_inline__)) 
# 322 "/libmdbx/src/internals.h"
                                        uint32_t
atomic_load32(const MDBX_atomic_uint32_t *p, enum MDBX_memory_order order) {
  _Static_assert(sizeof(MDBX_atomic_uint32_t) == 4, "sizeof(MDBX_atomic_uint32_t) == 4");

  
# 326 "/libmdbx/src/internals.h" 3 4
 ((void) (0))
# 326 "/libmdbx/src/internals.h"
                                                       ;
  return 
# 327 "/libmdbx/src/internals.h" 3 4
        __extension__ ({ __auto_type __atomic_load_ptr = (
# 327 "/libmdbx/src/internals.h"
        (&(p)->c11a)
# 327 "/libmdbx/src/internals.h" 3 4
        ); __typeof__ ((void)0, *__atomic_load_ptr) __atomic_load_tmp; __atomic_load (__atomic_load_ptr, &__atomic_load_tmp, (
# 327 "/libmdbx/src/internals.h"
        mo_c11_load(order)
# 327 "/libmdbx/src/internals.h" 3 4
        )); __atomic_load_tmp; })
# 327 "/libmdbx/src/internals.h"
                                                                           ;







}
# 366 "/libmdbx/src/internals.h"
typedef uint32_t pgno_t;
typedef MDBX_atomic_uint32_t atomic_pgno_t;







typedef uint64_t txnid_t;
typedef MDBX_atomic_uint64_t atomic_txnid_t;
# 395 "/libmdbx/src/internals.h"
typedef uint16_t indx_t;





#pragma pack(push, 4)


typedef struct MDBX_db {
  uint16_t md_flags;
  uint16_t md_depth;
  uint32_t md_xsize;
  pgno_t md_root;
  pgno_t md_branch_pages;
  pgno_t md_leaf_pages;
  pgno_t md_overflow_pages;
  uint64_t md_seq;
  uint64_t md_entries;
  uint64_t md_mod_txnid;
} MDBX_db;


typedef struct MDBX_geo {
  uint16_t grow_pv;

  uint16_t shrink_pv;

  pgno_t lower;
  pgno_t upper;
  pgno_t now;
  pgno_t next;

} MDBX_geo;




typedef struct MDBX_meta {


  uint32_t mm_magic_and_version[2];


  uint32_t mm_txnid_a[2];

  uint16_t mm_extra_flags;
  uint8_t mm_validator_id;

  uint8_t mm_extra_pagehdr;


  MDBX_geo mm_geo;

  MDBX_db mm_dbs[2];


  MDBX_canary mm_canary;






  uint32_t mm_datasync_sign[2];


  uint32_t mm_txnid_b[2];





  uint32_t mm_pages_retired[2];






  bin128_t mm_bootid;

} MDBX_meta;

#pragma pack(1)
# 498 "/libmdbx/src/internals.h"
typedef struct MDBX_page {
  union {





    uint64_t mp_txnid;
    struct MDBX_page *mp_next;
  };
  uint16_t mp_leaf2_ksize;
# 520 "/libmdbx/src/internals.h"
  uint16_t mp_flags;
  union {
    uint32_t mp_pages;
    __extension__ struct {
      indx_t mp_lower;
      indx_t mp_upper;
    };
  };
  pgno_t mp_pgno;



  indx_t mp_ptrs[] ;

} MDBX_page;




#pragma pack(pop)




typedef struct {
  MDBX_atomic_uint64_t newly;
  MDBX_atomic_uint64_t cow;
  MDBX_atomic_uint64_t clone;

  MDBX_atomic_uint64_t split;
  MDBX_atomic_uint64_t merge;
  MDBX_atomic_uint64_t spill;
  MDBX_atomic_uint64_t unspill;
  MDBX_atomic_uint64_t
      wops;
} MDBX_pgop_stat_t;
# 572 "/libmdbx/src/internals.h"
typedef pthread_mutex_t mdbx_ipclock_t;
# 581 "/libmdbx/src/internals.h"
static int mdbx_ipclock_stub(mdbx_ipclock_t *ipc);
static int mdbx_ipclock_destroy(mdbx_ipclock_t *ipc);
# 624 "/libmdbx/src/internals.h"
typedef struct MDBX_reader {






  MDBX_atomic_uint64_t mr_txnid;
# 643 "/libmdbx/src/internals.h"
  MDBX_atomic_uint64_t mr_tid;


  MDBX_atomic_uint32_t mr_pid;



  atomic_pgno_t mr_snapshot_pages_used;



  MDBX_atomic_uint64_t mr_snapshot_pages_retired;
} MDBX_reader;


typedef struct MDBX_lockinfo {


  uint64_t mti_magic_and_version;


  uint32_t mti_os_and_format;


  MDBX_atomic_uint32_t mti_envmode;



  atomic_pgno_t mti_autosync_threshold;



  MDBX_atomic_uint32_t mti_meta_sync_txnid;






  MDBX_atomic_uint64_t mti_autosync_period;


  MDBX_atomic_uint64_t mti_bait_uniqueness;

  
# 687 "/libmdbx/src/internals.h" 3 4
 _Alignas
# 687 "/libmdbx/src/internals.h"
 (64)




  MDBX_pgop_stat_t mti_pgop_stat;


  
# 695 "/libmdbx/src/internals.h" 3 4
 _Alignas
# 695 "/libmdbx/src/internals.h"
 (64)



  mdbx_ipclock_t mti_wlock;


  atomic_txnid_t mti_oldest_reader;




  MDBX_atomic_uint64_t mti_sync_timestamp;


  atomic_pgno_t mti_unsynced_pages;


  atomic_pgno_t mti_discarded_tail;


  MDBX_atomic_uint64_t mti_reader_check_timestamp;


  pgno_t mti_readahead_anchor;

  
# 721 "/libmdbx/src/internals.h" 3 4
 _Alignas
# 721 "/libmdbx/src/internals.h"
 (64)



  mdbx_ipclock_t mti_rlock;





  MDBX_atomic_uint32_t mti_numreaders;
  MDBX_atomic_uint32_t mti_readers_refresh_flag;



  
# 736 "/libmdbx/src/internals.h" 3 4
 _Alignas
# 736 "/libmdbx/src/internals.h"
 (64)
  MDBX_reader mti_readers[] ;

} MDBX_lockinfo;
# 802 "/libmdbx/src/internals.h"
typedef pgno_t *MDBX_PNL;
# 813 "/libmdbx/src/internals.h"
typedef txnid_t *MDBX_TXL;


typedef struct MDBX_dp {
  MDBX_page *ptr;
  pgno_t pgno;
  union {
    unsigned extra;
    __extension__ struct {
      unsigned multi : 1;
      unsigned lru : 31;
    };
  };
} MDBX_dp;


typedef struct MDBX_dpl {
  unsigned sorted;
  unsigned length;
  unsigned detent;


  MDBX_dp items[] ;

} MDBX_dpl;
# 874 "/libmdbx/src/internals.h"
typedef struct MDBX_dbx {
  MDBX_val md_name;
  MDBX_cmp_func *md_cmp;
  MDBX_cmp_func *md_dcmp;
  size_t md_klen_min, md_klen_max;
  size_t md_vlen_min,
      md_vlen_max;
} MDBX_dbx;



struct MDBX_txn {

  uint32_t mt_signature;
# 916 "/libmdbx/src/internals.h"
  uint32_t mt_flags;

  MDBX_txn *mt_parent;

  MDBX_txn *mt_child;
  MDBX_geo mt_geo;
# 930 "/libmdbx/src/internals.h"
  txnid_t mt_txnid;
  txnid_t mt_front;

  MDBX_env *mt_env;

  MDBX_dbx *mt_dbxs;

  MDBX_db *mt_dbs;

  unsigned *mt_dbiseqs;
# 950 "/libmdbx/src/internals.h"
  uint8_t *mt_dbistate;



  MDBX_dbi mt_numdbs;
  size_t mt_owner;
  MDBX_canary mt_canary;
  void *mt_userctx;
  MDBX_cursor **mt_cursors;

  union {
    struct {

      MDBX_reader *reader;
    } to;
    struct {

      pgno_t *reclaimed_pglist;
      txnid_t last_reclaimed;

      pgno_t loose_refund_wl ;





      unsigned dirtyroom;

      unsigned dirtylru;

      MDBX_dpl *dirtylist;

      MDBX_TXL lifo_reclaimed;

      MDBX_PNL retired_pages;


      MDBX_page *loose_pages;

      unsigned loose_count;



      MDBX_PNL spill_pages;
      unsigned spill_least_removed;
    } tw;
  };
};







struct MDBX_xcursor;
# 1014 "/libmdbx/src/internals.h"
struct MDBX_cursor {



  uint32_t mc_signature;

  MDBX_dbi mc_dbi;

  MDBX_cursor *mc_next;

  MDBX_cursor *mc_backup;

  struct MDBX_xcursor *mc_xcursor;

  MDBX_txn *mc_txn;

  MDBX_db *mc_db;

  MDBX_dbx *mc_dbx;

  uint8_t *mc_dbistate;
  unsigned mc_snum;
  unsigned mc_top;
# 1053 "/libmdbx/src/internals.h"
  unsigned mc_flags;
  MDBX_page *mc_pg[32];
  indx_t mc_ki[32];
};





typedef struct MDBX_xcursor {

  MDBX_cursor mx_cursor;

  MDBX_db mx_db;

  MDBX_dbx mx_dbx;
} MDBX_xcursor;

typedef struct MDBX_cursor_couple {
  MDBX_cursor outer;
  void *mc_userctx;
  MDBX_xcursor inner;
} MDBX_cursor_couple;


struct MDBX_env {


  MDBX_atomic_uint32_t me_signature;
# 1091 "/libmdbx/src/internals.h"
  uint32_t me_flags;
  mdbx_mmap_t me_dxb_mmap;


  mdbx_filehandle_t me_dsync_fd;
  mdbx_mmap_t me_lck_mmap;

  struct MDBX_lockinfo *me_lck;

  unsigned me_psize;
  unsigned me_leaf_nodemax;
  uint8_t me_psize2log;
  int8_t me_stuck_meta;
  uint16_t me_merge_threshold,
      me_merge_threshold_gc;

  unsigned me_os_psize;
  unsigned me_maxreaders;
  MDBX_dbi me_maxdbs;
  uint32_t me_pid;
  mdbx_thread_key_t me_txkey;
  char *me_pathname;
  void *me_pbuf;
  MDBX_txn *me_txn0;

  MDBX_dbx *me_dbxs;
  uint16_t *me_dbflags;
  unsigned *me_dbiseqs;
  unsigned
      me_maxgc_ov1page;
  uint32_t me_live_reader;
  void *me_userctx;
  MDBX_hsr_func *me_hsr_callback;

  struct {
    unsigned dp_reserve_limit;
    unsigned rp_augment_limit;
    unsigned dp_limit;
    unsigned dp_initial;
    uint8_t dp_loose_limit;
    uint8_t spill_max_denominator;
    uint8_t spill_min_denominator;
    uint8_t spill_parent4child_denominator;
    unsigned merge_threshold_16dot16_percent;
    union {
      unsigned all;

      struct {
        unsigned dp_limit : 1;
      } non_auto;
    } flags;
  } me_options;




  struct {
    size_t lower;
    size_t upper;
    size_t now;
    size_t grow;
    size_t shrink;
  } me_dbgeo;
# 1162 "/libmdbx/src/internals.h"
  MDBX_env *me_lcklist_next;



  MDBX_txn *me_txn;
  mdbx_fastmutex_t me_dbi_lock;
  MDBX_dbi me_numdbs;

  MDBX_page *me_dp_reserve;
  unsigned me_dp_reserve_len;

  MDBX_PNL me_retired_pages;






  mdbx_fastmutex_t me_remap_guard;
# 1203 "/libmdbx/src/internals.h"
  MDBX_atomic_uint64_t
      x_lckless_stub[(sizeof(MDBX_lockinfo) + 64 - 1) /
                     sizeof(MDBX_atomic_uint64_t)];
};
# 1215 "/libmdbx/src/internals.h"
extern uint8_t mdbx_runtime_flags;
extern uint8_t mdbx_loglevel;
extern MDBX_debug_func *mdbx_debug_logger;

__attribute__((__unused__)) static __inline void mdbx_jitter4testing(_Bool tiny) {




  (void)tiny;

}

static void __attribute__((__format__(__printf__, 4, 5)))
    mdbx_debug_log(int level, const char *function, int line, const char *fmt,
                   ...) __attribute__((__format__(__printf__, 4, 5)));
static void mdbx_debug_log_va(int level, const char *function,
                                          int line, const char *fmt,
                                          va_list args);
# 1255 "/libmdbx/src/internals.h"
void mdbx_assert_fail(const MDBX_env *env, const char *msg, const char *func,
                      int line);
# 1351 "/libmdbx/src/internals.h"
__attribute__((__unused__)) static __inline void
mdbx_flush_incoherent_mmap(void *addr, size_t nbytes, const intptr_t pagesize) {
# 1361 "/libmdbx/src/internals.h"
  (void)pagesize;
# 1375 "/libmdbx/src/internals.h"
  (void)addr;
  (void)nbytes;

}




static int mdbx_cleanup_dead_readers(MDBX_env *env, int rlocked,
                                                 int *dead);
static int mdbx_rthc_alloc(mdbx_thread_key_t *key,
                                       MDBX_reader *begin, MDBX_reader *end);
static void mdbx_rthc_remove(const mdbx_thread_key_t key);

static void mdbx_rthc_global_init(void);
static void mdbx_rthc_global_dtor(void);
static void mdbx_rthc_thread_dtor(void *ptr);
# 1463 "/libmdbx/src/internals.h"
typedef struct MDBX_node {

  union {
    uint32_t mn_dsize;
    uint32_t mn_pgno32;
  };
  uint8_t mn_flags;
  uint8_t mn_extra;
  uint16_t mn_ksize;
# 1492 "/libmdbx/src/internals.h"
  uint8_t mn_data[] ;

} MDBX_node;
# 1538 "/libmdbx/src/internals.h"
__attribute__((__unused__)) __attribute__((__const__, __nothrow__)) static __inline pgno_t
int64pgno(int64_t i64) {
  if (__builtin_expect(!!(i64 >= (int64_t)3 && i64 <= (int64_t)0x7FFFffffU + 1), 1))
    return (pgno_t)i64;
  return (i64 < (int64_t)3) ? 3 : 0x7FFFffffU;
}

__attribute__((__unused__)) __attribute__((__const__, __nothrow__)) static __inline pgno_t
pgno_add(size_t base, size_t augend) {
  do { if ((0)) do { if (__builtin_expect(!!(!(base <= 0x7FFFffffU + 1 && augend < 0x7FFFffffU)), 0)) mdbx_assert_fail(
# 1547 "/libmdbx/src/internals.h" 3 4
 ((void *)0)
# 1547 "/libmdbx/src/internals.h"
 , "base <= 0x7FFFffffU + 1 && augend < 0x7FFFffffU", __func__, 1547); } while (0); } while (0);
  return int64pgno(base + augend);
}

__attribute__((__unused__)) __attribute__((__const__, __nothrow__)) static __inline pgno_t
pgno_sub(size_t base, size_t subtrahend) {
  do { if ((0)) do { if (__builtin_expect(!!(!(base >= 3 && base <= 0x7FFFffffU + 1 && subtrahend < 0x7FFFffffU)), 0)) mdbx_assert_fail(
# 1553 "/libmdbx/src/internals.h" 3 4
 ((void *)0)
# 1553 "/libmdbx/src/internals.h"
 , "base >= 3 && base <= 0x7FFFffffU + 1 && subtrahend < 0x7FFFffffU", __func__, 1553); } while (0); } while (0)
                                 ;
  return int64pgno(base - subtrahend);
}

__attribute__((__unused__)) __attribute__((__const__, __nothrow__)) static 
# 1558 "/libmdbx/src/internals.h" 3 4
                                                    __inline __attribute__ ((__always_inline__)) 
# 1558 "/libmdbx/src/internals.h"
                                                                    _Bool
is_powerof2(size_t x) {
  return (x & (x - 1)) == 0;
}

__attribute__((__unused__)) __attribute__((__const__, __nothrow__)) static 
# 1563 "/libmdbx/src/internals.h" 3 4
                                                    __inline __attribute__ ((__always_inline__)) 
# 1563 "/libmdbx/src/internals.h"
                                                                    size_t
floor_powerof2(size_t value, size_t granularity) {
  do { if ((0)) do { if (__builtin_expect(!!(!(is_powerof2(granularity))), 0)) mdbx_assert_fail(
# 1565 "/libmdbx/src/internals.h" 3 4
 ((void *)0)
# 1565 "/libmdbx/src/internals.h"
 , "is_powerof2(granularity)", __func__, 1565); } while (0); } while (0);
  return value & ~(granularity - 1);
}

__attribute__((__unused__)) __attribute__((__const__, __nothrow__)) static 
# 1569 "/libmdbx/src/internals.h" 3 4
                                                    __inline __attribute__ ((__always_inline__)) 
# 1569 "/libmdbx/src/internals.h"
                                                                    size_t
ceil_powerof2(size_t value, size_t granularity) {
  return floor_powerof2(value + granularity - 1, granularity);
}

__attribute__((__unused__)) __attribute__((__const__, __nothrow__)) static unsigned
log2n_powerof2(size_t value) {
  do { if ((0)) do { if (__builtin_expect(!!(!(value > 0 && value < 
# 1576 "/libmdbx/src/internals.h" 3 4
 (2147483647) 
# 1576 "/libmdbx/src/internals.h"
 && is_powerof2(value))), 0)) mdbx_assert_fail(
# 1576 "/libmdbx/src/internals.h" 3 4
 ((void *)0)
# 1576 "/libmdbx/src/internals.h"
 , "value > 0 && value < (2147483647) && is_powerof2(value)", __func__, 1576); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!((value & -(int32_t)value) == value)), 0)) mdbx_assert_fail(
# 1577 "/libmdbx/src/internals.h" 3 4
 ((void *)0)
# 1577 "/libmdbx/src/internals.h"
 , "(value & -(int32_t)value) == value", __func__, 1577); } while (0); } while (0);

  return __builtin_ctzl(value);
# 1590 "/libmdbx/src/internals.h"
}
# 1604 "/libmdbx/src/internals.h"
__attribute__((__unused__)) static void static_checks(void) {
  _Static_assert(
# 1605 "/libmdbx/src/internals.h" 3 4
 (32767) 
# 1605 "/libmdbx/src/internals.h"
 - 2 == MDBX_MAX_DBI, "Oops, MDBX_MAX_DBI or CORE_DBS?")
                                                      ;
  _Static_assert((unsigned)(MDBX_DB_ACCEDE | MDBX_CREATE) == ((((MDBX_REVERSEKEY | MDBX_DUPSORT | MDBX_INTEGERKEY | MDBX_DUPFIXED | MDBX_INTEGERDUP | MDBX_REVERSEDUP) | MDBX_CREATE | MDBX_DB_ACCEDE) | 0x8000) & (((MDBX_SAFE_NOSYNC | MDBX_NOMETASYNC | 0x100000U | MDBX_NOMEMINIT | MDBX_COALESCE | MDBX_PAGEPERTURB | MDBX_ACCEDE) | (MDBX_NOSUBDIR | MDBX_RDONLY | MDBX_WRITEMAP | MDBX_NOTLS | MDBX_NORDAHEAD | MDBX_LIFORECLAIM | MDBX_EXCLUSIVE)) | (0x80000000U | 0x20000000U | 0x10000000U))), "Oops, some flags overlapped or wrong")


                                                           ;
  _Static_assert(((0x80000000U | 0x20000000U | 0x10000000U) & ((MDBX_SAFE_NOSYNC | MDBX_NOMETASYNC | 0x100000U | MDBX_NOMEMINIT | MDBX_COALESCE | MDBX_PAGEPERTURB | MDBX_ACCEDE) | (MDBX_NOSUBDIR | MDBX_RDONLY | MDBX_WRITEMAP | MDBX_NOTLS | MDBX_NORDAHEAD | MDBX_LIFORECLAIM | MDBX_EXCLUSIVE))) == 0, "Oops, some flags overlapped or wrong")
                                                           ;
}
# 16 "/libmdbx/src/alloy.c" 2

# 1 "/libmdbx/src/core.c" 1
# 43 "/libmdbx/src/core.c"
__attribute__((__const__, __nothrow__)) static unsigned branchless_abs(int value) {
  do { if ((0)) do { if (__builtin_expect(!!(!(value > 
# 44 "/libmdbx/src/core.c" 3 4
 (-0x7fffffff - 1)
# 44 "/libmdbx/src/core.c"
 )), 0)) mdbx_assert_fail(
# 44 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 44 "/libmdbx/src/core.c"
 , "value > (-0x7fffffff - 1)", __func__, 44); } while (0); } while (0);
  const unsigned expanded_sign =
      (unsigned)(value >> (sizeof(value) * 8 - 1));
  return ((unsigned)value + expanded_sign) ^ expanded_sign;
}


__attribute__((__const__, __nothrow__)) static __inline pgno_t me2v(unsigned m,
                                                        unsigned e) {
  do { if ((0)) do { if (__builtin_expect(!!(!(m < 2048 && e < 8)), 0)) mdbx_assert_fail(
# 53 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 53 "/libmdbx/src/core.c"
 , "m < 2048 && e < 8", __func__, 53); } while (0); } while (0);
  return (pgno_t)(32768 + ((m + 1) << (e + 8)));
}

__attribute__((__const__, __nothrow__)) static __inline uint16_t v2me(size_t v,
                                                          unsigned e) {
  do { if ((0)) do { if (__builtin_expect(!!(!(v > (e ? me2v(2047, e - 1) : 32768))), 0)) mdbx_assert_fail(
# 59 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 59 "/libmdbx/src/core.c"
 , "v > (e ? me2v(2047, e - 1) : 32768)", __func__, 59); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(v <= me2v(2047, e))), 0)) mdbx_assert_fail(
# 60 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 60 "/libmdbx/src/core.c"
 , "v <= me2v(2047, e)", __func__, 60); } while (0); } while (0);
  size_t m = (v - 32768 + ((size_t)1 << (e + 8)) - 1) >> (e + 8);
  m -= m > 0;
  do { if ((0)) do { if (__builtin_expect(!!(!(m < 2048 && e < 8)), 0)) mdbx_assert_fail(
# 63 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 63 "/libmdbx/src/core.c"
 , "m < 2048 && e < 8", __func__, 63); } while (0); } while (0);


  const uint16_t pv = (uint16_t)(0x8001 + (e << 12) + (m << 1));
  do { if ((0)) do { if (__builtin_expect(!!(!(pv != 65535)), 0)) mdbx_assert_fail(
# 67 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 67 "/libmdbx/src/core.c"
 , "pv != 65535", __func__, 67); } while (0); } while (0);
  return pv;
}


__attribute__((__const__, __nothrow__)) static pgno_t pv2pages(uint16_t pv) {
  if ((pv & 0x8001) != 0x8001)
    return pv;
  if (pv == 65535)
    return 65536;


  return me2v((pv >> 1) & 2047, (pv >> 12) & 7);
}


__attribute__((__const__, __nothrow__)) static uint16_t pages2pv(size_t pages) {
  if (pages < 32769 || (pages < 65536 && (pages & 1) == 0))
    return (uint16_t)pages;
  if (pages <= me2v(2047, 0))
    return v2me(pages, 0);
  if (pages <= me2v(2047, 1))
    return v2me(pages, 1);
  if (pages <= me2v(2047, 2))
    return v2me(pages, 2);
  if (pages <= me2v(2047, 3))
    return v2me(pages, 3);
  if (pages <= me2v(2047, 4))
    return v2me(pages, 4);
  if (pages <= me2v(2047, 5))
    return v2me(pages, 5);
  if (pages <= me2v(2047, 6))
    return v2me(pages, 6);
  return (pages < me2v(2046, 7)) ? v2me(pages, 7) : 65533;
}




__attribute__((__unused__)) __attribute__((__const__, __nothrow__)) static 
# 106 "/libmdbx/src/core.c" 3 4
                                                    __inline __attribute__ ((__always_inline__)) 
# 106 "/libmdbx/src/core.c"
                                                                    unsigned
field_alignment(unsigned alignment_baseline, size_t field_offset) {
  unsigned merge = alignment_baseline | (unsigned)field_offset;
  return merge & -(int)merge;
}


__attribute__((__pure__, __nothrow__)) static 
# 113 "/libmdbx/src/core.c" 3 4
                                 __inline __attribute__ ((__always_inline__)) 
# 113 "/libmdbx/src/core.c"
                                                 uint8_t
peek_u8(const uint8_t *const __restrict ptr) {
  return *ptr;
}


static 
# 119 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 119 "/libmdbx/src/core.c"
                      void poke_u8(uint8_t *const __restrict ptr,
                                    const uint8_t v) {
  *ptr = v;
}

__attribute__((__pure__, __nothrow__)) static 
# 124 "/libmdbx/src/core.c" 3 4
                                 __inline __attribute__ ((__always_inline__)) 
# 124 "/libmdbx/src/core.c"
                                                 uint16_t
unaligned_peek_u16(const unsigned expected_alignment, const void *const ptr) {
  do { if ((0)) do { if (__builtin_expect(!!(!((uintptr_t)ptr % expected_alignment == 0)), 0)) mdbx_assert_fail(
# 126 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 126 "/libmdbx/src/core.c"
 , "(uintptr_t)ptr % expected_alignment == 0", __func__, 126); } while (0); } while (0);
  if (4 >= 2 || (expected_alignment % sizeof(uint16_t)) == 0)
    return *(const uint16_t *)ptr;
  else {




    uint16_t v;
    memcpy(&v, ptr, sizeof(v));
    return v;

  }
}

static 
# 141 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 141 "/libmdbx/src/core.c"
                      void
unaligned_poke_u16(const unsigned expected_alignment,
                   void *const __restrict ptr, const uint16_t v) {
  do { if ((0)) do { if (__builtin_expect(!!(!((uintptr_t)ptr % expected_alignment == 0)), 0)) mdbx_assert_fail(
# 144 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 144 "/libmdbx/src/core.c"
 , "(uintptr_t)ptr % expected_alignment == 0", __func__, 144); } while (0); } while (0);
  if (4 >= 2 || (expected_alignment % sizeof(v)) == 0)
    *(uint16_t *)ptr = v;
  else {




    memcpy(ptr, &v, sizeof(v));

  }
}

__attribute__((__pure__, __nothrow__)) static 
# 157 "/libmdbx/src/core.c" 3 4
                                 __inline __attribute__ ((__always_inline__)) 
# 157 "/libmdbx/src/core.c"
                                                 uint32_t unaligned_peek_u32(
    const unsigned expected_alignment, const void *const __restrict ptr) {
  do { if ((0)) do { if (__builtin_expect(!!(!((uintptr_t)ptr % expected_alignment == 0)), 0)) mdbx_assert_fail(
# 159 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 159 "/libmdbx/src/core.c"
 , "(uintptr_t)ptr % expected_alignment == 0", __func__, 159); } while (0); } while (0);
  if (4 >= 4 || (expected_alignment % sizeof(uint32_t)) == 0)
    return *(const uint32_t *)ptr;
  else if ((expected_alignment % sizeof(uint16_t)) == 0) {
    const uint16_t lo =
        ((const uint16_t *)ptr)[1234 != 1234];
    const uint16_t hi =
        ((const uint16_t *)ptr)[1234 == 1234];
    return lo | (uint32_t)hi << 16;
  } else {




    uint32_t v;
    memcpy(&v, ptr, sizeof(v));
    return v;

  }
}

static 
# 180 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 180 "/libmdbx/src/core.c"
                      void
unaligned_poke_u32(const unsigned expected_alignment,
                   void *const __restrict ptr, const uint32_t v) {
  do { if ((0)) do { if (__builtin_expect(!!(!((uintptr_t)ptr % expected_alignment == 0)), 0)) mdbx_assert_fail(
# 183 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 183 "/libmdbx/src/core.c"
 , "(uintptr_t)ptr % expected_alignment == 0", __func__, 183); } while (0); } while (0);
  if (4 >= 4 || (expected_alignment % sizeof(v)) == 0)
    *(uint32_t *)ptr = v;
  else if ((expected_alignment % sizeof(uint16_t)) == 0) {
    ((uint16_t *)ptr)[1234 != 1234] = (uint16_t)v;
    ((uint16_t *)ptr)[1234 == 1234] =
        (uint16_t)(v >> 16);
  } else {




    memcpy(ptr, &v, sizeof(v));

  }
}

__attribute__((__pure__, __nothrow__)) static 
# 200 "/libmdbx/src/core.c" 3 4
                                 __inline __attribute__ ((__always_inline__)) 
# 200 "/libmdbx/src/core.c"
                                                 uint64_t unaligned_peek_u64(
    const unsigned expected_alignment, const void *const __restrict ptr) {
  do { if ((0)) do { if (__builtin_expect(!!(!((uintptr_t)ptr % expected_alignment == 0)), 0)) mdbx_assert_fail(
# 202 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 202 "/libmdbx/src/core.c"
 , "(uintptr_t)ptr % expected_alignment == 0", __func__, 202); } while (0); } while (0);
  if (4 >= 8 || (expected_alignment % sizeof(uint64_t)) == 0)
    return *(const uint64_t *)ptr;
  else if ((expected_alignment % sizeof(uint32_t)) == 0) {
    const uint32_t lo =
        ((const uint32_t *)ptr)[1234 != 1234];
    const uint32_t hi =
        ((const uint32_t *)ptr)[1234 == 1234];
    return lo | (uint64_t)hi << 32;
  } else {




    uint64_t v;
    memcpy(&v, ptr, sizeof(v));
    return v;

  }
}

static 
# 223 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 223 "/libmdbx/src/core.c"
                      uint64_t
unaligned_peek_u64_volatile(const unsigned expected_alignment,
                            volatile const void *const __restrict ptr) {
  do { if ((0)) do { if (__builtin_expect(!!(!((uintptr_t)ptr % expected_alignment == 0)), 0)) mdbx_assert_fail(
# 226 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 226 "/libmdbx/src/core.c"
 , "(uintptr_t)ptr % expected_alignment == 0", __func__, 226); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(expected_alignment % sizeof(uint32_t) == 0)), 0)) mdbx_assert_fail(
# 227 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 227 "/libmdbx/src/core.c"
 , "expected_alignment % sizeof(uint32_t) == 0", __func__, 227); } while (0); } while (0);
  if (4 >= 8 || (expected_alignment % sizeof(uint64_t)) == 0)
    return *(volatile const uint64_t *)ptr;
  else {




    const uint32_t lo = ((volatile const uint32_t *)
                             ptr)[1234 != 1234];
    const uint32_t hi = ((volatile const uint32_t *)
                             ptr)[1234 == 1234];
    return lo | (uint64_t)hi << 32;

  }
}

static 
# 244 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 244 "/libmdbx/src/core.c"
                      void
unaligned_poke_u64(const unsigned expected_alignment,
                   void *const __restrict ptr, const uint64_t v) {
  do { if ((0)) do { if (__builtin_expect(!!(!((uintptr_t)ptr % expected_alignment == 0)), 0)) mdbx_assert_fail(
# 247 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 247 "/libmdbx/src/core.c"
 , "(uintptr_t)ptr % expected_alignment == 0", __func__, 247); } while (0); } while (0);
  if (4 >= 8 || (expected_alignment % sizeof(v)) == 0)
    *(uint64_t *)ptr = v;
  else if ((expected_alignment % sizeof(uint32_t)) == 0) {
    ((uint32_t *)ptr)[1234 != 1234] = (uint32_t)v;
    ((uint32_t *)ptr)[1234 == 1234] =
        (uint32_t)(v >> 32);
  } else {




    memcpy(ptr, &v, sizeof(v));

  }
}
# 285 "/libmdbx/src/core.c"
__attribute__((__pure__, __nothrow__)) static 
# 285 "/libmdbx/src/core.c" 3 4
                                 __inline __attribute__ ((__always_inline__)) 
# 285 "/libmdbx/src/core.c"
                                                 pgno_t
node_pgno(const MDBX_node *const __restrict node) {
  pgno_t pgno = unaligned_peek_u32(1, (const char *)(node) + 
# 287 "/libmdbx/src/core.c" 3 4
               __builtin_offsetof (
# 287 "/libmdbx/src/core.c"
               MDBX_node
# 287 "/libmdbx/src/core.c" 3 4
               , 
# 287 "/libmdbx/src/core.c"
               mn_pgno32
# 287 "/libmdbx/src/core.c" 3 4
               )
# 287 "/libmdbx/src/core.c"
               );
  if (sizeof(pgno) > 4)
    pgno |= ((uint64_t)peek_u8((const uint8_t *)(node) + 
# 289 "/libmdbx/src/core.c" 3 4
                      __builtin_offsetof (
# 289 "/libmdbx/src/core.c"
                      MDBX_node
# 289 "/libmdbx/src/core.c" 3 4
                      , 
# 289 "/libmdbx/src/core.c"
                      mn_extra
# 289 "/libmdbx/src/core.c" 3 4
                      )
# 289 "/libmdbx/src/core.c"
                      )) << 32;
  return pgno;
}


static 
# 294 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 294 "/libmdbx/src/core.c"
                      void node_set_pgno(MDBX_node *const __restrict node,
                                          pgno_t pgno) {
  do { if ((0)) do { if (__builtin_expect(!!(!(pgno >= 3 && pgno <= 0x7FFFffffU)), 0)) mdbx_assert_fail(
# 296 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 296 "/libmdbx/src/core.c"
 , "pgno >= 3 && pgno <= 0x7FFFffffU", __func__, 296); } while (0); } while (0);

  unaligned_poke_u32(1, (char *)(node) + 
# 298 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 298 "/libmdbx/src/core.c"
 MDBX_node
# 298 "/libmdbx/src/core.c" 3 4
 , 
# 298 "/libmdbx/src/core.c"
 mn_pgno32
# 298 "/libmdbx/src/core.c" 3 4
 )
# 298 "/libmdbx/src/core.c"
 , (uint32_t)pgno);
  if (sizeof(pgno) > 4)
    poke_u8((uint8_t *)(node) + 
# 300 "/libmdbx/src/core.c" 3 4
   __builtin_offsetof (
# 300 "/libmdbx/src/core.c"
   MDBX_node
# 300 "/libmdbx/src/core.c" 3 4
   , 
# 300 "/libmdbx/src/core.c"
   mn_extra
# 300 "/libmdbx/src/core.c" 3 4
   )
# 300 "/libmdbx/src/core.c"
   , (uint8_t)((uint64_t)pgno >> 32))
                                                     ;
}


__attribute__((__pure__, __nothrow__)) static 
# 305 "/libmdbx/src/core.c" 3 4
                                 __inline __attribute__ ((__always_inline__)) 
# 305 "/libmdbx/src/core.c"
                                                 size_t
node_ds(const MDBX_node *const __restrict node) {
  return unaligned_peek_u32(1, (const char *)(node) + 
# 307 "/libmdbx/src/core.c" 3 4
        __builtin_offsetof (
# 307 "/libmdbx/src/core.c"
        MDBX_node
# 307 "/libmdbx/src/core.c" 3 4
        , 
# 307 "/libmdbx/src/core.c"
        mn_dsize
# 307 "/libmdbx/src/core.c" 3 4
        )
# 307 "/libmdbx/src/core.c"
        );
}


static 
# 311 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 311 "/libmdbx/src/core.c"
                      void node_set_ds(MDBX_node *const __restrict node,
                                        size_t size) {
  do { if ((0)) do { if (__builtin_expect(!!(!(size < 0x7fffffff)), 0)) mdbx_assert_fail(
# 313 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 313 "/libmdbx/src/core.c"
 , "size < 0x7fffffff", __func__, 313); } while (0); } while (0);
  unaligned_poke_u32(1, (char *)(node) + 
# 314 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 314 "/libmdbx/src/core.c"
 MDBX_node
# 314 "/libmdbx/src/core.c" 3 4
 , 
# 314 "/libmdbx/src/core.c"
 mn_dsize
# 314 "/libmdbx/src/core.c" 3 4
 )
# 314 "/libmdbx/src/core.c"
 , (uint32_t)size);
}


__attribute__((__pure__, __nothrow__)) static 
# 318 "/libmdbx/src/core.c" 3 4
                                 __inline __attribute__ ((__always_inline__)) 
# 318 "/libmdbx/src/core.c"
                                                 size_t
node_ks(const MDBX_node *const __restrict node) {
  return unaligned_peek_u16(1, (const char *)(node) + 
# 320 "/libmdbx/src/core.c" 3 4
        __builtin_offsetof (
# 320 "/libmdbx/src/core.c"
        MDBX_node
# 320 "/libmdbx/src/core.c" 3 4
        , 
# 320 "/libmdbx/src/core.c"
        mn_ksize
# 320 "/libmdbx/src/core.c" 3 4
        )
# 320 "/libmdbx/src/core.c"
        );
}


static 
# 324 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 324 "/libmdbx/src/core.c"
                      void node_set_ks(MDBX_node *const __restrict node,
                                        size_t size) {
  do { if ((0)) do { if (__builtin_expect(!!(!(size < 
# 326 "/libmdbx/src/core.c" 3 4
 (32767)
# 326 "/libmdbx/src/core.c"
 )), 0)) mdbx_assert_fail(
# 326 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 326 "/libmdbx/src/core.c"
 , "size < (32767)", __func__, 326); } while (0); } while (0);
  unaligned_poke_u16(1, (char *)(node) + 
# 327 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 327 "/libmdbx/src/core.c"
 MDBX_node
# 327 "/libmdbx/src/core.c" 3 4
 , 
# 327 "/libmdbx/src/core.c"
 mn_ksize
# 327 "/libmdbx/src/core.c" 3 4
 )
# 327 "/libmdbx/src/core.c"
 , (uint16_t)size);
}

__attribute__((__pure__, __nothrow__)) static 
# 330 "/libmdbx/src/core.c" 3 4
                                 __inline __attribute__ ((__always_inline__)) 
# 330 "/libmdbx/src/core.c"
                                                 uint8_t
node_flags(const MDBX_node *const __restrict node) {
  return peek_u8((const uint8_t *)(node) + 
# 332 "/libmdbx/src/core.c" 3 4
        __builtin_offsetof (
# 332 "/libmdbx/src/core.c"
        MDBX_node
# 332 "/libmdbx/src/core.c" 3 4
        , 
# 332 "/libmdbx/src/core.c"
        mn_flags
# 332 "/libmdbx/src/core.c" 3 4
        )
# 332 "/libmdbx/src/core.c"
        );
}

static 
# 335 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 335 "/libmdbx/src/core.c"
                      void node_set_flags(MDBX_node *const __restrict node,
                                           uint8_t flags) {
  poke_u8((uint8_t *)(node) + 
# 337 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 337 "/libmdbx/src/core.c"
 MDBX_node
# 337 "/libmdbx/src/core.c" 3 4
 , 
# 337 "/libmdbx/src/core.c"
 mn_flags
# 337 "/libmdbx/src/core.c" 3 4
 )
# 337 "/libmdbx/src/core.c"
 , flags);
}





__attribute__((__pure__, __nothrow__)) static 
# 344 "/libmdbx/src/core.c" 3 4
                                 __inline __attribute__ ((__always_inline__)) 
# 344 "/libmdbx/src/core.c"
                                                 void *
node_key(const MDBX_node *const __restrict node) {
  return (char *)node + 
# 346 "/libmdbx/src/core.c" 3 4
                       __builtin_offsetof (
# 346 "/libmdbx/src/core.c"
                       MDBX_node
# 346 "/libmdbx/src/core.c" 3 4
                       , 
# 346 "/libmdbx/src/core.c"
                       mn_data
# 346 "/libmdbx/src/core.c" 3 4
                       )
# 346 "/libmdbx/src/core.c"
                               ;
}


__attribute__((__pure__, __nothrow__)) static 
# 350 "/libmdbx/src/core.c" 3 4
                                 __inline __attribute__ ((__always_inline__)) 
# 350 "/libmdbx/src/core.c"
                                                 void *
node_data(const MDBX_node *const __restrict node) {
  return (char *)node_key(node) + node_ks(node);
}



__attribute__((__const__, __nothrow__)) static 
# 357 "/libmdbx/src/core.c" 3 4
                                  __inline __attribute__ ((__always_inline__)) 
# 357 "/libmdbx/src/core.c"
                                                  size_t
node_size_len(const size_t key_len, const size_t value_len) {
  return 
# 359 "/libmdbx/src/core.c" 3 4
        __builtin_offsetof (
# 359 "/libmdbx/src/core.c"
        MDBX_node
# 359 "/libmdbx/src/core.c" 3 4
        , 
# 359 "/libmdbx/src/core.c"
        mn_data
# 359 "/libmdbx/src/core.c" 3 4
        ) 
# 359 "/libmdbx/src/core.c"
                 + (((key_len + value_len) + 1U) & -2);
}
__attribute__((__pure__, __nothrow__)) static 
# 361 "/libmdbx/src/core.c" 3 4
                                 __inline __attribute__ ((__always_inline__)) 
# 361 "/libmdbx/src/core.c"
                                                 size_t
node_size(const MDBX_val *key, const MDBX_val *value) {
  return node_size_len(key ? key->iov_len : 0, value ? value->iov_len : 0);
}

__attribute__((__pure__, __nothrow__)) static 
# 366 "/libmdbx/src/core.c" 3 4
                                 __inline __attribute__ ((__always_inline__)) 
# 366 "/libmdbx/src/core.c"
                                                 pgno_t
peek_pgno(const void *const __restrict ptr) {
  if (sizeof(pgno_t) == sizeof(uint32_t))
    return (pgno_t)unaligned_peek_u32(1, ptr);
  else if (sizeof(pgno_t) == sizeof(uint64_t))
    return (pgno_t)unaligned_peek_u64(1, ptr);
  else {
    pgno_t pgno;
    memcpy(&pgno, ptr, sizeof(pgno));
    return pgno;
  }
}

static 
# 379 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 379 "/libmdbx/src/core.c"
                      void poke_pgno(void *const __restrict ptr,
                                      const pgno_t pgno) {
  if (sizeof(pgno) == sizeof(uint32_t))
    unaligned_poke_u32(1, ptr, pgno);
  else if (sizeof(pgno) == sizeof(uint64_t))
    unaligned_poke_u64(1, ptr, pgno);
  else
    memcpy(ptr, &pgno, sizeof(pgno));
}

__attribute__((__pure__, __nothrow__)) static 
# 389 "/libmdbx/src/core.c" 3 4
                                 __inline __attribute__ ((__always_inline__)) 
# 389 "/libmdbx/src/core.c"
                                                 pgno_t
node_largedata_pgno(const MDBX_node *const __restrict node) {
  do { if ((0)) do { if (__builtin_expect(!!(!(node_flags(node) & 0x01)), 0)) mdbx_assert_fail(
# 391 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 391 "/libmdbx/src/core.c"
 , "node_flags(node) & 0x01", __func__, 391); } while (0); } while (0);
  return peek_pgno(node_data(node));
}
# 442 "/libmdbx/src/core.c"
static __inline unsigned keysize_max(size_t pagesize, MDBX_db_flags_t flags) {
  do { if ((0)) do { if (__builtin_expect(!!(!(pagesize >= MDBX_MIN_PAGESIZE && pagesize <= MDBX_MAX_PAGESIZE && is_powerof2(pagesize))), 0)) mdbx_assert_fail(
# 443 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 443 "/libmdbx/src/core.c"
 , "pagesize >= MDBX_MIN_PAGESIZE && pagesize <= MDBX_MAX_PAGESIZE && is_powerof2(pagesize)", __func__, 443); } while (0); } while (0)
                               ;
  _Static_assert(((((((MDBX_MIN_PAGESIZE)-((unsigned)
# 445 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 445 "/libmdbx/src/core.c"
 MDBX_page
# 445 "/libmdbx/src/core.c" 3 4
 , 
# 445 "/libmdbx/src/core.c"
 mp_ptrs
# 445 "/libmdbx/src/core.c" 3 4
 )
# 445 "/libmdbx/src/core.c"
 )) - sizeof(indx_t) - 
# 445 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 445 "/libmdbx/src/core.c"
 MDBX_node
# 445 "/libmdbx/src/core.c" 3 4
 , 
# 445 "/libmdbx/src/core.c"
 mn_data
# 445 "/libmdbx/src/core.c" 3 4
 )
# 445 "/libmdbx/src/core.c"
 ) / (3 - 1) - sizeof(indx_t)) & ~(size_t)1)) - 
# 445 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 445 "/libmdbx/src/core.c"
 MDBX_node
# 445 "/libmdbx/src/core.c" 3 4
 , 
# 445 "/libmdbx/src/core.c"
 mn_data
# 445 "/libmdbx/src/core.c" 3 4
 ) 
# 445 "/libmdbx/src/core.c"
 >= 8, "BRANCH_NODE_MAX(MIN_PAGESIZE) - NODESIZE >= 8");
  if (flags & MDBX_INTEGERKEY)
    return 8 ;

  const intptr_t max_branch_key = ((((((pagesize)-((unsigned)
# 449 "/libmdbx/src/core.c" 3 4
                                 __builtin_offsetof (
# 449 "/libmdbx/src/core.c"
                                 MDBX_page
# 449 "/libmdbx/src/core.c" 3 4
                                 , 
# 449 "/libmdbx/src/core.c"
                                 mp_ptrs
# 449 "/libmdbx/src/core.c" 3 4
                                 )
# 449 "/libmdbx/src/core.c"
                                 )) - sizeof(indx_t) - 
# 449 "/libmdbx/src/core.c" 3 4
                                 __builtin_offsetof (
# 449 "/libmdbx/src/core.c"
                                 MDBX_node
# 449 "/libmdbx/src/core.c" 3 4
                                 , 
# 449 "/libmdbx/src/core.c"
                                 mn_data
# 449 "/libmdbx/src/core.c" 3 4
                                 )
# 449 "/libmdbx/src/core.c"
                                 ) / (3 - 1) - sizeof(indx_t)) & ~(size_t)1)) - 
# 449 "/libmdbx/src/core.c" 3 4
                                                             __builtin_offsetof (
# 449 "/libmdbx/src/core.c"
                                                             MDBX_node
# 449 "/libmdbx/src/core.c" 3 4
                                                             , 
# 449 "/libmdbx/src/core.c"
                                                             mn_data
# 449 "/libmdbx/src/core.c" 3 4
                                                             )
# 449 "/libmdbx/src/core.c"
                                                                     ;
  _Static_assert((((((MDBX_MIN_PAGESIZE)-((unsigned)
# 450 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 450 "/libmdbx/src/core.c"
 MDBX_page
# 450 "/libmdbx/src/core.c" 3 4
 , 
# 450 "/libmdbx/src/core.c"
 mp_ptrs
# 450 "/libmdbx/src/core.c" 3 4
 )
# 450 "/libmdbx/src/core.c"
 )) / 2) & ~(size_t)1) - sizeof(indx_t)) - 
# 450 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 450 "/libmdbx/src/core.c"
 MDBX_node
# 450 "/libmdbx/src/core.c" 3 4
 , 
# 450 "/libmdbx/src/core.c"
 mn_data
# 450 "/libmdbx/src/core.c" 3 4
 ) 
# 450 "/libmdbx/src/core.c"
 - 8 > sizeof(MDBX_db), "LEAF_NODE_MAX(MIN_PAGESIZE) - NODESIZE - 8 > sizeof(MDBX_db)")

                                ;
  if (flags &
      (MDBX_DUPSORT | MDBX_DUPFIXED | MDBX_REVERSEDUP | MDBX_INTEGERDUP)) {
    const intptr_t max_dupsort_leaf_key =
        (((((pagesize)-((unsigned)
# 456 "/libmdbx/src/core.c" 3 4
       __builtin_offsetof (
# 456 "/libmdbx/src/core.c"
       MDBX_page
# 456 "/libmdbx/src/core.c" 3 4
       , 
# 456 "/libmdbx/src/core.c"
       mp_ptrs
# 456 "/libmdbx/src/core.c" 3 4
       )
# 456 "/libmdbx/src/core.c"
       )) / 2) & ~(size_t)1) - sizeof(indx_t)) - 
# 456 "/libmdbx/src/core.c" 3 4
                                 __builtin_offsetof (
# 456 "/libmdbx/src/core.c"
                                 MDBX_node
# 456 "/libmdbx/src/core.c" 3 4
                                 , 
# 456 "/libmdbx/src/core.c"
                                 mn_data
# 456 "/libmdbx/src/core.c" 3 4
                                 ) 
# 456 "/libmdbx/src/core.c"
                                          - sizeof(MDBX_db);
    return (max_branch_key < max_dupsort_leaf_key)
               ? (unsigned)max_branch_key
               : (unsigned)max_dupsort_leaf_key;
  }
  return (unsigned)max_branch_key;
}

static __inline size_t valsize_max(size_t pagesize, MDBX_db_flags_t flags) {
  do { if ((0)) do { if (__builtin_expect(!!(!(pagesize >= MDBX_MIN_PAGESIZE && pagesize <= MDBX_MAX_PAGESIZE && is_powerof2(pagesize))), 0)) mdbx_assert_fail(
# 465 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 465 "/libmdbx/src/core.c"
 , "pagesize >= MDBX_MIN_PAGESIZE && pagesize <= MDBX_MAX_PAGESIZE && is_powerof2(pagesize)", __func__, 465); } while (0); } while (0)
                               ;

  if (flags & MDBX_INTEGERDUP)
    return 8 ;

  if (flags & (MDBX_DUPSORT | MDBX_DUPFIXED | MDBX_REVERSEDUP))
    return keysize_max(pagesize, 0);

  const unsigned page_ln2 = log2n_powerof2(pagesize);
  const size_t hard = 0x7FF00000ul;
  const size_t hard_pages = hard >> page_ln2;
  _Static_assert(((size_t)0x7FFFffffU) <= 0x7FFFffffU, "MDBX_PGL_LIMIT <= MAX_PAGENO");
  const size_t pages_limit = ((size_t)0x7FFFffffU) / 4;
  const size_t limit =
      (hard_pages < pages_limit) ? hard : (pages_limit << page_ln2);
  return (limit < ((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE) / 2) ? limit : ((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE) / 2;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_get_maxkeysize(const MDBX_env *env) {
  return mdbx_env_get_maxkeysize_ex(env, MDBX_DUPSORT);
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_get_maxkeysize_ex(const MDBX_env *env,
                                      MDBX_db_flags_t flags) {
  if (__builtin_expect(!!(!env || env->me_signature.weak != 0x9A899641U), 0))
    return -1;

  return (int)mdbx_limits_keysize_max((intptr_t)env->me_psize, flags);
}

size_t mdbx_default_pagesize(void) {
  size_t pagesize = mdbx_syspagesize();
  do { if (__builtin_expect(!!(!(is_powerof2(pagesize))), 0)) mdbx_assert_fail(
# 498 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 498 "/libmdbx/src/core.c"
 , "is_powerof2(pagesize)", __func__, 498); } while (0);
  pagesize = (pagesize >= MDBX_MIN_PAGESIZE) ? pagesize : MDBX_MIN_PAGESIZE;
  pagesize = (pagesize <= MDBX_MAX_PAGESIZE) ? pagesize : MDBX_MAX_PAGESIZE;
  return pagesize;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) intptr_t mdbx_limits_keysize_max(intptr_t pagesize,
                                        MDBX_db_flags_t flags) {
  if (pagesize < 1)
    pagesize = (intptr_t)mdbx_default_pagesize();
  if (__builtin_expect(!!(pagesize < (intptr_t)MDBX_MIN_PAGESIZE || pagesize > (intptr_t)MDBX_MAX_PAGESIZE || !is_powerof2((size_t)pagesize)), 0)

                                              )
    return -1;

  return keysize_max(pagesize, flags);
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_get_maxvalsize_ex(const MDBX_env *env,
                                      MDBX_db_flags_t flags) {
  if (__builtin_expect(!!(!env || env->me_signature.weak != 0x9A899641U), 0))
    return -1;

  return (int)mdbx_limits_valsize_max((intptr_t)env->me_psize, flags);
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) intptr_t mdbx_limits_valsize_max(intptr_t pagesize,
                                        MDBX_db_flags_t flags) {
  if (pagesize < 1)
    pagesize = (intptr_t)mdbx_default_pagesize();
  if (__builtin_expect(!!(pagesize < (intptr_t)MDBX_MIN_PAGESIZE || pagesize > (intptr_t)MDBX_MAX_PAGESIZE || !is_powerof2((size_t)pagesize)), 0)

                                              )
    return -1;

  return valsize_max(pagesize, flags);
}
# 543 "/libmdbx/src/core.c"
__attribute__((__pure__, __nothrow__)) static 
# 543 "/libmdbx/src/core.c" 3 4
                                 __inline __attribute__ ((__always_inline__)) 
# 543 "/libmdbx/src/core.c"
                                                 size_t
leaf_size(const MDBX_env *env, const MDBX_val *key, const MDBX_val *data) {
  size_t node_bytes = node_size(key, data);
  if (node_bytes > env->me_leaf_nodemax) {

    node_bytes = node_size_len(key->iov_len, 0) + sizeof(pgno_t);
  }

  return node_bytes + sizeof(indx_t);
}
# 566 "/libmdbx/src/core.c"
__attribute__((__pure__, __nothrow__)) static 
# 566 "/libmdbx/src/core.c" 3 4
                                 __inline __attribute__ ((__always_inline__)) 
# 566 "/libmdbx/src/core.c"
                                                 size_t
branch_size(const MDBX_env *env, const MDBX_val *key) {


  size_t node_bytes = node_size(key, 
# 570 "/libmdbx/src/core.c" 3 4
                                    ((void *)0)
# 570 "/libmdbx/src/core.c"
                                           );
  if (__builtin_expect(!!(node_bytes > env->me_leaf_nodemax), 0)) {


    mdbx_assert_fail(env, "INDXSIZE(key) <= env->me_nodemax", __func__,
                     575);
    node_bytes = node_size(key, 
# 576 "/libmdbx/src/core.c" 3 4
                               ((void *)0)
# 576 "/libmdbx/src/core.c"
                                      ) + sizeof(pgno_t);
  }

  return node_bytes + sizeof(indx_t);
}

__attribute__((__const__, __nothrow__)) static 
# 582 "/libmdbx/src/core.c" 3 4
                                  __inline __attribute__ ((__always_inline__)) 
# 582 "/libmdbx/src/core.c"
                                                  uint16_t
flags_db2sub(uint16_t db_flags) {
  uint16_t sub_flags = db_flags & MDBX_DUPFIXED;



  _Static_assert((MDBX_INTEGERDUP >> 2) == MDBX_INTEGERKEY, "(MDBX_INTEGERDUP >> SHIFT_INTEGERDUP_TO_INTEGERKEY) == MDBX_INTEGERKEY")
                                ;
  sub_flags |= (db_flags & MDBX_INTEGERDUP) >> 2;



  _Static_assert((MDBX_REVERSEDUP >> 5) == MDBX_REVERSEKEY, "(MDBX_REVERSEDUP >> SHIFT_REVERSEDUP_TO_REVERSEKEY) == MDBX_REVERSEKEY")
                                ;
  sub_flags |= (db_flags & MDBX_REVERSEDUP) >> 5;

  return sub_flags;
}



__attribute__((__pure__, __nothrow__)) static 
# 603 "/libmdbx/src/core.c" 3 4
                                 __inline __attribute__ ((__always_inline__)) 
# 603 "/libmdbx/src/core.c"
                                                 size_t
pgno2bytes(const MDBX_env *env, pgno_t pgno) {
  do { if ((0)) do { if (__builtin_expect(!!(!((1u << env->me_psize2log) == env->me_psize)), 0)) mdbx_assert_fail(env, "(1u << env->me_psize2log) == env->me_psize", __func__, 605); } while (0); } while (0);
  return ((size_t)pgno) << env->me_psize2log;
}

__attribute__((__pure__, __nothrow__)) static 
# 609 "/libmdbx/src/core.c" 3 4
                                 __inline __attribute__ ((__always_inline__)) 
# 609 "/libmdbx/src/core.c"
                                                 MDBX_page *
pgno2page(const MDBX_env *env, pgno_t pgno) {
  return (MDBX_page *)(env->me_dxb_mmap.dxb + pgno2bytes(env, pgno));
}

__attribute__((__pure__, __nothrow__)) static 
# 614 "/libmdbx/src/core.c" 3 4
                                 __inline __attribute__ ((__always_inline__)) 
# 614 "/libmdbx/src/core.c"
                                                 pgno_t
bytes2pgno(const MDBX_env *env, size_t bytes) {
  do { if ((0)) do { if (__builtin_expect(!!(!((env->me_psize >> env->me_psize2log) == 1)), 0)) mdbx_assert_fail(env, "(env->me_psize >> env->me_psize2log) == 1", __func__, 616); } while (0); } while (0);
  return (pgno_t)(bytes >> env->me_psize2log);
}

__attribute__((__pure__, __nothrow__)) static size_t
pgno_align2os_bytes(const MDBX_env *env, pgno_t pgno) {
  return ceil_powerof2(pgno2bytes(env, pgno), env->me_os_psize);
}

__attribute__((__pure__, __nothrow__)) static pgno_t pgno_align2os_pgno(const MDBX_env *env,
                                                            pgno_t pgno) {
  return bytes2pgno(env, pgno_align2os_bytes(env, pgno));
}

__attribute__((__pure__, __nothrow__)) static size_t
bytes_align2os_bytes(const MDBX_env *env, size_t bytes) {
  return ceil_powerof2(ceil_powerof2(bytes, env->me_psize), env->me_os_psize);
}


__attribute__((__pure__, __nothrow__)) static 
# 636 "/libmdbx/src/core.c" 3 4
                                 __inline __attribute__ ((__always_inline__)) 
# 636 "/libmdbx/src/core.c"
                                                 void *
page_data(const MDBX_page *mp) {
  return (char *)mp + ((unsigned)
# 638 "/libmdbx/src/core.c" 3 4
                     __builtin_offsetof (
# 638 "/libmdbx/src/core.c"
                     MDBX_page
# 638 "/libmdbx/src/core.c" 3 4
                     , 
# 638 "/libmdbx/src/core.c"
                     mp_ptrs
# 638 "/libmdbx/src/core.c" 3 4
                     )
# 638 "/libmdbx/src/core.c"
                     );
}

__attribute__((__pure__, __nothrow__)) static 
# 641 "/libmdbx/src/core.c" 3 4
                                 __inline __attribute__ ((__always_inline__)) 
# 641 "/libmdbx/src/core.c"
                                                 const MDBX_page *
data_page(const void *data) {
  return ((MDBX_page *)((char *)(data) - 
# 643 "/libmdbx/src/core.c" 3 4
        __builtin_offsetof (
# 643 "/libmdbx/src/core.c"
        MDBX_page
# 643 "/libmdbx/src/core.c" 3 4
        , 
# 643 "/libmdbx/src/core.c"
        mp_ptrs
# 643 "/libmdbx/src/core.c" 3 4
        )
# 643 "/libmdbx/src/core.c"
        ));
}

__attribute__((__pure__, __nothrow__)) static 
# 646 "/libmdbx/src/core.c" 3 4
                                 __inline __attribute__ ((__always_inline__)) 
# 646 "/libmdbx/src/core.c"
                                                 MDBX_meta *
page_meta(MDBX_page *mp) {
  return (MDBX_meta *)page_data(mp);
}


__attribute__((__pure__, __nothrow__)) static 
# 652 "/libmdbx/src/core.c" 3 4
                                 __inline __attribute__ ((__always_inline__)) 
# 652 "/libmdbx/src/core.c"
                                                 unsigned
page_numkeys(const MDBX_page *mp) {
  return mp->mp_lower >> 1;
}


__attribute__((__pure__, __nothrow__)) static 
# 658 "/libmdbx/src/core.c" 3 4
                                 __inline __attribute__ ((__always_inline__)) 
# 658 "/libmdbx/src/core.c"
                                                 unsigned
page_room(const MDBX_page *mp) {
  return mp->mp_upper - mp->mp_lower;
}

__attribute__((__pure__, __nothrow__)) static 
# 663 "/libmdbx/src/core.c" 3 4
                                 __inline __attribute__ ((__always_inline__)) 
# 663 "/libmdbx/src/core.c"
                                                 unsigned
page_space(const MDBX_env *env) {
  _Static_assert(((unsigned)
# 665 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 665 "/libmdbx/src/core.c"
 MDBX_page
# 665 "/libmdbx/src/core.c" 3 4
 , 
# 665 "/libmdbx/src/core.c"
 mp_ptrs
# 665 "/libmdbx/src/core.c" 3 4
 )
# 665 "/libmdbx/src/core.c"
 ) % 2 == 0, "PAGEHDRSZ % 2 == 0");
  return env->me_psize - ((unsigned)
# 666 "/libmdbx/src/core.c" 3 4
                        __builtin_offsetof (
# 666 "/libmdbx/src/core.c"
                        MDBX_page
# 666 "/libmdbx/src/core.c" 3 4
                        , 
# 666 "/libmdbx/src/core.c"
                        mp_ptrs
# 666 "/libmdbx/src/core.c" 3 4
                        )
# 666 "/libmdbx/src/core.c"
                        );
}

__attribute__((__pure__, __nothrow__)) static 
# 669 "/libmdbx/src/core.c" 3 4
                                 __inline __attribute__ ((__always_inline__)) 
# 669 "/libmdbx/src/core.c"
                                                 unsigned
page_used(const MDBX_env *env, const MDBX_page *mp) {
  return page_space(env) - page_room(mp);
}


__attribute__((__unused__)) __attribute__((__pure__, __nothrow__)) static __inline double
page_fill(const MDBX_env *env, const MDBX_page *mp) {
  return page_used(env, mp) * 100.0 / page_space(env);
}


__attribute__((__pure__, __nothrow__)) static 
# 681 "/libmdbx/src/core.c" 3 4
                                 __inline __attribute__ ((__always_inline__)) 
# 681 "/libmdbx/src/core.c"
                                                 pgno_t
number_of_ovpages(const MDBX_env *env, size_t bytes) {
  return bytes2pgno(env, ((unsigned)
# 683 "/libmdbx/src/core.c" 3 4
                        __builtin_offsetof (
# 683 "/libmdbx/src/core.c"
                        MDBX_page
# 683 "/libmdbx/src/core.c" 3 4
                        , 
# 683 "/libmdbx/src/core.c"
                        mp_ptrs
# 683 "/libmdbx/src/core.c" 3 4
                        )
# 683 "/libmdbx/src/core.c"
                        ) - 1 + bytes) + 1;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static int __attribute__((__format__(__printf__, 2, 3)))
    bad_page(const MDBX_page *mp, const char *fmt, ...) {
  if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) {
    static const MDBX_page *prev;
    if (prev != mp) {
      prev = mp;
      const char *type;
      switch (mp->mp_flags & (0x01 | 0x02 | 0x04 | 0x08 |
                              0x20 | 0x10 | 0x40)) {
      case 0x01:
        type = "branch";
        break;
      case 0x02:
        type = "leaf";
        break;
      case 0x02 | 0x40:
        type = "subleaf";
        break;
      case 0x02 | 0x20:
        type = "dupfixed-leaf";
        break;
      case 0x02 | 0x20 | 0x40:
        type = "dupfixed-subleaf";
        break;
      case 0x04:
        type = "large";
        break;
      default:
        type = "broken";
      }
      mdbx_debug_log(MDBX_LOG_ERROR, "badpage", 0,
                     "corrupted %s-page #%u, mod-txnid %" 
# 717 "/libmdbx/src/core.c" 3 4
                                                         "l" "i" 
# 717 "/libmdbx/src/core.c"
                                                                 "\n", type,
                     mp->mp_pgno, mp->mp_txnid);
    }

    va_list args;
    
# 722 "/libmdbx/src/core.c" 3 4
   __builtin_va_start(
# 722 "/libmdbx/src/core.c"
   args
# 722 "/libmdbx/src/core.c" 3 4
   ,
# 722 "/libmdbx/src/core.c"
   fmt
# 722 "/libmdbx/src/core.c" 3 4
   )
# 722 "/libmdbx/src/core.c"
                      ;
    mdbx_debug_log_va(MDBX_LOG_ERROR, "badpage", 0, fmt, args);
    
# 724 "/libmdbx/src/core.c" 3 4
   __builtin_va_end(
# 724 "/libmdbx/src/core.c"
   args
# 724 "/libmdbx/src/core.c" 3 4
   )
# 724 "/libmdbx/src/core.c"
               ;
  }
  return MDBX_CORRUPTED;
}


__attribute__((__pure__, __nothrow__)) static 
# 730 "/libmdbx/src/core.c" 3 4
                                 __inline __attribute__ ((__always_inline__)) 
# 730 "/libmdbx/src/core.c"
                                                 MDBX_node *
page_node(const MDBX_page *mp, unsigned i) {
  do { if ((0)) do { if (__builtin_expect(!!(!((mp->mp_flags & (0x20 | 0x04 | 0x08)) == 0)), 0)) mdbx_assert_fail(
# 732 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 732 "/libmdbx/src/core.c"
 , "(mp->mp_flags & (0x20 | 0x04 | 0x08)) == 0", __func__, 732); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(page_numkeys(mp) > (unsigned)(i))), 0)) mdbx_assert_fail(
# 733 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 733 "/libmdbx/src/core.c"
 , "page_numkeys(mp) > (unsigned)(i)", __func__, 733); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(mp->mp_ptrs[i] % 2 == 0)), 0)) mdbx_assert_fail(
# 734 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 734 "/libmdbx/src/core.c"
 , "mp->mp_ptrs[i] % 2 == 0", __func__, 734); } while (0); } while (0);
  return (MDBX_node *)((char *)mp + mp->mp_ptrs[i] + ((unsigned)
# 735 "/libmdbx/src/core.c" 3 4
                                                    __builtin_offsetof (
# 735 "/libmdbx/src/core.c"
                                                    MDBX_page
# 735 "/libmdbx/src/core.c" 3 4
                                                    , 
# 735 "/libmdbx/src/core.c"
                                                    mp_ptrs
# 735 "/libmdbx/src/core.c" 3 4
                                                    )
# 735 "/libmdbx/src/core.c"
                                                    ));
}




__attribute__((__pure__, __nothrow__)) static 
# 741 "/libmdbx/src/core.c" 3 4
                                 __inline __attribute__ ((__always_inline__)) 
# 741 "/libmdbx/src/core.c"
                                                 void *
page_leaf2key(const MDBX_page *mp, unsigned i, size_t keysize) {
  do { if ((0)) do { if (__builtin_expect(!!(!((mp->mp_flags & (0x01 | 0x02 | 0x20 | 0x04 | 0x08)) == (0x02 | 0x20))), 0)) mdbx_assert_fail(
# 743 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 743 "/libmdbx/src/core.c"
 , "(mp->mp_flags & (0x01 | 0x02 | 0x20 | 0x04 | 0x08)) == (0x02 | 0x20)", __func__, 743); } while (0); } while (0)
                            ;
  do { if ((0)) do { if (__builtin_expect(!!(!(mp->mp_leaf2_ksize == keysize)), 0)) mdbx_assert_fail(
# 745 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 745 "/libmdbx/src/core.c"
 , "mp->mp_leaf2_ksize == keysize", __func__, 745); } while (0); } while (0);
  (void)keysize;
  return (char *)mp + ((unsigned)
# 747 "/libmdbx/src/core.c" 3 4
                     __builtin_offsetof (
# 747 "/libmdbx/src/core.c"
                     MDBX_page
# 747 "/libmdbx/src/core.c" 3 4
                     , 
# 747 "/libmdbx/src/core.c"
                     mp_ptrs
# 747 "/libmdbx/src/core.c" 3 4
                     )
# 747 "/libmdbx/src/core.c"
                     ) + (i * mp->mp_leaf2_ksize);
}


static 
# 751 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 751 "/libmdbx/src/core.c"
                      void get_key(const MDBX_node *node, MDBX_val *keyptr) {
  keyptr->iov_len = node_ks(node);
  keyptr->iov_base = node_key(node);
}


static 
# 757 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 757 "/libmdbx/src/core.c"
                      void
get_key_optional(const MDBX_node *node, MDBX_val *keyptr ) {
  if (keyptr)
    get_key(node, keyptr);
}
# 880 "/libmdbx/src/core.c"
__attribute__((__unused__)) static 
# 880 "/libmdbx/src/core.c" 3 4
                        __inline __attribute__ ((__always_inline__)) 
# 880 "/libmdbx/src/core.c"
                                        uint64_t
atomic_store64(MDBX_atomic_uint64_t *p, const uint64_t value,
               enum MDBX_memory_order order) {
  _Static_assert(sizeof(MDBX_atomic_uint64_t) == 8, "sizeof(MDBX_atomic_uint64_t) == 8");


  do { if ((0)) do { if (__builtin_expect(!!(!(
# 886 "/libmdbx/src/core.c" 3 4
 __atomic_is_lock_free (sizeof (*(
# 886 "/libmdbx/src/core.c"
 (&(p)->c11a)
# 886 "/libmdbx/src/core.c" 3 4
 )), (
# 886 "/libmdbx/src/core.c"
 (&(p)->c11a)
# 886 "/libmdbx/src/core.c" 3 4
 ))
# 886 "/libmdbx/src/core.c"
 )), 0)) mdbx_assert_fail(
# 886 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 886 "/libmdbx/src/core.c"
 , "__atomic_is_lock_free (sizeof (*((&(p)->c11a))), ((&(p)->c11a)))", __func__, 886); } while (0); } while (0);
  
# 887 "/libmdbx/src/core.c" 3 4
 __extension__ ({ __auto_type __atomic_store_ptr = (
# 887 "/libmdbx/src/core.c"
 (&(p)->c11a)
# 887 "/libmdbx/src/core.c" 3 4
 ); __typeof__ ((void)0, *__atomic_store_ptr) __atomic_store_tmp = (
# 887 "/libmdbx/src/core.c"
 value
# 887 "/libmdbx/src/core.c" 3 4
 ); __atomic_store (__atomic_store_ptr, &__atomic_store_tmp, (
# 887 "/libmdbx/src/core.c"
 mo_c11_store(order)
# 887 "/libmdbx/src/core.c" 3 4
 )); })
# 887 "/libmdbx/src/core.c"
                                                                             ;
# 901 "/libmdbx/src/core.c"
  return value;
}

__attribute__((__unused__)) static

    
# 906 "/libmdbx/src/core.c" 3 4
   __inline __attribute__ ((__always_inline__))

        
# 908 "/libmdbx/src/core.c"
       uint64_t
        atomic_load64(const MDBX_atomic_uint64_t *p,
                      enum MDBX_memory_order order) {
  _Static_assert(sizeof(MDBX_atomic_uint64_t) == 8, "sizeof(MDBX_atomic_uint64_t) == 8");


  do { if ((0)) do { if (__builtin_expect(!!(!(
# 914 "/libmdbx/src/core.c" 3 4
 __atomic_is_lock_free (sizeof (*(
# 914 "/libmdbx/src/core.c"
 (&(p)->c11a)
# 914 "/libmdbx/src/core.c" 3 4
 )), (
# 914 "/libmdbx/src/core.c"
 (&(p)->c11a)
# 914 "/libmdbx/src/core.c" 3 4
 ))
# 914 "/libmdbx/src/core.c"
 )), 0)) mdbx_assert_fail(
# 914 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 914 "/libmdbx/src/core.c"
 , "__atomic_is_lock_free (sizeof (*((&(p)->c11a))), ((&(p)->c11a)))", __func__, 914); } while (0); } while (0);
  return 
# 915 "/libmdbx/src/core.c" 3 4
        __extension__ ({ __auto_type __atomic_load_ptr = (
# 915 "/libmdbx/src/core.c"
        (&(p)->c11a)
# 915 "/libmdbx/src/core.c" 3 4
        ); __typeof__ ((void)0, *__atomic_load_ptr) __atomic_load_tmp; __atomic_load (__atomic_load_ptr, &__atomic_load_tmp, (
# 915 "/libmdbx/src/core.c"
        mo_c11_load(order)
# 915 "/libmdbx/src/core.c" 3 4
        )); __atomic_load_tmp; })
# 915 "/libmdbx/src/core.c"
                                                                           ;
# 942 "/libmdbx/src/core.c"
}

static 
# 944 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 944 "/libmdbx/src/core.c"
                      void atomic_yield(void) {
# 960 "/libmdbx/src/core.c"
  __asm__ __volatile__("yield");
# 974 "/libmdbx/src/core.c"
}


static 
# 977 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 977 "/libmdbx/src/core.c"
                      _Bool atomic_cas64(MDBX_atomic_uint64_t *p, uint64_t c,
                                         uint64_t v) {

  _Static_assert(sizeof(long long) >= sizeof(uint64_t), "sizeof(long long) >= sizeof(uint64_t)");

  _Static_assert(2 > 0, "ATOMIC_LLONG_LOCK_FREE > 0");






  return 
# 989 "/libmdbx/src/core.c" 3 4
        __extension__ ({ __auto_type __atomic_compare_exchange_ptr = (
# 989 "/libmdbx/src/core.c"
        (&(p)->c11a)
# 989 "/libmdbx/src/core.c" 3 4
        ); __typeof__ ((void)0, *__atomic_compare_exchange_ptr) __atomic_compare_exchange_tmp = (
# 989 "/libmdbx/src/core.c"
        v
# 989 "/libmdbx/src/core.c" 3 4
        ); __atomic_compare_exchange (__atomic_compare_exchange_ptr, (
# 989 "/libmdbx/src/core.c"
        &c
# 989 "/libmdbx/src/core.c" 3 4
        ), &__atomic_compare_exchange_tmp, 0, (5), (5)); })
# 989 "/libmdbx/src/core.c"
                                                                        ;
# 1000 "/libmdbx/src/core.c"
}


static 
# 1003 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 1003 "/libmdbx/src/core.c"
                      _Bool atomic_cas32(MDBX_atomic_uint32_t *p, uint32_t c,
                                         uint32_t v) {

  _Static_assert(sizeof(int) >= sizeof(uint32_t), "sizeof(int) >= sizeof(uint32_t)");

  _Static_assert(2 > 0, "ATOMIC_INT_LOCK_FREE > 0");






  return 
# 1015 "/libmdbx/src/core.c" 3 4
        __extension__ ({ __auto_type __atomic_compare_exchange_ptr = (
# 1015 "/libmdbx/src/core.c"
        (&(p)->c11a)
# 1015 "/libmdbx/src/core.c" 3 4
        ); __typeof__ ((void)0, *__atomic_compare_exchange_ptr) __atomic_compare_exchange_tmp = (
# 1015 "/libmdbx/src/core.c"
        v
# 1015 "/libmdbx/src/core.c" 3 4
        ); __atomic_compare_exchange (__atomic_compare_exchange_ptr, (
# 1015 "/libmdbx/src/core.c"
        &c
# 1015 "/libmdbx/src/core.c" 3 4
        ), &__atomic_compare_exchange_tmp, 0, (5), (5)); })
# 1015 "/libmdbx/src/core.c"
                                                                        ;
# 1027 "/libmdbx/src/core.c"
}

static 
# 1029 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 1029 "/libmdbx/src/core.c"
                      uint32_t atomic_add32(MDBX_atomic_uint32_t *p,
                                             uint32_t v) {

  _Static_assert(sizeof(int) >= sizeof(uint32_t), "sizeof(int) >= sizeof(uint32_t)");

  _Static_assert(2 > 0, "ATOMIC_INT_LOCK_FREE > 0");






  return 
# 1041 "/libmdbx/src/core.c" 3 4
        __atomic_fetch_add ((
# 1041 "/libmdbx/src/core.c"
        (&(p)->c11a)
# 1041 "/libmdbx/src/core.c" 3 4
        ), (
# 1041 "/libmdbx/src/core.c"
        v
# 1041 "/libmdbx/src/core.c" 3 4
        ), 5)
# 1041 "/libmdbx/src/core.c"
                                                      ;
# 1052 "/libmdbx/src/core.c"
}



static 
# 1056 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 1056 "/libmdbx/src/core.c"
                      uint64_t safe64_txnid_next(uint64_t txnid) {
  txnid += 1u;




  return txnid;
}

static 
# 1065 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 1065 "/libmdbx/src/core.c"
                      void safe64_reset(MDBX_atomic_uint64_t *p,
                                         _Bool single_writer) {
# 1081 "/libmdbx/src/core.c"
    atomic_store64(p, 
# 1081 "/libmdbx/src/core.c" 3 4
                     (18446744073709551615UL)
# 1081 "/libmdbx/src/core.c"
                               ,
                   single_writer ? mo_AcquireRelease
                                 : mo_SequentialConsistency);





  do { if ((0)) do { if (__builtin_expect(!!(!(p->weak >= 0xffffFFFF00000000UL)), 0)) mdbx_assert_fail(
# 1089 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 1089 "/libmdbx/src/core.c"
 , "p->weak >= 0xffffFFFF00000000UL", __func__, 1089); } while (0); } while (0);
  mdbx_jitter4testing((1));
}

static 
# 1093 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 1093 "/libmdbx/src/core.c"
                      _Bool safe64_reset_compare(MDBX_atomic_uint64_t *p,
                                                 txnid_t compare) {







  _Bool rc = atomic_cas64(p, compare, 
# 1102 "/libmdbx/src/core.c" 3 4
                                    (18446744073709551615UL)
# 1102 "/libmdbx/src/core.c"
                                              );
# 1117 "/libmdbx/src/core.c"
  mdbx_jitter4testing((1));
  return rc;
}

static 
# 1121 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 1121 "/libmdbx/src/core.c"
                      void safe64_write(MDBX_atomic_uint64_t *p,
                                         const uint64_t v) {
  do { if ((0)) do { if (__builtin_expect(!!(!(p->weak >= 0xffffFFFF00000000UL)), 0)) mdbx_assert_fail(
# 1123 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 1123 "/libmdbx/src/core.c"
 , "p->weak >= 0xffffFFFF00000000UL", __func__, 1123); } while (0); } while (0);

  atomic_store64(p, v, mo_AcquireRelease);
# 1135 "/libmdbx/src/core.c"
  do { if ((0)) do { if (__builtin_expect(!!(!(p->weak == v)), 0)) mdbx_assert_fail(
# 1135 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 1135 "/libmdbx/src/core.c"
 , "p->weak == v", __func__, 1135); } while (0); } while (0);
  mdbx_jitter4testing((1));
}

static 
# 1139 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 1139 "/libmdbx/src/core.c"
                      uint64_t safe64_read(const MDBX_atomic_uint64_t *p) {
  mdbx_jitter4testing((1));
  uint64_t v = atomic_load64(p, mo_AcquireRelease);
  mdbx_jitter4testing((1));
  return v;
}
# 1166 "/libmdbx/src/core.c"
static 
# 1166 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 1166 "/libmdbx/src/core.c"
                      void safe64_update(MDBX_atomic_uint64_t *p,
                                          const uint64_t v) {

  atomic_store64(p, v, mo_Relaxed);




}


__attribute__((__unused__)) static

    
# 1179 "/libmdbx/src/core.c" 3 4
   __inline __attribute__ ((__always_inline__))

    
# 1181 "/libmdbx/src/core.c"
   void
    safe64_inc(MDBX_atomic_uint64_t *p, const uint64_t v) {
  do { if ((0)) do { if (__builtin_expect(!!(!(v > 0)), 0)) mdbx_assert_fail(
# 1183 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 1183 "/libmdbx/src/core.c"
 , "v > 0", __func__, 1183); } while (0); } while (0);
  safe64_update(p, atomic_load64(p, mo_Relaxed) + v);
}




typedef struct rthc_entry_t {
  MDBX_reader *begin;
  MDBX_reader *end;
  mdbx_thread_key_t thr_tls_key;
  _Bool key_valid;
} rthc_entry_t;







static bin128_t bootid;





int __cxa_thread_atexit_impl(void (*dtor)(void *), void *obj, void *dso_symbol)
    __attribute__((__weak__));
# 1221 "/libmdbx/src/core.c"
static pthread_mutex_t lcklist_mutex = 
# 1221 "/libmdbx/src/core.c" 3 4
                                      { { 0, 0, 0, 0, PTHREAD_MUTEX_TIMED_NP, 0, { 0, 0 } } }
# 1221 "/libmdbx/src/core.c"
                                                               ;
static pthread_mutex_t rthc_mutex = 
# 1222 "/libmdbx/src/core.c" 3 4
                                   { { 0, 0, 0, 0, PTHREAD_MUTEX_TIMED_NP, 0, { 0, 0 } } }
# 1222 "/libmdbx/src/core.c"
                                                            ;
static pthread_cond_t rthc_cond = 
# 1223 "/libmdbx/src/core.c" 3 4
                                 { { {0}, {0}, {0, 0}, {0, 0}, 0, 0, {0, 0} } }
# 1223 "/libmdbx/src/core.c"
                                                         ;
static mdbx_thread_key_t rthc_key;
static MDBX_atomic_uint32_t rthc_pending;

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static void workaround_glibc_bug21031(void) {
# 1237 "/libmdbx/src/core.c"
  sched_yield();
  sched_yield();
  sched_yield();
}


static unsigned rthc_count, rthc_limit;
static rthc_entry_t *rthc_table;
static rthc_entry_t rthc_table_static[16];

static __inline void rthc_lock(void) {



  do { if (__builtin_expect(!!(!(pthread_mutex_lock(&rthc_mutex) == 0)), 0)) mdbx_assert_fail(
# 1251 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 1251 "/libmdbx/src/core.c"
 , "pthread_mutex_lock(&rthc_mutex) == 0", __func__, 1251); } while (0);

}

static __inline void rthc_unlock(void) {



  do { if (__builtin_expect(!!(!(pthread_mutex_unlock(&rthc_mutex) == 0)), 0)) mdbx_assert_fail(
# 1259 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 1259 "/libmdbx/src/core.c"
 , "pthread_mutex_unlock(&rthc_mutex) == 0", __func__, 1259); } while (0);

}

static __inline int thread_key_create(mdbx_thread_key_t *key) {
  int rc;




  rc = pthread_key_create(key, 
# 1269 "/libmdbx/src/core.c" 3 4
                              ((void *)0)
# 1269 "/libmdbx/src/core.c"
                                     );

  do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 1271, "&key = %p, value %" 
# 1271 "/libmdbx/src/core.c" 3 4
 "l" "u" 
# 1271 "/libmdbx/src/core.c"
 ", rc %d" "\n", __Wpedantic_format_voidptr(key), (uintptr_t)*key, rc); } while (0)
                                                                  ;
  return rc;
}

static __inline void thread_key_delete(mdbx_thread_key_t key) {
  do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 1277, "key = %" 
# 1277 "/libmdbx/src/core.c" 3 4
 "l" "u" 
# 1277 "/libmdbx/src/core.c"
 "\n", (uintptr_t)key); } while (0);



  do { if (__builtin_expect(!!(!(pthread_key_delete(key) == 0)), 0)) mdbx_assert_fail(
# 1281 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 1281 "/libmdbx/src/core.c"
 , "pthread_key_delete(key) == 0", __func__, 1281); } while (0);
  workaround_glibc_bug21031();

}

static __inline void *thread_rthc_get(mdbx_thread_key_t key) {



  return pthread_getspecific(key);

}

static void thread_rthc_set(mdbx_thread_key_t key, const void *value) {






  static __thread char thread_registration_state;
  if (value && __builtin_expect(!!(thread_registration_state == 0), 0)) {
    thread_registration_state = 1;
    do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 1304, "thread registered 0x%" 
# 1304 "/libmdbx/src/core.c" 3 4
   "l" "x" 
# 1304 "/libmdbx/src/core.c"
   "\n", mdbx_thread_self()); } while (0);
    if (&__cxa_thread_atexit_impl == 
# 1305 "/libmdbx/src/core.c" 3 4
                                    ((void *)0) 
# 1305 "/libmdbx/src/core.c"
                                            ||
        __cxa_thread_atexit_impl(mdbx_rthc_thread_dtor,
                                 &thread_registration_state,
                                 (void *)&mdbx_version )) {
      do { if (__builtin_expect(!!(!(pthread_setspecific( rthc_key, &thread_registration_state) == 0)), 0)) mdbx_assert_fail(
# 1309 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 1309 "/libmdbx/src/core.c"
     , "pthread_setspecific( rthc_key, &thread_registration_state) == 0", __func__, 1309); } while (0)
                                                                          ;
      thread_registration_state = 2;
      const unsigned count_before = atomic_add32(&rthc_pending, 1);
      do { if (__builtin_expect(!!(!(count_before < 0x7fffffff)), 0)) mdbx_assert_fail(
# 1313 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 1313 "/libmdbx/src/core.c"
     , "count_before < INT_MAX", __func__, 1313); } while (0);
      do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 1314, "fallback to pthreads' tsd, key %" 
# 1314 "/libmdbx/src/core.c" 3 4
     "l" "u" 
# 1314 "/libmdbx/src/core.c"
     ", count %u" "\n", (uintptr_t)rthc_key, count_before); } while (0)
                                                   ;
      (void)count_before;
    }
  }
  do { if (__builtin_expect(!!(!(pthread_setspecific(key, value) == 0)), 0)) mdbx_assert_fail(
# 1319 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 1319 "/libmdbx/src/core.c"
 , "pthread_setspecific(key, value) == 0", __func__, 1319); } while (0);

}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) void mdbx_rthc_global_init(void) {
  rthc_limit = 16;
  rthc_table = rthc_table_static;




  do { if (__builtin_expect(!!(!(pthread_key_create(&rthc_key, mdbx_rthc_thread_dtor) == 0)), 0)) mdbx_assert_fail(
# 1330 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 1330 "/libmdbx/src/core.c"
 , "pthread_key_create(&rthc_key, mdbx_rthc_thread_dtor) == 0", __func__, 1330); } while (0)
                                                                        ;
  do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 1332, "pid %d, &mdbx_rthc_key = %p, value 0x%x" "\n", mdbx_getpid(), __Wpedantic_format_voidptr(&rthc_key), (unsigned)rthc_key); } while (0)
                                                                       ;



  uint32_t proba = 
# 1337 "/libmdbx/src/core.c" 3 4
                  (4294967295U)
# 1337 "/libmdbx/src/core.c"
                            ;
  while ((1)) {
    unsigned time_conversion_checkup =
        mdbx_osal_monotime_to_16dot16(mdbx_osal_16dot16_to_monotime(proba));
    unsigned one_more = (proba < 
# 1341 "/libmdbx/src/core.c" 3 4
                                (4294967295U)
# 1341 "/libmdbx/src/core.c"
                                          ) ? proba + 1 : proba;
    unsigned one_less = (proba > 0) ? proba - 1 : proba;
    do { if (__builtin_expect(!!(!(time_conversion_checkup >= one_less && time_conversion_checkup <= one_more)), 0)) mdbx_assert_fail(
# 1343 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 1343 "/libmdbx/src/core.c"
   , "time_conversion_checkup >= one_less && time_conversion_checkup <= one_more", __func__, 1343); } while (0)
                                                                 ;
    if (proba == 0)
      break;
    proba >>= 1;
  }

  bootid = mdbx_osal_bootid();
# 1362 "/libmdbx/src/core.c"
}


__attribute__((__cold__)) __attribute__((__optimize__("Os"))) void mdbx_rthc_thread_dtor(void *ptr) {
  rthc_lock();
  do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 1367, ">> pid %d, thread 0x%" 
# 1367 "/libmdbx/src/core.c" 3 4
 "l" "x" 
# 1367 "/libmdbx/src/core.c"
 ", rthc %p" "\n", mdbx_getpid(), mdbx_thread_self(), ptr); } while (0)
                                     ;

  const uint32_t self_pid = mdbx_getpid();
  for (unsigned i = 0; i < rthc_count; ++i) {
    if (!rthc_table[i].key_valid)
      continue;
    const mdbx_thread_key_t key = rthc_table[i].thr_tls_key;
    MDBX_reader *const rthc = thread_rthc_get(key);
    if (rthc < rthc_table[i].begin || rthc >= rthc_table[i].end)
      continue;

    if (pthread_setspecific(key, 
# 1379 "/libmdbx/src/core.c" 3 4
                                ((void *)0)
# 1379 "/libmdbx/src/core.c"
                                       ) != 0) {
      do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 1380, "== thread 0x%" 
# 1380 "/libmdbx/src/core.c" 3 4
     "l" "x" 
# 1380 "/libmdbx/src/core.c"
     ", rthc %p: ignore race with tsd-key deletion" "\n", mdbx_thread_self(), ptr); } while (0)

                                         ;
      continue ;
    }


    do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 1387, "== thread 0x%" 
# 1387 "/libmdbx/src/core.c" 3 4
   "l" "x" 
# 1387 "/libmdbx/src/core.c"
   ", rthc %p, [%i], %p ... %p (%+i), rtch-pid %i, " "current-pid %i" "\n", mdbx_thread_self(), __Wpedantic_format_voidptr(rthc), i, __Wpedantic_format_voidptr(rthc_table[i].begin), __Wpedantic_format_voidptr(rthc_table[i].end), (int)(rthc - rthc_table[i].begin), rthc->mr_pid.weak, self_pid); } while (0)





                                                                              ;
    if (atomic_load32(&rthc->mr_pid, mo_Relaxed) == self_pid) {
      do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 1395, "==== thread 0x%" 
# 1395 "/libmdbx/src/core.c" 3 4
     "l" "x" 
# 1395 "/libmdbx/src/core.c"
     ", rthc %p, cleanup" "\n", mdbx_thread_self(), __Wpedantic_format_voidptr(rthc)); } while (0)
                                                                      ;
      atomic_store32(&rthc->mr_pid, 0, mo_AcquireRelease);
    }
  }





  const char self_registration = *(volatile char *)ptr;
  *(volatile char *)ptr = 0;
  do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 1407, "== thread 0x%" 
# 1407 "/libmdbx/src/core.c" 3 4
 "l" "x" 
# 1407 "/libmdbx/src/core.c"
 ", rthc %p, pid %d, self-status %d" "\n", mdbx_thread_self(), ptr, mdbx_getpid(), self_registration); } while (0)
                                                                       ;
  if (self_registration == 2)
    do { if (__builtin_expect(!!(!(atomic_add32(&rthc_pending, 0 - (1)) > 0)), 0)) mdbx_assert_fail(
# 1410 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 1410 "/libmdbx/src/core.c"
   , "atomic_sub32(&rthc_pending, 1) > 0", __func__, 1410); } while (0);

  if (atomic_load32(&rthc_pending, mo_AcquireRelease) == 0) {
    do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 1413, "== thread 0x%" 
# 1413 "/libmdbx/src/core.c" 3 4
   "l" "x" 
# 1413 "/libmdbx/src/core.c"
   ", rthc %p, pid %d, wake" "\n", mdbx_thread_self(), ptr, mdbx_getpid()); } while (0)
                                                      ;
    do { if (__builtin_expect(!!(!(pthread_cond_broadcast(&rthc_cond) == 0)), 0)) mdbx_assert_fail(
# 1415 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 1415 "/libmdbx/src/core.c"
   , "pthread_cond_broadcast(&rthc_cond) == 0", __func__, 1415); } while (0);
  }

  do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 1418, "<< thread 0x%" 
# 1418 "/libmdbx/src/core.c" 3 4
 "l" "x" 
# 1418 "/libmdbx/src/core.c"
 ", rthc %p" "\n", mdbx_thread_self(), ptr); } while (0);




  pthread_mutex_unlock(&rthc_mutex);

}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) void mdbx_rthc_global_dtor(void) {
  do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 1428, ">> pid %d" "\n", mdbx_getpid()); } while (0);

  rthc_lock();

  char *rthc = pthread_getspecific(rthc_key);
  do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 1433, "== thread 0x%" 
# 1433 "/libmdbx/src/core.c" 3 4
 "l" "x" 
# 1433 "/libmdbx/src/core.c"
 ", rthc %p, pid %d, self-status %d, left %d" "\n", mdbx_thread_self(), __Wpedantic_format_voidptr(rthc), mdbx_getpid(), rthc ? *rthc : -1, atomic_load32(&rthc_pending, mo_Relaxed)); } while (0)


                                                                  ;
  if (rthc) {
    const char self_registration = *rthc;
    *rthc = 0;
    if (self_registration == 2)
      do { if (__builtin_expect(!!(!(atomic_add32(&rthc_pending, 0 - (1)) > 0)), 0)) mdbx_assert_fail(
# 1441 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 1441 "/libmdbx/src/core.c"
     , "atomic_sub32(&rthc_pending, 1) > 0", __func__, 1441); } while (0);
  }

  struct timespec abstime;
  do { if (__builtin_expect(!!(!(clock_gettime(
# 1445 "/libmdbx/src/core.c" 3 4
 0
# 1445 "/libmdbx/src/core.c"
 , &abstime) == 0)), 0)) mdbx_assert_fail(
# 1445 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 1445 "/libmdbx/src/core.c"
 , "clock_gettime(CLOCK_REALTIME, &abstime) == 0", __func__, 1445); } while (0);
  abstime.tv_nsec += 1000000000l / 10;
  if (abstime.tv_nsec >= 1000000000l) {
    abstime.tv_nsec -= 1000000000l;
    abstime.tv_sec += 1;
  }




  for (unsigned left;
       (left = atomic_load32(&rthc_pending, mo_AcquireRelease)) > 0;) {
    do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 1457, "pid %d, pending %u, wait for..." "\n", mdbx_getpid(), left); } while (0);
    const int rc = pthread_cond_timedwait(&rthc_cond, &rthc_mutex, &abstime);
    if (rc && rc != 
# 1459 "/libmdbx/src/core.c" 3 4
                   4
# 1459 "/libmdbx/src/core.c"
                        )
      break;
  }
  thread_key_delete(rthc_key);


  const uint32_t self_pid = mdbx_getpid();
  for (unsigned i = 0; i < rthc_count; ++i) {
    if (!rthc_table[i].key_valid)
      continue;
    const mdbx_thread_key_t key = rthc_table[i].thr_tls_key;
    thread_key_delete(key);
    for (MDBX_reader *rthc = rthc_table[i].begin; rthc < rthc_table[i].end;
         ++rthc) {
      do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 1473, "== [%i] = key %" 
# 1473 "/libmdbx/src/core.c" 3 4
     "l" "u" 
# 1473 "/libmdbx/src/core.c"
     ", %p ... %p, rthc %p (%+i), " "rthc-pid %i, current-pid %i" "\n", i, (uintptr_t)key, __Wpedantic_format_voidptr(rthc_table[i].begin), __Wpedantic_format_voidptr(rthc_table[i].end), __Wpedantic_format_voidptr(rthc), (int)(rthc - rthc_table[i].begin), rthc->mr_pid.weak, self_pid); } while (0)





                                      ;
      if (atomic_load32(&rthc->mr_pid, mo_Relaxed) == self_pid) {
        atomic_store32(&rthc->mr_pid, 0, mo_AcquireRelease);
        do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 1482, "== cleanup %p" "\n", __Wpedantic_format_voidptr(rthc)); } while (0);
      }
    }
  }

  rthc_limit = rthc_count = 0;
  if (rthc_table != rthc_table_static)
    free(rthc_table);
  rthc_table = 
# 1490 "/libmdbx/src/core.c" 3 4
              ((void *)0)
# 1490 "/libmdbx/src/core.c"
                     ;
  rthc_unlock();







  workaround_glibc_bug21031();


  do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 1502, "<< pid %d\n" "\n", mdbx_getpid()); } while (0);
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_rthc_alloc(mdbx_thread_key_t *key, MDBX_reader *begin,
                           MDBX_reader *end) {
  int rc;
  if (key) {



    rc = thread_key_create(key);
    if (rc != MDBX_SUCCESS)
      return rc;
  }

  rthc_lock();
  const mdbx_thread_key_t new_key = key ? *key : 0;
  do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 1519, ">> key %" 
# 1519 "/libmdbx/src/core.c" 3 4
 "l" "u" 
# 1519 "/libmdbx/src/core.c"
 ", rthc_count %u, rthc_limit %u" "\n", (uintptr_t)new_key, rthc_count, rthc_limit); } while (0)
                                                        ;
  if (rthc_count == rthc_limit) {
    rthc_entry_t *new_table =
        realloc((rthc_table == rthc_table_static) ? 
# 1523 "/libmdbx/src/core.c" 3 4
                                                        ((void *)0) 
# 1523 "/libmdbx/src/core.c"
                                                                : rthc_table,
                     sizeof(rthc_entry_t) * rthc_limit * 2);
    if (new_table == 
# 1525 "/libmdbx/src/core.c" 3 4
                    ((void *)0)
# 1525 "/libmdbx/src/core.c"
                           ) {
      rc = MDBX_ENOMEM;
      goto bailout;
    }
    if (rthc_table == rthc_table_static)
      memcpy(new_table, rthc_table_static, sizeof(rthc_table_static));
    rthc_table = new_table;
    rthc_limit *= 2;
  }
  do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 1534, "== [%i] = key %" 
# 1534 "/libmdbx/src/core.c" 3 4
 "l" "u" 
# 1534 "/libmdbx/src/core.c"
 ", %p ... %p" "\n", rthc_count, (uintptr_t)new_key, __Wpedantic_format_voidptr(begin), __Wpedantic_format_voidptr(end)); } while (0)

                                             ;
  rthc_table[rthc_count].key_valid = key ? (1) : (0);
  rthc_table[rthc_count].thr_tls_key = key ? new_key : 0;
  rthc_table[rthc_count].begin = begin;
  rthc_table[rthc_count].end = end;
  ++rthc_count;
  do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 1542, "<< key %" 
# 1542 "/libmdbx/src/core.c" 3 4
 "l" "u" 
# 1542 "/libmdbx/src/core.c"
 ", rthc_count %u, rthc_limit %u" "\n", (uintptr_t)new_key, rthc_count, rthc_limit); } while (0)
                                                        ;
  rthc_unlock();
  return MDBX_SUCCESS;

bailout:
  if (key)
    thread_key_delete(*key);
  rthc_unlock();
  return rc;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) void mdbx_rthc_remove(const mdbx_thread_key_t key) {
  thread_key_delete(key);
  rthc_lock();
  do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 1557, ">> key %zu, rthc_count %u, rthc_limit %u" "\n", (size_t)key, rthc_count, rthc_limit); } while (0)
                                    ;

  for (unsigned i = 0; i < rthc_count; ++i) {
    if (rthc_table[i].key_valid && key == rthc_table[i].thr_tls_key) {
      const uint32_t self_pid = mdbx_getpid();
      do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 1563, "== [%i], %p ...%p, current-pid %d" "\n", i, __Wpedantic_format_voidptr(rthc_table[i].begin), __Wpedantic_format_voidptr(rthc_table[i].end), self_pid); } while (0)

                                                                         ;

      for (MDBX_reader *rthc = rthc_table[i].begin; rthc < rthc_table[i].end;
           ++rthc) {
        if (atomic_load32(&rthc->mr_pid, mo_Relaxed) == self_pid) {
          atomic_store32(&rthc->mr_pid, 0, mo_AcquireRelease);
          do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 1571, "== cleanup %p" "\n", __Wpedantic_format_voidptr(rthc)); } while (0);
        }
      }
      if (--rthc_count > 0)
        rthc_table[i] = rthc_table[rthc_count];
      else if (rthc_table != rthc_table_static) {
        free(rthc_table);
        rthc_table = rthc_table_static;
        rthc_limit = 16;
      }
      break;
    }
  }

  do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 1585, "<< key %zu, rthc_count %u, rthc_limit %u" "\n", (size_t)key, rthc_count, rthc_limit); } while (0)
                                    ;
  rthc_unlock();
}




static MDBX_env *inprocess_lcklist_head = ((MDBX_env *)((uintptr_t)50459));

static __inline void lcklist_lock(void) {



  do { if (__builtin_expect(!!(!(pthread_mutex_lock(&lcklist_mutex) == 0)), 0)) mdbx_assert_fail(
# 1599 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 1599 "/libmdbx/src/core.c"
 , "pthread_mutex_lock(&lcklist_mutex) == 0", __func__, 1599); } while (0);

}

static __inline void lcklist_unlock(void) {



  do { if (__builtin_expect(!!(!(pthread_mutex_unlock(&lcklist_mutex) == 0)), 0)) mdbx_assert_fail(
# 1607 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 1607 "/libmdbx/src/core.c"
 , "pthread_mutex_unlock(&lcklist_mutex) == 0", __func__, 1607); } while (0);

}

__attribute__((__const__, __nothrow__)) static uint64_t rrxmrrxmsx_0(uint64_t v) {

  v ^= (v << 39 | v >> 25) ^ (v << 14 | v >> 50);
  v *= 0xA24BAED4963EE407UL;
  v ^= (v << 40 | v >> 24) ^ (v << 15 | v >> 49);
  v *= 0x9FB21C651E98DF25UL;
  return v ^ v >> 28;
}

static int uniq_peek(const mdbx_mmap_t *pending, mdbx_mmap_t *scan) {
  int rc;
  uint64_t bait;
  MDBX_lockinfo *const pending_lck = pending->lck;
  MDBX_lockinfo *const scan_lck = scan->lck;
  if (pending_lck) {
    bait = atomic_load64(&pending_lck->mti_bait_uniqueness, mo_AcquireRelease);
    rc = MDBX_SUCCESS;
  } else {
    bait = 0 ;
    rc = mdbx_msync(scan, 0, sizeof(MDBX_lockinfo), MDBX_SYNC_DATA);
    if (rc == MDBX_SUCCESS)
      rc = mdbx_pread(pending->fd, &bait, sizeof(scan_lck->mti_bait_uniqueness),
                      
# 1633 "/libmdbx/src/core.c" 3 4
                     __builtin_offsetof (
# 1633 "/libmdbx/src/core.c"
                     MDBX_lockinfo
# 1633 "/libmdbx/src/core.c" 3 4
                     , 
# 1633 "/libmdbx/src/core.c"
                     mti_bait_uniqueness
# 1633 "/libmdbx/src/core.c" 3 4
                     )
# 1633 "/libmdbx/src/core.c"
                                                                 );
  }
  if (__builtin_expect(!!(rc == MDBX_SUCCESS), 1) &&
      bait == atomic_load64(&scan_lck->mti_bait_uniqueness, mo_AcquireRelease))
    rc = MDBX_RESULT_TRUE;

  do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 1639, "uniq-peek: %s, bait 0x%016" 
# 1639 "/libmdbx/src/core.c" 3 4
 "l" "x" 
# 1639 "/libmdbx/src/core.c"
 ",%s rc %d" "\n", pending_lck ? "mem" : "file", bait, (rc == MDBX_RESULT_TRUE) ? " found," : (rc ? " FAILED," : ""), rc); } while (0)

                                                                               ;
  return rc;
}

static int uniq_poke(const mdbx_mmap_t *pending, mdbx_mmap_t *scan,
                     uint64_t *abra) {
  if (*abra == 0) {
    const uintptr_t tid = mdbx_thread_self();
    uintptr_t uit = 0;
    memcpy(&uit, &tid, (sizeof(tid) < sizeof(uit)) ? sizeof(tid) : sizeof(uit));
    *abra =
        rrxmrrxmsx_0(mdbx_osal_monotime() + 5873865991930747UL * uit);
  }
  const uint64_t cadabra =
      rrxmrrxmsx_0(*abra + 7680760450171793UL * (unsigned)mdbx_getpid())
          << 24 |
      *abra >> 40;
  MDBX_lockinfo *const scan_lck = scan->lck;
  atomic_store64(&scan_lck->mti_bait_uniqueness, cadabra,
                 mo_SequentialConsistency);
  *abra = *abra * 6364136223846793005UL + 1;
  return uniq_peek(pending, scan);
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static int uniq_check(const mdbx_mmap_t *pending, MDBX_env **found) {
  *found = 
# 1666 "/libmdbx/src/core.c" 3 4
          ((void *)0)
# 1666 "/libmdbx/src/core.c"
                 ;
  uint64_t salt = 0;
  for (MDBX_env *scan = inprocess_lcklist_head; scan != ((MDBX_env *)((uintptr_t)50459));
       scan = scan->me_lcklist_next) {
    MDBX_lockinfo *const scan_lck = scan->me_lck_mmap.lck;
    int err = atomic_load64(&scan_lck->mti_bait_uniqueness, mo_AcquireRelease)
                  ? uniq_peek(pending, &scan->me_lck_mmap)
                  : uniq_poke(pending, &scan->me_lck_mmap, &salt);
    if (err == MDBX_ENODATA) {
      uint64_t length;
      if (__builtin_expect(!!(mdbx_filesize(pending->fd, &length) == MDBX_SUCCESS && length == 0), 1)
                             ) {

        do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 1679, "uniq-probe: %s" "\n", "unique (new/empty lck)"); } while (0);
        return MDBX_RESULT_TRUE;
      }
    }
    if (err == MDBX_RESULT_TRUE)
      err = uniq_poke(pending, &scan->me_lck_mmap, &salt);
    if (err == MDBX_RESULT_TRUE) {
      (void)mdbx_msync(&scan->me_lck_mmap, 0, sizeof(MDBX_lockinfo),
                       MDBX_SYNC_NONE);
      err = uniq_poke(pending, &scan->me_lck_mmap, &salt);
    }
    if (err == MDBX_RESULT_TRUE) {
      err = uniq_poke(pending, &scan->me_lck_mmap, &salt);
      *found = scan;
      do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 1693, "uniq-probe: found %p" "\n", __Wpedantic_format_voidptr(*found)); } while (0);
      return MDBX_RESULT_FALSE;
    }
    if (__builtin_expect(!!(err != MDBX_SUCCESS), 0)) {
      do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 1697, "uniq-probe: failed rc %d" "\n", err); } while (0);
      return err;
    }
  }

  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 1702, "uniq-probe: %s" "\n", "unique"); } while (0);
  return MDBX_RESULT_TRUE;
}

static int lcklist_detach_locked(MDBX_env *env) {
  MDBX_env *inprocess_neighbor = 
# 1707 "/libmdbx/src/core.c" 3 4
                                ((void *)0)
# 1707 "/libmdbx/src/core.c"
                                       ;
  int rc = MDBX_SUCCESS;
  if (env->me_lcklist_next != 
# 1709 "/libmdbx/src/core.c" 3 4
                             ((void *)0)
# 1709 "/libmdbx/src/core.c"
                                    ) {
    do { if (__builtin_expect(!!(!(env->me_lcklist_next != 
# 1710 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 1710 "/libmdbx/src/core.c"
   )), 0)) mdbx_assert_fail(env, "env->me_lcklist_next != nullptr", __func__, 1710); } while (0);
    do { if (__builtin_expect(!!(!(inprocess_lcklist_head != ((MDBX_env *)((uintptr_t)50459)))), 0)) mdbx_assert_fail(env, "inprocess_lcklist_head != RTHC_ENVLIST_END", __func__, 1711); } while (0);
    for (MDBX_env **ptr = &inprocess_lcklist_head; *ptr != ((MDBX_env *)((uintptr_t)50459));
         ptr = &(*ptr)->me_lcklist_next) {
      if (*ptr == env) {
        *ptr = env->me_lcklist_next;
        env->me_lcklist_next = 
# 1716 "/libmdbx/src/core.c" 3 4
                              ((void *)0)
# 1716 "/libmdbx/src/core.c"
                                     ;
        break;
      }
    }
    do { if (__builtin_expect(!!(!(env->me_lcklist_next == 
# 1720 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 1720 "/libmdbx/src/core.c"
   )), 0)) mdbx_assert_fail(env, "env->me_lcklist_next == nullptr", __func__, 1720); } while (0);
  }

  rc = __builtin_expect(!!(mdbx_getpid() == env->me_pid), 1)
           ? uniq_check(&env->me_lck_mmap, &inprocess_neighbor)
           : MDBX_PANIC;
  if (!inprocess_neighbor && env->me_live_reader)
    (void)mdbx_rpid_clear(env);
  if (!((rc) != MDBX_RESULT_TRUE && (rc) != MDBX_RESULT_FALSE))
    rc = mdbx_lck_destroy(env, inprocess_neighbor);
  return rc;
}
# 2879 "/libmdbx/src/core.c"
static 
# 2879 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 2879 "/libmdbx/src/core.c"
                      size_t pnl2bytes(size_t size) {
  do { if ((0)) do { if (__builtin_expect(!!(!(size > 0 && size <= ((size_t)0x7FFFffffU))), 0)) mdbx_assert_fail(
# 2880 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 2880 "/libmdbx/src/core.c"
 , "size > 0 && size <= ((size_t)0x7FFFffffU)", __func__, 2880); } while (0); } while (0);

  size += size;

  _Static_assert((8 * 2u) + (((size_t)0x7FFFffffU) * (1 + 1) + 1024 + 2) * sizeof(pgno_t) < 
# 2884 "/libmdbx/src/core.c" 3 4
 (18446744073709551615UL) 
# 2884 "/libmdbx/src/core.c"
 / 4 * 3, "MDBX_ASSUME_MALLOC_OVERHEAD + (MDBX_PGL_LIMIT * (MDBX_PNL_PREALLOC_FOR_RADIXSORT + 1) + MDBX_PNL_GRANULATE + 2) * sizeof(pgno_t) < SIZE_MAX / 4 * 3")



                                 ;
  size_t bytes =
      ceil_powerof2((8 * 2u) + sizeof(pgno_t) * (size + 2),
                    1024 * sizeof(pgno_t)) -
      (8 * 2u);
  return bytes;
}

static 
# 2896 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 2896 "/libmdbx/src/core.c"
                      pgno_t bytes2pnl(const size_t bytes) {
  size_t size = bytes / sizeof(pgno_t);
  do { if ((0)) do { if (__builtin_expect(!!(!(size > 2 && size <= ((size_t)0x7FFFffffU) + 65536)), 0)) mdbx_assert_fail(
# 2898 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 2898 "/libmdbx/src/core.c"
 , "size > 2 && size <= ((size_t)0x7FFFffffU) + 65536", __func__, 2898); } while (0); } while (0);
  size -= 2;

  size >>= 1;

  return (pgno_t)size;
}

static MDBX_PNL mdbx_pnl_alloc(size_t size) {
  size_t bytes = pnl2bytes(size);
  MDBX_PNL pl = malloc(bytes);
  if (__builtin_expect(!!(pl), 1)) {

    bytes = malloc_usable_size(pl);

    pl[0] = bytes2pnl(bytes);
    do { if ((0)) do { if (__builtin_expect(!!(!(pl[0] >= size)), 0)) mdbx_assert_fail(
# 2914 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 2914 "/libmdbx/src/core.c"
   , "pl[0] >= size", __func__, 2914); } while (0); } while (0);
    pl[1] = 0;
    pl += 1;
  }
  return pl;
}

static void mdbx_pnl_free(MDBX_PNL pl) {
  if (__builtin_expect(!!(pl), 1))
    free(pl - 1);
}


static void mdbx_pnl_shrink(MDBX_PNL *ppl) {
  do { if ((0)) do { if (__builtin_expect(!!(!(bytes2pnl(pnl2bytes((1024 - 2 - (8 * 2u) / sizeof(pgno_t)))) >= (1024 - 2 - (8 * 2u) / sizeof(pgno_t)) && bytes2pnl(pnl2bytes((1024 - 2 - (8 * 2u) / sizeof(pgno_t)))) < (1024 - 2 - (8 * 2u) / sizeof(pgno_t)) * 3 / 2)), 0)) mdbx_assert_fail(
# 2928 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 2928 "/libmdbx/src/core.c"
 , "bytes2pnl(pnl2bytes((1024 - 2 - (8 * 2u) / sizeof(pgno_t)))) >= (1024 - 2 - (8 * 2u) / sizeof(pgno_t)) && bytes2pnl(pnl2bytes((1024 - 2 - (8 * 2u) / sizeof(pgno_t)))) < (1024 - 2 - (8 * 2u) / sizeof(pgno_t)) * 3 / 2", __func__, 2928); } while (0); } while (0)
                                                                           ;
  do { if ((0)) do { if (__builtin_expect(!!(!(((*ppl)[0]) <= ((size_t)0x7FFFffffU) && ((*ppl)[-1]) >= ((*ppl)[0]))), 0)) mdbx_assert_fail(
# 2930 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 2930 "/libmdbx/src/core.c"
 , "((*ppl)[0]) <= ((size_t)0x7FFFffffU) && ((*ppl)[-1]) >= ((*ppl)[0])", __func__, 2930); } while (0); } while (0)
                                                        ;
  ((*ppl)[0]) = 0;
  if (__builtin_expect(!!(((*ppl)[-1]) > (1024 - 2 - (8 * 2u) / sizeof(pgno_t)) * 2 - 64 / sizeof(pgno_t)), 0)
                                                                           ) {
    size_t bytes = pnl2bytes((1024 - 2 - (8 * 2u) / sizeof(pgno_t)));
    MDBX_PNL pl = realloc(*ppl - 1, bytes);
    if (__builtin_expect(!!(pl), 1)) {

      bytes = malloc_usable_size(pl);

      *pl = bytes2pnl(bytes);
      *ppl = pl + 1;
    }
  }
}


static int mdbx_pnl_reserve(MDBX_PNL *ppl, const size_t wanna) {
  const size_t allocated = ((*ppl)[-1]);
  do { if ((0)) do { if (__builtin_expect(!!(!(((*ppl)[0]) <= ((size_t)0x7FFFffffU) && ((*ppl)[-1]) >= ((*ppl)[0]))), 0)) mdbx_assert_fail(
# 2950 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 2950 "/libmdbx/src/core.c"
 , "((*ppl)[0]) <= ((size_t)0x7FFFffffU) && ((*ppl)[-1]) >= ((*ppl)[0])", __func__, 2950); } while (0); } while (0)
                                                        ;
  if (__builtin_expect(!!(allocated >= wanna), 1))
    return MDBX_SUCCESS;

  if (__builtin_expect(!!(wanna > ((size_t)0x7FFFffffU)), 0)) {
    do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 2956, "PNL too long (%zu > %zu)" "\n", wanna, (size_t)((size_t)0x7FFFffffU)); } while (0);
    return MDBX_TXN_FULL;
  }

  const size_t size = (wanna + wanna - allocated < ((size_t)0x7FFFffffU))
                          ? wanna + wanna - allocated
                          : ((size_t)0x7FFFffffU);
  size_t bytes = pnl2bytes(size);
  MDBX_PNL pl = realloc(*ppl - 1, bytes);
  if (__builtin_expect(!!(pl), 1)) {

    bytes = malloc_usable_size(pl);

    *pl = bytes2pnl(bytes);
    do { if ((0)) do { if (__builtin_expect(!!(!(*pl >= wanna)), 0)) mdbx_assert_fail(
# 2970 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 2970 "/libmdbx/src/core.c"
   , "*pl >= wanna", __func__, 2970); } while (0); } while (0);
    *ppl = pl + 1;
    return MDBX_SUCCESS;
  }
  return MDBX_ENOMEM;
}


static 
# 2978 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 2978 "/libmdbx/src/core.c"
                      int __attribute__((__warn_unused_result__)) mdbx_pnl_need(MDBX_PNL *ppl,
                                                             size_t num) {
  do { if ((0)) do { if (__builtin_expect(!!(!(((*ppl)[0]) <= ((size_t)0x7FFFffffU) && ((*ppl)[-1]) >= ((*ppl)[0]))), 0)) mdbx_assert_fail(
# 2980 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 2980 "/libmdbx/src/core.c"
 , "((*ppl)[0]) <= ((size_t)0x7FFFffffU) && ((*ppl)[-1]) >= ((*ppl)[0])", __func__, 2980); } while (0); } while (0)
                                                        ;
  do { if ((0)) do { if (__builtin_expect(!!(!(num <= ((size_t)0x7FFFffffU))), 0)) mdbx_assert_fail(
# 2982 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 2982 "/libmdbx/src/core.c"
 , "num <= ((size_t)0x7FFFffffU)", __func__, 2982); } while (0); } while (0);
  const size_t wanna = ((*ppl)[0]) + num;
  return __builtin_expect(!!(((*ppl)[-1]) >= wanna), 1)
             ? MDBX_SUCCESS
             : mdbx_pnl_reserve(ppl, wanna);
}

static 
# 2989 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 2989 "/libmdbx/src/core.c"
                      void mdbx_pnl_xappend(MDBX_PNL pl, pgno_t pgno) {
  do { if ((0)) do { if (__builtin_expect(!!(!(((pl)[0]) < ((pl)[-1]))), 0)) mdbx_assert_fail(
# 2990 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 2990 "/libmdbx/src/core.c"
 , "((pl)[0]) < ((pl)[-1])", __func__, 2990); } while (0); } while (0);
  if ((0)) {
    for (unsigned i = ((pl)[0]); i > 0; --i)
      do { if ((0)) do { if (__builtin_expect(!!(!(pgno != pl[i])), 0)) mdbx_assert_fail(
# 2993 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 2993 "/libmdbx/src/core.c"
     , "pgno != pl[i]", __func__, 2993); } while (0); } while (0);
  }
  ((pl)[0]) += 1;
  ((pl)[((pl)[0])]) = pgno;
}



# 3000 "/libmdbx/src/core.c" 3 4
__inline __attribute__ ((__always_inline__)) 
# 3000 "/libmdbx/src/core.c"
               static int __attribute__((__warn_unused_result__))
mdbx_pnl_append_range(_Bool spilled, MDBX_PNL *ppl, pgno_t pgno, unsigned n) {
  do { if ((0)) do { if (__builtin_expect(!!(!(n > 0)), 0)) mdbx_assert_fail(
# 3002 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3002 "/libmdbx/src/core.c"
 , "n > 0", __func__, 3002); } while (0); } while (0);
  int rc = mdbx_pnl_need(ppl, n);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  const MDBX_PNL pnl = *ppl;
# 3016 "/libmdbx/src/core.c"
  unsigned w = ((pnl)[0]) + n;
  ((pnl)[0]) = w;
  do {
    pnl[w--] = pgno;
    pgno += spilled ? 2 : 1;
  } while (--n);


  return MDBX_SUCCESS;
}


static __attribute__((__hot__)) __attribute__((__optimize__("O3"))) int __attribute__((__warn_unused_result__)) mdbx_pnl_insert_range(MDBX_PNL *ppl,
                                                           pgno_t pgno,
                                                           unsigned n) {
  do { if ((0)) do { if (__builtin_expect(!!(!(n > 0)), 0)) mdbx_assert_fail(
# 3031 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3031 "/libmdbx/src/core.c"
 , "n > 0", __func__, 3031); } while (0); } while (0);
  int rc = mdbx_pnl_need(ppl, n);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  const MDBX_PNL pnl = *ppl;
  unsigned r = ((pnl)[0]), w = r + n;
  ((pnl)[0]) = w;
  while (r && ((pnl[r]) <= (pgno)))
    pnl[w--] = pnl[r--];

  for (pgno_t fill = 0 ? pgno + n : pgno; w > r; --w)
    pnl[w] = 0 ? --fill : fill++;

  return MDBX_SUCCESS;
}

static _Bool mdbx_pnl_check(const MDBX_PNL pl, const size_t limit) {
  do { if ((0)) do { if (__builtin_expect(!!(!(limit >= 3 - 1)), 0)) mdbx_assert_fail(
# 3049 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3049 "/libmdbx/src/core.c"
 , "limit >= 3 - 1", __func__, 3049); } while (0); } while (0);
  if (__builtin_expect(!!(((pl)[0])), 1)) {
    do { if ((0)) do { if (__builtin_expect(!!(!(((pl)[((pl)[0])]) >= 3)), 0)) mdbx_assert_fail(
# 3051 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 3051 "/libmdbx/src/core.c"
   , "((pl)[((pl)[0])]) >= 3", __func__, 3051); } while (0); } while (0);
    do { if ((0)) do { if (__builtin_expect(!!(!(((pl)[1]) < limit)), 0)) mdbx_assert_fail(
# 3052 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 3052 "/libmdbx/src/core.c"
   , "((pl)[1]) < limit", __func__, 3052); } while (0); } while (0);
    do { if ((0)) do { if (__builtin_expect(!!(!(((pl)[0]) <= ((size_t)0x7FFFffffU))), 0)) mdbx_assert_fail(
# 3053 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 3053 "/libmdbx/src/core.c"
   , "((pl)[0]) <= ((size_t)0x7FFFffffU)", __func__, 3053); } while (0); } while (0);
    if (__builtin_expect(!!(((pl)[0]) > ((size_t)0x7FFFffffU)), 0))
      return (0);
    if (__builtin_expect(!!(((pl)[((pl)[0])]) < 3), 0))
      return (0);
    if (__builtin_expect(!!(((pl)[1]) >= limit), 0))
      return (0);
    if ((0)) {
      for (const pgno_t *scan = &((pl)[((pl)[0])]); --scan > pl;) {
        do { if ((0)) do { if (__builtin_expect(!!(!(((scan[0]) > (scan[1])))), 0)) mdbx_assert_fail(
# 3062 "/libmdbx/src/core.c" 3 4
       ((void *)0)
# 3062 "/libmdbx/src/core.c"
       , "((scan[0]) > (scan[1]))", __func__, 3062); } while (0); } while (0);
        if (__builtin_expect(!!(!((scan[0]) > (scan[1]))), 0))
          return (0);
      }
    }
  }
  return (1);
}

static 
# 3071 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 3071 "/libmdbx/src/core.c"
                      _Bool mdbx_pnl_check4assert(const MDBX_PNL pl,
                                                  const size_t limit) {
  if (__builtin_expect(!!(pl == 
# 3073 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 3073 "/libmdbx/src/core.c"
     ), 0))
    return (1);
  do { if ((0)) do { if (__builtin_expect(!!(!(((pl)[-1]) >= ((pl)[0]))), 0)) mdbx_assert_fail(
# 3075 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3075 "/libmdbx/src/core.c"
 , "((pl)[-1]) >= ((pl)[0])", __func__, 3075); } while (0); } while (0);
  if (__builtin_expect(!!(((pl)[-1]) < ((pl)[0])), 0))
    return (0);
  return mdbx_pnl_check(pl, limit);
}


static void __attribute__((__hot__)) __attribute__((__optimize__("O3"))) mdbx_pnl_xmerge(MDBX_PNL dst, const MDBX_PNL src) {
  do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_pnl_check4assert(dst, 0x7FFFffffU + 1))), 0)) mdbx_assert_fail(
# 3083 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3083 "/libmdbx/src/core.c"
 , "mdbx_pnl_check4assert(dst, 0x7FFFffffU + 1)", __func__, 3083); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_pnl_check(src, 0x7FFFffffU + 1))), 0)) mdbx_assert_fail(
# 3084 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3084 "/libmdbx/src/core.c"
 , "mdbx_pnl_check(src, 0x7FFFffffU + 1)", __func__, 3084); } while (0); } while (0);
  const size_t total = ((dst)[0]) + ((src)[0]);
  do { if ((0)) do { if (__builtin_expect(!!(!(((dst)[-1]) >= total)), 0)) mdbx_assert_fail(
# 3086 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3086 "/libmdbx/src/core.c"
 , "((dst)[-1]) >= total", __func__, 3086); } while (0); } while (0);
  pgno_t *w = dst + total;
  pgno_t *d = dst + ((dst)[0]);
  const pgno_t *s = src + ((src)[0]);
  dst[0] = (0 ? 0 : ~(pgno_t)0);
  while (s > src) {
    while (((*s) > (*d)))
      *w-- = *d--;
    *w-- = *s--;
  }
  ((dst)[0]) = (pgno_t)total;
  do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_pnl_check4assert(dst, 0x7FFFffffU + 1))), 0)) mdbx_assert_fail(
# 3097 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3097 "/libmdbx/src/core.c"
 , "mdbx_pnl_check4assert(dst, 0x7FFFffffU + 1)", __func__, 3097); } while (0); } while (0);
}

static void mdbx_spill_remove(MDBX_txn *txn, unsigned idx, unsigned npages) {
  do { if ((0)) do { if (__builtin_expect(!!(!(idx > 0 && idx <= ((txn->tw.spill_pages)[0]) && txn->tw.spill_least_removed > 0)), 0)) mdbx_assert_fail((txn)->mt_env, "idx > 0 && idx <= ((txn->tw.spill_pages)[0]) && txn->tw.spill_least_removed > 0", __func__, 3101); } while (0); } while (0)
                                                        ;
  txn->tw.spill_least_removed =
      (idx < txn->tw.spill_least_removed) ? idx : txn->tw.spill_least_removed;
  txn->tw.spill_pages[idx] |= 1;
  ((txn->tw.spill_pages)[0]) -=
      (idx == ((txn->tw.spill_pages)[0]));

  while (__builtin_expect(!!(npages > 1), 0)) {
    const pgno_t pgno = (txn->tw.spill_pages[idx] >> 1) + 1;
    if (0) {
      if (++idx > ((txn->tw.spill_pages)[0]) ||
          (txn->tw.spill_pages[idx] >> 1) != pgno)
        return;
    } else {
      if (--idx < 1 || (txn->tw.spill_pages[idx] >> 1) != pgno)
        return;
      txn->tw.spill_least_removed = (idx < txn->tw.spill_least_removed)
                                        ? idx
                                        : txn->tw.spill_least_removed;
    }
    txn->tw.spill_pages[idx] |= 1;
    ((txn->tw.spill_pages)[0]) -=
        (idx == ((txn->tw.spill_pages)[0]));
    --npages;
  }
}

static MDBX_PNL mdbx_spill_purge(MDBX_txn *txn) {
  do { if ((0)) do { if (__builtin_expect(!!(!(txn->tw.spill_least_removed > 0)), 0)) mdbx_assert_fail((txn)->mt_env, "txn->tw.spill_least_removed > 0", __func__, 3130); } while (0); } while (0);
  const MDBX_PNL sl = txn->tw.spill_pages;
  if (txn->tw.spill_least_removed != 0x7fffffff) {
    unsigned len = ((sl)[0]), r, w;
    for (w = r = txn->tw.spill_least_removed; r <= len; ++r) {
      sl[w] = sl[r];
      w += 1 - (sl[r] & 1);
    }
    for (size_t i = 1; i < w; ++i)
      do { if ((0)) do { if (__builtin_expect(!!(!((sl[i] & 1) == 0)), 0)) mdbx_assert_fail((txn)->mt_env, "(sl[i] & 1) == 0", __func__, 3139); } while (0); } while (0);
    ((sl)[0]) = w - 1;
    txn->tw.spill_least_removed = 0x7fffffff;
  } else {
    for (size_t i = 1; i <= ((sl)[0]); ++i)
      do { if ((0)) do { if (__builtin_expect(!!(!((sl[i] & 1) == 0)), 0)) mdbx_assert_fail((txn)->mt_env, "(sl[i] & 1) == 0", __func__, 3144); } while (0); } while (0);
  }
  return sl;
}






__attribute__((__hot__)) __attribute__((__optimize__("O3"))) static _Bool pgno_radixsort(pgno_t *const begin, const unsigned length) { pgno_t *tmp; if (1) { tmp = begin + length + 0; } else { tmp = malloc(sizeof(pgno_t) * length); if (__builtin_expect(!!(!tmp), 0)) return (0); } unsigned key_shift = 0, key_diff_mask; do { struct { unsigned a[256], b[256]; } counters; memset(&counters, 0, sizeof(counters)); key_diff_mask = 0; unsigned prev_key = ((~(pgno_t)0) - *(begin)) >> key_shift; pgno_t *r = begin, *end = begin + length; do { const unsigned key = ((~(pgno_t)0) - *(r)) >> key_shift; counters.a[key & 255]++; counters.b[(key >> 8) & 255]++; key_diff_mask |= prev_key ^ key; prev_key = key; } while (++r != end); unsigned ta = 0, tb = 0; for (unsigned i = 0; i < 256; ++i) { const unsigned ia = counters.a[i]; counters.a[i] = ta; ta += ia; const unsigned ib = counters.b[i]; counters.b[i] = tb; tb += ib; } r = begin; do { const unsigned key = ((~(pgno_t)0) - *(r)) >> key_shift; tmp[counters.a[key & 255]++] = *r; } while (++r != end); if (__builtin_expect(!!(key_diff_mask < 256), 0)) { memcpy(begin, tmp, (char *)end - (char *)begin); break; } end = (r = tmp) + length; do { const unsigned key = ((~(pgno_t)0) - *(r)) >> key_shift; begin[counters.b[(key >> 8) & 255]++] = *r; } while (++r != end); key_shift += 16; } while (key_diff_mask >> 16); if (!(1)) free(tmp); return (1); }


static __inline _Bool pgno_sort_is_sorted(const pgno_t *first, const pgno_t *last) { while (++first <= last) if (((first[0]) > (first[-1]))) return (0); return (1); } typedef struct { pgno_t *lo, *hi; } pgno_sort_stack; static __attribute__((__hot__)) __attribute__((__optimize__("O3"))) void pgno_sort(pgno_t *const begin, pgno_t *const end) { pgno_sort_stack stack[sizeof(unsigned) * 8], *top = stack; pgno_t *hi = end - 1; pgno_t *lo = begin; while ((1)) { const ptrdiff_t len = hi - lo; if (len < 16) { switch (len + 1) { default: __builtin_unreachable(); case 0: case 1: break; case 2: do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[1])); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); break; case 3: do { do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[1])); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); } while (0); break; case 4: do { do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[1])); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); } while (0); break; case 5: do { do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[0]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[2]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[1])); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); } while (0); break; case 6: do { do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[4]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[3]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[1])); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[2]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[0]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[2]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); } while (0); break; case 7: do { do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[0]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[1]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[2]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[4]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[2]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[3]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[1])); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[4]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[3]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); } while (0); break; case 8: do { do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[0]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[1]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[2]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[3]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[4]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[5]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[2]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[3]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[1])); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[4]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[3]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); } while (0); break; case 9: do { do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[1])); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[4]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[7]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[1])); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[2]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[0]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[5]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[3]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[4]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[2]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[0]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[5]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[2]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[4]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[2]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); } while (0); break; case 10: do { do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[4]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[3]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[2]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[1]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[0]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[6]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[0]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[5]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[3]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[7]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[1])); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[2]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[5]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[4]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[7]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[3]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[2]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[6]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[4]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[4]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); } while (0); break; case 11: do { do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[1])); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[4]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[5]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[4]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[8]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[9]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[0]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[3]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[1]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[6]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[4]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[5]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[2]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[0]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[3]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[1]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[6]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[7]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[3]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[6]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[2]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[7]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[7]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); } while (0); break; case 12: do { do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[1])); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[4]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[10]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[10]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[5]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[9]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[4]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[8]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[9]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[0]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[7]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[1]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[6]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[3]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[4]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[5]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[2]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[0]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[7]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[3]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[1]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[6]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[7]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[3]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[6]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[2]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[7]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[7]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); } while (0); break; case 13: do { do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[1]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[9]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[5]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[0]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[2]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[1])); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[4]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[8]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[7]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[5]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[3]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[10]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[10]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[6]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[7]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[11]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[11]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[4]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[6]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[10]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[10]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[1]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[2]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[9]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[4]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[8]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[0]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[2]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[6]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[9]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[3]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[7]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[4]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[4]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); } while (0); break; case 14: do { do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[1])); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[4]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[10]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[10]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[12]); const _Bool swap_cmp = ((swap_tmp) > (lo[13])); (lo[12]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[4]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[8]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[5]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[9]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[0]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[8]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[1]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[13])); (lo[9]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[2]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[3]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[0]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[1]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[2]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[3]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[4]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[13])); (lo[5]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[5]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[6]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[3]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[7]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[4]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[13])); (lo[7]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[2]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[9]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[2]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[11]); const _Bool swap_cmp = ((swap_tmp) > (lo[13])); (lo[11]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[3]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[7]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[6]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[10]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[10]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[3]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[7]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[7]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[9]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[11]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[11]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); } while (0); break; case 15: do { do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[1])); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[4]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[10]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[10]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[12]); const _Bool swap_cmp = ((swap_tmp) > (lo[13])); (lo[12]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[4]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[8]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[12]); const _Bool swap_cmp = ((swap_tmp) > (lo[14])); (lo[12]) = swap_cmp ? swap_tmp : lo[14]; (lo[14]) = swap_cmp ? lo[14] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[5]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[9]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[0]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[8]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[1]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[13])); (lo[9]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[2]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[10]); const _Bool swap_cmp = ((swap_tmp) > (lo[14])); (lo[10]) = swap_cmp ? swap_tmp : lo[14]; (lo[14]) = swap_cmp ? lo[14] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[3]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[0]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[1]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[2]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[3]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[4]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[13])); (lo[5]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[14])); (lo[6]) = swap_cmp ? swap_tmp : lo[14]; (lo[14]) = swap_cmp ? lo[14] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[5]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[6]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[3]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[13]); const _Bool swap_cmp = ((swap_tmp) > (lo[14])); (lo[13]) = swap_cmp ? swap_tmp : lo[14]; (lo[14]) = swap_cmp ? lo[14] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[7]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[4]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[13])); (lo[7]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[2]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[11]); const _Bool swap_cmp = ((swap_tmp) > (lo[14])); (lo[11]) = swap_cmp ? swap_tmp : lo[14]; (lo[14]) = swap_cmp ? lo[14] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[9]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[2]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[11]); const _Bool swap_cmp = ((swap_tmp) > (lo[13])); (lo[11]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[3]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[7]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[6]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[10]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[10]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[3]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[7]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[7]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[9]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[11]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[11]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); } while (0); break; case 16: do { do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[1])); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[4]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[10]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[10]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[12]); const _Bool swap_cmp = ((swap_tmp) > (lo[13])); (lo[12]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[14]); const _Bool swap_cmp = ((swap_tmp) > (lo[15])); (lo[14]) = swap_cmp ? swap_tmp : lo[15]; (lo[15]) = swap_cmp ? lo[15] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[4]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[8]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[12]); const _Bool swap_cmp = ((swap_tmp) > (lo[14])); (lo[12]) = swap_cmp ? swap_tmp : lo[14]; (lo[14]) = swap_cmp ? lo[14] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[5]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[9]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[13]); const _Bool swap_cmp = ((swap_tmp) > (lo[15])); (lo[13]) = swap_cmp ? swap_tmp : lo[15]; (lo[15]) = swap_cmp ? lo[15] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[0]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[8]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[1]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[13])); (lo[9]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[2]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[10]); const _Bool swap_cmp = ((swap_tmp) > (lo[14])); (lo[10]) = swap_cmp ? swap_tmp : lo[14]; (lo[14]) = swap_cmp ? lo[14] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[3]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[11]); const _Bool swap_cmp = ((swap_tmp) > (lo[15])); (lo[11]) = swap_cmp ? swap_tmp : lo[15]; (lo[15]) = swap_cmp ? lo[15] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[0]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[1]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[2]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[3]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[4]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[13])); (lo[5]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[14])); (lo[6]) = swap_cmp ? swap_tmp : lo[14]; (lo[14]) = swap_cmp ? lo[14] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[15])); (lo[7]) = swap_cmp ? swap_tmp : lo[15]; (lo[15]) = swap_cmp ? lo[15] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[5]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[6]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[3]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[13]); const _Bool swap_cmp = ((swap_tmp) > (lo[14])); (lo[13]) = swap_cmp ? swap_tmp : lo[14]; (lo[14]) = swap_cmp ? lo[14] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[7]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[4]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[13])); (lo[7]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[2]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[11]); const _Bool swap_cmp = ((swap_tmp) > (lo[14])); (lo[11]) = swap_cmp ? swap_tmp : lo[14]; (lo[14]) = swap_cmp ? lo[14] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[9]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[2]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[11]); const _Bool swap_cmp = ((swap_tmp) > (lo[13])); (lo[11]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[3]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[7]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[6]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[10]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[10]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[3]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[7]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[7]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[9]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[11]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[11]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const pgno_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); } while (0); break; }; if (__builtin_expect(!!(top == stack), 0)) break; do { --top; lo = top->lo; hi = top->hi; } while (0); continue; } pgno_t *mid = lo + (len >> 1); do { const pgno_t swap_tmp = (*lo); const _Bool swap_cmp = ((swap_tmp) > (*mid)); (*lo) = swap_cmp ? swap_tmp : *mid; (*mid) = swap_cmp ? *mid : swap_tmp; } while (0); do { const pgno_t swap_tmp = (*mid); const _Bool swap_cmp = ((swap_tmp) > (*hi)); (*mid) = swap_cmp ? swap_tmp : *hi; (*hi) = swap_cmp ? *hi : swap_tmp; } while (0); do { const pgno_t swap_tmp = (*lo); const _Bool swap_cmp = ((swap_tmp) > (*mid)); (*lo) = swap_cmp ? swap_tmp : *mid; (*mid) = swap_cmp ? *mid : swap_tmp; } while (0); pgno_t *right = hi - 1; pgno_t *left = lo + 1; while (1) { while (((*left) > (*mid))) ++left; while (((*mid) > (*right))) --right; if (__builtin_expect(!!(left > right), 0)) { if ((0)) { if (pgno_sort_is_sorted(lo, right)) lo = right + 1; if (pgno_sort_is_sorted(left, hi)) hi = left; } break; } do { const pgno_t swap_tmp = (*left); (*left) = (*right); (*right) = swap_tmp; } while (0); mid = (mid == left) ? right : (mid == right) ? left : mid; ++left; --right; } if (right - lo > hi - left) { do { top->lo = (lo); top->hi = (right); ++top; } while (0); lo = left; } else { do { top->lo = (left); top->hi = (hi); ++top; } while (0); hi = right; } } if ((0)) { for (pgno_t *scan = begin + 1; scan < end; ++scan) do { if ((0)) do { if (__builtin_expect(!!(!(((scan[-1]) > (scan[0])))), 0)) mdbx_assert_fail(
# 3157 "/libmdbx/src/core.c" 3 4
((void *)0)
# 3157 "/libmdbx/src/core.c"
, "((scan[-1]) > (scan[0]))", __func__, 3157); } while (0); } while (0); } }

static __attribute__((__hot__)) __attribute__((__optimize__("O3"))) void mdbx_pnl_sort_nochk(MDBX_PNL pnl) {
  if (__builtin_expect(!!(((pnl)[0]) < 333), 1) ||
      __builtin_expect(!!(!pgno_radixsort(&((pnl)[1]), ((pnl)[0]))), 0))
    pgno_sort((&(pnl)[1]), (&(pnl)[((pnl)[0]) + 1]));
}

static __inline void mdbx_pnl_sort(MDBX_PNL pnl, size_t limit4check) {
  mdbx_pnl_sort_nochk(pnl);
  do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_pnl_check(pnl, limit4check))), 0)) mdbx_assert_fail(
# 3167 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3167 "/libmdbx/src/core.c"
 , "mdbx_pnl_check(pnl, limit4check)", __func__, 3167); } while (0); } while (0);
  (void)limit4check;
}



static 
# 3173 "/libmdbx/src/core.c" 3 4
__inline __attribute__ ((__always_inline__)) 
# 3173 "/libmdbx/src/core.c"
const pgno_t *pgno_bsearch( const pgno_t *first, unsigned length, const pgno_t item) { const pgno_t *const begin = first, *const end = begin + length; while (length > 3) { const unsigned whole = length; length >>= 1; const pgno_t *const middle = first + length; const unsigned left = whole - length - 1; const _Bool cmp = ((*middle) > (item)); length = cmp ? left : length; first = cmp ? middle + 1 : first; } switch (length) { case 3: if (!((*first) > (item))) break; ++first; __attribute__((__fallthrough__)) ; case 2: if (!((*first) > (item))) break; ++first; __attribute__((__fallthrough__)) ; case 1: if (!((*first) > (item))) break; ++first; __attribute__((__fallthrough__)) ; case 0: break; default: __builtin_unreachable(); } if ((0)) { for (const pgno_t *scan = begin; scan < first; ++scan) do { if ((0)) do { if (__builtin_expect(!!(!(((*scan) > (item)))), 0)) mdbx_assert_fail(
# 3173 "/libmdbx/src/core.c" 3 4
((void *)0)
# 3173 "/libmdbx/src/core.c"
, "((*scan) > (item))", __func__, 3173); } while (0); } while (0); for (const pgno_t *scan = first; scan < end; ++scan) do { if ((0)) do { if (__builtin_expect(!!(!(!((*scan) > (item)))), 0)) mdbx_assert_fail(
# 3173 "/libmdbx/src/core.c" 3 4
((void *)0)
# 3173 "/libmdbx/src/core.c"
, "!((*scan) > (item))", __func__, 3173); } while (0); } while (0); (void)begin, (void)end; } return first; }

static __attribute__((__hot__)) __attribute__((__optimize__("O3"))) unsigned mdbx_pnl_search_nochk(const MDBX_PNL pnl, pgno_t pgno) {
  const pgno_t *begin = (&(pnl)[1]);
  const pgno_t *it = pgno_bsearch(begin, ((pnl)[0]), pgno);
  const pgno_t *end = begin + ((pnl)[0]);
  do { if ((0)) do { if (__builtin_expect(!!(!(it >= begin && it <= end)), 0)) mdbx_assert_fail(
# 3179 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3179 "/libmdbx/src/core.c"
 , "it >= begin && it <= end", __func__, 3179); } while (0); } while (0);
  if (it != begin)
    do { if ((0)) do { if (__builtin_expect(!!(!(((it[-1]) > (pgno)))), 0)) mdbx_assert_fail(
# 3181 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 3181 "/libmdbx/src/core.c"
   , "((it[-1]) > (pgno))", __func__, 3181); } while (0); } while (0);
  if (it != end)
    do { if ((0)) do { if (__builtin_expect(!!(!(!((it[0]) > (pgno)))), 0)) mdbx_assert_fail(
# 3183 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 3183 "/libmdbx/src/core.c"
   , "!((it[0]) > (pgno))", __func__, 3183); } while (0); } while (0);
  return (unsigned)(it - begin + 1);
}

static __inline unsigned mdbx_pnl_search(const MDBX_PNL pnl, pgno_t pgno,
                                         size_t limit) {
  do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_pnl_check4assert(pnl, limit))), 0)) mdbx_assert_fail(
# 3189 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3189 "/libmdbx/src/core.c"
 , "mdbx_pnl_check4assert(pnl, limit)", __func__, 3189); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(pgno < limit)), 0)) mdbx_assert_fail(
# 3190 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3190 "/libmdbx/src/core.c"
 , "pgno < limit", __func__, 3190); } while (0); } while (0);
  (void)limit;
  return mdbx_pnl_search_nochk(pnl, pgno);
}

static __inline unsigned mdbx_search_spilled(const MDBX_txn *txn, pgno_t pgno) {
  const MDBX_PNL pnl = txn->tw.spill_pages;
  if (__builtin_expect(!!(!pnl), 1))
    return 0;
  pgno <<= 1;
  unsigned n = mdbx_pnl_search(pnl, pgno, (size_t)(0x7FFFffffU + 1) << 1);
  return (n <= ((pnl)[0]) && pnl[n] == pgno) ? n : 0;
}

static __inline _Bool mdbx_intersect_spilled(const MDBX_txn *txn, pgno_t pgno,
                                            unsigned npages) {
  const MDBX_PNL pnl = txn->tw.spill_pages;
  if (__builtin_expect(!!(!pnl), 1))
    return (0);
  const unsigned len = ((pnl)[0]);
  if ((MDBX_LOG_EXTRA < MDBX_LOG_VERBOSE && MDBX_LOG_EXTRA <= mdbx_loglevel)) {
    do { if ((MDBX_LOG_EXTRA < MDBX_LOG_VERBOSE && MDBX_LOG_EXTRA <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_EXTRA, __func__, 3211, "PNL len %u [", len); } while (0);
    for (unsigned i = 1; i <= len; ++i)
      do { if ((MDBX_LOG_EXTRA < MDBX_LOG_VERBOSE && MDBX_LOG_EXTRA <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_EXTRA, 
# 3213 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 3213 "/libmdbx/src/core.c"
     , 0, " %li", (pnl[i] & 1) ? -(long)(pnl[i] >> 1) : (long)(pnl[i] >> 1)); } while (0)
                                                                        ;
    do { if ((MDBX_LOG_EXTRA < MDBX_LOG_VERBOSE && MDBX_LOG_EXTRA <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_EXTRA, 
# 3215 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 3215 "/libmdbx/src/core.c"
   , 0, "%s\n", "]"); } while (0);
  }
  const pgno_t spilled_range_begin = pgno << 1;
  const pgno_t spilled_range_last = ((pgno + npages) << 1) - 1;






  const unsigned n =
      mdbx_pnl_search(pnl, spilled_range_last, (size_t)(0x7FFFffffU + 1) << 1);
  do { if ((0)) do { if (__builtin_expect(!!(!(n && (n == ((pnl)[0]) + 1 || spilled_range_last >= pnl[n]))), 0)) mdbx_assert_fail(
# 3227 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3227 "/libmdbx/src/core.c"
 , "n && (n == ((pnl)[0]) + 1 || spilled_range_last >= pnl[n])", __func__, 3227); } while (0); } while (0);
  const _Bool rc = n <= ((pnl)[0]) && pnl[n] >= spilled_range_begin;

  if ((0)) {
    _Bool check = (0);
    for (unsigned i = 0; i < npages; ++i)
      check |= mdbx_search_spilled(txn, pgno + i) != 0;
    do { if ((0)) do { if (__builtin_expect(!!(!(check == rc)), 0)) mdbx_assert_fail(
# 3234 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 3234 "/libmdbx/src/core.c"
   , "check == rc", __func__, 3234); } while (0); } while (0);
  }
  return rc;
}



static 
# 3241 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 3241 "/libmdbx/src/core.c"
                      size_t txl2bytes(const size_t size) {
  do { if ((0)) do { if (__builtin_expect(!!(!(size > 0 && size <= ((1u << 17) - 2 - (8 * 2u) / sizeof(txnid_t)) * 2)), 0)) mdbx_assert_fail(
# 3242 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3242 "/libmdbx/src/core.c"
 , "size > 0 && size <= ((1u << 17) - 2 - (8 * 2u) / sizeof(txnid_t)) * 2", __func__, 3242); } while (0); } while (0);
  size_t bytes =
      ceil_powerof2((8 * 2u) + sizeof(txnid_t) * (size + 2),
                    32 * sizeof(txnid_t)) -
      (8 * 2u);
  return bytes;
}

static 
# 3250 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 3250 "/libmdbx/src/core.c"
                      size_t bytes2txl(const size_t bytes) {
  size_t size = bytes / sizeof(txnid_t);
  do { if ((0)) do { if (__builtin_expect(!!(!(size > 2 && size <= ((1u << 17) - 2 - (8 * 2u) / sizeof(txnid_t)) * 2)), 0)) mdbx_assert_fail(
# 3252 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3252 "/libmdbx/src/core.c"
 , "size > 2 && size <= ((1u << 17) - 2 - (8 * 2u) / sizeof(txnid_t)) * 2", __func__, 3252); } while (0); } while (0);
  return size - 2;
}

static MDBX_TXL mdbx_txl_alloc(void) {
  size_t bytes = txl2bytes((32 - 2 - (8 * 2u) / sizeof(txnid_t)));
  MDBX_TXL tl = malloc(bytes);
  if (__builtin_expect(!!(tl), 1)) {

    bytes = malloc_usable_size(tl);

    tl[0] = bytes2txl(bytes);
    do { if ((0)) do { if (__builtin_expect(!!(!(tl[0] >= (32 - 2 - (8 * 2u) / sizeof(txnid_t)))), 0)) mdbx_assert_fail(
# 3264 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 3264 "/libmdbx/src/core.c"
   , "tl[0] >= (32 - 2 - (8 * 2u) / sizeof(txnid_t))", __func__, 3264); } while (0); } while (0);
    tl[1] = 0;
    tl += 1;
  }
  return tl;
}

static void mdbx_txl_free(MDBX_TXL tl) {
  if (__builtin_expect(!!(tl), 1))
    free(tl - 1);
}

static int mdbx_txl_reserve(MDBX_TXL *ptl, const size_t wanna) {
  const size_t allocated = (size_t)((*ptl)[-1]);
  do { if ((0)) do { if (__builtin_expect(!!(!(((*ptl)[0]) <= ((1u << 17) - 2 - (8 * 2u) / sizeof(txnid_t)) && ((*ptl)[-1]) >= ((*ptl)[0]))), 0)) mdbx_assert_fail(
# 3278 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3278 "/libmdbx/src/core.c"
 , "((*ptl)[0]) <= ((1u << 17) - 2 - (8 * 2u) / sizeof(txnid_t)) && ((*ptl)[-1]) >= ((*ptl)[0])", __func__, 3278); } while (0); } while (0)
                                                        ;
  if (__builtin_expect(!!(allocated >= wanna), 1))
    return MDBX_SUCCESS;

  if (__builtin_expect(!!(wanna > ((1u << 17) - 2 - (8 * 2u) / sizeof(txnid_t))), 0)) {
    do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 3284, "TXL too long (%zu > %zu)" "\n", wanna, (size_t)((1u << 17) - 2 - (8 * 2u) / sizeof(txnid_t))); } while (0);
    return MDBX_TXN_FULL;
  }

  const size_t size = (wanna + wanna - allocated < ((1u << 17) - 2 - (8 * 2u) / sizeof(txnid_t)))
                          ? wanna + wanna - allocated
                          : ((1u << 17) - 2 - (8 * 2u) / sizeof(txnid_t));
  size_t bytes = txl2bytes(size);
  MDBX_TXL tl = realloc(*ptl - 1, bytes);
  if (__builtin_expect(!!(tl), 1)) {

    bytes = malloc_usable_size(tl);

    *tl = bytes2txl(bytes);
    do { if ((0)) do { if (__builtin_expect(!!(!(*tl >= wanna)), 0)) mdbx_assert_fail(
# 3298 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 3298 "/libmdbx/src/core.c"
   , "*tl >= wanna", __func__, 3298); } while (0); } while (0);
    *ptl = tl + 1;
    return MDBX_SUCCESS;
  }
  return MDBX_ENOMEM;
}

static 
# 3305 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 3305 "/libmdbx/src/core.c"
                      int __attribute__((__warn_unused_result__)) mdbx_txl_need(MDBX_TXL *ptl,
                                                             size_t num) {
  do { if ((0)) do { if (__builtin_expect(!!(!(((*ptl)[0]) <= ((1u << 17) - 2 - (8 * 2u) / sizeof(txnid_t)) && ((*ptl)[-1]) >= ((*ptl)[0]))), 0)) mdbx_assert_fail(
# 3307 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3307 "/libmdbx/src/core.c"
 , "((*ptl)[0]) <= ((1u << 17) - 2 - (8 * 2u) / sizeof(txnid_t)) && ((*ptl)[-1]) >= ((*ptl)[0])", __func__, 3307); } while (0); } while (0)
                                                        ;
  do { if ((0)) do { if (__builtin_expect(!!(!(num <= ((size_t)0x7FFFffffU))), 0)) mdbx_assert_fail(
# 3309 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3309 "/libmdbx/src/core.c"
 , "num <= ((size_t)0x7FFFffffU)", __func__, 3309); } while (0); } while (0);
  const size_t wanna = (size_t)((*ptl)[0]) + num;
  return __builtin_expect(!!(((*ptl)[-1]) >= wanna), 1)
             ? MDBX_SUCCESS
             : mdbx_txl_reserve(ptl, wanna);
}

static 
# 3316 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 3316 "/libmdbx/src/core.c"
                      void mdbx_txl_xappend(MDBX_TXL tl, txnid_t id) {
  do { if ((0)) do { if (__builtin_expect(!!(!(((tl)[0]) < ((tl)[-1]))), 0)) mdbx_assert_fail(
# 3317 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3317 "/libmdbx/src/core.c"
 , "((tl)[0]) < ((tl)[-1])", __func__, 3317); } while (0); } while (0);
  ((tl)[0]) += 1;
  ((tl)[((tl)[0])]) = id;
}


static __inline _Bool txnid_sort_is_sorted(const txnid_t *first, const txnid_t *last) { while (++first <= last) if (((first[0]) > (first[-1]))) return (0); return (1); } typedef struct { txnid_t *lo, *hi; } txnid_sort_stack; static __attribute__((__hot__)) __attribute__((__optimize__("O3"))) void txnid_sort(txnid_t *const begin, txnid_t *const end) { txnid_sort_stack stack[sizeof(unsigned) * 8], *top = stack; txnid_t *hi = end - 1; txnid_t *lo = begin; while ((1)) { const ptrdiff_t len = hi - lo; if (len < 16) { switch (len + 1) { default: __builtin_unreachable(); case 0: case 1: break; case 2: do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[1])); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); break; case 3: do { do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[1])); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); } while (0); break; case 4: do { do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[1])); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); } while (0); break; case 5: do { do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[0]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[2]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[1])); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); } while (0); break; case 6: do { do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[4]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[3]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[1])); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[2]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[0]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[2]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); } while (0); break; case 7: do { do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[0]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[1]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[2]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[4]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[2]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[3]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[1])); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[4]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[3]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); } while (0); break; case 8: do { do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[0]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[1]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[2]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[3]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[4]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[5]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[2]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[3]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[1])); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[4]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[3]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); } while (0); break; case 9: do { do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[1])); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[4]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[7]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[1])); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[2]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[0]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[5]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[3]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[4]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[2]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[0]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[5]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[2]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[4]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[2]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); } while (0); break; case 10: do { do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[4]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[3]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[2]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[1]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[0]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[6]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[0]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[5]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[3]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[7]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[1])); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[2]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[5]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[4]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[7]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[3]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[2]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[6]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[4]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[4]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); } while (0); break; case 11: do { do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[1])); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[4]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[5]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[4]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[8]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[9]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[0]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[3]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[1]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[6]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[4]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[5]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[2]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[0]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[3]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[1]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[6]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[7]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[3]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[6]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[2]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[7]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[7]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); } while (0); break; case 12: do { do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[1])); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[4]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[10]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[10]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[5]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[9]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[4]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[8]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[9]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[0]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[7]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[1]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[6]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[3]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[4]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[5]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[2]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[0]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[7]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[3]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[1]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[6]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[7]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[3]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[6]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[2]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[7]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[7]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); } while (0); break; case 13: do { do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[1]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[9]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[5]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[0]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[2]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[1])); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[4]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[8]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[7]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[5]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[3]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[10]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[10]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[6]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[7]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[11]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[11]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[4]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[6]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[10]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[10]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[1]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[2]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[9]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[4]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[8]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[0]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[2]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[6]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[9]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[3]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[7]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[4]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[4]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); } while (0); break; case 14: do { do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[1])); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[4]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[10]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[10]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[12]); const _Bool swap_cmp = ((swap_tmp) > (lo[13])); (lo[12]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[4]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[8]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[5]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[9]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[0]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[8]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[1]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[13])); (lo[9]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[2]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[3]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[0]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[1]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[2]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[3]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[4]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[13])); (lo[5]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[5]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[6]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[3]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[7]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[4]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[13])); (lo[7]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[2]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[9]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[2]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[11]); const _Bool swap_cmp = ((swap_tmp) > (lo[13])); (lo[11]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[3]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[7]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[6]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[10]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[10]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[3]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[7]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[7]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[9]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[11]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[11]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); } while (0); break; case 15: do { do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[1])); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[4]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[10]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[10]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[12]); const _Bool swap_cmp = ((swap_tmp) > (lo[13])); (lo[12]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[4]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[8]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[12]); const _Bool swap_cmp = ((swap_tmp) > (lo[14])); (lo[12]) = swap_cmp ? swap_tmp : lo[14]; (lo[14]) = swap_cmp ? lo[14] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[5]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[9]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[0]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[8]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[1]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[13])); (lo[9]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[2]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[10]); const _Bool swap_cmp = ((swap_tmp) > (lo[14])); (lo[10]) = swap_cmp ? swap_tmp : lo[14]; (lo[14]) = swap_cmp ? lo[14] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[3]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[0]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[1]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[2]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[3]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[4]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[13])); (lo[5]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[14])); (lo[6]) = swap_cmp ? swap_tmp : lo[14]; (lo[14]) = swap_cmp ? lo[14] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[5]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[6]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[3]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[13]); const _Bool swap_cmp = ((swap_tmp) > (lo[14])); (lo[13]) = swap_cmp ? swap_tmp : lo[14]; (lo[14]) = swap_cmp ? lo[14] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[7]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[4]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[13])); (lo[7]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[2]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[11]); const _Bool swap_cmp = ((swap_tmp) > (lo[14])); (lo[11]) = swap_cmp ? swap_tmp : lo[14]; (lo[14]) = swap_cmp ? lo[14] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[9]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[2]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[11]); const _Bool swap_cmp = ((swap_tmp) > (lo[13])); (lo[11]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[3]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[7]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[6]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[10]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[10]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[3]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[7]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[7]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[9]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[11]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[11]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); } while (0); break; case 16: do { do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[1])); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[4]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[10]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[10]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[12]); const _Bool swap_cmp = ((swap_tmp) > (lo[13])); (lo[12]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[14]); const _Bool swap_cmp = ((swap_tmp) > (lo[15])); (lo[14]) = swap_cmp ? swap_tmp : lo[15]; (lo[15]) = swap_cmp ? lo[15] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[4]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[8]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[12]); const _Bool swap_cmp = ((swap_tmp) > (lo[14])); (lo[12]) = swap_cmp ? swap_tmp : lo[14]; (lo[14]) = swap_cmp ? lo[14] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[3])); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[5]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[9]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[13]); const _Bool swap_cmp = ((swap_tmp) > (lo[15])); (lo[13]) = swap_cmp ? swap_tmp : lo[15]; (lo[15]) = swap_cmp ? lo[15] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[0]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[8]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[1]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[13])); (lo[9]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[2]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[10]); const _Bool swap_cmp = ((swap_tmp) > (lo[14])); (lo[10]) = swap_cmp ? swap_tmp : lo[14]; (lo[14]) = swap_cmp ? lo[14] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[3]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[11]); const _Bool swap_cmp = ((swap_tmp) > (lo[15])); (lo[11]) = swap_cmp ? swap_tmp : lo[15]; (lo[15]) = swap_cmp ? lo[15] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[0]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[1]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[2]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[3]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[4]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[13])); (lo[5]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[14])); (lo[6]) = swap_cmp ? swap_tmp : lo[14]; (lo[14]) = swap_cmp ? lo[14] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[15])); (lo[7]) = swap_cmp ? swap_tmp : lo[15]; (lo[15]) = swap_cmp ? lo[15] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[5]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[6]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[3]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[13]); const _Bool swap_cmp = ((swap_tmp) > (lo[14])); (lo[13]) = swap_cmp ? swap_tmp : lo[14]; (lo[14]) = swap_cmp ? lo[14] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[11])); (lo[7]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[2])); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[4]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[13])); (lo[7]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[2]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[11]); const _Bool swap_cmp = ((swap_tmp) > (lo[14])); (lo[11]) = swap_cmp ? swap_tmp : lo[14]; (lo[14]) = swap_cmp ? lo[14] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[9]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[2]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[11]); const _Bool swap_cmp = ((swap_tmp) > (lo[13])); (lo[11]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[3]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[7]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[6]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[10]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[10]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[5])); (lo[3]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[7]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp) > (lo[4])); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp) > (lo[6])); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp) > (lo[8])); (lo[7]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp) > (lo[10])); (lo[9]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[11]); const _Bool swap_cmp = ((swap_tmp) > (lo[12])); (lo[11]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp) > (lo[7])); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const txnid_t swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp) > (lo[9])); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); } while (0); break; }; if (__builtin_expect(!!(top == stack), 0)) break; do { --top; lo = top->lo; hi = top->hi; } while (0); continue; } txnid_t *mid = lo + (len >> 1); do { const txnid_t swap_tmp = (*lo); const _Bool swap_cmp = ((swap_tmp) > (*mid)); (*lo) = swap_cmp ? swap_tmp : *mid; (*mid) = swap_cmp ? *mid : swap_tmp; } while (0); do { const txnid_t swap_tmp = (*mid); const _Bool swap_cmp = ((swap_tmp) > (*hi)); (*mid) = swap_cmp ? swap_tmp : *hi; (*hi) = swap_cmp ? *hi : swap_tmp; } while (0); do { const txnid_t swap_tmp = (*lo); const _Bool swap_cmp = ((swap_tmp) > (*mid)); (*lo) = swap_cmp ? swap_tmp : *mid; (*mid) = swap_cmp ? *mid : swap_tmp; } while (0); txnid_t *right = hi - 1; txnid_t *left = lo + 1; while (1) { while (((*left) > (*mid))) ++left; while (((*mid) > (*right))) --right; if (__builtin_expect(!!(left > right), 0)) { if ((0)) { if (txnid_sort_is_sorted(lo, right)) lo = right + 1; if (txnid_sort_is_sorted(left, hi)) hi = left; } break; } do { const txnid_t swap_tmp = (*left); (*left) = (*right); (*right) = swap_tmp; } while (0); mid = (mid == left) ? right : (mid == right) ? left : mid; ++left; --right; } if (right - lo > hi - left) { do { top->lo = (lo); top->hi = (right); ++top; } while (0); lo = left; } else { do { top->lo = (left); top->hi = (hi); ++top; } while (0); hi = right; } } if ((0)) { for (txnid_t *scan = begin + 1; scan < end; ++scan) do { if ((0)) do { if (__builtin_expect(!!(!(((scan[-1]) > (scan[0])))), 0)) mdbx_assert_fail(
# 3323 "/libmdbx/src/core.c" 3 4
((void *)0)
# 3323 "/libmdbx/src/core.c"
, "((scan[-1]) > (scan[0]))", __func__, 3323); } while (0); } while (0); } }
static void mdbx_txl_sort(MDBX_TXL tl) {
  txnid_sort((&(tl)[1]), (&(tl)[((tl)[0]) + 1]));
}

static int __attribute__((__warn_unused_result__)) mdbx_txl_append(MDBX_TXL *ptl, txnid_t id) {
  if (__builtin_expect(!!(((*ptl)[0]) == ((*ptl)[-1])), 0)) {
    int rc = mdbx_txl_need(ptl, 32);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      return rc;
  }
  mdbx_txl_xappend(*ptl, id);
  return MDBX_SUCCESS;
}
# 3346 "/libmdbx/src/core.c"
static 
# 3346 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 3346 "/libmdbx/src/core.c"
                      size_t dpl2bytes(ptrdiff_t size) {
  do { if ((0)) do { if (__builtin_expect(!!(!(size > 32 && (size_t)size <= ((size_t)0x7FFFffffU))), 0)) mdbx_assert_fail(
# 3347 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3347 "/libmdbx/src/core.c"
 , "size > 32 && (size_t)size <= ((size_t)0x7FFFffffU)", __func__, 3347); } while (0); } while (0);

  size += size;

  _Static_assert((8 * 2u) + sizeof(MDBX_dpl) + (((size_t)0x7FFFffffU) * (1 + 1) + (16 + 2)) * sizeof(MDBX_dp) + 1024 * sizeof(void *) * 2 < 
# 3351 "/libmdbx/src/core.c" 3 4
 (18446744073709551615UL) 
# 3351 "/libmdbx/src/core.c"
 / 4 * 3, "MDBX_ASSUME_MALLOC_OVERHEAD + sizeof(MDBX_dpl) + (MDBX_PGL_LIMIT * (MDBX_DPL_PREALLOC_FOR_RADIXSORT + 1) + MDBX_DPL_RESERVE_GAP) * sizeof(MDBX_dp) + MDBX_PNL_GRANULATE * sizeof(void *) * 2 < SIZE_MAX / 4 * 3")




                                 ;
  size_t bytes =
      ceil_powerof2((8 * 2u) + sizeof(MDBX_dpl) +
                        ((size_t)size + (16 + 2)) * sizeof(MDBX_dp),
                    1024 * sizeof(void *) * 2) -
      (8 * 2u);
  return bytes;
}

static 
# 3365 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 3365 "/libmdbx/src/core.c"
                      unsigned bytes2dpl(const ptrdiff_t bytes) {
  size_t size = (bytes - sizeof(MDBX_dpl)) / sizeof(MDBX_dp);
  do { if ((0)) do { if (__builtin_expect(!!(!(size > 32 + (16 + 2) && size <= ((size_t)0x7FFFffffU) + 1024)), 0)) mdbx_assert_fail(
# 3367 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3367 "/libmdbx/src/core.c"
 , "size > 32 + (16 + 2) && size <= ((size_t)0x7FFFffffU) + 1024", __func__, 3367); } while (0); } while (0)
                                                     ;
  size -= (16 + 2);

  size >>= 1;

  return (unsigned)size;
}

static 
# 3376 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 3376 "/libmdbx/src/core.c"
                      unsigned dpl_setlen(MDBX_dpl *dl, unsigned len) {
  static const MDBX_page dpl_stub_pageE = {
      {0}, 0, 0x10, {0}, ~(pgno_t)0};
  do { if ((0)) do { if (__builtin_expect(!!(!(dpl_stub_pageE.mp_flags == 0x10 && dpl_stub_pageE.mp_pgno == (~(pgno_t)0))), 0)) mdbx_assert_fail(
# 3379 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3379 "/libmdbx/src/core.c"
 , "dpl_stub_pageE.mp_flags == 0x10 && dpl_stub_pageE.mp_pgno == (~(pgno_t)0)", __func__, 3379); } while (0); } while (0)
                                             ;
  dl->length = len;
  dl->items[len + 1].ptr = (MDBX_page *)&dpl_stub_pageE;
  dl->items[len + 1].pgno = (~(pgno_t)0);
  dl->items[len + 1].extra = 0;
  return len;
}

static 
# 3388 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 3388 "/libmdbx/src/core.c"
                      void dpl_clear(MDBX_dpl *dl) {
  static const MDBX_page dpl_stub_pageB = {{0}, 0, 0x10, {0}, 0};
  do { if ((0)) do { if (__builtin_expect(!!(!(dpl_stub_pageB.mp_flags == 0x10 && dpl_stub_pageB.mp_pgno == 0)), 0)) mdbx_assert_fail(
# 3390 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3390 "/libmdbx/src/core.c"
 , "dpl_stub_pageB.mp_flags == 0x10 && dpl_stub_pageB.mp_pgno == 0", __func__, 3390); } while (0); } while (0);
  dl->sorted = dpl_setlen(dl, 0);
  dl->items[0].ptr = (MDBX_page *)&dpl_stub_pageB;
  dl->items[0].pgno = 0;
  dl->items[0].extra = 0;
  do { if ((0)) do { if (__builtin_expect(!!(!(dl->items[0].pgno == 0 && dl->items[dl->length + 1].pgno == (~(pgno_t)0))), 0)) mdbx_assert_fail(
# 3395 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3395 "/libmdbx/src/core.c"
 , "dl->items[0].pgno == 0 && dl->items[dl->length + 1].pgno == (~(pgno_t)0)", __func__, 3395); } while (0); } while (0);
}

static void mdbx_dpl_free(MDBX_txn *txn) {
  if (__builtin_expect(!!(txn->tw.dirtylist), 1)) {
    free(txn->tw.dirtylist);
    txn->tw.dirtylist = 
# 3401 "/libmdbx/src/core.c" 3 4
                       ((void *)0)
# 3401 "/libmdbx/src/core.c"
                           ;
  }
}

static MDBX_dpl *mdbx_dpl_reserve(MDBX_txn *txn, size_t size) {
  size_t bytes = dpl2bytes((size < ((size_t)0x7FFFffffU)) ? size : ((size_t)0x7FFFffffU));
  MDBX_dpl *const dl = realloc(txn->tw.dirtylist, bytes);
  if (__builtin_expect(!!(dl), 1)) {

    bytes = malloc_usable_size(dl);

    dl->detent = bytes2dpl(bytes);
    do { if ((0)) do { if (__builtin_expect(!!(!(txn->tw.dirtylist == 
# 3413 "/libmdbx/src/core.c" 3 4
   ((void *)0) 
# 3413 "/libmdbx/src/core.c"
   || dl->length <= dl->detent)), 0)) mdbx_assert_fail((txn)->mt_env, "txn->tw.dirtylist == ((void *)0) || dl->length <= dl->detent", __func__, 3413); } while (0); } while (0);
    txn->tw.dirtylist = dl;
  }
  return dl;
}

static int mdbx_dpl_alloc(MDBX_txn *txn) {
  do { if ((0)) do { if (__builtin_expect(!!(!((txn->mt_flags & MDBX_TXN_RDONLY) == 0)), 0)) mdbx_assert_fail((txn)->mt_env, "(txn->mt_flags & MDBX_TXN_RDONLY) == 0", __func__, 3420); } while (0); } while (0);
  const int wanna = (txn->mt_env->me_options.dp_initial < txn->mt_geo.upper)
                        ? txn->mt_env->me_options.dp_initial
                        : txn->mt_geo.upper;
  if (txn->tw.dirtylist) {
    dpl_clear(txn->tw.dirtylist);
    const int realloc_threshold = 64;
    if (__builtin_expect(!!(!((int)(txn->tw.dirtylist->detent - wanna) > realloc_threshold || (int)(txn->tw.dirtylist->detent - wanna) < -realloc_threshold)), 1)

                                                                             )
      return MDBX_SUCCESS;
  }
  if (__builtin_expect(!!(!mdbx_dpl_reserve(txn, wanna)), 0))
    return MDBX_ENOMEM;
  dpl_clear(txn->tw.dirtylist);
  return MDBX_SUCCESS;
}


__attribute__((__hot__)) __attribute__((__optimize__("O3"))) static _Bool dpl_radixsort(MDBX_dp *const begin, const unsigned length) { MDBX_dp *tmp; if (1) { tmp = begin + length + 1; } else { tmp = malloc(sizeof(MDBX_dp) * length); if (__builtin_expect(!!(!tmp), 0)) return (0); } unsigned key_shift = 0, key_diff_mask; do { struct { unsigned a[256], b[256]; } counters; memset(&counters, 0, sizeof(counters)); key_diff_mask = 0; unsigned prev_key = ((begin)->pgno) >> key_shift; MDBX_dp *r = begin, *end = begin + length; do { const unsigned key = ((r)->pgno) >> key_shift; counters.a[key & 255]++; counters.b[(key >> 8) & 255]++; key_diff_mask |= prev_key ^ key; prev_key = key; } while (++r != end); unsigned ta = 0, tb = 0; for (unsigned i = 0; i < 256; ++i) { const unsigned ia = counters.a[i]; counters.a[i] = ta; ta += ia; const unsigned ib = counters.b[i]; counters.b[i] = tb; tb += ib; } r = begin; do { const unsigned key = ((r)->pgno) >> key_shift; tmp[counters.a[key & 255]++] = *r; } while (++r != end); if (__builtin_expect(!!(key_diff_mask < 256), 0)) { memcpy(begin, tmp, (char *)end - (char *)begin); break; } end = (r = tmp) + length; do { const unsigned key = ((r)->pgno) >> key_shift; begin[counters.b[(key >> 8) & 255]++] = *r; } while (++r != end); key_shift += 16; } while (key_diff_mask >> 16); if (!(1)) free(tmp); return (1); }



static __inline _Bool dp_sort_is_sorted(const MDBX_dp *first, const MDBX_dp *last) { while (++first <= last) if (((first[0]).pgno < (first[-1]).pgno)) return (0); return (1); } typedef struct { MDBX_dp *lo, *hi; } dp_sort_stack; static __attribute__((__hot__)) __attribute__((__optimize__("O3"))) void dp_sort(MDBX_dp *const begin, MDBX_dp *const end) { dp_sort_stack stack[sizeof(unsigned) * 8], *top = stack; MDBX_dp *hi = end - 1; MDBX_dp *lo = begin; while ((1)) { const ptrdiff_t len = hi - lo; if (len < 16) { switch (len + 1) { default: __builtin_unreachable(); case 0: case 1: break; case 2: do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[1]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); break; case 3: do { do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[2]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[2]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[1]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); } while (0); break; case 4: do { do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[1]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[3]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[2]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[3]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[2]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); } while (0); break; case 5: do { do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[3]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[2]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[1]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[3]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[2]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); } while (0); break; case 6: do { do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[2]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[2]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[1]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[3]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[3]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[3]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); } while (0); break; case 7: do { do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[2]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[3]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[1]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[3]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[2]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); } while (0); break; case 8: do { do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[7]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[2]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[3]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[7]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[1]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[7]).pgno); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[3]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[2]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); } while (0); break; case 9: do { do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[1]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[7]).pgno); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[2]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[7]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[1]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[7]).pgno); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[3]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[7]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[3]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[7]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[3]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[3]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); } while (0); break; case 10: do { do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[9]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[7]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[9]).pgno); (lo[6]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[3]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[2]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[9]).pgno); (lo[7]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[1]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[7]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[9]).pgno); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[2]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[7]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[6]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[3]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[7]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[3]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[7]).pgno); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); } while (0); break; case 11: do { do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[1]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[3]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[7]).pgno); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[9]).pgno); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[3]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[7]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[2]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[10]).pgno); (lo[8]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[2]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[10]).pgno); (lo[9]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[7]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[10]).pgno); (lo[6]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[9]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[10]).pgno); (lo[6]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[3]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[9]).pgno); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[10]).pgno); (lo[7]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[6]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[9]).pgno); (lo[7]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[7]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); } while (0); break; case 12: do { do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[1]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[3]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[7]).pgno); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[9]).pgno); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[10]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[11]).pgno); (lo[10]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[3]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[7]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[11]).pgno); (lo[9]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[2]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[10]).pgno); (lo[8]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[2]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[10]).pgno); (lo[9]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[11]).pgno); (lo[7]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[10]).pgno); (lo[6]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[7]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[9]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[11]).pgno); (lo[7]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[10]).pgno); (lo[6]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[3]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[9]).pgno); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[10]).pgno); (lo[7]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[6]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[9]).pgno); (lo[7]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[7]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); } while (0); break; case 13: do { do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[7]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[11]).pgno); (lo[9]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[12]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[1]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[3]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[11]).pgno); (lo[8]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[12]).pgno); (lo[7]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[9]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[2]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[7]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[10]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[11]).pgno); (lo[10]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[12]).pgno); (lo[6]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[7]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[11]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[12]).pgno); (lo[11]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[9]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[10]).pgno); (lo[6]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[9]).pgno); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[10]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[11]).pgno); (lo[10]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[7]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[11]).pgno); (lo[9]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[3]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[7]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[10]).pgno); (lo[8]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[6]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[10]).pgno); (lo[9]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[2]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[7]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[3]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[7]).pgno); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[9]).pgno); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); } while (0); break; case 14: do { do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[1]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[3]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[7]).pgno); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[9]).pgno); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[10]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[11]).pgno); (lo[10]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[12]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[13]).pgno); (lo[12]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[2]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[10]).pgno); (lo[8]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[3]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[7]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[11]).pgno); (lo[9]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[12]).pgno); (lo[8]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[13]).pgno); (lo[9]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[7]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[9]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[10]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[11]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[12]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[13]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[10]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[9]).pgno); (lo[6]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[12]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[11]).pgno); (lo[7]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[2]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[13]).pgno); (lo[7]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[10]).pgno); (lo[9]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[11]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[13]).pgno); (lo[11]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[12]).pgno); (lo[7]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[6]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[10]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[12]).pgno); (lo[10]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[9]).pgno); (lo[7]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[7]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[10]).pgno); (lo[9]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[11]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[12]).pgno); (lo[11]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[7]).pgno); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[9]).pgno); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); } while (0); break; case 15: do { do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[1]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[3]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[7]).pgno); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[9]).pgno); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[10]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[11]).pgno); (lo[10]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[12]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[13]).pgno); (lo[12]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[2]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[10]).pgno); (lo[8]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[12]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[14]).pgno); (lo[12]) = swap_cmp ? swap_tmp : lo[14]; (lo[14]) = swap_cmp ? lo[14] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[3]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[7]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[11]).pgno); (lo[9]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[12]).pgno); (lo[8]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[13]).pgno); (lo[9]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[10]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[14]).pgno); (lo[10]) = swap_cmp ? swap_tmp : lo[14]; (lo[14]) = swap_cmp ? lo[14] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[7]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[9]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[10]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[11]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[12]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[13]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[14]).pgno); (lo[6]) = swap_cmp ? swap_tmp : lo[14]; (lo[14]) = swap_cmp ? lo[14] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[10]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[9]).pgno); (lo[6]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[12]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[13]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[14]).pgno); (lo[13]) = swap_cmp ? swap_tmp : lo[14]; (lo[14]) = swap_cmp ? lo[14] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[11]).pgno); (lo[7]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[2]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[13]).pgno); (lo[7]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[11]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[14]).pgno); (lo[11]) = swap_cmp ? swap_tmp : lo[14]; (lo[14]) = swap_cmp ? lo[14] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[10]).pgno); (lo[9]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[11]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[13]).pgno); (lo[11]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[12]).pgno); (lo[7]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[6]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[10]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[12]).pgno); (lo[10]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[9]).pgno); (lo[7]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[7]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[10]).pgno); (lo[9]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[11]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[12]).pgno); (lo[11]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[7]).pgno); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[9]).pgno); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); } while (0); break; case 16: do { do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[1]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[1]; (lo[1]) = swap_cmp ? lo[1] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[3]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[7]).pgno); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[9]).pgno); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[10]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[11]).pgno); (lo[10]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[12]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[13]).pgno); (lo[12]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[14]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[15]).pgno); (lo[14]) = swap_cmp ? swap_tmp : lo[15]; (lo[15]) = swap_cmp ? lo[15] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[2]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[10]).pgno); (lo[8]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[12]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[14]).pgno); (lo[12]) = swap_cmp ? swap_tmp : lo[14]; (lo[14]) = swap_cmp ? lo[14] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[3]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[3]; (lo[3]) = swap_cmp ? lo[3] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[7]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[11]).pgno); (lo[9]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[13]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[15]).pgno); (lo[13]) = swap_cmp ? swap_tmp : lo[15]; (lo[15]) = swap_cmp ? lo[15] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[12]).pgno); (lo[8]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[13]).pgno); (lo[9]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[10]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[14]).pgno); (lo[10]) = swap_cmp ? swap_tmp : lo[14]; (lo[14]) = swap_cmp ? lo[14] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[7]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[11]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[15]).pgno); (lo[11]) = swap_cmp ? swap_tmp : lo[15]; (lo[15]) = swap_cmp ? lo[15] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[0]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[0]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[9]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[10]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[11]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[12]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[13]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[14]).pgno); (lo[6]) = swap_cmp ? swap_tmp : lo[14]; (lo[14]) = swap_cmp ? lo[14] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[15]).pgno); (lo[7]) = swap_cmp ? swap_tmp : lo[15]; (lo[15]) = swap_cmp ? lo[15] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[10]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[9]).pgno); (lo[6]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[12]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[13]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[14]).pgno); (lo[13]) = swap_cmp ? swap_tmp : lo[14]; (lo[14]) = swap_cmp ? lo[14] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[11]).pgno); (lo[7]) = swap_cmp ? swap_tmp : lo[11]; (lo[11]) = swap_cmp ? lo[11] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[2]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[2]; (lo[2]) = swap_cmp ? lo[2] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[4]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[4]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[1]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[1]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[13]).pgno); (lo[7]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[11]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[14]).pgno); (lo[11]) = swap_cmp ? swap_tmp : lo[14]; (lo[14]) = swap_cmp ? lo[14] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[10]).pgno); (lo[9]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[2]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[2]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[11]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[13]).pgno); (lo[11]) = swap_cmp ? swap_tmp : lo[13]; (lo[13]) = swap_cmp ? lo[13] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[12]).pgno); (lo[7]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[6]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[10]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[12]).pgno); (lo[10]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[5]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[5]; (lo[5]) = swap_cmp ? lo[5] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[9]).pgno); (lo[7]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[3]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[4]).pgno); (lo[3]) = swap_cmp ? swap_tmp : lo[4]; (lo[4]) = swap_cmp ? lo[4] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[5]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[6]).pgno); (lo[5]) = swap_cmp ? swap_tmp : lo[6]; (lo[6]) = swap_cmp ? lo[6] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[7]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[8]).pgno); (lo[7]) = swap_cmp ? swap_tmp : lo[8]; (lo[8]) = swap_cmp ? lo[8] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[9]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[10]).pgno); (lo[9]) = swap_cmp ? swap_tmp : lo[10]; (lo[10]) = swap_cmp ? lo[10] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[11]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[12]).pgno); (lo[11]) = swap_cmp ? swap_tmp : lo[12]; (lo[12]) = swap_cmp ? lo[12] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[6]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[7]).pgno); (lo[6]) = swap_cmp ? swap_tmp : lo[7]; (lo[7]) = swap_cmp ? lo[7] : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (lo[8]); const _Bool swap_cmp = ((swap_tmp).pgno < (lo[9]).pgno); (lo[8]) = swap_cmp ? swap_tmp : lo[9]; (lo[9]) = swap_cmp ? lo[9] : swap_tmp; } while (0); } while (0); break; }; if (__builtin_expect(!!(top == stack), 0)) break; do { --top; lo = top->lo; hi = top->hi; } while (0); continue; } MDBX_dp *mid = lo + (len >> 1); do { const MDBX_dp swap_tmp = (*lo); const _Bool swap_cmp = ((swap_tmp).pgno < (*mid).pgno); (*lo) = swap_cmp ? swap_tmp : *mid; (*mid) = swap_cmp ? *mid : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (*mid); const _Bool swap_cmp = ((swap_tmp).pgno < (*hi).pgno); (*mid) = swap_cmp ? swap_tmp : *hi; (*hi) = swap_cmp ? *hi : swap_tmp; } while (0); do { const MDBX_dp swap_tmp = (*lo); const _Bool swap_cmp = ((swap_tmp).pgno < (*mid).pgno); (*lo) = swap_cmp ? swap_tmp : *mid; (*mid) = swap_cmp ? *mid : swap_tmp; } while (0); MDBX_dp *right = hi - 1; MDBX_dp *left = lo + 1; while (1) { while (((*left).pgno < (*mid).pgno)) ++left; while (((*mid).pgno < (*right).pgno)) --right; if (__builtin_expect(!!(left > right), 0)) { if ((0)) { if (dp_sort_is_sorted(lo, right)) lo = right + 1; if (dp_sort_is_sorted(left, hi)) hi = left; } break; } do { const MDBX_dp swap_tmp = (*left); (*left) = (*right); (*right) = swap_tmp; } while (0); mid = (mid == left) ? right : (mid == right) ? left : mid; ++left; --right; } if (right - lo > hi - left) { do { top->lo = (lo); top->hi = (right); ++top; } while (0); lo = left; } else { do { top->lo = (left); top->hi = (hi); ++top; } while (0); hi = right; } } if ((0)) { for (MDBX_dp *scan = begin + 1; scan < end; ++scan) do { if ((0)) do { if (__builtin_expect(!!(!(((scan[-1]).pgno < (scan[0]).pgno))), 0)) mdbx_assert_fail(
# 3443 "/libmdbx/src/core.c" 3 4
((void *)0)
# 3443 "/libmdbx/src/core.c"
, "((scan[-1]).pgno < (scan[0]).pgno)", __func__, 3443); } while (0); } while (0); } }

__attribute__((__hot__)) __attribute__((__optimize__("O3"))) __attribute__((__noinline__)) static MDBX_dpl *mdbx_dpl_sort_slowpath(const MDBX_txn *txn) {
  MDBX_dpl *dl = txn->tw.dirtylist;
  do { if ((0)) do { if (__builtin_expect(!!(!(dl->items[0].pgno == 0 && dl->items[dl->length + 1].pgno == (~(pgno_t)0))), 0)) mdbx_assert_fail(
# 3447 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3447 "/libmdbx/src/core.c"
 , "dl->items[0].pgno == 0 && dl->items[dl->length + 1].pgno == (~(pgno_t)0)", __func__, 3447); } while (0); } while (0);
  const unsigned unsorted = dl->length - dl->sorted;
  if (__builtin_expect(!!(unsorted < 333), 1) ||
      __builtin_expect(!!(!dpl_radixsort(dl->items + 1, dl->length)), 0)) {
    if (dl->sorted > unsorted / 4 + 4 &&
        (1 ||
         dl->length + unsorted < dl->detent + 16)) {
      MDBX_dp *const sorted_begin = dl->items + 1;
      MDBX_dp *const sorted_end = sorted_begin + dl->sorted;
      MDBX_dp *const end =
          dl->items + (1
                           ? dl->length + dl->length + 1
                           : dl->detent + (16 + 2));
      MDBX_dp *const tmp = end - unsorted;
      do { if ((0)) do { if (__builtin_expect(!!(!(dl->items + dl->length + 1 < tmp)), 0)) mdbx_assert_fail(
# 3461 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 3461 "/libmdbx/src/core.c"
     , "dl->items + dl->length + 1 < tmp", __func__, 3461); } while (0); } while (0);

      memcpy(tmp, sorted_end, unsorted * sizeof(MDBX_dp));
      dp_sort(tmp, tmp + unsorted);

      MDBX_dp *w = dl->items + dl->length;
      MDBX_dp *l = dl->items + dl->sorted;
      MDBX_dp *r = end - 1;
      do {
        const _Bool cmp = l->pgno > r->pgno;
        *w = cmp ? *l : *r;
        l -= cmp;
        r += cmp - 1;
      } while (__builtin_expect(!!(--w > l), 1));
      do { if ((0)) do { if (__builtin_expect(!!(!(r == tmp - 1)), 0)) mdbx_assert_fail(
# 3475 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 3475 "/libmdbx/src/core.c"
     , "r == tmp - 1", __func__, 3475); } while (0); } while (0);
      do { if ((0)) do { if (__builtin_expect(!!(!(dl->items[0].pgno == 0 && dl->items[dl->length + 1].pgno == (~(pgno_t)0))), 0)) mdbx_assert_fail(
# 3476 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 3476 "/libmdbx/src/core.c"
     , "dl->items[0].pgno == 0 && dl->items[dl->length + 1].pgno == (~(pgno_t)0)", __func__, 3476); } while (0); } while (0)
                                                         ;
      if ((0))
        for (unsigned i = 0; i <= dl->length; ++i)
          do { if ((0)) do { if (__builtin_expect(!!(!(dl->items[i].pgno < dl->items[i + 1].pgno)), 0)) mdbx_assert_fail(
# 3480 "/libmdbx/src/core.c" 3 4
         ((void *)0)
# 3480 "/libmdbx/src/core.c"
         , "dl->items[i].pgno < dl->items[i + 1].pgno", __func__, 3480); } while (0); } while (0);
    } else {
      dp_sort(dl->items + 1, dl->items + dl->length + 1);
      do { if ((0)) do { if (__builtin_expect(!!(!(dl->items[0].pgno == 0 && dl->items[dl->length + 1].pgno == (~(pgno_t)0))), 0)) mdbx_assert_fail(
# 3483 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 3483 "/libmdbx/src/core.c"
     , "dl->items[0].pgno == 0 && dl->items[dl->length + 1].pgno == (~(pgno_t)0)", __func__, 3483); } while (0); } while (0)
                                                         ;
    }
  } else {
    do { if ((0)) do { if (__builtin_expect(!!(!(dl->items[0].pgno == 0 && dl->items[dl->length + 1].pgno == (~(pgno_t)0))), 0)) mdbx_assert_fail(
# 3487 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 3487 "/libmdbx/src/core.c"
   , "dl->items[0].pgno == 0 && dl->items[dl->length + 1].pgno == (~(pgno_t)0)", __func__, 3487); } while (0); } while (0)
                                                       ;
  }
  dl->sorted = dl->length;
  return dl;
}

static 
# 3494 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 3494 "/libmdbx/src/core.c"
                      MDBX_dpl *mdbx_dpl_sort(const MDBX_txn *txn) {
  MDBX_dpl *dl = txn->tw.dirtylist;
  do { if ((0)) do { if (__builtin_expect(!!(!(dl->length <= ((size_t)0x7FFFffffU))), 0)) mdbx_assert_fail(
# 3496 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3496 "/libmdbx/src/core.c"
 , "dl->length <= ((size_t)0x7FFFffffU)", __func__, 3496); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(dl->sorted <= dl->length)), 0)) mdbx_assert_fail(
# 3497 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3497 "/libmdbx/src/core.c"
 , "dl->sorted <= dl->length", __func__, 3497); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(dl->items[0].pgno == 0 && dl->items[dl->length + 1].pgno == (~(pgno_t)0))), 0)) mdbx_assert_fail(
# 3498 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3498 "/libmdbx/src/core.c"
 , "dl->items[0].pgno == 0 && dl->items[dl->length + 1].pgno == (~(pgno_t)0)", __func__, 3498); } while (0); } while (0);
  return __builtin_expect(!!(dl->sorted == dl->length), 1) ? dl : mdbx_dpl_sort_slowpath(txn);
}




static 
# 3505 "/libmdbx/src/core.c" 3 4
__inline __attribute__ ((__always_inline__)) 
# 3505 "/libmdbx/src/core.c"
const MDBX_dp *dp_bsearch( const MDBX_dp *first, unsigned length, const pgno_t item) { const MDBX_dp *const begin = first, *const end = begin + length; while (length > 3) { const unsigned whole = length; length >>= 1; const MDBX_dp *const middle = first + length; const unsigned left = whole - length - 1; const _Bool cmp = ((*middle).pgno < (item)); length = cmp ? left : length; first = cmp ? middle + 1 : first; } switch (length) { case 3: if (!((*first).pgno < (item))) break; ++first; __attribute__((__fallthrough__)) ; case 2: if (!((*first).pgno < (item))) break; ++first; __attribute__((__fallthrough__)) ; case 1: if (!((*first).pgno < (item))) break; ++first; __attribute__((__fallthrough__)) ; case 0: break; default: __builtin_unreachable(); } if ((0)) { for (const MDBX_dp *scan = begin; scan < first; ++scan) do { if ((0)) do { if (__builtin_expect(!!(!(((*scan).pgno < (item)))), 0)) mdbx_assert_fail(
# 3505 "/libmdbx/src/core.c" 3 4
((void *)0)
# 3505 "/libmdbx/src/core.c"
, "((*scan).pgno < (item))", __func__, 3505); } while (0); } while (0); for (const MDBX_dp *scan = first; scan < end; ++scan) do { if ((0)) do { if (__builtin_expect(!!(!(!((*scan).pgno < (item)))), 0)) mdbx_assert_fail(
# 3505 "/libmdbx/src/core.c" 3 4
((void *)0)
# 3505 "/libmdbx/src/core.c"
, "!((*scan).pgno < (item))", __func__, 3505); } while (0); } while (0); (void)begin, (void)end; } return first; }

static unsigned __attribute__((__hot__)) __attribute__((__optimize__("O3"))) mdbx_dpl_search(const MDBX_txn *txn, pgno_t pgno) {
  MDBX_dpl *dl = txn->tw.dirtylist;
  do { if ((0)) do { if (__builtin_expect(!!(!(dl->items[0].pgno == 0 && dl->items[dl->length + 1].pgno == (~(pgno_t)0))), 0)) mdbx_assert_fail(
# 3509 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3509 "/libmdbx/src/core.c"
 , "dl->items[0].pgno == 0 && dl->items[dl->length + 1].pgno == (~(pgno_t)0)", __func__, 3509); } while (0); } while (0);
  if ((0)) {
    for (const MDBX_dp *ptr = dl->items + dl->sorted; --ptr > dl->items;) {
      do { if ((0)) do { if (__builtin_expect(!!(!(ptr[0].pgno < ptr[1].pgno)), 0)) mdbx_assert_fail(
# 3512 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 3512 "/libmdbx/src/core.c"
     , "ptr[0].pgno < ptr[1].pgno", __func__, 3512); } while (0); } while (0);
      do { if ((0)) do { if (__builtin_expect(!!(!(ptr[0].pgno >= 3)), 0)) mdbx_assert_fail(
# 3513 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 3513 "/libmdbx/src/core.c"
     , "ptr[0].pgno >= 3", __func__, 3513); } while (0); } while (0);
    }
  }

  switch (dl->length - dl->sorted) {
  default:

    mdbx_dpl_sort_slowpath(txn);
    break;
  case 0:

    break;
# 3533 "/libmdbx/src/core.c"
    case 16: if (dl->items[dl->length - 16 + 1].pgno == pgno) return dl->length - 16 + 1; __attribute__((__fallthrough__));
    case 15: if (dl->items[dl->length - 15 + 1].pgno == pgno) return dl->length - 15 + 1; __attribute__((__fallthrough__));
    case 14: if (dl->items[dl->length - 14 + 1].pgno == pgno) return dl->length - 14 + 1; __attribute__((__fallthrough__));
    case 13: if (dl->items[dl->length - 13 + 1].pgno == pgno) return dl->length - 13 + 1; __attribute__((__fallthrough__));
    case 12: if (dl->items[dl->length - 12 + 1].pgno == pgno) return dl->length - 12 + 1; __attribute__((__fallthrough__));
    case 11: if (dl->items[dl->length - 11 + 1].pgno == pgno) return dl->length - 11 + 1; __attribute__((__fallthrough__));
    case 10: if (dl->items[dl->length - 10 + 1].pgno == pgno) return dl->length - 10 + 1; __attribute__((__fallthrough__));
    case 9: if (dl->items[dl->length - 9 + 1].pgno == pgno) return dl->length - 9 + 1; __attribute__((__fallthrough__));
    case 8: if (dl->items[dl->length - 8 + 1].pgno == pgno) return dl->length - 8 + 1; __attribute__((__fallthrough__));
    case 7: if (dl->items[dl->length - 7 + 1].pgno == pgno) return dl->length - 7 + 1; __attribute__((__fallthrough__));
    case 6: if (dl->items[dl->length - 6 + 1].pgno == pgno) return dl->length - 6 + 1; __attribute__((__fallthrough__));
    case 5: if (dl->items[dl->length - 5 + 1].pgno == pgno) return dl->length - 5 + 1; __attribute__((__fallthrough__));
    case 4: if (dl->items[dl->length - 4 + 1].pgno == pgno) return dl->length - 4 + 1; __attribute__((__fallthrough__));
    case 3: if (dl->items[dl->length - 3 + 1].pgno == pgno) return dl->length - 3 + 1; __attribute__((__fallthrough__));
    case 2: if (dl->items[dl->length - 2 + 1].pgno == pgno) return dl->length - 2 + 1; __attribute__((__fallthrough__));
  case 1:
    if (dl->items[dl->length].pgno == pgno)
      return dl->length;

    break;
  }
  return (unsigned)(dp_bsearch(dl->items + 1, dl->sorted, pgno) - dl->items);
}

__attribute__((__pure__, __nothrow__)) static __inline unsigned
dpl_npages(const MDBX_dpl *dl, unsigned i) {
  do { if ((0)) do { if (__builtin_expect(!!(!(0 <= (int)i && i <= dl->length)), 0)) mdbx_assert_fail(
# 3559 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3559 "/libmdbx/src/core.c"
 , "0 <= (int)i && i <= dl->length", __func__, 3559); } while (0); } while (0);
  unsigned n = __builtin_expect(!!(!dl->items[i].multi), 1) ? 1 : dl->items[i].ptr->mp_pages;
  do { if ((0)) do { if (__builtin_expect(!!(!(n == (__builtin_expect(!!(((dl->items[i].ptr)->mp_flags & 0x04) != 0), 0) ? dl->items[i].ptr->mp_pages : 1))), 0)) mdbx_assert_fail(
# 3561 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3561 "/libmdbx/src/core.c"
 , "n == (__builtin_expect(!!(((dl->items[i].ptr)->mp_flags & 0x04) != 0), 0) ? dl->items[i].ptr->mp_pages : 1)", __func__, 3561); } while (0); } while (0);
  return n;
}

__attribute__((__pure__, __nothrow__)) static __inline unsigned
dpl_endpgno(const MDBX_dpl *dl, unsigned i) {
  return dpl_npages(dl, i) + dl->items[i].pgno;
}

static __inline _Bool mdbx_dpl_intersect(const MDBX_txn *txn, pgno_t pgno,
                                        unsigned npages) {
  MDBX_dpl *dl = txn->tw.dirtylist;
  do { if ((0)) do { if (__builtin_expect(!!(!(dl->sorted == dl->length)), 0)) mdbx_assert_fail(
# 3573 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3573 "/libmdbx/src/core.c"
 , "dl->sorted == dl->length", __func__, 3573); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(dl->items[0].pgno == 0 && dl->items[dl->length + 1].pgno == (~(pgno_t)0))), 0)) mdbx_assert_fail(
# 3574 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3574 "/libmdbx/src/core.c"
 , "dl->items[0].pgno == 0 && dl->items[dl->length + 1].pgno == (~(pgno_t)0)", __func__, 3574); } while (0); } while (0);
  unsigned const n = mdbx_dpl_search(txn, pgno);
  do { if ((0)) do { if (__builtin_expect(!!(!(n >= 1 && n <= dl->length + 1)), 0)) mdbx_assert_fail(
# 3576 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3576 "/libmdbx/src/core.c"
 , "n >= 1 && n <= dl->length + 1", __func__, 3576); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(pgno <= dl->items[n].pgno)), 0)) mdbx_assert_fail(
# 3577 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3577 "/libmdbx/src/core.c"
 , "pgno <= dl->items[n].pgno", __func__, 3577); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(pgno > dl->items[n - 1].pgno)), 0)) mdbx_assert_fail(
# 3578 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3578 "/libmdbx/src/core.c"
 , "pgno > dl->items[n - 1].pgno", __func__, 3578); } while (0); } while (0);
  const _Bool rc =
                                      pgno + npages > dl->items[n].pgno ||
                                   dpl_endpgno(dl, n - 1) > pgno;
  if ((0)) {
    _Bool check = (0);
    for (unsigned i = 1; i <= dl->length; ++i) {
      const MDBX_page *const dp = dl->items[i].ptr;
      if (!(dp->mp_pgno >= pgno + npages ||
            dpl_endpgno(dl, i) <= pgno))
        check |= (1);
    }
    do { if ((0)) do { if (__builtin_expect(!!(!(check == rc)), 0)) mdbx_assert_fail(
# 3590 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 3590 "/libmdbx/src/core.c"
   , "check == rc", __func__, 3590); } while (0); } while (0);
  }
  return rc;
}

static 
# 3595 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 3595 "/libmdbx/src/core.c"
                      unsigned mdbx_dpl_exist(MDBX_txn *txn, pgno_t pgno) {
  MDBX_dpl *dl = txn->tw.dirtylist;
  unsigned i = mdbx_dpl_search(txn, pgno);
  do { if ((0)) do { if (__builtin_expect(!!(!((int)i > 0)), 0)) mdbx_assert_fail(
# 3598 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3598 "/libmdbx/src/core.c"
 , "(int)i > 0", __func__, 3598); } while (0); } while (0);
  return (dl->items[i].pgno == pgno) ? i : 0;
}

__attribute__((__unused__)) static const MDBX_page *debug_dpl_find(const MDBX_txn *txn,
                                                         const pgno_t pgno) {
  const MDBX_dpl *dl = txn->tw.dirtylist;
  do { if ((0)) do { if (__builtin_expect(!!(!(dl->items[0].pgno == 0 && dl->items[dl->length + 1].pgno == (~(pgno_t)0))), 0)) mdbx_assert_fail(
# 3605 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3605 "/libmdbx/src/core.c"
 , "dl->items[0].pgno == 0 && dl->items[dl->length + 1].pgno == (~(pgno_t)0)", __func__, 3605); } while (0); } while (0);
  for (unsigned i = dl->length; i > dl->sorted; --i)
    if (dl->items[i].pgno == pgno)
      return dl->items[i].ptr;

  if (dl->sorted) {
    const unsigned i =
        (unsigned)(dp_bsearch(dl->items + 1, dl->sorted, pgno) - dl->items);
    if (dl->items[i].pgno == pgno)
      return dl->items[i].ptr;
  }
  return 
# 3616 "/libmdbx/src/core.c" 3 4
        ((void *)0)
# 3616 "/libmdbx/src/core.c"
               ;
}

static void mdbx_dpl_remove(const MDBX_txn *txn, unsigned i) {
  MDBX_dpl *dl = txn->tw.dirtylist;
  do { if ((0)) do { if (__builtin_expect(!!(!((int)i > 0 && i <= dl->length)), 0)) mdbx_assert_fail(
# 3621 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3621 "/libmdbx/src/core.c"
 , "(int)i > 0 && i <= dl->length", __func__, 3621); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(dl->items[0].pgno == 0 && dl->items[dl->length + 1].pgno == (~(pgno_t)0))), 0)) mdbx_assert_fail(
# 3622 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3622 "/libmdbx/src/core.c"
 , "dl->items[0].pgno == 0 && dl->items[dl->length + 1].pgno == (~(pgno_t)0)", __func__, 3622); } while (0); } while (0);
  dl->sorted -= dl->sorted >= i;
  dl->length -= 1;
  memmove(dl->items + i, dl->items + i + 1,
          (dl->length - i + 2) * sizeof(dl->items[0]));
  do { if ((0)) do { if (__builtin_expect(!!(!(dl->items[0].pgno == 0 && dl->items[dl->length + 1].pgno == (~(pgno_t)0))), 0)) mdbx_assert_fail(
# 3627 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3627 "/libmdbx/src/core.c"
 , "dl->items[0].pgno == 0 && dl->items[dl->length + 1].pgno == (~(pgno_t)0)", __func__, 3627); } while (0); } while (0);
}

static 
# 3630 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 3630 "/libmdbx/src/core.c"
                      int __attribute__((__warn_unused_result__))
mdbx_dpl_append(MDBX_txn *txn, pgno_t pgno, MDBX_page *page, unsigned npages) {
  MDBX_dpl *dl = txn->tw.dirtylist;
  do { if ((0)) do { if (__builtin_expect(!!(!(dl->length <= ((size_t)0x7FFFffffU) + 1024)), 0)) mdbx_assert_fail(
# 3633 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3633 "/libmdbx/src/core.c"
 , "dl->length <= ((size_t)0x7FFFffffU) + 1024", __func__, 3633); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(dl->items[0].pgno == 0 && dl->items[dl->length + 1].pgno == (~(pgno_t)0))), 0)) mdbx_assert_fail(
# 3634 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3634 "/libmdbx/src/core.c"
 , "dl->items[0].pgno == 0 && dl->items[dl->length + 1].pgno == (~(pgno_t)0)", __func__, 3634); } while (0); } while (0);
  if ((0)) {
    for (unsigned i = dl->length; i > 0; --i) {
      do { if ((0)) do { if (__builtin_expect(!!(!(dl->items[i].pgno != pgno)), 0)) mdbx_assert_fail(
# 3637 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 3637 "/libmdbx/src/core.c"
     , "dl->items[i].pgno != pgno", __func__, 3637); } while (0); } while (0);
      if (__builtin_expect(!!(dl->items[i].pgno == pgno), 0)) {
        do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 3639, "Page %u already exist in the DPL at %u" "\n", pgno, i); } while (0);
        return MDBX_PROBLEM;
      }
    }
  }

  const unsigned length = dl->length + 1;
  const unsigned sorted =
      (dl->sorted == dl->length && dl->items[dl->length].pgno < pgno)
          ? length
          : dl->sorted;

  if (__builtin_expect(!!(dl->length == dl->detent), 0)) {
    if (__builtin_expect(!!(dl->detent >= ((size_t)0x7FFFffffU)), 0)) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 3653, "DPL is full (MDBX_PGL_LIMIT %zu)" "\n", ((size_t)0x7FFFffffU)); } while (0);
      return MDBX_TXN_FULL;
    }
    const size_t size = (dl->detent < (1024 - 2 - (8 * 2u) / sizeof(pgno_t)) * 42)
                            ? dl->detent + dl->detent
                            : dl->detent + dl->detent / 2;
    dl = mdbx_dpl_reserve(txn, size);
    if (__builtin_expect(!!(!dl), 0))
      return MDBX_ENOMEM;
    do { if ((0)) do { if (__builtin_expect(!!(!(dl->length < dl->detent)), 0)) mdbx_assert_fail((txn)->mt_env, "dl->length < dl->detent", __func__, 3662); } while (0); } while (0);
  }


  dl->items[length + 1] = dl->items[length];

  dl->items[length].ptr = page;
  dl->items[length].pgno = pgno;
  dl->items[length].multi = npages > 1;
  dl->items[length].lru = txn->tw.dirtylru++;
  dl->length = length;
  dl->sorted = sorted;
  do { if ((0)) do { if (__builtin_expect(!!(!(dl->items[0].pgno == 0 && dl->items[dl->length + 1].pgno == (~(pgno_t)0))), 0)) mdbx_assert_fail(
# 3674 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3674 "/libmdbx/src/core.c"
 , "dl->items[0].pgno == 0 && dl->items[dl->length + 1].pgno == (~(pgno_t)0)", __func__, 3674); } while (0); } while (0);
  return MDBX_SUCCESS;
}

static __inline uint32_t mdbx_dpl_age(const MDBX_txn *txn, unsigned i) {
  const MDBX_dpl *dl = txn->tw.dirtylist;
  do { if ((0)) do { if (__builtin_expect(!!(!((int)i > 0 && i <= dl->length)), 0)) mdbx_assert_fail(
# 3680 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 3680 "/libmdbx/src/core.c"
 , "(int)i > 0 && i <= dl->length", __func__, 3680); } while (0); } while (0);

  return (txn->tw.dirtylru - dl->items[i].lru) & 0x7fffFFFFU;
}



uint8_t mdbx_runtime_flags = ((0) > 0) * MDBX_DBG_ASSERT + ((0) > 1) * MDBX_DBG_AUDIT;
uint8_t mdbx_loglevel = MDBX_LOG_FATAL;
MDBX_debug_func *mdbx_debug_logger;

static __attribute__((__warn_unused_result__)) __inline int mdbx_page_retire(MDBX_cursor *mc,
                                                         MDBX_page *mp);

static int __attribute__((__warn_unused_result__)) mdbx_page_dirty(MDBX_txn *txn, MDBX_page *mp,
                                               unsigned npages);
struct page_result {
  MDBX_page *page;
  int err;
};

static struct page_result mdbx_page_alloc(MDBX_cursor *mc, const pgno_t num,
                                          int flags);
static txnid_t mdbx_kick_longlived_readers(MDBX_env *env,
                                           const txnid_t laggard);

static struct page_result mdbx_page_new(MDBX_cursor *mc, const unsigned flags,
                                        const unsigned npages);
static int mdbx_page_touch(MDBX_cursor *mc);
static int mdbx_cursor_touch(MDBX_cursor *mc);
static int mdbx_touch_dbi(MDBX_cursor *mc);






enum {

  MDBX_END_COMMITTED,
  MDBX_END_PURE_COMMIT,
  MDBX_END_ABORT,
  MDBX_END_RESET,
  MDBX_END_RESET_TMP,
  MDBX_END_FAIL_BEGIN,
  MDBX_END_FAIL_BEGINCHILD
};





static int mdbx_txn_end(MDBX_txn *txn, const unsigned mode);

__attribute__((__hot__)) __attribute__((__optimize__("O3"))) static struct page_result __attribute__((__warn_unused_result__))
mdbx_page_get_ex(MDBX_cursor *const mc, const pgno_t pgno, txnid_t front);
static 
# 3736 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 3736 "/libmdbx/src/core.c"
                      int __attribute__((__warn_unused_result__)) mdbx_page_get(MDBX_cursor *mc,
                                                             pgno_t pgno,
                                                             MDBX_page **mp,
                                                             txnid_t front) {

  struct page_result ret = mdbx_page_get_ex(mc, pgno, front);
  *mp = ret.page;
  return ret.err;
}

static int __attribute__((__warn_unused_result__)) mdbx_page_search_root(MDBX_cursor *mc,
                                                     const MDBX_val *key,
                                                     int flags);





static int __attribute__((__warn_unused_result__)) mdbx_page_search(MDBX_cursor *mc,
                                                const MDBX_val *key, int flags);
static int __attribute__((__warn_unused_result__)) mdbx_page_merge(MDBX_cursor *csrc,
                                               MDBX_cursor *cdst);


static int __attribute__((__warn_unused_result__)) mdbx_page_split(MDBX_cursor *mc,
                                               const MDBX_val *const newkey,
                                               MDBX_val *const newdata,
                                               pgno_t newpgno, unsigned nflags);

static _Bool meta_checktxnid(const MDBX_env *env, const MDBX_meta *meta,
                            _Bool report);
static int __attribute__((__warn_unused_result__)) mdbx_validate_meta_copy(MDBX_env *env,
                                                       const MDBX_meta *meta,
                                                       MDBX_meta *dest);
static int __attribute__((__warn_unused_result__)) mdbx_override_meta(MDBX_env *env,
                                                  unsigned target,
                                                  txnid_t txnid,
                                                  const MDBX_meta *shape);
static int __attribute__((__warn_unused_result__)) mdbx_read_header(MDBX_env *env, MDBX_meta *meta,
                                                const int lck_exclusive,
                                                const mdbx_mode_t mode_bits);
static int __attribute__((__warn_unused_result__)) mdbx_sync_locked(MDBX_env *env, unsigned flags,
                                                MDBX_meta *const pending);
static int mdbx_env_close0(MDBX_env *env);

struct node_result {
  MDBX_node *node;
  _Bool exact;
};

static struct node_result mdbx_node_search(MDBX_cursor *mc,
                                           const MDBX_val *key);

static int __attribute__((__warn_unused_result__)) mdbx_node_add_branch(MDBX_cursor *mc,
                                                    unsigned indx,
                                                    const MDBX_val *key,
                                                    pgno_t pgno);
static int __attribute__((__warn_unused_result__)) mdbx_node_add_leaf(MDBX_cursor *mc,
                                                  unsigned indx,
                                                  const MDBX_val *key,
                                                  MDBX_val *data,
                                                  unsigned flags);
static int __attribute__((__warn_unused_result__)) mdbx_node_add_leaf2(MDBX_cursor *mc,
                                                   unsigned indx,
                                                   const MDBX_val *key);

static void mdbx_node_del(MDBX_cursor *mc, size_t ksize);
static void mdbx_node_shrink(MDBX_page *mp, unsigned indx);
static int __attribute__((__warn_unused_result__)) mdbx_node_move(MDBX_cursor *csrc,
                                              MDBX_cursor *cdst, _Bool fromleft);
static int __attribute__((__warn_unused_result__)) mdbx_node_read(MDBX_cursor *mc,
                                              const MDBX_node *leaf,
                                              MDBX_val *data,
                                              const txnid_t front);
static int __attribute__((__warn_unused_result__)) mdbx_rebalance(MDBX_cursor *mc);
static int __attribute__((__warn_unused_result__)) mdbx_update_key(MDBX_cursor *mc,
                                               const MDBX_val *key);

static void mdbx_cursor_pop(MDBX_cursor *mc);
static int __attribute__((__warn_unused_result__)) mdbx_cursor_push(MDBX_cursor *mc, MDBX_page *mp);

static int __attribute__((__warn_unused_result__)) mdbx_audit_ex(MDBX_txn *txn,
                                             unsigned retired_stored,
                                             _Bool dont_filter_gc);

static int __attribute__((__warn_unused_result__)) mdbx_page_check(MDBX_cursor *const mc,
                                               const MDBX_page *const mp,
                                               unsigned options);
static int __attribute__((__warn_unused_result__)) mdbx_cursor_check(MDBX_cursor *mc,
                                                 unsigned options);
static int __attribute__((__warn_unused_result__)) mdbx_cursor_del0(MDBX_cursor *mc);
static int __attribute__((__warn_unused_result__)) mdbx_del0(MDBX_txn *txn, MDBX_dbi dbi,
                                         const MDBX_val *key,
                                         const MDBX_val *data, unsigned flags);


static int __attribute__((__warn_unused_result__)) mdbx_cursor_sibling(MDBX_cursor *mc, int dir);
static int __attribute__((__warn_unused_result__)) mdbx_cursor_next(MDBX_cursor *mc, MDBX_val *key,
                                                MDBX_val *data,
                                                MDBX_cursor_op op);
static int __attribute__((__warn_unused_result__)) mdbx_cursor_prev(MDBX_cursor *mc, MDBX_val *key,
                                                MDBX_val *data,
                                                MDBX_cursor_op op);
struct cursor_set_result {
  int err;
  _Bool exact;
};

static struct cursor_set_result mdbx_cursor_set(MDBX_cursor *mc, MDBX_val *key,
                                                MDBX_val *data,
                                                MDBX_cursor_op op);
static int __attribute__((__warn_unused_result__)) mdbx_cursor_first(MDBX_cursor *mc, MDBX_val *key,
                                                 MDBX_val *data);
static int __attribute__((__warn_unused_result__)) mdbx_cursor_last(MDBX_cursor *mc, MDBX_val *key,
                                                MDBX_val *data);

static int __attribute__((__warn_unused_result__)) mdbx_cursor_init(MDBX_cursor *mc, MDBX_txn *txn,
                                                MDBX_dbi dbi);
static int __attribute__((__warn_unused_result__)) mdbx_xcursor_init0(MDBX_cursor *mc);
static int __attribute__((__warn_unused_result__)) mdbx_xcursor_init1(MDBX_cursor *mc,
                                                  MDBX_node *node,
                                                  const MDBX_page *mp);
static int __attribute__((__warn_unused_result__)) mdbx_xcursor_init2(MDBX_cursor *mc,
                                                  MDBX_xcursor *src_mx,
                                                  _Bool new_dupdata);
static void cursor_copy(const MDBX_cursor *csrc, MDBX_cursor *cdst);

static int __attribute__((__warn_unused_result__)) mdbx_drop_tree(MDBX_cursor *mc,
                                              const _Bool may_have_subDBs);
static int __attribute__((__warn_unused_result__)) mdbx_fetch_sdb(MDBX_txn *txn, MDBX_dbi dbi);
static int __attribute__((__warn_unused_result__)) mdbx_setup_dbx(MDBX_dbx *const dbx,
                                              const MDBX_db *const db,
                                              const unsigned pagesize);

static MDBX_cmp_func cmp_lexical, cmp_reverse, cmp_int_align4, cmp_int_align2,
    cmp_int_unaligned, cmp_lenfast;

static __inline MDBX_cmp_func *get_default_keycmp(unsigned flags);
static __inline MDBX_cmp_func *get_default_datacmp(unsigned flags);

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) const char *mdbx_liberr2str(int errnum) {

  static const char *const tbl[] = {
      "MDBX_KEYEXIST: Key/data pair already exists",
      "MDBX_NOTFOUND: No matching key/data pair found",
      "MDBX_PAGE_NOTFOUND: Requested page not found",
      "MDBX_CORRUPTED: Database is corrupted",
      "MDBX_PANIC: Environment had fatal error",
      "MDBX_VERSION_MISMATCH: DB version mismatch libmdbx",
      "MDBX_INVALID: File is not an MDBX file",
      "MDBX_MAP_FULL: Environment mapsize limit reached",
      "MDBX_DBS_FULL: Too many DBI-handles (maxdbs reached)",
      "MDBX_READERS_FULL: Too many readers (maxreaders reached)",
      
# 3889 "/libmdbx/src/core.c" 3 4
     ((void *)0) 
# 3889 "/libmdbx/src/core.c"
                                                      ,
      "MDBX_TXN_FULL: Transaction has too many dirty pages,"
      " i.e transaction is too big",
      "MDBX_CURSOR_FULL: Cursor stack limit reachedn - this usually indicates"
      " corruption, i.e branch-pages loop",
      "MDBX_PAGE_FULL: Internal error - Page has no more space",
      "MDBX_UNABLE_EXTEND_MAPSIZE: Database engine was unable to extend"
      " mapping, e.g. since address space is unavailable or busy,"
      " or Operation system not supported such operations",
      "MDBX_INCOMPATIBLE: Environment or database is not compatible"
      " with the requested operation or the specified flags",
      "MDBX_BAD_RSLOT: Invalid reuse of reader locktable slot,"
      " e.g. read-transaction already run for current thread",
      "MDBX_BAD_TXN: Transaction is not valid for requested operation,"
      " e.g. had errored and be must aborted, has a child, or is invalid",
      "MDBX_BAD_VALSIZE: Invalid size or alignment of key or data"
      " for target database, either invalid subDB name",
      "MDBX_BAD_DBI: The specified DBI-handle is invalid"
      " or changed by another thread/transaction",
      "MDBX_PROBLEM: Unexpected internal error, transaction should be aborted",
      "MDBX_BUSY: Another write transaction is running,"
      " or environment is already used while opening with MDBX_EXCLUSIVE flag",
  };

  if (errnum >= MDBX_KEYEXIST && errnum <= MDBX_BUSY) {
    int i = errnum - MDBX_KEYEXIST;
    return tbl[i];
  }

  switch (errnum) {
  case MDBX_SUCCESS:
    return "MDBX_SUCCESS: Successful";
  case MDBX_EMULTIVAL:
    return "MDBX_EMULTIVAL: The specified key has"
           " more than one associated value";
  case MDBX_EBADSIGN:
    return "MDBX_EBADSIGN: Wrong signature of a runtime object(s),"
           " e.g. memory corruption or double-free";
  case MDBX_WANNA_RECOVERY:
    return "MDBX_WANNA_RECOVERY: Database should be recovered,"
           " but this could NOT be done automatically for now"
           " since it opened in read-only mode";
  case MDBX_EKEYMISMATCH:
    return "MDBX_EKEYMISMATCH: The given key value is mismatched to the"
           " current cursor position";
  case MDBX_TOO_LARGE:
    return "MDBX_TOO_LARGE: Database is too large for current system,"
           " e.g. could NOT be mapped into RAM";
  case MDBX_THREAD_MISMATCH:
    return "MDBX_THREAD_MISMATCH: A thread has attempted to use a not"
           " owned object, e.g. a transaction that started by another thread";
  case MDBX_TXN_OVERLAPPING:
    return "MDBX_TXN_OVERLAPPING: Overlapping read and write transactions for"
           " the current thread";
  default:
    return 
# 3944 "/libmdbx/src/core.c" 3 4
          ((void *)0)
# 3944 "/libmdbx/src/core.c"
              ;
  }
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) const char *mdbx_strerror_r(int errnum, char *buf, size_t buflen) {
  const char *msg = mdbx_liberr2str(errnum);
  if (!msg && buflen > 0 && buflen < 0x7fffffff) {
# 3959 "/libmdbx/src/core.c"
    if (errnum > 0)
      msg = strerror_r(errnum, buf, buflen);
# 3974 "/libmdbx/src/core.c"
    if (!msg) {
      (void)snprintf(buf, buflen, "error %d", errnum);
      msg = buf;
    }
    buf[buflen - 1] = '\0';
  }
  return msg;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) const char *mdbx_strerror(int errnum) {




  const char *msg = mdbx_liberr2str(errnum);
  if (!msg) {
    if (errnum > 0)
      msg = strerror(errnum);
    if (!msg) {
      static char buf[32];
      (void)snprintf(buf, sizeof(buf) - 1, "error %d", errnum);
      msg = buf;
    }
  }
  return msg;

}
# 4026 "/libmdbx/src/core.c"
__attribute__((__cold__)) __attribute__((__optimize__("Os"))) void mdbx_debug_log_va(int level, const char *function, int line,
                              const char *fmt, va_list args) {
  if (mdbx_debug_logger)
    mdbx_debug_logger(level, function, line, fmt, args);
  else {
# 4053 "/libmdbx/src/core.c"
    if (function && line > 0)
      fprintf(
# 4054 "/libmdbx/src/core.c" 3 4
             stderr
# 4054 "/libmdbx/src/core.c"
                   , "%s:%d ", function, line);
    else if (function)
      fprintf(
# 4056 "/libmdbx/src/core.c" 3 4
             stderr
# 4056 "/libmdbx/src/core.c"
                   , "%s: ", function);
    else if (line > 0)
      fprintf(
# 4058 "/libmdbx/src/core.c" 3 4
             stderr
# 4058 "/libmdbx/src/core.c"
                   , "%d: ", line);
    vfprintf(
# 4059 "/libmdbx/src/core.c" 3 4
            stderr
# 4059 "/libmdbx/src/core.c"
                  , fmt, args);
    fflush(
# 4060 "/libmdbx/src/core.c" 3 4
          stderr
# 4060 "/libmdbx/src/core.c"
                );

  }
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) void mdbx_debug_log(int level, const char *function, int line,
                           const char *fmt, ...) {
  va_list args;
  
# 4068 "/libmdbx/src/core.c" 3 4
 __builtin_va_start(
# 4068 "/libmdbx/src/core.c"
 args
# 4068 "/libmdbx/src/core.c" 3 4
 ,
# 4068 "/libmdbx/src/core.c"
 fmt
# 4068 "/libmdbx/src/core.c" 3 4
 )
# 4068 "/libmdbx/src/core.c"
                    ;
  mdbx_debug_log_va(level, function, line, fmt, args);
  
# 4070 "/libmdbx/src/core.c" 3 4
 __builtin_va_end(
# 4070 "/libmdbx/src/core.c"
 args
# 4070 "/libmdbx/src/core.c" 3 4
 )
# 4070 "/libmdbx/src/core.c"
             ;
}


const char *mdbx_dump_val(const MDBX_val *key, char *const buf,
                          const size_t bufsize) {
  if (!key)
    return "<null>";
  if (!key->iov_len)
    return "<empty>";
  if (!buf || bufsize < 4)
    return 
# 4081 "/libmdbx/src/core.c" 3 4
          ((void *)0)
# 4081 "/libmdbx/src/core.c"
                 ;

  _Bool is_ascii = (1);
  const uint8_t *const data = key->iov_base;
  for (unsigned i = 0; i < key->iov_len; i++)
    if (data[i] < ' ' || data[i] > '~') {
      is_ascii = (0);
      break;
    }

  if (is_ascii) {
    int len =
        snprintf(buf, bufsize, "%.*s",
                 (key->iov_len > 0x7fffffff) ? 0x7fffffff : (int)key->iov_len, data);
    do { if ((0)) do { if (__builtin_expect(!!(!(len > 0 && (unsigned)len < bufsize)), 0)) mdbx_assert_fail(
# 4095 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 4095 "/libmdbx/src/core.c"
   , "len > 0 && (unsigned)len < bufsize", __func__, 4095); } while (0); } while (0);
    (void)len;
  } else {
    char *const detent = buf + bufsize - 2;
    char *ptr = buf;
    *ptr++ = '<';
    for (unsigned i = 0; i < key->iov_len; i++) {
      const ptrdiff_t left = detent - ptr;
      do { if ((0)) do { if (__builtin_expect(!!(!(left > 0)), 0)) mdbx_assert_fail(
# 4103 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 4103 "/libmdbx/src/core.c"
     , "left > 0", __func__, 4103); } while (0); } while (0);
      int len = snprintf(ptr, left, "%02x", data[i]);
      if (len < 0 || len >= left)
        break;
      ptr += len;
    }
    if (ptr < detent) {
      ptr[0] = '>';
      ptr[1] = '\0';
    }
  }
  return buf;
}




static const char *mdbx_leafnode_type(MDBX_node *n) {
  static const char *const tp[2][2] = {{"", ": DB"},
                                       {": sub-page", ": sub-DB"}};
  return (((node_flags(n)) & (0x01)) == (0x01))
             ? ": overflow page"
             : tp[(((node_flags(n)) & (0x04)) == (0x04))]
                 [(((node_flags(n)) & (0x02)) == (0x02))];
}


__attribute__((__unused__)) static void mdbx_page_list(MDBX_page *mp) {
  pgno_t pgno = mp->mp_pgno;
  const char *type;
  MDBX_node *node;
  unsigned i, nkeys, nsize, total = 0;
  MDBX_val key;
  char _kbuf[511 * 4 + 2];

  switch (mp->mp_flags &
          (0x01 | 0x02 | 0x20 | 0x08 | 0x04 | 0x40)) {
  case 0x01:
    type = "Branch page";
    break;
  case 0x02:
    type = "Leaf page";
    break;
  case 0x02 | 0x40:
    type = "Leaf sub-page";
    break;
  case 0x02 | 0x20:
    type = "Leaf2 page";
    break;
  case 0x02 | 0x20 | 0x40:
    type = "Leaf2 sub-page";
    break;
  case 0x04:
    do { if ((MDBX_LOG_VERBOSE < MDBX_LOG_VERBOSE && MDBX_LOG_VERBOSE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_VERBOSE, __func__, 4156, "Overflow page %" 
# 4156 "/libmdbx/src/core.c" 3 4
   "u" 
# 4156 "/libmdbx/src/core.c"
   " pages %u\n" "\n", pgno, mp->mp_pages); } while (0);
    return;
  case 0x08:
    do { if ((MDBX_LOG_VERBOSE < MDBX_LOG_VERBOSE && MDBX_LOG_VERBOSE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_VERBOSE, __func__, 4159, "Meta-page %" 
# 4159 "/libmdbx/src/core.c" 3 4
   "u" 
# 4159 "/libmdbx/src/core.c"
   " txnid %" 
# 4159 "/libmdbx/src/core.c" 3 4
   "l" "u" 
# 4159 "/libmdbx/src/core.c"
   "\n" "\n", pgno, unaligned_peek_u64(4, page_meta(mp)->mm_txnid_a)); } while (0)
                                                                  ;
    return;
  default:
    do { if ((MDBX_LOG_VERBOSE < MDBX_LOG_VERBOSE && MDBX_LOG_VERBOSE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_VERBOSE, __func__, 4163, "Bad page %" 
# 4163 "/libmdbx/src/core.c" 3 4
   "u" 
# 4163 "/libmdbx/src/core.c"
   " flags 0x%X\n" "\n", pgno, mp->mp_flags); } while (0);
    return;
  }

  nkeys = page_numkeys(mp);
  do { if ((MDBX_LOG_VERBOSE < MDBX_LOG_VERBOSE && MDBX_LOG_VERBOSE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_VERBOSE, __func__, 4168, "%s %" 
# 4168 "/libmdbx/src/core.c" 3 4
 "u" 
# 4168 "/libmdbx/src/core.c"
 " numkeys %u\n" "\n", type, pgno, nkeys); } while (0);

  for (i = 0; i < nkeys; i++) {
    if (__builtin_expect(!!(((mp)->mp_flags & 0x20) != 0), 0)) {
      key.iov_len = nsize = mp->mp_leaf2_ksize;
      key.iov_base = page_leaf2key(mp, i, nsize);
      total += nsize;
      do { if ((MDBX_LOG_VERBOSE < MDBX_LOG_VERBOSE && MDBX_LOG_VERBOSE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_VERBOSE, __func__, 4175, "key %u: nsize %u, %s\n" "\n", i, nsize, mdbx_dump_val(&key, _kbuf, 511 * 2 + 1)); } while (0);
      continue;
    }
    node = page_node(mp, i);
    key.iov_len = node_ks(node);
    key.iov_base = node->mn_data;
    nsize = (unsigned)(
# 4181 "/libmdbx/src/core.c" 3 4
                      __builtin_offsetof (
# 4181 "/libmdbx/src/core.c"
                      MDBX_node
# 4181 "/libmdbx/src/core.c" 3 4
                      , 
# 4181 "/libmdbx/src/core.c"
                      mn_data
# 4181 "/libmdbx/src/core.c" 3 4
                      ) 
# 4181 "/libmdbx/src/core.c"
                               + key.iov_len);
    if ((((mp)->mp_flags & 0x01) != 0)) {
      do { if ((MDBX_LOG_VERBOSE < MDBX_LOG_VERBOSE && MDBX_LOG_VERBOSE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_VERBOSE, __func__, 4183, "key %u: page %" 
# 4183 "/libmdbx/src/core.c" 3 4
     "u" 
# 4183 "/libmdbx/src/core.c"
     ", %s\n" "\n", i, node_pgno(node), mdbx_dump_val(&key, _kbuf, 511 * 2 + 1)); } while (0)
                              ;
      total += nsize;
    } else {
      if ((((node_flags(node)) & (0x01)) == (0x01)))
        nsize += sizeof(pgno_t);
      else
        nsize += (unsigned)node_ds(node);
      total += nsize;
      nsize += sizeof(indx_t);
      do { if ((MDBX_LOG_VERBOSE < MDBX_LOG_VERBOSE && MDBX_LOG_VERBOSE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_VERBOSE, __func__, 4193, "key %u: nsize %u, %s%s\n" "\n", i, nsize, mdbx_dump_val(&key, _kbuf, 511 * 2 + 1), mdbx_leafnode_type(node)); } while (0)
                                            ;
    }
    total = (((total) + 1U) & -2);
  }
  do { if ((MDBX_LOG_VERBOSE < MDBX_LOG_VERBOSE && MDBX_LOG_VERBOSE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_VERBOSE, __func__, 4198, "Total: header %u + contents %u + unused %u\n" "\n", __builtin_expect(!!(((mp)->mp_flags & 0x20) != 0), 0) ? ((unsigned)
# 4198 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 4198 "/libmdbx/src/core.c"
 MDBX_page
# 4198 "/libmdbx/src/core.c" 3 4
 , 
# 4198 "/libmdbx/src/core.c"
 mp_ptrs
# 4198 "/libmdbx/src/core.c" 3 4
 )
# 4198 "/libmdbx/src/core.c"
 ) : ((unsigned)
# 4198 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 4198 "/libmdbx/src/core.c"
 MDBX_page
# 4198 "/libmdbx/src/core.c" 3 4
 , 
# 4198 "/libmdbx/src/core.c"
 mp_ptrs
# 4198 "/libmdbx/src/core.c" 3 4
 )
# 4198 "/libmdbx/src/core.c"
 ) + mp->mp_lower, total, page_room(mp)); } while (0)

                             ;
}
# 4220 "/libmdbx/src/core.c"
__attribute__((__unused__)) static _Bool cursor_is_tracked(const MDBX_cursor *mc) {
  for (MDBX_cursor *scan = mc->mc_txn->mt_cursors[mc->mc_dbi]; scan;
       scan = scan->mc_next)
    if (mc == ((mc->mc_flags & 0x04) ? &scan->mc_xcursor->mx_cursor : scan))
      return (1);
  return (0);
}
# 4250 "/libmdbx/src/core.c"
int mdbx_cmp(const MDBX_txn *txn, MDBX_dbi dbi, const MDBX_val *a,
             const MDBX_val *b) {
  do { if ((0)) do { if (__builtin_expect(!!(!(txn->mt_signature == 0x93D53A31U)), 0)) mdbx_assert_fail(
# 4252 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 4252 "/libmdbx/src/core.c"
 , "txn->mt_signature == 0x93D53A31U", __func__, 4252); } while (0); } while (0);
  return txn->mt_dbxs[dbi].md_cmp(a, b);
}

int mdbx_dcmp(const MDBX_txn *txn, MDBX_dbi dbi, const MDBX_val *a,
              const MDBX_val *b) {
  do { if ((0)) do { if (__builtin_expect(!!(!(txn->mt_signature == 0x93D53A31U)), 0)) mdbx_assert_fail(
# 4258 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 4258 "/libmdbx/src/core.c"
 , "txn->mt_signature == 0x93D53A31U", __func__, 4258); } while (0); } while (0);
  return txn->mt_dbxs[dbi].md_dcmp(a, b);
}




static MDBX_page *mdbx_page_malloc(MDBX_txn *txn, unsigned num) {
  MDBX_env *env = txn->mt_env;
  MDBX_page *np = env->me_dp_reserve;
  size_t size = env->me_psize;
  if (__builtin_expect(!!(num == 1 && np), 1)) {
    do { if ((0)) do { if (__builtin_expect(!!(!(env->me_dp_reserve_len > 0)), 0)) mdbx_assert_fail(env, "env->me_dp_reserve_len > 0", __func__, 4270); } while (0); } while (0);
    do { do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 4271, "UNPOISON_MEMORY_REGION(%p, %zu) at %u" "\n", (void *)(np), (size_t)(size), 4271); } while (0); ((void)(np), (void)(size)); } while (0);
    ;
    ;
    env->me_dp_reserve = np->mp_next;
    env->me_dp_reserve_len -= 1;
  } else {
    size = pgno2bytes(env, num);
    np = malloc(size);
    if (__builtin_expect(!!(!np), 0)) {
      txn->mt_flags |= 0x02;
      return np;
    }
    ;
  }

  if ((env->me_flags & MDBX_NOMEMINIT) == 0) {



    size_t skip = ((unsigned)
# 4290 "/libmdbx/src/core.c" 3 4
                 __builtin_offsetof (
# 4290 "/libmdbx/src/core.c"
                 MDBX_page
# 4290 "/libmdbx/src/core.c" 3 4
                 , 
# 4290 "/libmdbx/src/core.c"
                 mp_ptrs
# 4290 "/libmdbx/src/core.c" 3 4
                 )
# 4290 "/libmdbx/src/core.c"
                 );
    if (num > 1)
      skip += pgno2bytes(env, num - 1);
    memset((char *)np + skip, 0, size - skip);
  }



  ;
  np->mp_flags = 0;
  np->mp_pages = num;
  return np;
}


static void mdbx_dpage_free(MDBX_env *env, MDBX_page *dp, unsigned npages) {
  ;
  do { do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 4307, "UNPOISON_MEMORY_REGION(%p, %zu) at %u" "\n", (void *)(dp), (size_t)(pgno2bytes(env, npages)), 4307); } while (0); ((void)(dp), (void)(pgno2bytes(env, npages))); } while (0);
  if (0 != 0 || __builtin_expect(!!(env->me_flags & MDBX_PAGEPERTURB), 0))
    memset(dp, -1, pgno2bytes(env, npages));
  if (npages == 1 &&
      env->me_dp_reserve_len < env->me_options.dp_reserve_limit) {
    do { do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 4312, "POISON_MEMORY_REGION(%p, %zu) at %u" "\n", (void *)((char *)dp + sizeof(dp->mp_next)), (size_t)(pgno2bytes(env, npages) - sizeof(dp->mp_next)), 4312); } while (0); ((void)((char *)dp + sizeof(dp->mp_next)), (void)(pgno2bytes(env, npages) - sizeof(dp->mp_next))); } while (0)

                                                           ;
    dp->mp_next = env->me_dp_reserve;
    ;
    env->me_dp_reserve = dp;
    env->me_dp_reserve_len += 1;
  } else {

    ;
    free(dp);
  }
}


static void mdbx_dlist_free(MDBX_txn *txn) {
  MDBX_env *env = txn->mt_env;
  MDBX_dpl *const dl = txn->tw.dirtylist;

  for (unsigned i = 1; i <= dl->length; i++) {
    MDBX_page *dp = dl->items[i].ptr;
    mdbx_dpage_free(env, dp, dpl_npages(dl, i));
  }

  dpl_clear(dl);
}

static 
# 4339 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 4339 "/libmdbx/src/core.c"
                      MDBX_db *mdbx_outer_db(MDBX_cursor *mc) {
  do { if ((0)) do { if (__builtin_expect(!!(!((mc->mc_flags & 0x04) != 0)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "(mc->mc_flags & 0x04) != 0", __func__, 4340); } while (0); } while (0);
  MDBX_xcursor *mx = ((MDBX_xcursor *)((char *)(mc->mc_db) - 
# 4341 "/libmdbx/src/core.c" 3 4
                    __builtin_offsetof (
# 4341 "/libmdbx/src/core.c"
                    MDBX_xcursor
# 4341 "/libmdbx/src/core.c" 3 4
                    , 
# 4341 "/libmdbx/src/core.c"
                    mx_db
# 4341 "/libmdbx/src/core.c" 3 4
                    )
# 4341 "/libmdbx/src/core.c"
                    ));
  MDBX_cursor_couple *couple = ((MDBX_cursor_couple *)((char *)(mx) - 
# 4342 "/libmdbx/src/core.c" 3 4
                              __builtin_offsetof (
# 4342 "/libmdbx/src/core.c"
                              MDBX_cursor_couple
# 4342 "/libmdbx/src/core.c" 3 4
                              , 
# 4342 "/libmdbx/src/core.c"
                              inner
# 4342 "/libmdbx/src/core.c" 3 4
                              )
# 4342 "/libmdbx/src/core.c"
                              ));
  do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_db == &couple->outer.mc_xcursor->mx_db)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mc->mc_db == &couple->outer.mc_xcursor->mx_db", __func__, 4343); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_dbx == &couple->outer.mc_xcursor->mx_dbx)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mc->mc_dbx == &couple->outer.mc_xcursor->mx_dbx", __func__, 4344); } while (0); } while (0);
  return couple->outer.mc_db;
}

__attribute__((__unused__)) __attribute__((__cold__)) __attribute__((__optimize__("Os"))) static _Bool mdbx_dirtylist_check(MDBX_txn *txn) {
  const MDBX_dpl *const dl = txn->tw.dirtylist;
  do { if ((0)) do { if (__builtin_expect(!!(!(dl->items[0].pgno == 0 && dl->items[dl->length + 1].pgno == (~(pgno_t)0))), 0)) mdbx_assert_fail(
# 4350 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 4350 "/libmdbx/src/core.c"
 , "dl->items[0].pgno == 0 && dl->items[dl->length + 1].pgno == (~(pgno_t)0)", __func__, 4350); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(txn->tw.dirtyroom + dl->length == (txn->mt_parent ? txn->mt_parent->tw.dirtyroom : txn->mt_env->me_options.dp_limit))), 0)) mdbx_assert_fail((txn)->mt_env, "txn->tw.dirtyroom + dl->length == (txn->mt_parent ? txn->mt_parent->tw.dirtyroom : txn->mt_env->me_options.dp_limit)", __func__, 4351); } while (0); } while (0)

                                                                            ;

  if (!(0))
    return (1);

  unsigned loose = 0;
  for (unsigned i = dl->length; i > 0; --i) {
    const MDBX_page *const dp = dl->items[i].ptr;
    if (!dp)
      continue;

    do { if ((0)) do { if (__builtin_expect(!!(!(dp->mp_pgno == dl->items[i].pgno)), 0)) mdbx_assert_fail((txn)->mt_env, "dp->mp_pgno == dl->items[i].pgno", __func__, 4364); } while (0); } while (0);
    if (__builtin_expect(!!(dp->mp_pgno != dl->items[i].pgno), 0))
      return (0);

    const uint32_t age = mdbx_dpl_age(txn, i);
    do { if ((0)) do { if (__builtin_expect(!!(!(age < 
# 4369 "/libmdbx/src/core.c" 3 4
   (4294967295U) 
# 4369 "/libmdbx/src/core.c"
   / 3)), 0)) mdbx_assert_fail((txn)->mt_env, "age < (4294967295U) / 3", __func__, 4369); } while (0); } while (0);
    if (__builtin_expect(!!(age > 
# 4370 "/libmdbx/src/core.c" 3 4
       (4294967295U) 
# 4370 "/libmdbx/src/core.c"
       / 3), 0))
      return (0);

    do { if ((0)) do { if (__builtin_expect(!!(!(dp->mp_flags == 0x4000 || ((dp)->mp_txnid == (txn)->mt_front))), 0)) mdbx_assert_fail((txn)->mt_env, "dp->mp_flags == 0x4000 || ((dp)->mp_txnid == (txn)->mt_front)", __func__, 4373); } while (0); } while (0);
    if (dp->mp_flags == 0x4000) {
      loose += 1;
    } else if (__builtin_expect(!!(!((dp)->mp_txnid == (txn)->mt_front)), 0))
      return (0);

    const unsigned num = dpl_npages(dl, i);
    do { if ((0)) do { if (__builtin_expect(!!(!(txn->mt_geo.next >= dp->mp_pgno + num)), 0)) mdbx_assert_fail((txn)->mt_env, "txn->mt_geo.next >= dp->mp_pgno + num", __func__, 4380); } while (0); } while (0);
    if (__builtin_expect(!!(txn->mt_geo.next < dp->mp_pgno + num), 0))
      return (0);

    if (i < dl->sorted) {
      do { if ((0)) do { if (__builtin_expect(!!(!(dl->items[i + 1].pgno >= dp->mp_pgno + num)), 0)) mdbx_assert_fail((txn)->mt_env, "dl->items[i + 1].pgno >= dp->mp_pgno + num", __func__, 4385); } while (0); } while (0);
      if (__builtin_expect(!!(dl->items[i + 1].pgno < dp->mp_pgno + num), 0))
        return (0);
    }

    const unsigned rpa = mdbx_pnl_search(txn->tw.reclaimed_pglist, dp->mp_pgno,
                                         txn->mt_geo.next);
    do { if ((0)) do { if (__builtin_expect(!!(!(rpa > ((txn->tw.reclaimed_pglist)[0]) || txn->tw.reclaimed_pglist[rpa] != dp->mp_pgno)), 0)) mdbx_assert_fail((txn)->mt_env, "rpa > ((txn->tw.reclaimed_pglist)[0]) || txn->tw.reclaimed_pglist[rpa] != dp->mp_pgno", __func__, 4392); } while (0); } while (0)
                                                                       ;
    if (rpa <= ((txn->tw.reclaimed_pglist)[0]) &&
        __builtin_expect(!!(txn->tw.reclaimed_pglist[rpa] == dp->mp_pgno), 0))
      return (0);
    if (num > 1) {
      const unsigned rpb = mdbx_pnl_search(
          txn->tw.reclaimed_pglist, dp->mp_pgno + num - 1, txn->mt_geo.next);
      do { if ((0)) do { if (__builtin_expect(!!(!(rpa == rpb)), 0)) mdbx_assert_fail((txn)->mt_env, "rpa == rpb", __func__, 4400); } while (0); } while (0);
      if (__builtin_expect(!!(rpa != rpb), 0))
        return (0);
    }
  }

  do { if ((0)) do { if (__builtin_expect(!!(!(loose == txn->tw.loose_count)), 0)) mdbx_assert_fail((txn)->mt_env, "loose == txn->tw.loose_count", __func__, 4406); } while (0); } while (0);
  if (__builtin_expect(!!(loose != txn->tw.loose_count), 0))
    return (0);

  for (unsigned i = 1; i <= ((txn->tw.retired_pages)[0]); ++i) {
    const MDBX_page *const dp = debug_dpl_find(txn, txn->tw.retired_pages[i]);
    do { if ((0)) do { if (__builtin_expect(!!(!(!dp)), 0)) mdbx_assert_fail((txn)->mt_env, "!dp", __func__, 4412); } while (0); } while (0);
    if (__builtin_expect(!!(dp), 0))
      return (0);
  }

  return (1);
}


static void mdbx_refund_reclaimed(MDBX_txn *txn) {

  pgno_t next_pgno = txn->mt_geo.next;
  const MDBX_PNL pnl = txn->tw.reclaimed_pglist;
  do { if ((0)) do { if (__builtin_expect(!!(!(((pnl)[0]) && ((pnl)[1]) == next_pgno - 1)), 0)) mdbx_assert_fail((txn)->mt_env, "((pnl)[0]) && ((pnl)[1]) == next_pgno - 1", __func__, 4425); } while (0); } while (0);







  unsigned i = 1;
  do { if ((0)) do { if (__builtin_expect(!!(!(pnl[i] == next_pgno - 1)), 0)) mdbx_assert_fail((txn)->mt_env, "pnl[i] == next_pgno - 1", __func__, 4434); } while (0); } while (0);
  unsigned len = ((pnl)[0]);
  while (--next_pgno, ++i <= len && pnl[i] == next_pgno - 1)
    ;
  ((pnl)[0]) = len -= i - 1;
  for (unsigned move = 0; move < len; ++move)
    pnl[1 + move] = pnl[i + move];

  do { if ((MDBX_LOG_VERBOSE < MDBX_LOG_VERBOSE && MDBX_LOG_VERBOSE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_VERBOSE, __func__, 4442, "refunded %" 
# 4442 "/libmdbx/src/core.c" 3 4
 "u" 
# 4442 "/libmdbx/src/core.c"
 " pages: %" 
# 4442 "/libmdbx/src/core.c" 3 4
 "u" 
# 4442 "/libmdbx/src/core.c"
 " -> %" 
# 4442 "/libmdbx/src/core.c" 3 4
 "u" 
# 4442 "/libmdbx/src/core.c"
 "\n", txn->mt_geo.next - next_pgno, txn->mt_geo.next, next_pgno); } while (0)
                                                                           ;
  txn->mt_geo.next = next_pgno;
  do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_pnl_check4assert(txn->tw.reclaimed_pglist, txn->mt_geo.next - 1))), 0)) mdbx_assert_fail((txn)->mt_env, "mdbx_pnl_check4assert(txn->tw.reclaimed_pglist, txn->mt_geo.next - 1)", __func__, 4445); } while (0); } while (0)
                                                                 ;
}

static void mdbx_refund_loose(MDBX_txn *txn) {
  do { if ((0)) do { if (__builtin_expect(!!(!(txn->tw.loose_pages != 
# 4450 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 4450 "/libmdbx/src/core.c"
 )), 0)) mdbx_assert_fail((txn)->mt_env, "txn->tw.loose_pages != ((void *)0)", __func__, 4450); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(txn->tw.loose_count > 0)), 0)) mdbx_assert_fail((txn)->mt_env, "txn->tw.loose_count > 0", __func__, 4451); } while (0); } while (0);

  MDBX_dpl *const dl = txn->tw.dirtylist;
  do { if ((0)) do { if (__builtin_expect(!!(!(dl->length >= txn->tw.loose_count)), 0)) mdbx_assert_fail((txn)->mt_env, "dl->length >= txn->tw.loose_count", __func__, 4454); } while (0); } while (0);

  pgno_t onstack[64 * 8 / sizeof(pgno_t)];
  MDBX_PNL suitable = onstack;

  if (dl->length - dl->sorted > txn->tw.loose_count) {

    if (bytes2pnl(sizeof(onstack)) < txn->tw.loose_count) {
      suitable = mdbx_pnl_alloc(txn->tw.loose_count);
      if (__builtin_expect(!!(!suitable), 0))
        return ;
    }


    do { if ((0)) do { if (__builtin_expect(!!(!(txn->mt_geo.next >= 3 + txn->tw.loose_count)), 0)) mdbx_assert_fail((txn)->mt_env, "txn->mt_geo.next >= 3 + txn->tw.loose_count", __func__, 4468); } while (0); } while (0);
    pgno_t most = 3;
    unsigned w = 0;
    for (const MDBX_page *lp = txn->tw.loose_pages; lp; lp = lp->mp_next) {
      do { if ((0)) do { if (__builtin_expect(!!(!(lp->mp_flags == 0x4000)), 0)) mdbx_assert_fail((txn)->mt_env, "lp->mp_flags == 0x4000", __func__, 4472); } while (0); } while (0);
      do { if ((0)) do { if (__builtin_expect(!!(!(txn->mt_geo.next > lp->mp_pgno)), 0)) mdbx_assert_fail((txn)->mt_env, "txn->mt_geo.next > lp->mp_pgno", __func__, 4473); } while (0); } while (0);
      if (__builtin_expect(!!(txn->mt_geo.next - txn->tw.loose_count <= lp->mp_pgno), 1)) {
        do { if ((0)) do { if (__builtin_expect(!!(!(w < ((suitable == onstack) ? bytes2pnl(sizeof(onstack)) : ((suitable)[-1])))), 0)) mdbx_assert_fail((txn)->mt_env, "w < ((suitable == onstack) ? bytes2pnl(sizeof(onstack)) : ((suitable)[-1]))", __func__, 4475); } while (0); } while (0)

                                                                               ;
        suitable[++w] = lp->mp_pgno;
        most = (lp->mp_pgno > most) ? lp->mp_pgno : most;
      }
    }

    if (most + 1 == txn->mt_geo.next) {

      ((suitable)[0]) = w;
      mdbx_pnl_sort(suitable, 0x7FFFffffU + 1);


      const int step = 0 ? -1 : 1;
      const int begin = 0 ? ((suitable)[0]) : 1;
      const int end = 0 ? 0 : ((suitable)[0]) + 1;
      do { if ((0)) do { if (__builtin_expect(!!(!(suitable[begin] >= suitable[end - step])), 0)) mdbx_assert_fail((txn)->mt_env, "suitable[begin] >= suitable[end - step]", __func__, 4492); } while (0); } while (0);
      do { if ((0)) do { if (__builtin_expect(!!(!(most == suitable[begin])), 0)) mdbx_assert_fail((txn)->mt_env, "most == suitable[begin]", __func__, 4493); } while (0); } while (0);

      for (int i = begin + step; i != end; i += step) {
        if (suitable[i] != most - 1)
          break;
        most -= 1;
      }
      const unsigned refunded = txn->mt_geo.next - most;
      do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 4501, "refund-suitable %u pages %" 
# 4501 "/libmdbx/src/core.c" 3 4
     "u" 
# 4501 "/libmdbx/src/core.c"
     " -> %" 
# 4501 "/libmdbx/src/core.c" 3 4
     "u" 
# 4501 "/libmdbx/src/core.c"
     "\n", refunded, most, txn->mt_geo.next); } while (0)
                                                   ;
      txn->tw.loose_count -= refunded;
      txn->tw.dirtyroom += refunded;
      do { if ((0)) do { if (__builtin_expect(!!(!(txn->tw.dirtyroom <= txn->mt_env->me_options.dp_limit)), 0)) mdbx_assert_fail(
# 4505 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 4505 "/libmdbx/src/core.c"
     , "txn->tw.dirtyroom <= txn->mt_env->me_options.dp_limit", __func__, 4505); } while (0); } while (0);
      txn->mt_geo.next = most;


      unsigned r = 0;
      w = 0;
      if (dl->sorted) {
        do {
          if (dl->items[++r].pgno < most) {
            if (++w != r)
              dl->items[w] = dl->items[r];
          }
        } while (r < dl->sorted);
        dl->sorted = w;
      }
      while (r < dl->length) {
        if (dl->items[++r].pgno < most) {
          if (++w != r)
            dl->items[w] = dl->items[r];
        }
      }
      dpl_setlen(dl, w);
      do { if ((0)) do { if (__builtin_expect(!!(!(txn->tw.dirtyroom + txn->tw.dirtylist->length == (txn->mt_parent ? txn->mt_parent->tw.dirtyroom : txn->mt_env->me_options.dp_limit))), 0)) mdbx_assert_fail((txn)->mt_env, "txn->tw.dirtyroom + txn->tw.dirtylist->length == (txn->mt_parent ? txn->mt_parent->tw.dirtyroom : txn->mt_env->me_options.dp_limit)", __func__, 4527); } while (0); } while (0)


                                                                           ;

      goto unlink_loose;
    }
  } else {

    mdbx_dpl_sort(txn);
    do { if ((0)) do { if (__builtin_expect(!!(!(dl->length < 2 || dl->items[1].pgno < dl->items[dl->length].pgno)), 0)) mdbx_assert_fail((txn)->mt_env, "dl->length < 2 || dl->items[1].pgno < dl->items[dl->length].pgno", __func__, 4537); } while (0); } while (0)
                                                                         ;
    do { if ((0)) do { if (__builtin_expect(!!(!(dl->sorted == dl->length)), 0)) mdbx_assert_fail((txn)->mt_env, "dl->sorted == dl->length", __func__, 4539); } while (0); } while (0);


    unsigned n;
    for (n = dl->length; dl->items[n].pgno == txn->mt_geo.next - 1 &&
                         dl->items[n].ptr->mp_flags == 0x4000;
         --n) {
      do { if ((0)) do { if (__builtin_expect(!!(!(n > 0)), 0)) mdbx_assert_fail((txn)->mt_env, "n > 0", __func__, 4546); } while (0); } while (0);
      MDBX_page *dp = dl->items[n].ptr;
      do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 4548, "refund-sorted page %" 
# 4548 "/libmdbx/src/core.c" 3 4
     "u" 
# 4548 "/libmdbx/src/core.c"
     "\n", dp->mp_pgno); } while (0);
      do { if ((0)) do { if (__builtin_expect(!!(!(dp->mp_pgno == dl->items[n].pgno)), 0)) mdbx_assert_fail((txn)->mt_env, "dp->mp_pgno == dl->items[n].pgno", __func__, 4549); } while (0); } while (0);
      txn->mt_geo.next -= 1;
    }
    dpl_setlen(dl, n);

    if (dl->sorted != dl->length) {
      const unsigned refunded = dl->sorted - dl->length;
      dl->sorted = dl->length;
      txn->tw.loose_count -= refunded;
      txn->tw.dirtyroom += refunded;
      do { if ((0)) do { if (__builtin_expect(!!(!(txn->tw.dirtyroom + txn->tw.dirtylist->length == (txn->mt_parent ? txn->mt_parent->tw.dirtyroom : txn->mt_env->me_options.dp_limit))), 0)) mdbx_assert_fail((txn)->mt_env, "txn->tw.dirtyroom + txn->tw.dirtylist->length == (txn->mt_parent ? txn->mt_parent->tw.dirtyroom : txn->mt_env->me_options.dp_limit)", __func__, 4559); } while (0); } while (0)


                                                                           ;


    unlink_loose:
      for (MDBX_page **link = &txn->tw.loose_pages; *link;) {
        MDBX_page *dp = *link;
        do { if ((0)) do { if (__builtin_expect(!!(!(dp->mp_flags == 0x4000)), 0)) mdbx_assert_fail((txn)->mt_env, "dp->mp_flags == 0x4000", __func__, 4568); } while (0); } while (0);
        if (txn->mt_geo.next > dp->mp_pgno) {
          link = &dp->mp_next;
        } else {
          *link = dp->mp_next;
          if ((txn->mt_flags & MDBX_WRITEMAP) == 0)
            mdbx_dpage_free(txn->mt_env, dp, 1);
        }
      }
    }
  }

  do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_dirtylist_check(txn))), 0)) mdbx_assert_fail((txn)->mt_env, "mdbx_dirtylist_check(txn)", __func__, 4580); } while (0); } while (0);
  if (suitable != onstack)
    mdbx_pnl_free(suitable);
  txn->tw.loose_refund_wl = txn->mt_geo.next;
}

static _Bool mdbx_refund(MDBX_txn *txn) {
  const pgno_t before = txn->mt_geo.next;

  if (txn->tw.loose_pages && txn->tw.loose_refund_wl > txn->mt_geo.next)
    mdbx_refund_loose(txn);

  while ((1)) {
    if (((txn->tw.reclaimed_pglist)[0]) == 0 ||
        ((txn->tw.reclaimed_pglist)[1]) != txn->mt_geo.next - 1)
      break;

    mdbx_refund_reclaimed(txn);
    if (!txn->tw.loose_pages || txn->tw.loose_refund_wl <= txn->mt_geo.next)
      break;

    const pgno_t memo = txn->mt_geo.next;
    mdbx_refund_loose(txn);
    if (memo == txn->mt_geo.next)
      break;
  }

  if (before == txn->mt_geo.next)
    return (0);

  if (txn->tw.spill_pages)

    mdbx_spill_purge(txn);

  return (1);
}
# 4624 "/libmdbx/src/core.c"
__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static void mdbx_kill_page(MDBX_txn *txn, MDBX_page *mp, pgno_t pgno,
                                  unsigned npages) {
  MDBX_env *const env = txn->mt_env;
  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 4627, "kill %u page(s) %" 
# 4627 "/libmdbx/src/core.c" 3 4
 "u" 
# 4627 "/libmdbx/src/core.c"
 "\n", npages, pgno); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(pgno >= 3 && npages)), 0)) mdbx_assert_fail(env, "pgno >= 3 && npages", __func__, 4628); } while (0); } while (0);
  if (!((mp)->mp_txnid < (txn)->mt_txnid)) {
    const size_t bytes = pgno2bytes(env, npages);
    memset(mp, -1, bytes);
    mp->mp_pgno = pgno;
    if ((env->me_flags & MDBX_WRITEMAP) == 0)
      mdbx_pwrite(env->me_dxb_mmap.fd, mp, bytes, pgno2bytes(env, pgno));
  } else {
    struct iovec iov[64];
    iov[0].iov_len = env->me_psize;
    iov[0].iov_base = (char *)env->me_pbuf + env->me_psize;
    size_t iov_off = pgno2bytes(env, pgno);
    unsigned n = 1;
    while (--npages) {
      iov[n] = iov[0];
      if (++n == 64) {
        mdbx_pwritev(env->me_dxb_mmap.fd, iov, 64, iov_off,
                     pgno2bytes(env, 64));
        iov_off += pgno2bytes(env, 64);
        n = 0;
      }
    }
    mdbx_pwritev(env->me_dxb_mmap.fd, iov, n, iov_off, pgno2bytes(env, n));
  }
}


static __inline void mdbx_page_wash(MDBX_txn *txn, const unsigned di,
                                    MDBX_page *const mp,
                                    const unsigned npages) {
  do { if ((0)) do { if (__builtin_expect(!!(!(di && di <= txn->tw.dirtylist->length && txn->tw.dirtylist->items[di].ptr == mp)), 0)) mdbx_assert_fail((txn)->mt_env, "di && di <= txn->tw.dirtylist->length && txn->tw.dirtylist->items[di].ptr == mp", __func__, 4658); } while (0); } while (0)
                                                               ;
  mdbx_dpl_remove(txn, di);
  txn->tw.dirtyroom++;
  do { if ((0)) do { if (__builtin_expect(!!(!(txn->tw.dirtyroom + txn->tw.dirtylist->length == (txn->mt_parent ? txn->mt_parent->tw.dirtyroom : txn->mt_env->me_options.dp_limit))), 0)) mdbx_assert_fail((txn)->mt_env, "txn->tw.dirtyroom + txn->tw.dirtylist->length == (txn->mt_parent ? txn->mt_parent->tw.dirtyroom : txn->mt_env->me_options.dp_limit)", __func__, 4662); } while (0); } while (0)

                                                                            ;
  mp->mp_txnid = 
# 4665 "/libmdbx/src/core.c" 3 4
                (18446744073709551615UL)
# 4665 "/libmdbx/src/core.c"
                             ;
  mp->mp_flags = 0xFFFF;
  ;
  if (txn->mt_flags & MDBX_WRITEMAP) {
   
                                                                           ;
    do { do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 4671, "POISON_MEMORY_REGION(%p, %zu) at %u" "\n", (void *)(page_data(mp)), (size_t)(pgno2bytes(txn->mt_env, npages) - ((unsigned)
# 4671 "/libmdbx/src/core.c" 3 4
   __builtin_offsetof (
# 4671 "/libmdbx/src/core.c"
   MDBX_page
# 4671 "/libmdbx/src/core.c" 3 4
   , 
# 4671 "/libmdbx/src/core.c"
   mp_ptrs
# 4671 "/libmdbx/src/core.c" 3 4
   )
# 4671 "/libmdbx/src/core.c"
   )), 4671); } while (0); ((void)(page_data(mp)), (void)(pgno2bytes(txn->mt_env, npages) - ((unsigned)
# 4671 "/libmdbx/src/core.c" 3 4
   __builtin_offsetof (
# 4671 "/libmdbx/src/core.c"
   MDBX_page
# 4671 "/libmdbx/src/core.c" 3 4
   , 
# 4671 "/libmdbx/src/core.c"
   mp_ptrs
# 4671 "/libmdbx/src/core.c" 3 4
   )
# 4671 "/libmdbx/src/core.c"
   ))); } while (0)
                                                                               ;
  } else
    mdbx_dpage_free(txn->mt_env, mp, npages);
}

static __inline txnid_t pp_txnid4chk(const MDBX_page *mp, const MDBX_txn *txn) {
  (void)txn;




  return mp->mp_txnid;

}
# 4695 "/libmdbx/src/core.c"
static int mdbx_page_retire_ex(MDBX_cursor *mc, const pgno_t pgno,
                               MDBX_page *mp ,
                               int pagetype ) {
  int rc;
  MDBX_txn *const txn = mc->mc_txn;
  do { if ((0)) do { if (__builtin_expect(!!(!(!mp || (mp->mp_pgno == pgno && ((mp)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) == pagetype))), 0)) mdbx_assert_fail((txn)->mt_env, "!mp || (mp->mp_pgno == pgno && ((mp)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) == pagetype)", __func__, 4700); } while (0); } while (0);
# 4713 "/libmdbx/src/core.c"
  unsigned di = 0, si = 0, npages = 1;
  _Bool is_frozen = (0), is_spilled = (0), is_shadowed = (0);
  if (__builtin_expect(!!(!mp), 0)) {
    if ((0) && pagetype) {
      MDBX_page *check;
      rc = mdbx_page_get(mc, pgno, &check, txn->mt_front);
      if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
        return rc;
      do { if ((0)) do { if (__builtin_expect(!!(!((((check)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) & ~0x20) == (pagetype & ~0x8000))), 0)) mdbx_assert_fail((txn)->mt_env, "(((check)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) & ~0x20) == (pagetype & ~0x8000)", __func__, 4721); } while (0); } while (0);
      do { if ((0)) do { if (__builtin_expect(!!(!(!(pagetype & 0x8000) || ((check)->mp_txnid < (txn)->mt_txnid))), 0)) mdbx_assert_fail((txn)->mt_env, "!(pagetype & 0x8000) || ((check)->mp_txnid < (txn)->mt_txnid)", __func__, 4722); } while (0); } while (0);
    }
    if (pagetype & 0x8000) {
      is_frozen = (1);
      if ((0)) {
        for (MDBX_txn *scan = txn; scan; scan = scan->mt_parent) {
          do { if ((0)) do { if (__builtin_expect(!!(!(!mdbx_search_spilled(scan, pgno))), 0)) mdbx_assert_fail((txn)->mt_env, "!mdbx_search_spilled(scan, pgno)", __func__, 4728); } while (0); } while (0);
          do { if ((0)) do { if (__builtin_expect(!!(!(!scan->tw.dirtylist || !debug_dpl_find(scan, pgno))), 0)) mdbx_assert_fail((txn)->mt_env, "!scan->tw.dirtylist || !debug_dpl_find(scan, pgno)", __func__, 4729); } while (0); } while (0);
        }
      }
      goto status_done;
    } else if (pagetype && txn->tw.dirtylist) {
      if ((di = mdbx_dpl_exist(txn, pgno)) != 0) {
        mp = txn->tw.dirtylist->items[di].ptr;
        do { if ((0)) do { if (__builtin_expect(!!(!(((mp)->mp_txnid == (txn)->mt_front))), 0)) mdbx_assert_fail((txn)->mt_env, "((mp)->mp_txnid == (txn)->mt_front)", __func__, 4736); } while (0); } while (0);
        goto status_done;
      }
      if ((si = mdbx_search_spilled(txn, pgno)) != 0) {
        is_spilled = (1);
        goto status_done;
      }
      for (MDBX_txn *parent = txn->mt_parent; parent;
           parent = parent->mt_parent) {
        if (mdbx_dpl_exist(parent, pgno)) {
          is_shadowed = (1);
          goto status_done;
        }
        if (mdbx_search_spilled(parent, pgno)) {
          is_spilled = (1);
          goto status_done;
        }
      }
      is_frozen = (1);
      goto status_done;
    }

    rc = mdbx_page_get(mc, pgno, &mp, txn->mt_front);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      return rc;
    do { if ((0)) do { if (__builtin_expect(!!(!(!pagetype || ((mp)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) == pagetype)), 0)) mdbx_assert_fail((txn)->mt_env, "!pagetype || ((mp)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) == pagetype", __func__, 4761); } while (0); } while (0);
    pagetype = ((mp)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04));
  }

  is_frozen = ((mp)->mp_txnid < (txn)->mt_txnid);
  if (!is_frozen) {
    const _Bool is_dirty = ((mp)->mp_txnid == (txn)->mt_front);
    is_spilled = ((mp)->mp_txnid == (txn)->mt_txnid) && !(txn->mt_flags & MDBX_WRITEMAP);
    is_shadowed = ((mp)->mp_txnid > (txn)->mt_txnid);
    if (is_dirty) {
      do { if ((0)) do { if (__builtin_expect(!!(!(!is_spilled)), 0)) mdbx_assert_fail((txn)->mt_env, "!is_spilled", __func__, 4771); } while (0); } while (0);
      do { if ((0)) do { if (__builtin_expect(!!(!(!mdbx_search_spilled(txn, pgno))), 0)) mdbx_assert_fail((txn)->mt_env, "!mdbx_search_spilled(txn, pgno)", __func__, 4772); } while (0); } while (0);
      do { if ((0)) do { if (__builtin_expect(!!(!(debug_dpl_find(txn, pgno) == mp || txn->mt_parent || (txn->mt_flags & MDBX_WRITEMAP))), 0)) mdbx_assert_fail((txn)->mt_env, "debug_dpl_find(txn, pgno) == mp || txn->mt_parent || (txn->mt_flags & MDBX_WRITEMAP)", __func__, 4773); } while (0); } while (0)
                                                            ;
    } else {
      do { if ((0)) do { if (__builtin_expect(!!(!(!debug_dpl_find(txn, pgno))), 0)) mdbx_assert_fail((txn)->mt_env, "!debug_dpl_find(txn, pgno)", __func__, 4776); } while (0); } while (0);
    }

    di = is_dirty ? mdbx_dpl_exist(txn, pgno) : 0;
    si = is_spilled ? mdbx_search_spilled(txn, pgno) : 0;
    do { if ((0)) do { if (__builtin_expect(!!(!(!is_dirty || di || (txn->mt_flags & MDBX_WRITEMAP))), 0)) mdbx_assert_fail((txn)->mt_env, "!is_dirty || di || (txn->mt_flags & MDBX_WRITEMAP)", __func__, 4781); } while (0); } while (0);
  } else {
    do { if ((0)) do { if (__builtin_expect(!!(!(!((mp)->mp_txnid == (txn)->mt_front))), 0)) mdbx_assert_fail((txn)->mt_env, "!((mp)->mp_txnid == (txn)->mt_front)", __func__, 4783); } while (0); } while (0);
    do { if ((0)) do { if (__builtin_expect(!!(!(!((mp)->mp_txnid == (txn)->mt_txnid))), 0)) mdbx_assert_fail((txn)->mt_env, "!((mp)->mp_txnid == (txn)->mt_txnid)", __func__, 4784); } while (0); } while (0);
    do { if ((0)) do { if (__builtin_expect(!!(!(!((mp)->mp_txnid > (txn)->mt_txnid))), 0)) mdbx_assert_fail((txn)->mt_env, "!((mp)->mp_txnid > (txn)->mt_txnid)", __func__, 4785); } while (0); } while (0);
  }

status_done:
  if (__builtin_expect(!!((pagetype & 0x04) == 0), 1)) {
    _Static_assert(0x01 == 1, "P_BRANCH == 1");
    const _Bool is_branch = pagetype & 0x01;
    if (__builtin_expect(!!(mc->mc_flags & 0x04), 0)) {
      MDBX_db *outer = mdbx_outer_db(mc);
      do { if ((0)) do { if (__builtin_expect(!!(!(!is_branch || outer->md_branch_pages > 0)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "!is_branch || outer->md_branch_pages > 0", __func__, 4794); } while (0); } while (0);
      outer->md_branch_pages -= is_branch;
      do { if ((0)) do { if (__builtin_expect(!!(!(is_branch || outer->md_leaf_pages > 0)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "is_branch || outer->md_leaf_pages > 0", __func__, 4796); } while (0); } while (0);
      outer->md_leaf_pages -= 1 - is_branch;
    }
    do { if ((0)) do { if (__builtin_expect(!!(!(!is_branch || mc->mc_db->md_branch_pages > 0)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "!is_branch || mc->mc_db->md_branch_pages > 0", __func__, 4799); } while (0); } while (0);
    mc->mc_db->md_branch_pages -= is_branch;
    do { if ((0)) do { if (__builtin_expect(!!(!((pagetype & 0x02) == 0 || mc->mc_db->md_leaf_pages > 0)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "(pagetype & 0x02) == 0 || mc->mc_db->md_leaf_pages > 0", __func__, 4801); } while (0); } while (0);
    mc->mc_db->md_leaf_pages -= (pagetype & 0x02) != 0;
  } else {
    npages = mp->mp_pages;
    do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_db->md_overflow_pages >= npages)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mc->mc_db->md_overflow_pages >= npages", __func__, 4805); } while (0); } while (0);
    mc->mc_db->md_overflow_pages -= npages;
  }

  if (is_frozen) {
  retire:
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 4811, "retire %u page %" 
# 4811 "/libmdbx/src/core.c" 3 4
   "u" 
# 4811 "/libmdbx/src/core.c"
   "\n", npages, pgno); } while (0);
    rc = mdbx_pnl_append_range((0), &txn->tw.retired_pages, pgno, npages);
    do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_dirtylist_check(txn))), 0)) mdbx_assert_fail((txn)->mt_env, "mdbx_dirtylist_check(txn)", __func__, 4813); } while (0); } while (0);
    return rc;
  }




  if (1 && __builtin_expect(!!(pgno + npages == txn->mt_geo.next), 0)) {
    const char *kind = 
# 4821 "/libmdbx/src/core.c" 3 4
                      ((void *)0)
# 4821 "/libmdbx/src/core.c"
                             ;
    if (di) {



      kind = "dirty";

      mdbx_page_wash(txn, di, mp, npages);
    } else if (si) {



      kind = "spilled";
      mdbx_spill_remove(txn, si, npages);
    } else if ((txn->mt_flags & MDBX_WRITEMAP)) {
      kind = "writemap";
      do { if ((0)) do { if (__builtin_expect(!!(!(mp && ((mp)->mp_txnid == (txn)->mt_front))), 0)) mdbx_assert_fail((txn)->mt_env, "mp && ((mp)->mp_txnid == (txn)->mt_front)", __func__, 4837); } while (0); } while (0);
    } else {



      kind = "parent's";
      if ((0) && mp) {
        kind = 
# 4844 "/libmdbx/src/core.c" 3 4
              ((void *)0)
# 4844 "/libmdbx/src/core.c"
                     ;
        for (MDBX_txn *parent = txn->mt_parent; parent;
             parent = parent->mt_parent) {
          if (mdbx_search_spilled(parent, pgno)) {
            kind = "parent-spilled";
            do { if ((0)) do { if (__builtin_expect(!!(!(is_spilled)), 0)) mdbx_assert_fail((txn)->mt_env, "is_spilled", __func__, 4849); } while (0); } while (0);
            break;
          }
          if (mp == debug_dpl_find(parent, pgno)) {
            kind = "parent-dirty";
            do { if ((0)) do { if (__builtin_expect(!!(!(!is_spilled)), 0)) mdbx_assert_fail((txn)->mt_env, "!is_spilled", __func__, 4854); } while (0); } while (0);
            break;
          }
        }
        do { if ((0)) do { if (__builtin_expect(!!(!(kind != 
# 4858 "/libmdbx/src/core.c" 3 4
       ((void *)0)
# 4858 "/libmdbx/src/core.c"
       )), 0)) mdbx_assert_fail((txn)->mt_env, "kind != ((void *)0)", __func__, 4858); } while (0); } while (0);
      }
      do { if ((0)) do { if (__builtin_expect(!!(!(is_spilled || is_shadowed || (mp && ((mp)->mp_txnid > (txn)->mt_txnid)))), 0)) mdbx_assert_fail((txn)->mt_env, "is_spilled || is_shadowed || (mp && ((mp)->mp_txnid > (txn)->mt_txnid))", __func__, 4860); } while (0); } while (0)
                                                                             ;
    }
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 4863, "refunded %u %s page %" 
# 4863 "/libmdbx/src/core.c" 3 4
   "u" 
# 4863 "/libmdbx/src/core.c"
   "\n", npages, kind, pgno); } while (0);
    txn->mt_geo.next = pgno;
    mdbx_refund(txn);
    return MDBX_SUCCESS;
  }

  if (di) {


    if (__builtin_expect(!!(npages == 1 && txn->tw.loose_count < txn->mt_env->me_options.dp_loose_limit && (!1 || txn->mt_geo.next > pgno + txn->mt_env->me_options.dp_loose_limit || txn->mt_geo.next <= txn->mt_env->me_options.dp_loose_limit)), 1)





                                                                             ) {
      do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 4879, "loosen dirty page %" 
# 4879 "/libmdbx/src/core.c" 3 4
     "u" 
# 4879 "/libmdbx/src/core.c"
     "\n", pgno); } while (0);
      mp->mp_flags = 0x4000;
      mp->mp_next = txn->tw.loose_pages;
      txn->tw.loose_pages = mp;
      txn->tw.loose_count++;

      txn->tw.loose_refund_wl = (pgno + 2 > txn->tw.loose_refund_wl)
                                    ? pgno + 2
                                    : txn->tw.loose_refund_wl;

      if (0 != 0 || __builtin_expect(!!(txn->mt_env->me_flags & MDBX_PAGEPERTURB), 0))
        memset(page_data(mp), -1, txn->mt_env->me_psize - ((unsigned)
# 4890 "/libmdbx/src/core.c" 3 4
                                                         __builtin_offsetof (
# 4890 "/libmdbx/src/core.c"
                                                         MDBX_page
# 4890 "/libmdbx/src/core.c" 3 4
                                                         , 
# 4890 "/libmdbx/src/core.c"
                                                         mp_ptrs
# 4890 "/libmdbx/src/core.c" 3 4
                                                         )
# 4890 "/libmdbx/src/core.c"
                                                         ));
     
                                                                   ;
      do { do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 4893, "POISON_MEMORY_REGION(%p, %zu) at %u" "\n", (void *)(page_data(mp)), (size_t)(txn->mt_env->me_psize - ((unsigned)
# 4893 "/libmdbx/src/core.c" 3 4
     __builtin_offsetof (
# 4893 "/libmdbx/src/core.c"
     MDBX_page
# 4893 "/libmdbx/src/core.c" 3 4
     , 
# 4893 "/libmdbx/src/core.c"
     mp_ptrs
# 4893 "/libmdbx/src/core.c" 3 4
     )
# 4893 "/libmdbx/src/core.c"
     )), 4893); } while (0); ((void)(page_data(mp)), (void)(txn->mt_env->me_psize - ((unsigned)
# 4893 "/libmdbx/src/core.c" 3 4
     __builtin_offsetof (
# 4893 "/libmdbx/src/core.c"
     MDBX_page
# 4893 "/libmdbx/src/core.c" 3 4
     , 
# 4893 "/libmdbx/src/core.c"
     mp_ptrs
# 4893 "/libmdbx/src/core.c" 3 4
     )
# 4893 "/libmdbx/src/core.c"
     ))); } while (0)
                                                                       ;
      return MDBX_SUCCESS;
    }


    if (__builtin_expect(!!(txn->mt_env->me_flags & MDBX_PAGEPERTURB), 0))

    {




      for (MDBX_txn *parent = txn->mt_parent;
           parent && (parent->mt_flags & 0x08);
           parent = parent->mt_parent) {
        if (mdbx_intersect_spilled(parent, pgno, npages))
          goto skip_invalidate;
        if (mdbx_dpl_intersect(parent, pgno, npages))
          goto skip_invalidate;
      }




        mdbx_kill_page(txn, mp, pgno, npages);
      if (!(txn->mt_flags & MDBX_WRITEMAP)) {
       
                                                                               ;
        do { do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 4922, "POISON_MEMORY_REGION(%p, %zu) at %u" "\n", (void *)(page_data(pgno2page(txn->mt_env, pgno))), (size_t)(pgno2bytes(txn->mt_env, npages) - ((unsigned)
# 4922 "/libmdbx/src/core.c" 3 4
       __builtin_offsetof (
# 4922 "/libmdbx/src/core.c"
       MDBX_page
# 4922 "/libmdbx/src/core.c" 3 4
       , 
# 4922 "/libmdbx/src/core.c"
       mp_ptrs
# 4922 "/libmdbx/src/core.c" 3 4
       )
# 4922 "/libmdbx/src/core.c"
       )), 4922); } while (0); ((void)(page_data(pgno2page(txn->mt_env, pgno))), (void)(pgno2bytes(txn->mt_env, npages) - ((unsigned)
# 4922 "/libmdbx/src/core.c" 3 4
       __builtin_offsetof (
# 4922 "/libmdbx/src/core.c"
       MDBX_page
# 4922 "/libmdbx/src/core.c" 3 4
       , 
# 4922 "/libmdbx/src/core.c"
       mp_ptrs
# 4922 "/libmdbx/src/core.c" 3 4
       )
# 4922 "/libmdbx/src/core.c"
       ))); } while (0)

                                                     ;
      }
    }
  skip_invalidate:

    mdbx_page_wash(txn, di, mp, npages);

  reclaim:
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 4932, "reclaim %u %s page %" 
# 4932 "/libmdbx/src/core.c" 3 4
   "u" 
# 4932 "/libmdbx/src/core.c"
   "\n", npages, "dirty", pgno); } while (0);
    rc = mdbx_pnl_insert_range(&txn->tw.reclaimed_pglist, pgno, npages);
    do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_pnl_check4assert(txn->tw.reclaimed_pglist, txn->mt_geo.next - 1))), 0)) mdbx_assert_fail((txn)->mt_env, "mdbx_pnl_check4assert(txn->tw.reclaimed_pglist, txn->mt_geo.next - 1)", __func__, 4934); } while (0); } while (0)

                                                                               ;
    do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_dirtylist_check(txn))), 0)) mdbx_assert_fail((txn)->mt_env, "mdbx_dirtylist_check(txn)", __func__, 4937); } while (0); } while (0);
    return rc;
  }

  if (si) {

    mdbx_spill_remove(txn, si, npages);





    for (MDBX_txn *parent = txn->mt_parent; parent;
         parent = parent->mt_parent) {
      if (mdbx_dpl_exist(parent, pgno))
        goto retire;
    }


    goto reclaim;
  }

  if (is_shadowed) {

    if ((0)) {
      const MDBX_page *parent_dp = 
# 4962 "/libmdbx/src/core.c" 3 4
                                  ((void *)0)
# 4962 "/libmdbx/src/core.c"
                                         ;

      for (MDBX_txn *parent = txn->mt_parent; parent && !parent_dp;
           parent = parent->mt_parent) {
        do { if ((0)) do { if (__builtin_expect(!!(!(!mdbx_search_spilled(parent, pgno))), 0)) mdbx_assert_fail((txn)->mt_env, "!mdbx_search_spilled(parent, pgno)", __func__, 4966); } while (0); } while (0);
        parent_dp = debug_dpl_find(parent, pgno);
      }
      do { if ((0)) do { if (__builtin_expect(!!(!(parent_dp && (!mp || parent_dp == mp))), 0)) mdbx_assert_fail((txn)->mt_env, "parent_dp && (!mp || parent_dp == mp)", __func__, 4969); } while (0); } while (0);
    }



    goto reclaim;
  }







  goto retire;
}

static __inline int mdbx_page_retire(MDBX_cursor *mc, MDBX_page *mp) {
  return mdbx_page_retire_ex(mc, mp->mp_pgno, mp, ((mp)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)));
}

struct mdbx_iov_ctx {
  unsigned iov_items;
  size_t iov_bytes;
  size_t iov_off;
  pgno_t flush_begin;
  pgno_t flush_end;
  struct iovec iov[64];
};

static __inline void mdbx_iov_init(MDBX_txn *const txn,
                                   struct mdbx_iov_ctx *ctx) {
  ctx->flush_begin = 0x7FFFffffU;
  ctx->flush_end = 3;
  ctx->iov_items = 0;
  ctx->iov_bytes = 0;
  ctx->iov_off = 0;
  (void)txn;
}

static __inline void mdbx_iov_done(MDBX_txn *const txn,
                                   struct mdbx_iov_ctx *ctx) {
  do { if ((0)) do { if (__builtin_expect(!!(!(ctx->iov_items == 0)), 0)) mdbx_assert_fail((txn)->mt_env, "ctx->iov_items == 0", __func__, 5011); } while (0); } while (0);

  MDBX_env *const env = txn->mt_env;
  if (!(txn->mt_flags & MDBX_WRITEMAP) &&
      mdbx_linux_kernel_version < 0x02060b00)



    mdbx_flush_incoherent_mmap(
        env->me_dxb_mmap.dxb + pgno2bytes(env, ctx->flush_begin),
        pgno2bytes(env, ctx->flush_end - ctx->flush_begin), env->me_os_psize);

}

static int mdbx_iov_write(MDBX_txn *const txn, struct mdbx_iov_ctx *ctx) {
  do { if ((0)) do { if (__builtin_expect(!!(!(!(txn->mt_flags & MDBX_WRITEMAP))), 0)) mdbx_assert_fail((txn)->mt_env, "!(txn->mt_flags & MDBX_WRITEMAP)", __func__, 5026); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(ctx->iov_items > 0)), 0)) mdbx_assert_fail((txn)->mt_env, "ctx->iov_items > 0", __func__, 5027); } while (0); } while (0);

  MDBX_env *const env = txn->mt_env;
  int rc;
  if (__builtin_expect(!!(ctx->iov_items == 1), 1)) {
    do { if ((0)) do { if (__builtin_expect(!!(!(ctx->iov_bytes == (size_t)ctx->iov[0].iov_len)), 0)) mdbx_assert_fail(env, "ctx->iov_bytes == (size_t)ctx->iov[0].iov_len", __func__, 5032); } while (0); } while (0);
    rc = mdbx_pwrite(env->me_dxb_mmap.fd, ctx->iov[0].iov_base, ctx->iov[0].iov_len,
                     ctx->iov_off);
  } else {
    rc = mdbx_pwritev(env->me_dxb_mmap.fd, ctx->iov, ctx->iov_items, ctx->iov_off,
                      ctx->iov_bytes);
  }

  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 5041, "Write error: %s" "\n", mdbx_strerror(rc)); } while (0);
  else {
   
                                             ;
    do { do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 5045, "UNPOISON_MEMORY_REGION(%p, %zu) at %u" "\n", (void *)(txn->mt_env->me_dxb_mmap.dxb + ctx->iov_off), (size_t)(ctx->iov_bytes), 5045); } while (0); ((void)(txn->mt_env->me_dxb_mmap.dxb + ctx->iov_off), (void)(ctx->iov_bytes)); } while (0)
                                                    ;
  }

  unsigned iov_items = ctx->iov_items;

  txn->mt_env->me_lck->mti_pgop_stat.wops.weak += iov_items;

  ctx->iov_items = 0;
  ctx->iov_bytes = 0;

  uint64_t timestamp = 0;
  for (unsigned i = 0; i < iov_items; i++) {
    MDBX_page *wp = (MDBX_page *)ctx->iov[i].iov_base;
    const MDBX_page *rp = pgno2page(txn->mt_env, wp->mp_pgno);


    while (__builtin_expect(!!(rc == MDBX_SUCCESS), 1) &&
           __builtin_expect(!!(memcmp(wp, rp, ctx->iov[i].iov_len) != 0), 0)) {
      if (!timestamp) {
        timestamp = mdbx_osal_monotime();
        mdbx_iov_done(txn, ctx);
        do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 5067, "catch delayed/non-arrived page %" 
# 5067 "/libmdbx/src/core.c" 3 4
       "u" 
# 5067 "/libmdbx/src/core.c"
       " %s" "\n", wp->mp_pgno, "(workaround for incoherent flaw of unified page/buffer cache)"); } while (0)

                                                                            ;
      } else if (__builtin_expect(!!(mdbx_osal_monotime() - timestamp > 65536 / 10), 0)) {
        do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 5071, "bailout waiting for %" 
# 5071 "/libmdbx/src/core.c" 3 4
       "u" 
# 5071 "/libmdbx/src/core.c"
       " page arrival %s" "\n", wp->mp_pgno, "(workaround for incoherent flaw of unified page/buffer cache)"); } while (0)

                                                                            ;
        rc = MDBX_CORRUPTED;
      }



      sched_yield();





    }
    mdbx_dpage_free(env, wp, bytes2pgno(env, ctx->iov[i].iov_len));
  }
  return rc;
}

static int iov_page(MDBX_txn *txn, struct mdbx_iov_ctx *ctx, MDBX_page *dp,
                    unsigned npages) {
  MDBX_env *const env = txn->mt_env;
  do { if ((0)) do { if (__builtin_expect(!!(!(dp->mp_pgno >= 3 && dp->mp_pgno < txn->mt_geo.next)), 0)) mdbx_assert_fail((txn)->mt_env, "dp->mp_pgno >= 3 && dp->mp_pgno < txn->mt_geo.next", __func__, 5094); } while (0); } while (0)
                                                                            ;
  do { if ((0)) do { if (__builtin_expect(!!(!(((dp)->mp_txnid == (txn)->mt_front))), 0)) mdbx_assert_fail((txn)->mt_env, "((dp)->mp_txnid == (txn)->mt_front)", __func__, 5096); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(!(dp->mp_flags & ~(0x01 | 0x02 | 0x20 | 0x04)))), 0)) mdbx_assert_fail((txn)->mt_env, "!(dp->mp_flags & ~(0x01 | 0x02 | 0x20 | 0x04))", __func__, 5097); } while (0); } while (0)
                                                                             ;

  ctx->flush_begin =
      (ctx->flush_begin < dp->mp_pgno) ? ctx->flush_begin : dp->mp_pgno;
  ctx->flush_end = (ctx->flush_end > dp->mp_pgno + npages)
                       ? ctx->flush_end
                       : dp->mp_pgno + npages;
  env->me_lck->mti_unsynced_pages.weak += npages;

  if (((dp)->mp_txnid > (txn)->mt_txnid)) {
    do { if ((0)) do { if (__builtin_expect(!!(!(!(txn->mt_flags & MDBX_WRITEMAP))), 0)) mdbx_assert_fail((txn)->mt_env, "!(txn->mt_flags & MDBX_WRITEMAP)", __func__, 5108); } while (0); } while (0);
    dp->mp_txnid = txn->mt_txnid;
    do { if ((0)) do { if (__builtin_expect(!!(!(((dp)->mp_txnid == (txn)->mt_txnid))), 0)) mdbx_assert_fail((txn)->mt_env, "((dp)->mp_txnid == (txn)->mt_txnid)", __func__, 5110); } while (0); } while (0);
    const size_t size = pgno2bytes(env, npages);
    if (ctx->iov_off + ctx->iov_bytes != pgno2bytes(env, dp->mp_pgno) ||
        ctx->iov_items == (sizeof(ctx->iov) / sizeof(ctx->iov[0])) ||
        ctx->iov_bytes + size > 0x3fff0000U) {
      if (ctx->iov_items) {
        int err = mdbx_iov_write(txn, ctx);
        if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
          return err;

        if (mdbx_linux_kernel_version >= 0x02060b00)




          mdbx_flush_incoherent_mmap(env->me_dxb_mmap.dxb + ctx->iov_off, ctx->iov_bytes,
                                     env->me_os_psize);
      }
      ctx->iov_off = pgno2bytes(env, dp->mp_pgno);
    }
    ctx->iov[ctx->iov_items].iov_base = (void *)dp;
    ctx->iov[ctx->iov_items].iov_len = size;
    ctx->iov_items += 1;
    ctx->iov_bytes += size;
  } else {
    do { if ((0)) do { if (__builtin_expect(!!(!(txn->mt_flags & MDBX_WRITEMAP)), 0)) mdbx_assert_fail((txn)->mt_env, "txn->mt_flags & MDBX_WRITEMAP", __func__, 5135); } while (0); } while (0);
  }
  return MDBX_SUCCESS;
}

static int spill_page(MDBX_txn *txn, struct mdbx_iov_ctx *ctx, MDBX_page *dp,
                      unsigned npages) {
  do { if ((0)) do { if (__builtin_expect(!!(!(!(txn->mt_flags & MDBX_WRITEMAP))), 0)) mdbx_assert_fail((txn)->mt_env, "!(txn->mt_flags & MDBX_WRITEMAP)", __func__, 5142); } while (0); } while (0);
  pgno_t pgno = dp->mp_pgno;
  int err = iov_page(txn, ctx, dp, npages);
  if (__builtin_expect(!!(err == MDBX_SUCCESS), 1)) {
    err = mdbx_pnl_append_range((1), &txn->tw.spill_pages, pgno << 1, npages);

    if (__builtin_expect(!!(err == MDBX_SUCCESS), 1))
      txn->mt_env->me_lck->mti_pgop_stat.spill.weak += npages;

  }
  return err;
}



static unsigned mdbx_cursor_keep(MDBX_txn *txn, MDBX_cursor *mc) {
  unsigned keep = 0;
  while (mc->mc_flags & 0x01) {
    for (unsigned i = 0; i < mc->mc_snum; ++i) {
      const MDBX_page *mp = mc->mc_pg[i];
      if (((mp)->mp_txnid == (txn)->mt_front) && !(((mp)->mp_flags & 0x40) != 0)) {
        unsigned const n = mdbx_dpl_search(txn, mp->mp_pgno);
        if (txn->tw.dirtylist->items[n].pgno == mp->mp_pgno &&
            mdbx_dpl_age(txn, n)) {
          txn->tw.dirtylist->items[n].lru = txn->tw.dirtylru;
          ++keep;
        }
      }
    }
    if (!mc->mc_xcursor)
      break;
    mc = &mc->mc_xcursor->mx_cursor;
  }
  return keep;
}

static unsigned mdbx_txn_keep(MDBX_txn *txn, MDBX_cursor *m0) {
  unsigned keep = m0 ? mdbx_cursor_keep(txn, m0) : 0;
  for (unsigned i = 0; i < txn->mt_numdbs; ++i)
    if ((((txn->mt_dbistate[i]) & (MDBX_DBI_DIRTY | 0x10)) == (MDBX_DBI_DIRTY | 0x10)) &&
        txn->mt_dbs[i].md_root != (~(pgno_t)0))
      for (MDBX_cursor *mc = txn->mt_cursors[i]; mc; mc = mc->mc_next)
        if (mc != m0)
          keep += mdbx_cursor_keep(txn, mc);
  return keep;
}





static unsigned spill_prio(const MDBX_txn *txn, const unsigned i,
                           const uint32_t reciprocal) {
  MDBX_dpl *const dl = txn->tw.dirtylist;
  const uint32_t age = mdbx_dpl_age(txn, i);
  const unsigned npages = dpl_npages(dl, i);
  const pgno_t pgno = dl->items[i].pgno;
  if (age == 0) {
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 5200, "skip %s %u page %" 
# 5200 "/libmdbx/src/core.c" 3 4
   "u" 
# 5200 "/libmdbx/src/core.c"
   "\n", "keep", npages, pgno); } while (0);
    return 256;
  }

  MDBX_page *const dp = dl->items[i].ptr;
  if (dp->mp_flags & (0x4000 | 0x2000)) {
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 5206, "skip %s %u page %" 
# 5206 "/libmdbx/src/core.c" 3 4
   "u" 
# 5206 "/libmdbx/src/core.c"
   "\n", (dp->mp_flags & 0x4000) ? "loose" : (dp->mp_flags & 0x4000) ? "loose" : "parent-spilled", npages, pgno); } while (0)



                            ;
    return 256;
  }



  MDBX_txn *parent = txn->mt_parent;
  if (parent && (parent->mt_flags & 0x08)) {
    do
      if (mdbx_intersect_spilled(parent, pgno, npages)) {
        do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 5220, "skip-2 parent-spilled %u page %" 
# 5220 "/libmdbx/src/core.c" 3 4
       "u" 
# 5220 "/libmdbx/src/core.c"
       "\n", npages, pgno); } while (0);
        dp->mp_flags |= 0x2000;
        return 256;
      }
    while ((parent = parent->mt_parent) != 
# 5224 "/libmdbx/src/core.c" 3 4
                                          ((void *)0)
# 5224 "/libmdbx/src/core.c"
                                                 );
  }

  do { if ((0)) do { if (__builtin_expect(!!(!(age * (uint64_t)reciprocal < 
# 5227 "/libmdbx/src/core.c" 3 4
 (4294967295U)
# 5227 "/libmdbx/src/core.c"
 )), 0)) mdbx_assert_fail((txn)->mt_env, "age * (uint64_t)reciprocal < (4294967295U)", __func__, 5227); } while (0); } while (0);
  unsigned prio = age * reciprocal >> 24;
  do { if ((0)) do { if (__builtin_expect(!!(!(prio < 256)), 0)) mdbx_assert_fail((txn)->mt_env, "prio < 256", __func__, 5229); } while (0); } while (0);
  if (__builtin_expect(!!(npages == 1), 1))
    return prio = 256 - prio;


  uint32_t factor = npages | npages >> 1;
  factor |= factor >> 2;
  factor |= factor >> 4;
  factor |= factor >> 8;
  factor |= factor >> 16;
  factor = prio * log2n_powerof2(factor + 1) + 157;
  factor = (factor < 256) ? 255 - factor : 0;
  do { if ((0)) do { if (__builtin_expect(!!(!(factor < 256 && factor < (256 - prio))), 0)) mdbx_assert_fail((txn)->mt_env, "factor < 256 && factor < (256 - prio)", __func__, 5241); } while (0); } while (0);
  return prio = factor;
}
# 5272 "/libmdbx/src/core.c"
static int mdbx_txn_spill(MDBX_txn *const txn, MDBX_cursor *const m0,
                          const unsigned need) {


  if (__builtin_expect(!!(txn->tw.dirtyroom + txn->tw.loose_count >= need), 1))
    return MDBX_SUCCESS;
  unsigned wanna_spill = need - txn->tw.dirtyroom;






  const unsigned dirty = txn->tw.dirtylist->length;
  const unsigned spill_min =
      txn->mt_env->me_options.spill_min_denominator
          ? dirty / txn->mt_env->me_options.spill_min_denominator
          : 0;
  const unsigned spill_max =
      dirty - (txn->mt_env->me_options.spill_max_denominator
                   ? dirty / txn->mt_env->me_options.spill_max_denominator
                   : 0);
  wanna_spill = (wanna_spill > spill_min) ? wanna_spill : spill_min;
  wanna_spill = (wanna_spill < spill_max) ? wanna_spill : spill_max;
  if (!wanna_spill)
    return MDBX_SUCCESS;

  do { if ((MDBX_LOG_NOTICE < MDBX_LOG_VERBOSE && MDBX_LOG_NOTICE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_NOTICE, __func__, 5299, "spilling %u dirty-entries (have %u dirty-room, need %u)" "\n", wanna_spill, txn->tw.dirtyroom, need); } while (0)
                                                   ;
  do { if ((0)) do { if (__builtin_expect(!!(!(txn->tw.dirtylist->length >= wanna_spill)), 0)) mdbx_assert_fail((txn)->mt_env, "txn->tw.dirtylist->length >= wanna_spill", __func__, 5301); } while (0); } while (0);

  struct mdbx_iov_ctx ctx;
  mdbx_iov_init(txn, &ctx);
  int rc = MDBX_SUCCESS;
  if (txn->mt_flags & MDBX_WRITEMAP) {
    MDBX_dpl *const dl = txn->tw.dirtylist;
    const unsigned span = dl->length - txn->tw.loose_count;
    txn->tw.dirtyroom += span;
    unsigned r, w;
    for (w = 0, r = 1; r <= dl->length; ++r) {
      MDBX_page *dp = dl->items[r].ptr;
      if (dp->mp_flags & 0x4000)
        dl->items[++w] = dl->items[r];
      else if (!1) {
        rc = iov_page(txn, &ctx, dp, dpl_npages(dl, r));
        do { if ((0)) do { if (__builtin_expect(!!(!(rc == MDBX_SUCCESS)), 0)) mdbx_assert_fail((txn)->mt_env, "rc == MDBX_SUCCESS", __func__, 5317); } while (0); } while (0);
      }
    }

    do { if ((0)) do { if (__builtin_expect(!!(!(span == r - 1 - w && w == txn->tw.loose_count)), 0)) mdbx_assert_fail((txn)->mt_env, "span == r - 1 - w && w == txn->tw.loose_count", __func__, 5321); } while (0); } while (0);
    dl->sorted = (dl->sorted == dl->length) ? w : 0;
    dpl_setlen(dl, w);
    do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_dirtylist_check(txn))), 0)) mdbx_assert_fail((txn)->mt_env, "mdbx_dirtylist_check(txn)", __func__, 5324); } while (0); } while (0);

    if (!1 && ctx.flush_end > ctx.flush_begin) {
      MDBX_env *const env = txn->mt_env;

      env->me_lck->mti_pgop_stat.wops.weak += 1;

      rc = mdbx_msync(&env->me_dxb_mmap,
                      pgno_align2os_bytes(env, ctx.flush_begin),
                      pgno_align2os_bytes(env, ctx.flush_end - ctx.flush_begin),
                      MDBX_SYNC_NONE);
    }
    return rc;
  }

  do { if ((0)) do { if (__builtin_expect(!!(!(!(txn->mt_flags & MDBX_WRITEMAP))), 0)) mdbx_assert_fail((txn)->mt_env, "!(txn->mt_flags & MDBX_WRITEMAP)", __func__, 5339); } while (0); } while (0);
  if (!txn->tw.spill_pages) {
    txn->tw.spill_least_removed = 0x7fffffff;
    txn->tw.spill_pages = mdbx_pnl_alloc(wanna_spill);
    if (__builtin_expect(!!(!txn->tw.spill_pages), 0)) {
      rc = MDBX_ENOMEM;
    bailout:
      txn->mt_flags |= 0x02;
      return rc;
    }
  } else {

    mdbx_spill_purge(txn);
    rc = mdbx_pnl_reserve(&txn->tw.spill_pages, wanna_spill);
    (void)rc

        ;
  }


  MDBX_dpl *const dl = mdbx_dpl_sort(txn);


  const unsigned unspillable = mdbx_txn_keep(txn, m0);
  if (unspillable + txn->tw.loose_count >= dl->length) {




    do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 5368, "all %u dirty pages are unspillable  since referenced " "by a cursor(s), use fewer cursors or increase " "MDBX_opt_txn_dp_limit" "\n", unspillable); } while (0)


                           ;
    goto done;
  }
# 5399 "/libmdbx/src/core.c"
  uint32_t age_max = 0;
  for (unsigned i = 1; i <= dl->length; ++i) {
    const uint32_t age = mdbx_dpl_age(txn, i);
    age_max = (age_max >= age) ? age_max : age;
  }

  do { if ((MDBX_LOG_VERBOSE < MDBX_LOG_VERBOSE && MDBX_LOG_VERBOSE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_VERBOSE, __func__, 5405, "lru-head %u, age-max %u" "\n", txn->tw.dirtylru, age_max); } while (0);


  unsigned radix_counters[256], spillable = 0, spilled = 0;
  memset(&radix_counters, 0, sizeof(radix_counters));
  const uint32_t reciprocal = (255U << 24) / (age_max + 1);
  for (unsigned i = 1; i <= dl->length; ++i) {
    unsigned prio = spill_prio(txn, i, reciprocal);
    if (prio < 256) {
      radix_counters[prio] += 1;
      spillable += 1;
    }
  }

  if (__builtin_expect(!!(spillable > 0), 1)) {
    unsigned prio2spill = 0, prio2adjacent = 128, amount = radix_counters[0];
    for (unsigned i = 1; i < 256; i++) {
      if (amount < wanna_spill) {
        prio2spill = i;
        prio2adjacent = i + (257 - i) / 2;
        amount += radix_counters[i];
      } else if (amount + amount < spillable + wanna_spill
                                                                                        ) {
        prio2adjacent = i;
        amount += radix_counters[i];
      } else
        break;
    }

    do { if ((MDBX_LOG_VERBOSE < MDBX_LOG_VERBOSE && MDBX_LOG_VERBOSE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_VERBOSE, __func__, 5434, "prio2spill %u, prio2adjacent %u, amount %u, spillable %u, " "wanna_spill %u" "\n", prio2spill, prio2adjacent, amount, spillable, wanna_spill); } while (0)

                                                                           ;
    do { if ((0)) do { if (__builtin_expect(!!(!(prio2spill < prio2adjacent && prio2adjacent <= 256)), 0)) mdbx_assert_fail((txn)->mt_env, "prio2spill < prio2adjacent && prio2adjacent <= 256", __func__, 5437); } while (0); } while (0);

    unsigned prev_prio = 256;
    unsigned r, w, prio;
    for (w = 0, r = 1; r <= dl->length && spilled < wanna_spill;
         prev_prio = prio, ++r) {
      prio = spill_prio(txn, r, reciprocal);
      MDBX_page *const dp = dl->items[r].ptr;
      if (prio < prio2adjacent) {
        const pgno_t pgno = dl->items[r].pgno;
        const unsigned npages = dpl_npages(dl, r);
        if (prio <= prio2spill) {
          if (prev_prio < prio2adjacent && prev_prio > prio2spill &&
              dpl_endpgno(dl, r - 1) == pgno) {
            do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 5451, "co-spill %u prev-adjacent page %" 
# 5451 "/libmdbx/src/core.c" 3 4
           "u" 
# 5451 "/libmdbx/src/core.c"
           " (age %d, prio %u)" "\n", dpl_npages(dl, w), dl->items[r - 1].pgno, mdbx_dpl_age(txn, r - 1), prev_prio); } while (0)


                                                           ;
            --w;
            rc = spill_page(txn, &ctx, dl->items[r - 1].ptr,
                            dpl_npages(dl, r - 1));
            if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
              break;
            ++spilled;
          }

          do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 5463, "spill %u page %" 
# 5463 "/libmdbx/src/core.c" 3 4
         "u" 
# 5463 "/libmdbx/src/core.c"
         " (age %d, prio %u)" "\n", npages, dp->mp_pgno, mdbx_dpl_age(txn, r), prio); } while (0)
                                                             ;
          rc = spill_page(txn, &ctx, dp, npages);
          if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
            break;
          ++spilled;
          continue;
        }

        if (prev_prio <= prio2spill && dpl_endpgno(dl, r - 1) == pgno) {
          do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 5473, "co-spill %u next-adjacent page %" 
# 5473 "/libmdbx/src/core.c" 3 4
         "u" 
# 5473 "/libmdbx/src/core.c"
         " (age %d, prio %u)" "\n", npages, dp->mp_pgno, mdbx_dpl_age(txn, r), prio); } while (0)

                                                                     ;
          rc = spill_page(txn, &ctx, dp, npages);
          if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
            break;
          prio = prev_prio ;
          ++spilled;
          continue;
        }
      }
      dl->items[++w] = dl->items[r];
    }

    do { if ((0)) do { if (__builtin_expect(!!(!(spillable == 0 || spilled > 0)), 0)) mdbx_assert_fail((txn)->mt_env, "spillable == 0 || spilled > 0", __func__, 5487); } while (0); } while (0);

    while (r <= dl->length)
      dl->items[++w] = dl->items[r++];
    do { if ((0)) do { if (__builtin_expect(!!(!(r - 1 - w == spilled)), 0)) mdbx_assert_fail((txn)->mt_env, "r - 1 - w == spilled", __func__, 5491); } while (0); } while (0);

    dl->sorted = dpl_setlen(dl, w);
    txn->tw.dirtyroom += spilled;
    do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_dirtylist_check(txn))), 0)) mdbx_assert_fail((txn)->mt_env, "mdbx_dirtylist_check(txn)", __func__, 5495); } while (0); } while (0);

    if (ctx.iov_items)
      rc = mdbx_iov_write(txn, &ctx);

    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      goto bailout;

    mdbx_pnl_sort(txn->tw.spill_pages, (size_t)txn->mt_geo.next << 1);
    txn->mt_flags |= 0x08;
    do { if ((MDBX_LOG_NOTICE < MDBX_LOG_VERBOSE && MDBX_LOG_NOTICE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_NOTICE, __func__, 5505, "spilled %u dirty-entries, now have %u dirty-room" "\n", spilled, txn->tw.dirtyroom); } while (0)
                                  ;
    mdbx_iov_done(txn, &ctx);
  } else {
    do { if ((0)) do { if (__builtin_expect(!!(!(ctx.iov_items == 0 && rc == MDBX_SUCCESS)), 0)) mdbx_assert_fail((txn)->mt_env, "ctx.iov_items == 0 && rc == MDBX_SUCCESS", __func__, 5509); } while (0); } while (0);
    for (unsigned i = 1; i <= dl->length; ++i) {
      MDBX_page *dp = dl->items[i].ptr;
      do { if ((MDBX_LOG_NOTICE < MDBX_LOG_VERBOSE && MDBX_LOG_NOTICE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_NOTICE, __func__, 5512, "dirtylist[%u]: pgno %u, npages %u, flags 0x%04X, age %u, prio %u" "\n", i, dp->mp_pgno, dpl_npages(dl, i), dp->mp_flags, mdbx_dpl_age(txn, i), spill_prio(txn, i, reciprocal)); } while (0)


                                         ;
    }
  }
# 5533 "/libmdbx/src/core.c"
done:
  return __builtin_expect(!!(txn->tw.dirtyroom + txn->tw.loose_count > ((need > 32) ? 32 : need)), 1)

             ? MDBX_SUCCESS
             : MDBX_TXN_FULL;
}

static int mdbx_cursor_spill(MDBX_cursor *mc, const MDBX_val *key,
                             const MDBX_val *data) {
  MDBX_txn *txn = mc->mc_txn;


  unsigned need = 32 + 3;

  if (mc->mc_dbi > 0) {
    need += txn->mt_dbs[0].md_depth + 3;

    if (mc->mc_dbi > 1)
      need += txn->mt_dbs[1].md_depth + 3;
  }




  need += need;

  need += bytes2pgno(txn->mt_env, node_size(key, data)) + 1;
# 5568 "/libmdbx/src/core.c"
  return mdbx_txn_spill(txn, mc, need);
}



static _Bool meta_bootid_match(const MDBX_meta *meta) {
  return memcmp(&meta->mm_bootid, &bootid, 16) == 0 &&
         (bootid.x | bootid.y) != 0;
}

static _Bool meta_weak_acceptable(const MDBX_env *env, const MDBX_meta *meta,
                                 const int lck_exclusive) {
  return lck_exclusive
             ? meta_bootid_match(meta)
             : env->me_lck_mmap.lck &&
                   (env->me_lck_mmap.lck->mti_envmode.weak & MDBX_RDONLY) == 0;
}




__attribute__((__pure__, __nothrow__)) static __inline txnid_t
constmeta_txnid(const MDBX_env *env, const MDBX_meta *meta) {
  mdbx_memory_fence(mo_AcquireRelease, (0));
  txnid_t a = unaligned_peek_u64(4, &meta->mm_txnid_a);
  txnid_t b = unaligned_peek_u64(4, &meta->mm_txnid_b);
  do { if ((0)) do { if (__builtin_expect(!!(!(a == b)), 0)) mdbx_assert_fail(env, "a == b", __func__, 5594); } while (0); } while (0);
  (void)env;
  return (a == b) ? a : 0;
}

static __inline txnid_t meta_txnid(const MDBX_env *env,
                                   volatile const MDBX_meta *meta) {
  (void)env;
  mdbx_memory_fence(mo_AcquireRelease, (0));
  txnid_t a = unaligned_peek_u64_volatile(4, &meta->mm_txnid_a);
  txnid_t b = unaligned_peek_u64_volatile(4, &meta->mm_txnid_b);
  return (a == b) ? a : 0;
}

static __inline void meta_update_begin(const MDBX_env *env, MDBX_meta *meta,
                                       txnid_t txnid) {
  do { if ((0)) do { if (__builtin_expect(!!(!(meta >= page_meta(pgno2page(env, 0)) && meta < page_meta(pgno2page(env, 3)))), 0)) mdbx_assert_fail(env, "meta >= page_meta(pgno2page(env, 0)) && meta < page_meta(pgno2page(env, 3))", __func__, 5610); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(unaligned_peek_u64(4, meta->mm_txnid_a) < txnid && unaligned_peek_u64(4, meta->mm_txnid_b) < txnid)), 0)) mdbx_assert_fail(env, "unaligned_peek_u64(4, meta->mm_txnid_a) < txnid && unaligned_peek_u64(4, meta->mm_txnid_b) < txnid", __func__, 5611); } while (0); } while (0)
                                                                       ;
  (void)env;
  unaligned_poke_u64(4, meta->mm_txnid_b, 0);
  mdbx_memory_fence(mo_AcquireRelease, (1));
  unaligned_poke_u64(4, meta->mm_txnid_a, txnid);
}

static __inline void meta_update_end(const MDBX_env *env, MDBX_meta *meta,
                                     txnid_t txnid) {
  do { if ((0)) do { if (__builtin_expect(!!(!(meta >= page_meta(pgno2page(env, 0)) && meta < page_meta(pgno2page(env, 3)))), 0)) mdbx_assert_fail(env, "meta >= page_meta(pgno2page(env, 0)) && meta < page_meta(pgno2page(env, 3))", __func__, 5621); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(unaligned_peek_u64(4, meta->mm_txnid_a) == txnid)), 0)) mdbx_assert_fail(env, "unaligned_peek_u64(4, meta->mm_txnid_a) == txnid", __func__, 5622); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(unaligned_peek_u64(4, meta->mm_txnid_b) < txnid)), 0)) mdbx_assert_fail(env, "unaligned_peek_u64(4, meta->mm_txnid_b) < txnid", __func__, 5623); } while (0); } while (0);
  (void)env;
  mdbx_jitter4testing((1));
  memcpy(&meta->mm_bootid, &bootid, 16);
  unaligned_poke_u64(4, meta->mm_txnid_b, txnid);
  mdbx_memory_fence(mo_AcquireRelease, (1));
}

static __inline void meta_set_txnid(const MDBX_env *env, MDBX_meta *meta,
                                    const txnid_t txnid) {
  do { if ((0)) do { if (__builtin_expect(!!(!(!env->me_dxb_mmap.dxb || meta < page_meta(pgno2page(env, 0)) || meta >= page_meta(pgno2page(env, 3)))), 0)) mdbx_assert_fail(env, "!env->me_dxb_mmap.dxb || meta < page_meta(pgno2page(env, 0)) || meta >= page_meta(pgno2page(env, 3))", __func__, 5633); } while (0); } while (0)
                                                 ;
  (void)env;


  memcpy(&meta->mm_bootid, &bootid, 16);
  unaligned_poke_u64(4, meta->mm_txnid_a, txnid);
  unaligned_poke_u64(4, meta->mm_txnid_b, txnid);
}

static __inline uint64_t meta_sign(const MDBX_meta *meta) {
  uint64_t sign = 0u;



  (void)meta;


  return (sign > 1u) ? sign : ~sign;
}

enum meta_choise_mode { prefer_last, prefer_steady };

static __inline _Bool meta_ot(const enum meta_choise_mode mode,
                             const MDBX_env *env, volatile const MDBX_meta *a,
                             volatile const MDBX_meta *b) {
  mdbx_jitter4testing((1));
  const txnid_t txnid_a = meta_txnid(env, a);
  mdbx_jitter4testing((1));
  const txnid_t txnid_b = meta_txnid(env, b);
  mdbx_jitter4testing((1));
  const _Bool is_stead_b = ((unaligned_peek_u64_volatile(4, (b)->mm_datasync_sign)) > 1u);

  if (mode == prefer_steady) {
    mdbx_jitter4testing((1));
    const _Bool is_stead_a = ((unaligned_peek_u64_volatile(4, (a)->mm_datasync_sign)) > 1u);
    if (is_stead_a != is_stead_b)
      return is_stead_b;
  } else {
    do { if ((0)) do { if (__builtin_expect(!!(!(mode == prefer_last)), 0)) mdbx_assert_fail(env, "mode == prefer_last", __func__, 5672); } while (0); } while (0);
  }
  if (txnid_a == txnid_b)
    return is_stead_b;
  return txnid_a < txnid_b;
}

static _Bool meta_eq(const MDBX_env *env, volatile const MDBX_meta *a,
                    volatile const MDBX_meta *b) {
  mdbx_jitter4testing((1));
  const txnid_t txnid = meta_txnid(env, a);
  if (!txnid || txnid != meta_txnid(env, b))
    return (0);

  mdbx_jitter4testing((1));
  if (((unaligned_peek_u64_volatile(4, (a)->mm_datasync_sign)) > 1u) != ((unaligned_peek_u64_volatile(4, (b)->mm_datasync_sign)) > 1u))
    return (0);

  mdbx_jitter4testing((1));
  return (1);
}

static int meta_eq_mask(const MDBX_env *env) {
  volatile const MDBX_meta *m0 = page_meta(pgno2page(env, 0));
  volatile const MDBX_meta *m1 = page_meta(pgno2page(env, 1));
  volatile const MDBX_meta *m2 = page_meta(pgno2page(env, 2));

  int rc = meta_eq(env, m0, m1) ? 1 : 0;
  if (meta_eq(env, m1, m2))
    rc += 2;
  if (meta_eq(env, m2, m0))
    rc += 4;
  return rc;
}

static __inline volatile const MDBX_meta *
meta_recent(const enum meta_choise_mode mode, const MDBX_env *env,
            volatile const MDBX_meta *a, volatile const MDBX_meta *b) {
  const _Bool a_older_that_b = meta_ot(mode, env, a, b);
  do { if ((0)) do { if (__builtin_expect(!!(!(!meta_eq(env, a, b))), 0)) mdbx_assert_fail(env, "!meta_eq(env, a, b)", __func__, 5711); } while (0); } while (0);
  return a_older_that_b ? b : a;
}

static const MDBX_meta *meta_ancient_prefer_weak(const MDBX_env *env,
                                                 const MDBX_meta *a,
                                                 const MDBX_meta *b) {
  const _Bool a_older_that_b = meta_ot(prefer_steady, env, a, b);
  do { if ((0)) do { if (__builtin_expect(!!(!(!meta_eq(env, a, b))), 0)) mdbx_assert_fail(env, "!meta_eq(env, a, b)", __func__, 5719); } while (0); } while (0);
  return a_older_that_b ? a : b;
}

static __inline volatile const MDBX_meta *
meta_mostrecent(const enum meta_choise_mode mode, const MDBX_env *env) {
  volatile const MDBX_meta *m0 = page_meta(pgno2page(env, 0));
  volatile const MDBX_meta *m1 = page_meta(pgno2page(env, 1));
  volatile const MDBX_meta *m2 = page_meta(pgno2page(env, 2));

  volatile const MDBX_meta *head = meta_recent(mode, env, m0, m1);
  head = meta_recent(mode, env, head, m2);
  return head;
}

static volatile const MDBX_meta *meta_prefer_steady(const MDBX_env *env) {
  return meta_mostrecent(prefer_steady, env);
}

__attribute__((__pure__, __nothrow__)) static const MDBX_meta *
constmeta_prefer_steady(const MDBX_env *env) {
  return (const MDBX_meta *)meta_mostrecent(prefer_steady, env);
}

static volatile const MDBX_meta *meta_prefer_last(const MDBX_env *env) {
  return meta_mostrecent(prefer_last, env);
}

__attribute__((__pure__, __nothrow__)) static const MDBX_meta *
constmeta_prefer_last(const MDBX_env *env) {
  return (const MDBX_meta *)meta_mostrecent(prefer_last, env);
}

static txnid_t mdbx_recent_committed_txnid(const MDBX_env *env) {
  while ((1)) {
    volatile const MDBX_meta *head = meta_prefer_last(env);
    const txnid_t recent = meta_txnid(env, head);
    mdbx_compiler_barrier();
    if (__builtin_expect(!!(head == meta_prefer_last(env) && recent == meta_txnid(env, head)), 1)
                                               )
      return recent;
  }
}

static txnid_t mdbx_recent_steady_txnid(const MDBX_env *env) {
  while ((1)) {
    volatile const MDBX_meta *head = meta_prefer_steady(env);
    const txnid_t recent = meta_txnid(env, head);
    mdbx_compiler_barrier();
    if (__builtin_expect(!!(head == meta_prefer_steady(env) && recent == meta_txnid(env, head)), 1)
                                               )
      return recent;
  }
}

static const char *mdbx_durable_str(volatile const MDBX_meta *const meta) {
  if (((unaligned_peek_u64_volatile(4, (meta)->mm_datasync_sign)) > 1u))
    return (unaligned_peek_u64_volatile(4, meta->mm_datasync_sign) ==
            meta_sign((const MDBX_meta *)meta))
               ? "Steady"
               : "Tainted";
  return "Weak";
}




static txnid_t mdbx_find_oldest(const MDBX_txn *txn) {
  do { if ((0)) do { if (__builtin_expect(!!(!((txn->mt_flags & MDBX_TXN_RDONLY) == 0)), 0)) mdbx_assert_fail((txn)->mt_env, "(txn->mt_flags & MDBX_TXN_RDONLY) == 0", __func__, 5787); } while (0); } while (0);
  MDBX_env *env = txn->mt_env;
  const txnid_t edge = mdbx_recent_steady_txnid(env);
  do { if ((0)) do { if (__builtin_expect(!!(!(edge <= txn->mt_txnid)), 0)) mdbx_assert_fail((txn)->mt_env, "edge <= txn->mt_txnid", __func__, 5790); } while (0); } while (0);

  MDBX_lockinfo *const lck = env->me_lck_mmap.lck;
  if (__builtin_expect(!!(lck == 
# 5793 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 5793 "/libmdbx/src/core.c"
     ), 0))
    return atomic_store64(&lck->mti_oldest_reader, edge, mo_Relaxed);

  const txnid_t last_oldest =
      atomic_load64(&lck->mti_oldest_reader, mo_AcquireRelease);
  do { if ((0)) do { if (__builtin_expect(!!(!(edge >= last_oldest)), 0)) mdbx_assert_fail((txn)->mt_env, "edge >= last_oldest", __func__, 5798); } while (0); } while (0);
  if (__builtin_expect(!!(last_oldest == edge), 1))
    return edge;

  const uint32_t nothing_changed = ((uint32_t)("None"[0]) << 24 | (uint32_t)("None"[1]) << 16 | (uint32_t)("None"[2]) << 8 | ("None"[3]));
  const uint32_t snap_readers_refresh_flag =
      atomic_load32(&lck->mti_readers_refresh_flag, mo_AcquireRelease);
  mdbx_jitter4testing((0));
  if (snap_readers_refresh_flag == nothing_changed)
    return last_oldest;

  txnid_t oldest = edge;
  atomic_store32(&lck->mti_readers_refresh_flag, nothing_changed, mo_Relaxed);
  const unsigned snap_nreaders =
      atomic_load32(&lck->mti_numreaders, mo_AcquireRelease);
  for (unsigned i = 0; i < snap_nreaders; ++i) {
    if (atomic_load32(&lck->mti_readers[i].mr_pid, mo_AcquireRelease)) {

      const txnid_t snap = safe64_read(&lck->mti_readers[i].mr_txnid);
      if (oldest > snap && last_oldest <= snap) {
        oldest = snap;
        if (oldest == last_oldest)
          return oldest;
      }
    }
  }

  if (oldest != last_oldest) {
    do { if ((MDBX_LOG_VERBOSE < MDBX_LOG_VERBOSE && MDBX_LOG_VERBOSE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_VERBOSE, __func__, 5826, "update oldest %" 
# 5826 "/libmdbx/src/core.c" 3 4
   "l" "i" 
# 5826 "/libmdbx/src/core.c"
   " -> %" 
# 5826 "/libmdbx/src/core.c" 3 4
   "l" "i" 
# 5826 "/libmdbx/src/core.c"
   "\n", last_oldest, oldest); } while (0)
                        ;
    do { if ((0)) do { if (__builtin_expect(!!(!(oldest >= lck->mti_oldest_reader.weak)), 0)) mdbx_assert_fail((txn)->mt_env, "oldest >= lck->mti_oldest_reader.weak", __func__, 5828); } while (0); } while (0);
    atomic_store64(&lck->mti_oldest_reader, oldest, mo_Relaxed);
  }
  return oldest;
}


__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static pgno_t mdbx_find_largest(MDBX_env *env, pgno_t largest) {
  MDBX_lockinfo *const lck = env->me_lck_mmap.lck;
  if (__builtin_expect(!!(lck != 
# 5837 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 5837 "/libmdbx/src/core.c"
     ), 1)) {
    const unsigned snap_nreaders =
        atomic_load32(&lck->mti_numreaders, mo_AcquireRelease);
    for (unsigned i = 0; i < snap_nreaders; ++i) {
    retry:
      if (atomic_load32(&lck->mti_readers[i].mr_pid, mo_AcquireRelease)) {

        const pgno_t snap_pages = atomic_load32(
            &lck->mti_readers[i].mr_snapshot_pages_used, mo_Relaxed);
        const txnid_t snap_txnid = safe64_read(&lck->mti_readers[i].mr_txnid);
        if (__builtin_expect(!!(snap_pages != atomic_load32(&lck->mti_readers[i].mr_snapshot_pages_used, mo_AcquireRelease) || snap_txnid != safe64_read(&lck->mti_readers[i].mr_txnid)), 0)



                                                                         )
          goto retry;
        if (largest < snap_pages &&
            atomic_load64(&lck->mti_oldest_reader, mo_AcquireRelease) <=
                                             snap_txnid &&
            snap_txnid <= env->me_txn0->mt_txnid)
          largest = snap_pages;
      }
    }
  }

  return largest;
}


static int __attribute__((__warn_unused_result__)) mdbx_page_dirty(MDBX_txn *txn, MDBX_page *mp,
                                               unsigned npages) {







  int rc;
  mp->mp_txnid = txn->mt_front;
  if (__builtin_expect(!!(txn->tw.dirtyroom == 0), 0)) {
    if (txn->tw.loose_count) {
      MDBX_page *loose = txn->tw.loose_pages;
      do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 5880, "purge-and-reclaim loose page %" 
# 5880 "/libmdbx/src/core.c" 3 4
     "u" 
# 5880 "/libmdbx/src/core.c"
     "\n", loose->mp_pgno); } while (0);
      rc = mdbx_pnl_insert_range(&txn->tw.reclaimed_pglist, loose->mp_pgno, 1);
      if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
        goto bailout;
      unsigned di = mdbx_dpl_search(txn, loose->mp_pgno);
      do { if ((0)) do { if (__builtin_expect(!!(!(txn->tw.dirtylist->items[di].ptr == loose)), 0)) mdbx_assert_fail((txn)->mt_env, "txn->tw.dirtylist->items[di].ptr == loose", __func__, 5885); } while (0); } while (0);
      mdbx_dpl_remove(txn, di);
      txn->tw.loose_pages = loose->mp_next;
      txn->tw.loose_count--;
      txn->tw.dirtyroom++;
      if (!(txn->mt_flags & MDBX_WRITEMAP))
        mdbx_dpage_free(txn->mt_env, loose, 1);
    } else {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 5893, "Dirtyroom is depleted, DPL length %u" "\n", txn->tw.dirtylist->length); } while (0)
                                           ;
      if (!(txn->mt_flags & MDBX_WRITEMAP))
        mdbx_dpage_free(txn->mt_env, mp, npages);
      return MDBX_TXN_FULL;
    }
  }

  rc = mdbx_dpl_append(txn, mp->mp_pgno, mp, npages);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0)) {
  bailout:
    txn->mt_flags |= 0x02;
    return rc;
  }
  txn->tw.dirtyroom--;
  do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_dirtylist_check(txn))), 0)) mdbx_assert_fail((txn)->mt_env, "mdbx_dirtylist_check(txn)", __func__, 5908); } while (0); } while (0);
  return MDBX_SUCCESS;
}


__attribute__((__unused__)) static 
# 5913 "/libmdbx/src/core.c" 3 4
                        __inline __attribute__ ((__always_inline__)) 
# 5913 "/libmdbx/src/core.c"
                                        int ignore_enosys(int err) {

  if (err == 
# 5915 "/libmdbx/src/core.c" 3 4
            38
# 5915 "/libmdbx/src/core.c"
                  )
    return MDBX_RESULT_TRUE;






  if (err == 
# 5923 "/libmdbx/src/core.c" 3 4
            95
# 5923 "/libmdbx/src/core.c"
                   )
    return MDBX_RESULT_TRUE;






  if (err == 
# 5931 "/libmdbx/src/core.c" 3 4
            95
# 5931 "/libmdbx/src/core.c"
                      )
    return MDBX_RESULT_TRUE;

  if (err == 
# 5934 "/libmdbx/src/core.c" 3 4
            11
# 5934 "/libmdbx/src/core.c"
                  )
    return MDBX_RESULT_TRUE;
  return err;
}




__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static int mdbx_set_readahead(MDBX_env *env, const pgno_t edge,
                                     const _Bool enable,
                                     const _Bool force_whole) {
  do { if ((0)) do { if (__builtin_expect(!!(!(edge >= 3 && edge <= 0x7FFFffffU + 1)), 0)) mdbx_assert_fail(env, "edge >= 3 && edge <= 0x7FFFffffU + 1", __func__, 5945); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!((enable & 1) == (enable != 0))), 0)) mdbx_assert_fail(env, "(enable & 1) == (enable != 0)", __func__, 5946); } while (0); } while (0);
  const _Bool toggle = force_whole ||
                      ((enable ^ env->me_lck->mti_readahead_anchor) & 1) ||
                      !env->me_lck->mti_readahead_anchor;
  const pgno_t prev_edge = env->me_lck->mti_readahead_anchor >> 1;
  const size_t limit = env->me_dxb_mmap.limit;
  size_t offset =
      toggle ? 0
             : pgno_align2os_bytes(env, (prev_edge < edge) ? prev_edge : edge);
  offset = (offset < limit) ? offset : limit;

  size_t length =
      pgno_align2os_bytes(env, (prev_edge < edge) ? edge : prev_edge);
  length = (length < limit) ? length : limit;
  length -= offset;

  do { if ((0)) do { if (__builtin_expect(!!(!(0 <= (intptr_t)length)), 0)) mdbx_assert_fail(env, "0 <= (intptr_t)length", __func__, 5962); } while (0); } while (0);
  if (length == 0)
    return MDBX_SUCCESS;

  do { if ((MDBX_LOG_NOTICE < MDBX_LOG_VERBOSE && MDBX_LOG_NOTICE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_NOTICE, __func__, 5966, "readahead %s %u..%u" "\n", enable ? "ON" : "OFF", bytes2pgno(env, offset), bytes2pgno(env, offset + length)); } while (0)
                                                                        ;






  int err;
  if (enable) {

    err = madvise(env->me_dxb_mmap.dxb + offset, length, 
# 5977 "/libmdbx/src/core.c" 3 4
                                               0
# 5977 "/libmdbx/src/core.c"
                                                          )
              ? ignore_enosys(
# 5978 "/libmdbx/src/core.c" 3 4
                             (*__errno_location ())
# 5978 "/libmdbx/src/core.c"
                                  )
              : MDBX_SUCCESS;
    if (__builtin_expect(!!(((err) != MDBX_RESULT_TRUE && (err) != MDBX_RESULT_FALSE)), 0))
      return err;
# 5997 "/libmdbx/src/core.c"
    if (toggle) {
# 6010 "/libmdbx/src/core.c"
      err = madvise(env->me_dxb_mmap.dxb + offset, length, 
# 6010 "/libmdbx/src/core.c" 3 4
                                                 3
# 6010 "/libmdbx/src/core.c"
                                                              )
                ? ignore_enosys(
# 6011 "/libmdbx/src/core.c" 3 4
                               (*__errno_location ())
# 6011 "/libmdbx/src/core.c"
                                    )
                : MDBX_SUCCESS;
      if (__builtin_expect(!!(((err) != MDBX_RESULT_TRUE && (err) != MDBX_RESULT_FALSE)), 0))
        return err;
# 6035 "/libmdbx/src/core.c"
    }
  } else {

    err = madvise(env->me_dxb_mmap.dxb + offset, length, 
# 6038 "/libmdbx/src/core.c" 3 4
                                               1
# 6038 "/libmdbx/src/core.c"
                                                          )
              ? ignore_enosys(
# 6039 "/libmdbx/src/core.c" 3 4
                             (*__errno_location ())
# 6039 "/libmdbx/src/core.c"
                                  )
              : MDBX_SUCCESS;
    if (__builtin_expect(!!(((err) != MDBX_RESULT_TRUE && (err) != MDBX_RESULT_FALSE)), 0))
      return err;
# 6058 "/libmdbx/src/core.c"
  }

  env->me_lck->mti_readahead_anchor = (enable & 1) + (edge << 1);
  err = MDBX_SUCCESS;
  return err;
}


__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static int mdbx_mapresize(MDBX_env *env, const pgno_t used_pgno,
                                 const pgno_t size_pgno,
                                 const pgno_t limit_pgno, const _Bool implicit) {
  const size_t limit_bytes = pgno_align2os_bytes(env, limit_pgno);
  const size_t size_bytes = pgno_align2os_bytes(env, size_pgno);
  const size_t prev_size = env->me_dxb_mmap.current;
  const size_t prev_limit = env->me_dxb_mmap.limit;

  const void *const prev_addr = env->me_dxb_mmap.dxb;


  do { if ((MDBX_LOG_VERBOSE < MDBX_LOG_VERBOSE && MDBX_LOG_VERBOSE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_VERBOSE, __func__, 6077, "resize datafile/mapping: " "present %" 
# 6077 "/libmdbx/src/core.c" 3 4
 "l" "u" 
# 6077 "/libmdbx/src/core.c"
 " -> %" 
# 6077 "/libmdbx/src/core.c" 3 4
 "l" "u" 
# 6077 "/libmdbx/src/core.c"
 ", " "limit %" 
# 6077 "/libmdbx/src/core.c" 3 4
 "l" "u" 
# 6077 "/libmdbx/src/core.c"
 " -> %" 
# 6077 "/libmdbx/src/core.c" 3 4
 "l" "u" 
# 6077 "/libmdbx/src/core.c"
 "\n", prev_size, size_bytes, prev_limit, limit_bytes); } while (0)


                                                              ;

  do { if ((0)) do { if (__builtin_expect(!!(!(limit_bytes >= size_bytes)), 0)) mdbx_assert_fail(env, "limit_bytes >= size_bytes", __func__, 6082); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(bytes2pgno(env, size_bytes) >= size_pgno)), 0)) mdbx_assert_fail(env, "bytes2pgno(env, size_bytes) >= size_pgno", __func__, 6083); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(bytes2pgno(env, limit_bytes) >= limit_pgno)), 0)) mdbx_assert_fail(env, "bytes2pgno(env, limit_bytes) >= limit_pgno", __func__, 6084); } while (0); } while (0);

  unsigned mresize_flags =
      env->me_flags & (MDBX_RDONLY | MDBX_WRITEMAP | MDBX_UTTERLY_NOSYNC);
# 6125 "/libmdbx/src/core.c"
  int rc = mdbx_fastmutex_acquire(&env->me_remap_guard);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;
  if (limit_bytes == env->me_dxb_mmap.limit &&
      size_bytes == env->me_dxb_mmap.current)
    goto bailout;

  MDBX_lockinfo *const lck = env->me_lck_mmap.lck;
  if (limit_bytes != env->me_dxb_mmap.limit && !(env->me_flags & MDBX_NOTLS) &&
      lck && !implicit) {
    int err = mdbx_rdt_lock(env) ;
    if (__builtin_expect(!!(((err) != MDBX_RESULT_TRUE && (err) != MDBX_RESULT_FALSE)), 0)) {
      rc = err;
      goto bailout;
    }


    const unsigned snap_nreaders =
        atomic_load32(&lck->mti_numreaders, mo_AcquireRelease);
    do { if ((0)) do { if (__builtin_expect(!!(!(!implicit)), 0)) mdbx_assert_fail(env, "!implicit", __func__, 6144); } while (0); } while (0);
    mresize_flags |= 0x00000200 | 0x00000100;
    for (unsigned i = 0; i < snap_nreaders; ++i) {
      if (lck->mti_readers[i].mr_pid.weak == env->me_pid &&
          lck->mti_readers[i].mr_tid.weak != mdbx_thread_self()) {


        mdbx_rdt_unlock(env);
        mresize_flags &= ~(0x00000200 | 0x00000100);
        break;
      }
    }
  }


  if ((env->me_flags & MDBX_WRITEMAP) && env->me_lck->mti_unsynced_pages.weak) {

    env->me_lck->mti_pgop_stat.wops.weak += 1;

    rc = mdbx_msync(&env->me_dxb_mmap, 0, pgno_align2os_bytes(env, used_pgno),
                    MDBX_SYNC_NONE);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      goto bailout;
  }


  if (size_bytes < prev_size) {
    do { if ((MDBX_LOG_NOTICE < MDBX_LOG_VERBOSE && MDBX_LOG_NOTICE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_NOTICE, __func__, 6171, "resize-MADV_%s %u..%u" "\n", (env->me_flags & MDBX_WRITEMAP) ? "REMOVE" : "DONTNEED", size_pgno, bytes2pgno(env, prev_size)); } while (0)

                                                      ;
    rc = MDBX_RESULT_TRUE;

    if (env->me_flags & MDBX_WRITEMAP)
      rc =
          madvise(env->me_dxb_mmap.dxb + size_bytes, prev_size - size_bytes, 
# 6178 "/libmdbx/src/core.c" 3 4
                                                                   9
# 6178 "/libmdbx/src/core.c"
                                                                              )
              ? ignore_enosys(
# 6179 "/libmdbx/src/core.c" 3 4
                             (*__errno_location ())
# 6179 "/libmdbx/src/core.c"
                                  )
              : MDBX_SUCCESS;


    if (rc == MDBX_RESULT_TRUE)
      rc = madvise(env->me_dxb_mmap.dxb + size_bytes, prev_size - size_bytes,
                   
# 6185 "/libmdbx/src/core.c" 3 4
                  4
# 6185 "/libmdbx/src/core.c"
                               )
               ? ignore_enosys(
# 6186 "/libmdbx/src/core.c" 3 4
                              (*__errno_location ())
# 6186 "/libmdbx/src/core.c"
                                   )
               : MDBX_SUCCESS;
# 6199 "/libmdbx/src/core.c"
    if (__builtin_expect(!!(((rc) != MDBX_RESULT_TRUE && (rc) != MDBX_RESULT_FALSE)), 0))
      goto bailout;
    if (env->me_lck->mti_discarded_tail.weak > size_pgno)
      env->me_lck->mti_discarded_tail.weak = size_pgno;
  }


  rc = mdbx_mresize(mresize_flags, &env->me_dxb_mmap, size_bytes, limit_bytes);


  if (rc == MDBX_SUCCESS) {
    env->me_lck->mti_discarded_tail.weak = size_pgno;
    const _Bool readahead =
        !(env->me_flags & MDBX_NORDAHEAD) &&
        mdbx_is_readahead_reasonable(size_bytes, -(intptr_t)prev_size);
    const _Bool force = limit_bytes != prev_limit ||
                       env->me_dxb_mmap.address != prev_addr



        ;
    rc = mdbx_set_readahead(env, size_pgno, readahead, force);
  }


bailout:
  if (rc == MDBX_SUCCESS) {
    do { if ((0)) do { if (__builtin_expect(!!(!(size_bytes == env->me_dxb_mmap.current)), 0)) mdbx_assert_fail(env, "size_bytes == env->me_dxb_mmap.current", __func__, 6226); } while (0); } while (0);
    do { if ((0)) do { if (__builtin_expect(!!(!(size_bytes <= env->me_dxb_mmap.filesize)), 0)) mdbx_assert_fail(env, "size_bytes <= env->me_dxb_mmap.filesize", __func__, 6227); } while (0); } while (0);
    do { if ((0)) do { if (__builtin_expect(!!(!(limit_bytes == env->me_dxb_mmap.limit)), 0)) mdbx_assert_fail(env, "limit_bytes == env->me_dxb_mmap.limit", __func__, 6228); } while (0); } while (0);
# 6238 "/libmdbx/src/core.c"
  } else {
    if (rc != MDBX_UNABLE_EXTEND_MAPSIZE && rc != MDBX_EPERM) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 6240, "failed resize datafile/mapping: " "present %" 
# 6240 "/libmdbx/src/core.c" 3 4
     "l" "u" 
# 6240 "/libmdbx/src/core.c"
     " -> %" 
# 6240 "/libmdbx/src/core.c" 3 4
     "l" "u" 
# 6240 "/libmdbx/src/core.c"
     ", " "limit %" 
# 6240 "/libmdbx/src/core.c" 3 4
     "l" "u" 
# 6240 "/libmdbx/src/core.c"
     " -> %" 
# 6240 "/libmdbx/src/core.c" 3 4
     "l" "u" 
# 6240 "/libmdbx/src/core.c"
     ", errcode %d" "\n", prev_size, size_bytes, prev_limit, limit_bytes, rc); } while (0)


                                                                    ;
    } else {
      do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 6245, "unable resize datafile/mapping: " "present %" 
# 6245 "/libmdbx/src/core.c" 3 4
     "l" "u" 
# 6245 "/libmdbx/src/core.c"
     " -> %" 
# 6245 "/libmdbx/src/core.c" 3 4
     "l" "u" 
# 6245 "/libmdbx/src/core.c"
     ", " "limit %" 
# 6245 "/libmdbx/src/core.c" 3 4
     "l" "u" 
# 6245 "/libmdbx/src/core.c"
     " -> %" 
# 6245 "/libmdbx/src/core.c" 3 4
     "l" "u" 
# 6245 "/libmdbx/src/core.c"
     ", errcode %d" "\n", prev_size, size_bytes, prev_limit, limit_bytes, rc); } while (0)


                                                                      ;
    }
    if (!env->me_dxb_mmap.address) {
      env->me_flags |= 0x80000000U;
      if (env->me_txn)
        env->me_txn->mt_flags |= 0x02;
      rc = MDBX_PANIC;
    }
  }
# 6267 "/libmdbx/src/core.c"
  if (env->me_lck_mmap.lck &&
      (mresize_flags & (0x00000200 | 0x00000100)) != 0)
    mdbx_rdt_unlock(env);
  int err = mdbx_fastmutex_release(&env->me_remap_guard);

  if (err != MDBX_SUCCESS) {
    mdbx_debug_log(MDBX_LOG_FATAL, __func__, 6273, "failed resume-after-remap: errcode %d" "\n", err);;
    return MDBX_PANIC;
  }
  return rc;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static int mdbx_mapresize_implicit(MDBX_env *env, const pgno_t used_pgno,
                                          const pgno_t size_pgno,
                                          const pgno_t limit_pgno) {
  const pgno_t mapped_pgno = bytes2pgno(env, env->me_dxb_mmap.limit);
  do { if ((0)) do { if (__builtin_expect(!!(!(mapped_pgno >= used_pgno)), 0)) mdbx_assert_fail(env, "mapped_pgno >= used_pgno", __func__, 6283); } while (0); } while (0);
  return mdbx_mapresize(
      env, used_pgno, size_pgno,
      (size_pgno > mapped_pgno)
          ? limit_pgno
          :

          mapped_pgno,
      (1));
}

static int mdbx_meta_unsteady(MDBX_env *env, const txnid_t last_steady,
                              MDBX_meta *const meta, mdbx_filehandle_t fd) {
  const uint64_t wipe = 0u;
  if (__builtin_expect(!!(((unaligned_peek_u64_volatile(4, (meta)->mm_datasync_sign)) > 1u)), 0) &&
      constmeta_txnid(env, meta) <= last_steady) {
    do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 6299, "wipe txn #%" 
# 6299 "/libmdbx/src/core.c" 3 4
   "l" "i" 
# 6299 "/libmdbx/src/core.c"
   ", meta %" 
# 6299 "/libmdbx/src/core.c" 3 4
   "u" 
# 6299 "/libmdbx/src/core.c"
   "\n", last_steady, data_page(meta)->mp_pgno); } while (0)
                                          ;
    if (env->me_flags & MDBX_WRITEMAP)
      unaligned_poke_u64(4, meta->mm_datasync_sign, wipe);
    else
      return mdbx_pwrite(fd, &wipe, sizeof(meta->mm_datasync_sign),
                         (uint8_t *)&meta->mm_datasync_sign - env->me_dxb_mmap.dxb);
    if (constmeta_txnid(env, meta) == last_steady)
      do { if ((0)) do { if (__builtin_expect(!!(!(meta_checktxnid(env, meta, (1)))), 0)) mdbx_assert_fail(env, "meta_checktxnid(env, meta, (1))", __func__, 6307); } while (0); } while (0);
  }
  return MDBX_SUCCESS;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static int mdbx_wipe_steady(MDBX_env *env, const txnid_t last_steady) {

  env->me_lck->mti_pgop_stat.wops.weak += 1;

  const mdbx_filehandle_t fd = (env->me_dsync_fd != (-1))
                                   ? env->me_dsync_fd
                                   : env->me_dxb_mmap.fd;
  int err = mdbx_meta_unsteady(env, last_steady, page_meta(pgno2page(env, 0)), fd);
  if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
    return err;
  err = mdbx_meta_unsteady(env, last_steady, page_meta(pgno2page(env, 1)), fd);
  if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
    return err;
  err = mdbx_meta_unsteady(env, last_steady, page_meta(pgno2page(env, 2)), fd);
  if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
    return err;

  if (env->me_flags & MDBX_WRITEMAP) {
    mdbx_memory_barrier();
    err = mdbx_msync(&env->me_dxb_mmap, 0, pgno_align2os_bytes(env, 3),
                     MDBX_SYNC_DATA);
    if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
      return err;
  } else {
    if (fd == env->me_dxb_mmap.fd) {

      static _Bool syncfilerange_unavailable;
      if (!syncfilerange_unavailable &&
          sync_file_range(env->me_dxb_mmap.fd, 0, pgno2bytes(env, 3),
                          
# 6341 "/libmdbx/src/core.c" 3 4
                         2 
# 6341 "/libmdbx/src/core.c"
                                               | 
# 6341 "/libmdbx/src/core.c" 3 4
                                                 4
# 6341 "/libmdbx/src/core.c"
                                                                           )) {
        err = 
# 6342 "/libmdbx/src/core.c" 3 4
             (*__errno_location ())
# 6342 "/libmdbx/src/core.c"
                  ;
        if (ignore_enosys(err) == MDBX_RESULT_TRUE)
          syncfilerange_unavailable = (1);
      }
      if (syncfilerange_unavailable)

        err = mdbx_fsync(env->me_dxb_mmap.fd, MDBX_SYNC_DATA);
      if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
        return err;
    }
    mdbx_flush_incoherent_mmap(env->me_dxb_mmap.dxb, pgno2bytes(env, 3),
                               env->me_os_psize);
  }


  atomic_store32(&env->me_lck->mti_readers_refresh_flag, (1), mo_Relaxed);
  return MDBX_SUCCESS;
}
# 6384 "/libmdbx/src/core.c"
__attribute__((__hot__)) __attribute__((__optimize__("O3"))) static struct page_result mdbx_page_alloc(MDBX_cursor *mc,
                                                const pgno_t num, int flags) {
  struct page_result ret;
  MDBX_txn *const txn = mc->mc_txn;
  MDBX_env *const env = txn->mt_env;
  do { if ((0)) do { if (__builtin_expect(!!(!(num == 0 || !(flags & 8))), 0)) mdbx_assert_fail(env, "num == 0 || !(flags & 8)", __func__, 6389); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(num > 0 || !(flags & 4))), 0)) mdbx_assert_fail(env, "num > 0 || !(flags & 4)", __func__, 6390); } while (0); } while (0);

  const unsigned coalesce_threshold =
      env->me_maxgc_ov1page - env->me_maxgc_ov1page / 4;
  if (__builtin_expect(!!(flags & 2), 1)) {
    flags |= env->me_flags & (MDBX_COALESCE | MDBX_LIFORECLAIM);
    if (((txn->tw.reclaimed_pglist)[0]) > coalesce_threshold)
      flags &= ~MDBX_COALESCE;
    if (__builtin_expect(!!((mc->mc_flags & 0x20) || txn->mt_dbs[0].md_entries == 0 || (txn->tw.dirtyroom < txn->mt_dbs[0].md_depth && !(txn->mt_dbistate[0] & MDBX_DBI_DIRTY))), 0)
# 6407 "/libmdbx/src/core.c"
                                                        )
      flags &= ~(2 | MDBX_COALESCE);
  }

  if (__builtin_expect(!!(num == 1 && (flags & 1) != 0), 1)) {

    do { if ((0)) do { if (__builtin_expect(!!(!((flags & 8) == 0)), 0)) mdbx_assert_fail(env, "(flags & 8) == 0", __func__, 6413); } while (0); } while (0);
    if (__builtin_expect(!!(txn->tw.loose_pages), 1)) {

      if (txn->tw.loose_refund_wl > txn->mt_geo.next) {
        mdbx_refund(txn);
        if (__builtin_expect(!!(!txn->tw.loose_pages), 0))
          goto no_loose;
      }


      ret.page = txn->tw.loose_pages;
      txn->tw.loose_pages = ret.page->mp_next;
      txn->tw.loose_count--;
      do { if ((MDBX_LOG_EXTRA < MDBX_LOG_VERBOSE && MDBX_LOG_EXTRA <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_EXTRA, __func__, 6426, "db %d use loose page %" 
# 6426 "/libmdbx/src/core.c" 3 4
     "u"
# 6426 "/libmdbx/src/core.c"
     , (((mc)->mc_flags & 0x04) ? -(int)(mc)->mc_dbi : (int)(mc)->mc_dbi), ret.page->mp_pgno); } while (0)
                                         ;
      do { if ((0)) do { if (__builtin_expect(!!(!(ret.page->mp_pgno < txn->mt_geo.next)), 0)) mdbx_assert_fail((txn)->mt_env, "ret.page->mp_pgno < txn->mt_geo.next", __func__, 6428); } while (0); } while (0);
      do { if (__builtin_expect(!!(!(ret.page->mp_pgno >= 3)), 0)) mdbx_assert_fail(env, "ret.page->mp_pgno >= NUM_METAS", __func__, 6429); } while (0);
      ;
      do { do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 6431, "UNPOISON_MEMORY_REGION(%p, %zu) at %u" "\n", (void *)(page_data(ret.page)), (size_t)(page_space(txn->mt_env)), 6431); } while (0); ((void)(page_data(ret.page)), (void)(page_space(txn->mt_env))); } while (0)
                                                               ;
      ret.page->mp_txnid = txn->mt_front;
      ret.err = MDBX_SUCCESS;
      return ret;
    }
  }

no_loose:


  do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_pnl_check4assert(txn->tw.reclaimed_pglist, txn->mt_geo.next - 1))), 0)) mdbx_assert_fail((txn)->mt_env, "mdbx_pnl_check4assert(txn->tw.reclaimed_pglist, txn->mt_geo.next - 1)", __func__, 6442); } while (0); } while (0)

                                                                             ;
  pgno_t pgno, *re_list = txn->tw.reclaimed_pglist;
  unsigned range_begin = 0, re_len = ((re_list)[0]);
  txnid_t oldest = 0, last = 0;

  while ((1)) {
    MDBX_cursor_couple recur;
    for (MDBX_cursor_op op = MDBX_FIRST;;
         op = (flags & MDBX_LIFORECLAIM) ? MDBX_PREV : MDBX_NEXT) {
      MDBX_val key, data;



      do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_pnl_check4assert(txn->tw.reclaimed_pglist, txn->mt_geo.next))), 0)) mdbx_assert_fail((txn)->mt_env, "mdbx_pnl_check4assert(txn->tw.reclaimed_pglist, txn->mt_geo.next)", __func__, 6457); } while (0); } while (0)
                                                                 ;
      if (!(flags & (MDBX_COALESCE | 8)) && re_len >= num) {
        do { if ((0)) do { if (__builtin_expect(!!(!(((re_list)[((re_list)[0])]) < txn->mt_geo.next && ((re_list)[1]) < txn->mt_geo.next)), 0)) mdbx_assert_fail((txn)->mt_env, "((re_list)[((re_list)[0])]) < txn->mt_geo.next && ((re_list)[1]) < txn->mt_geo.next", __func__, 6460); } while (0); } while (0)
                                                                          ;
        range_begin = 0 ? 1 : re_len;
        pgno = ((re_list)[((re_list)[0])]);
        if (__builtin_expect(!!(num == 1), 1))
          goto done;

        const unsigned wanna_range = num - 1;
# 6479 "/libmdbx/src/core.c"
        do { if ((0)) do { if (__builtin_expect(!!(!(pgno == re_list[re_len] && range_begin == re_len)), 0)) mdbx_assert_fail((txn)->mt_env, "pgno == re_list[re_len] && range_begin == re_len", __func__, 6479); } while (0); } while (0);
        while ((1)) {
          if (re_list[range_begin - wanna_range] - pgno == wanna_range)
            goto done;
          if (range_begin == wanna_range)
            break;
          pgno = re_list[--range_begin];
        }

      }

      if (op == MDBX_FIRST) {
        if (__builtin_expect(!!(!(flags & 2)), 0))
          break ;


        oldest = (flags & MDBX_LIFORECLAIM)
                     ? mdbx_find_oldest(txn)
                     : atomic_load64(&env->me_lck->mti_oldest_reader,
                                     mo_AcquireRelease);
        ret.err = mdbx_cursor_init(&recur.outer, txn, 0);
        if (__builtin_expect(!!(ret.err != MDBX_SUCCESS), 0))
          goto fail;
        if (flags & MDBX_LIFORECLAIM) {

          if (oldest > 1UL) {
            last = oldest - 1;
            op = MDBX_SET_RANGE;
          }
        } else if (txn->tw.last_reclaimed) {

          last = txn->tw.last_reclaimed;
          op = MDBX_SET_RANGE;
        }

        key.iov_base = &last;
        key.iov_len = sizeof(last);
      }

      if (!(flags & MDBX_LIFORECLAIM)) {

        if (op != MDBX_FIRST && ++last >= oldest) {
          oldest = mdbx_find_oldest(txn);
          if (oldest <= last)
            break;
        }
      }

      ret.err = mdbx_cursor_get(&recur.outer, &key, 
# 6527 "/libmdbx/src/core.c" 3 4
                                                   ((void *)0)
# 6527 "/libmdbx/src/core.c"
                                                       , op);
      if (ret.err == MDBX_NOTFOUND && (flags & MDBX_LIFORECLAIM)) {
        if (op == MDBX_SET_RANGE)
          continue;
        txnid_t snap = mdbx_find_oldest(txn);
        if (oldest < snap) {
          oldest = snap;
          last = oldest - 1;
          key.iov_base = &last;
          key.iov_len = sizeof(last);
          op = MDBX_SET_RANGE;
          ret.err = mdbx_cursor_get(&recur.outer, &key, 
# 6538 "/libmdbx/src/core.c" 3 4
                                                       ((void *)0)
# 6538 "/libmdbx/src/core.c"
                                                           , op);
        }
      }
      if (__builtin_expect(!!(ret.err), 0)) {
        if (ret.err == MDBX_NOTFOUND)
          break;
        goto fail;
      }

      if (!0 &&
          __builtin_expect(!!(key.iov_len != sizeof(txnid_t)), 0)) {
        ret.err = MDBX_CORRUPTED;
        goto fail;
      }
      last = unaligned_peek_u64(4, key.iov_base);
      if (!0 &&
          __builtin_expect(!!(last < 1UL || last > (0xffffFFFF00000000UL - 1)), 0)) {
        ret.err = MDBX_CORRUPTED;
        goto fail;
      }
      if (oldest <= last) {
        oldest = mdbx_find_oldest(txn);
        if (oldest <= last) {
          if (flags & MDBX_LIFORECLAIM)
            continue;
          break;
        }
      }

      if (flags & MDBX_LIFORECLAIM) {

        if (txn->tw.lifo_reclaimed) {
          size_t i;
          for (i = (size_t)((txn->tw.lifo_reclaimed)[0]); i > 0; --i)
            if (txn->tw.lifo_reclaimed[i] == last)
              break;
          if (i)
            continue;
        }
      }


      MDBX_page *const mp = recur.outer.mc_pg[recur.outer.mc_top];
      if (__builtin_expect(!!((ret.err = mdbx_node_read( &recur.outer, page_node(mp, recur.outer.mc_ki[recur.outer.mc_top]), &data, pp_txnid4chk(mp, txn))) != MDBX_SUCCESS), 0)


                                                                       )
        goto fail;

      if ((flags & MDBX_LIFORECLAIM) && !txn->tw.lifo_reclaimed) {
        txn->tw.lifo_reclaimed = mdbx_txl_alloc();
        if (__builtin_expect(!!(!txn->tw.lifo_reclaimed), 0)) {
          ret.err = MDBX_ENOMEM;
          goto fail;
        }
      }


      do { if ((0)) do { if (__builtin_expect(!!(!((mc->mc_flags & 0x40) == 0)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "(mc->mc_flags & 0x40) == 0", __func__, 6596); } while (0); } while (0);
      pgno_t *gc_pnl = (pgno_t *)data.iov_base;
      do { if ((0)) do { if (__builtin_expect(!!(!(data.iov_len >= ((((gc_pnl)[0]) + 1) * sizeof(pgno_t)))), 0)) mdbx_assert_fail((txn)->mt_env, "data.iov_len >= ((((gc_pnl)[0]) + 1) * sizeof(pgno_t))", __func__, 6598); } while (0); } while (0);
      if (__builtin_expect(!!(data.iov_len < ((((gc_pnl)[0]) + 1) * sizeof(pgno_t)) || !mdbx_pnl_check(gc_pnl, txn->mt_geo.next)), 0)
                                                              ) {
        ret.err = MDBX_CORRUPTED;
        goto fail;
      }
      const unsigned gc_len = ((gc_pnl)[0]);
      if (__builtin_expect(!!(((txn->tw.reclaimed_pglist)[0]) >= env->me_options.rp_augment_limit), 0)

                                                     &&
          ((
            (flags & 8) == 0 &&
                                                txn->mt_geo.upper >=
                txn->mt_geo.next + (size_t)num) ||
           gc_len + ((txn->tw.reclaimed_pglist)[0]) >=
               ((size_t)0x7FFFffffU))) {



        do { if ((MDBX_LOG_NOTICE < MDBX_LOG_VERBOSE && MDBX_LOG_NOTICE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_NOTICE, __func__, 6617, "stop reclaiming to avoid PNL overflow: %u (current) + %u " "(chunk) -> %u" "\n", ((txn->tw.reclaimed_pglist)[0]), gc_len, gc_len + ((txn->tw.reclaimed_pglist)[0])); } while (0)


                                                                     ;
        flags &= ~(2 | MDBX_COALESCE);
        break;
      }
      ret.err = mdbx_pnl_need(&txn->tw.reclaimed_pglist, gc_len);
      if (__builtin_expect(!!(ret.err != MDBX_SUCCESS), 0))
        goto fail;
      re_list = txn->tw.reclaimed_pglist;


      if (flags & MDBX_LIFORECLAIM) {
        ret.err = mdbx_txl_append(&txn->tw.lifo_reclaimed, last);
        if (__builtin_expect(!!(ret.err != MDBX_SUCCESS), 0))
          goto fail;
      }
      txn->tw.last_reclaimed = last;

      if ((MDBX_LOG_EXTRA < MDBX_LOG_VERBOSE && MDBX_LOG_EXTRA <= mdbx_loglevel)) {
        do { if ((MDBX_LOG_EXTRA < MDBX_LOG_VERBOSE && MDBX_LOG_EXTRA <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_EXTRA, __func__, 6638, "PNL read txn %" 
# 6638 "/libmdbx/src/core.c" 3 4
       "l" "i" 
# 6638 "/libmdbx/src/core.c"
       " root %" 
# 6638 "/libmdbx/src/core.c" 3 4
       "u" 
# 6638 "/libmdbx/src/core.c"
       " num %u, PNL", last, txn->mt_dbs[0].md_root, gc_len); } while (0)

                                                                     ;
        for (unsigned i = gc_len; i; i--)
          do { if ((MDBX_LOG_EXTRA < MDBX_LOG_VERBOSE && MDBX_LOG_EXTRA <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_EXTRA, 
# 6642 "/libmdbx/src/core.c" 3 4
         ((void *)0)
# 6642 "/libmdbx/src/core.c"
         , 0, " %" 
# 6642 "/libmdbx/src/core.c" 3 4
         "u"
# 6642 "/libmdbx/src/core.c"
         , gc_pnl[i]); } while (0);
        do { if ((MDBX_LOG_EXTRA < MDBX_LOG_VERBOSE && MDBX_LOG_EXTRA <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_EXTRA, 
# 6643 "/libmdbx/src/core.c" 3 4
       ((void *)0)
# 6643 "/libmdbx/src/core.c"
       , 0, "%s\n", "."); } while (0);
      }


      const unsigned prev_re_len = ((re_list)[0]);
      mdbx_pnl_xmerge(re_list, gc_pnl);

      if (!0 &&
          __builtin_expect(!!(!mdbx_pnl_check(re_list, txn->mt_geo.next)), 0)) {
        ret.err = MDBX_CORRUPTED;
        goto fail;
      }
      do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_dirtylist_check(txn))), 0)) mdbx_assert_fail((txn)->mt_env, "mdbx_dirtylist_check(txn)", __func__, 6655); } while (0); } while (0);

      re_len = ((re_list)[0]);
      do { if ((0)) do { if (__builtin_expect(!!(!(re_len == 0 || re_list[re_len] < txn->mt_geo.next)), 0)) mdbx_assert_fail((txn)->mt_env, "re_len == 0 || re_list[re_len] < txn->mt_geo.next", __func__, 6658); } while (0); } while (0);
      if (1 && re_len &&
          __builtin_expect(!!(((re_list)[1]) == txn->mt_geo.next - 1), 0)) {

        mdbx_refund(txn);
        re_list = txn->tw.reclaimed_pglist;
        re_len = ((re_list)[0]);
      }


      if (__builtin_expect(!!(flags & 8), 0)) {
        do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 6669, "early-return NULL-page for %s mode" "\n", "MDBX_ALLOC_SLOT"); } while (0);
        ret.err = MDBX_SUCCESS;
        ret.page = 
# 6671 "/libmdbx/src/core.c" 3 4
                  ((void *)0)
# 6671 "/libmdbx/src/core.c"
                      ;
        return ret;
      }


      if (flags & MDBX_COALESCE) {
        if (re_len > coalesce_threshold ||
            (re_len > prev_re_len &&
             re_len - prev_re_len >=
                 coalesce_threshold / 2)) {
          do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 6681, "clear %s %s" "\n", "MDBX_COALESCE", "since got threshold"); } while (0);
          flags &= ~MDBX_COALESCE;
        }
      }
    }

    if ((((flags) & (MDBX_COALESCE | 2)) == (MDBX_COALESCE | 2))) {
      do { if ((MDBX_LOG_EXTRA < MDBX_LOG_VERBOSE && MDBX_LOG_EXTRA <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_EXTRA, __func__, 6688, "clear %s and continue", "MDBX_COALESCE"); } while (0);
      flags &= ~MDBX_COALESCE;
      continue;
    }
# 6701 "/libmdbx/src/core.c"
    range_begin = 0;
    pgno = txn->mt_geo.next;
    const size_t next = (size_t)pgno + num;

    if (flags & 2) {
      const MDBX_meta *const head = constmeta_prefer_last(env);
      const MDBX_meta *const steady = constmeta_prefer_steady(env);

      if (head != steady && ((unaligned_peek_u64_volatile(4, (steady)->mm_datasync_sign)) > 1u) &&
          oldest == constmeta_txnid(env, steady)) {
        do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 6711, "gc-kick-steady: head %" 
# 6711 "/libmdbx/src/core.c" 3 4
       "l" "i" 
# 6711 "/libmdbx/src/core.c"
       "-%s, tail %" 
# 6711 "/libmdbx/src/core.c" 3 4
       "l" "i" 
# 6711 "/libmdbx/src/core.c"
       "-%s, oldest %" 
# 6711 "/libmdbx/src/core.c" 3 4
       "l" "i" 
# 6711 "/libmdbx/src/core.c"
       "\n", constmeta_txnid(env, head), mdbx_durable_str(head), constmeta_txnid(env, steady), mdbx_durable_str(steady), oldest); } while (0)



                          ;
        ret.err = MDBX_RESULT_TRUE;
        const pgno_t autosync_threshold =
            atomic_load32(&env->me_lck->mti_autosync_threshold, mo_Relaxed);
        const uint64_t autosync_period =
            atomic_load64(&env->me_lck->mti_autosync_period, mo_Relaxed);
# 6729 "/libmdbx/src/core.c"
        if ((((env->me_flags) & (MDBX_UTTERLY_NOSYNC)) == (MDBX_UTTERLY_NOSYNC)) &&
            ((autosync_threshold | autosync_period) == 0 ||
             next >= steady->mm_geo.now)) {


          ret.err = mdbx_wipe_steady(env, oldest);
          do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 6735, "gc-wipe-steady, rc %d" "\n", ret.err); } while (0);
          do { if ((0)) do { if (__builtin_expect(!!(!(steady != meta_prefer_steady(env))), 0)) mdbx_assert_fail(env, "steady != meta_prefer_steady(env)", __func__, 6736); } while (0); } while (0);
        } else if ((flags & 4) == 0 ||
                   (autosync_threshold &&
                    atomic_load32(&env->me_lck->mti_unsynced_pages,
                                  mo_Relaxed) >= autosync_threshold) ||
                   (autosync_period &&
                    mdbx_osal_monotime() -
                            atomic_load64(&env->me_lck->mti_sync_timestamp,
                                          mo_Relaxed) >=
                        autosync_period) ||
                   next >= txn->mt_geo.upper ||
                   (next >= txn->mt_geo.now &&
                    (autosync_threshold | autosync_period) == 0)) {

          MDBX_meta meta = *head;
          ret.err = mdbx_sync_locked(env, env->me_flags & MDBX_WRITEMAP, &meta);
          do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 6752, "gc-make-steady, rc %d" "\n", ret.err); } while (0);
          do { if ((0)) do { if (__builtin_expect(!!(!(steady != meta_prefer_steady(env))), 0)) mdbx_assert_fail(env, "steady != meta_prefer_steady(env)", __func__, 6753); } while (0); } while (0);
        }
        if (ret.err == MDBX_SUCCESS) {
          if (mdbx_find_oldest(txn) > oldest)
            continue;


          if (oldest < txn->mt_txnid - 1u &&
              mdbx_kick_longlived_readers(env, oldest) > oldest)
            continue;
        } else if (__builtin_expect(!!(ret.err != MDBX_RESULT_TRUE), 0))
          goto fail;
      }
    }



    if ((flags & 4) && next <= txn->mt_geo.now)
      goto done;
    if ((flags & 2) && oldest < txn->mt_txnid - 1u &&
        mdbx_kick_longlived_readers(env, oldest) > oldest)
      continue;

    ret.err = MDBX_NOTFOUND;
    if (flags & 4) {
      ret.err = MDBX_MAP_FULL;
      if (next < txn->mt_geo.upper && txn->mt_geo.grow_pv) {
        do { if ((0)) do { if (__builtin_expect(!!(!(next > txn->mt_geo.now)), 0)) mdbx_assert_fail(env, "next > txn->mt_geo.now", __func__, 6780); } while (0); } while (0);
        const pgno_t grow_step = pv2pages(txn->mt_geo.grow_pv);
        size_t aligned = pgno_align2os_pgno(
            env, (pgno_t)(next + grow_step - next % grow_step));

        if (aligned > txn->mt_geo.upper)
          aligned = txn->mt_geo.upper;
        do { if ((0)) do { if (__builtin_expect(!!(!(aligned > txn->mt_geo.now)), 0)) mdbx_assert_fail(env, "aligned > txn->mt_geo.now", __func__, 6787); } while (0); } while (0);

        do { if ((MDBX_LOG_VERBOSE < MDBX_LOG_VERBOSE && MDBX_LOG_VERBOSE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_VERBOSE, __func__, 6789, "try growth datafile to %zu pages (+%zu)" "\n", aligned, aligned - txn->mt_geo.now); } while (0)
                                                ;
        ret.err = mdbx_mapresize_implicit(env, txn->mt_geo.next,
                                          (pgno_t)aligned, txn->mt_geo.upper);
        if (ret.err == MDBX_SUCCESS) {
          env->me_txn->mt_geo.now = (pgno_t)aligned;
          goto done;
        }

        do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 6798, "unable growth datafile to %zu pages (+%zu), errcode %d" "\n", aligned, aligned - txn->mt_geo.now, ret.err); } while (0)
                                                                ;
      } else {
        do { if ((MDBX_LOG_NOTICE < MDBX_LOG_VERBOSE && MDBX_LOG_NOTICE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_NOTICE, __func__, 6801, "gc-alloc: next %zu > upper %" 
# 6801 "/libmdbx/src/core.c" 3 4
       "u" 
# 6801 "/libmdbx/src/core.c"
       "\n", next, txn->mt_geo.upper); } while (0)
                                      ;
      }
    }

  fail:
    do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_pnl_check4assert(txn->tw.reclaimed_pglist, txn->mt_geo.next - 1))), 0)) mdbx_assert_fail(env, "mdbx_pnl_check4assert(txn->tw.reclaimed_pglist, txn->mt_geo.next - 1)", __func__, 6807); } while (0); } while (0)

                                                                              ;
    if (__builtin_expect(!!(!(flags & 16)), 1))
      txn->mt_flags |= 0x02;
    if (num != 1 || ret.err != MDBX_NOTFOUND)
      do { if ((MDBX_LOG_NOTICE < MDBX_LOG_VERBOSE && MDBX_LOG_NOTICE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_NOTICE, __func__, 6813, "alloc %u pages failed, flags 0x%x, errcode %d" "\n", num, flags, ret.err); } while (0)
                          ;
    else
      do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 6816, "alloc %u pages failed, flags 0x%x, errcode %d" "\n", num, flags, ret.err); } while (0)
                         ;
    do { if ((0)) do { if (__builtin_expect(!!(!(ret.err != MDBX_SUCCESS)), 0)) mdbx_assert_fail(env, "ret.err != MDBX_SUCCESS", __func__, 6818); } while (0); } while (0);
    ret.page = 
# 6819 "/libmdbx/src/core.c" 3 4
              ((void *)0)
# 6819 "/libmdbx/src/core.c"
                  ;
    return ret;
  }

done:
  do { if ((0)) do { if (__builtin_expect(!!(!(!(flags & 8))), 0)) mdbx_assert_fail(env, "!(flags & 8)", __func__, 6824); } while (0); } while (0);
  do { if (__builtin_expect(!!(!(pgno >= 3)), 0)) mdbx_assert_fail(env, "pgno >= NUM_METAS", __func__, 6825); } while (0);
  if (__builtin_expect(!!(flags & 16), 0)) {
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 6827, "return NULL-page for %u pages of %s mode" "\n", num, "MDBX_ALLOC_FAKE"); } while (0)
                                 ;
    ret.page = 
# 6829 "/libmdbx/src/core.c" 3 4
              ((void *)0)
# 6829 "/libmdbx/src/core.c"
                  ;
    ret.err = MDBX_SUCCESS;
    return ret;
  }

  if (env->me_flags & MDBX_WRITEMAP) {
    ret.page = pgno2page(env, pgno);

    ;
    do { do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 6838, "UNPOISON_MEMORY_REGION(%p, %zu) at %u" "\n", (void *)(ret.page), (size_t)(pgno2bytes(env, num)), 6838); } while (0); ((void)(ret.page), (void)(pgno2bytes(env, num))); } while (0);
  } else {
    ret.page = mdbx_page_malloc(txn, num);
    if (__builtin_expect(!!(!ret.page), 0)) {
      ret.err = MDBX_ENOMEM;
      goto fail;
    }
  }

  if (range_begin) {
    do { if ((0)) do { if (__builtin_expect(!!(!((mc->mc_flags & 0x40) == 0)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "(mc->mc_flags & 0x40) == 0", __func__, 6848); } while (0); } while (0);
    do { if ((0)) do { if (__builtin_expect(!!(!(pgno < txn->mt_geo.next)), 0)) mdbx_assert_fail((txn)->mt_env, "pgno < txn->mt_geo.next", __func__, 6849); } while (0); } while (0);
    do { if ((0)) do { if (__builtin_expect(!!(!(pgno == re_list[range_begin])), 0)) mdbx_assert_fail((txn)->mt_env, "pgno == re_list[range_begin]", __func__, 6850); } while (0); } while (0);






    ((re_list)[0]) = re_len -= num;
    for (unsigned i = range_begin - num; i < re_len;)
      re_list[++i] = re_list[++range_begin];

    do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_pnl_check4assert(txn->tw.reclaimed_pglist, txn->mt_geo.next - 1))), 0)) mdbx_assert_fail((txn)->mt_env, "mdbx_pnl_check4assert(txn->tw.reclaimed_pglist, txn->mt_geo.next - 1)", __func__, 6861); } while (0); } while (0)

                                                                               ;
  } else {
    txn->mt_geo.next = pgno + num;
    do { if ((0)) do { if (__builtin_expect(!!(!(txn->mt_geo.next <= txn->mt_geo.now)), 0)) mdbx_assert_fail(env, "txn->mt_geo.next <= txn->mt_geo.now", __func__, 6866); } while (0); } while (0);
  }

  if (__builtin_expect(!!(env->me_flags & MDBX_PAGEPERTURB), 0))
    memset(ret.page, -1, pgno2bytes(env, num));
  ;

  ret.page->mp_pgno = pgno;
  ret.page->mp_leaf2_ksize = 0;
  ret.page->mp_flags = 0;
  if (((0) || (0)) && num > 1) {
    ret.page->mp_pages = num;
    ret.page->mp_flags = 0x04;
  }
  ret.err = mdbx_page_dirty(txn, ret.page, num);
  if (__builtin_expect(!!(ret.err != MDBX_SUCCESS), 0))
    goto fail;

  do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_pnl_check4assert(txn->tw.reclaimed_pglist, txn->mt_geo.next - 1))), 0)) mdbx_assert_fail((txn)->mt_env, "mdbx_pnl_check4assert(txn->tw.reclaimed_pglist, txn->mt_geo.next - 1)", __func__, 6884); } while (0); } while (0)

                                                                             ;
  return ret;
}


__attribute__((__hot__)) __attribute__((__optimize__("O3"))) static void mdbx_page_copy(MDBX_page *dst, const MDBX_page *src,
                                 size_t psize) {
  _Static_assert(
# 6893 "/libmdbx/src/core.c" 3 4
 (65535) 
# 6893 "/libmdbx/src/core.c"
 > MDBX_MAX_PAGESIZE - ((unsigned)
# 6893 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 6893 "/libmdbx/src/core.c"
 MDBX_page
# 6893 "/libmdbx/src/core.c" 3 4
 , 
# 6893 "/libmdbx/src/core.c"
 mp_ptrs
# 6893 "/libmdbx/src/core.c" 3 4
 )
# 6893 "/libmdbx/src/core.c"
 ), "UINT16_MAX > MAX_PAGESIZE - PAGEHDRSZ");
  _Static_assert(MDBX_MIN_PAGESIZE > ((unsigned)
# 6894 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 6894 "/libmdbx/src/core.c"
 MDBX_page
# 6894 "/libmdbx/src/core.c" 3 4
 , 
# 6894 "/libmdbx/src/core.c"
 mp_ptrs
# 6894 "/libmdbx/src/core.c" 3 4
 )
# 6894 "/libmdbx/src/core.c"
 ) + 
# 6894 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 6894 "/libmdbx/src/core.c"
 MDBX_node
# 6894 "/libmdbx/src/core.c" 3 4
 , 
# 6894 "/libmdbx/src/core.c"
 mn_data
# 6894 "/libmdbx/src/core.c" 3 4
 ) 
# 6894 "/libmdbx/src/core.c"
 * 4, "MIN_PAGESIZE > PAGEHDRSZ + NODESIZE * 4");
  if ((src->mp_flags & (0x20 | 0x04)) == 0) {
    size_t upper = src->mp_upper, lower = src->mp_lower, unused = upper - lower;



    if (unused >= 64 * 2) {
      lower = ceil_powerof2(lower + ((unsigned)
# 6901 "/libmdbx/src/core.c" 3 4
                                   __builtin_offsetof (
# 6901 "/libmdbx/src/core.c"
                                   MDBX_page
# 6901 "/libmdbx/src/core.c" 3 4
                                   , 
# 6901 "/libmdbx/src/core.c"
                                   mp_ptrs
# 6901 "/libmdbx/src/core.c" 3 4
                                   )
# 6901 "/libmdbx/src/core.c"
                                   ), sizeof(void *));
      upper = floor_powerof2(upper + ((unsigned)
# 6902 "/libmdbx/src/core.c" 3 4
                                    __builtin_offsetof (
# 6902 "/libmdbx/src/core.c"
                                    MDBX_page
# 6902 "/libmdbx/src/core.c" 3 4
                                    , 
# 6902 "/libmdbx/src/core.c"
                                    mp_ptrs
# 6902 "/libmdbx/src/core.c" 3 4
                                    )
# 6902 "/libmdbx/src/core.c"
                                    ), sizeof(void *));
      memcpy(dst, src, lower);
      dst = (void *)((char *)dst + upper);
      src = (void *)((char *)src + upper);
      psize -= upper;
    }
  }
  memcpy(dst, src, psize);
}





static struct page_result __attribute__((__warn_unused_result__))
mdbx_page_unspill(MDBX_txn *const txn, const MDBX_page *const mp) {
  do { if ((MDBX_LOG_VERBOSE < MDBX_LOG_VERBOSE && MDBX_LOG_VERBOSE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_VERBOSE, __func__, 6918, "unspill page %" 
# 6918 "/libmdbx/src/core.c" 3 4
 "u" 
# 6918 "/libmdbx/src/core.c"
 "\n", mp->mp_pgno); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!((txn->mt_flags & MDBX_WRITEMAP) == 0)), 0)) mdbx_assert_fail((txn)->mt_env, "(txn->mt_flags & MDBX_WRITEMAP) == 0", __func__, 6919); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(((mp)->mp_txnid == (txn)->mt_txnid))), 0)) mdbx_assert_fail((txn)->mt_env, "((mp)->mp_txnid == (txn)->mt_txnid)", __func__, 6920); } while (0); } while (0);
  const MDBX_txn *scan = txn;
  struct page_result ret;
  do {
    do { if ((0)) do { if (__builtin_expect(!!(!((scan->mt_flags & 0x08) != 0)), 0)) mdbx_assert_fail((txn)->mt_env, "(scan->mt_flags & 0x08) != 0", __func__, 6924); } while (0); } while (0);
    const unsigned si = mdbx_search_spilled(scan, mp->mp_pgno);
    if (!si)
      continue;
    const unsigned npages = __builtin_expect(!!(((mp)->mp_flags & 0x04) != 0), 0) ? mp->mp_pages : 1;
    ret.page = mdbx_page_malloc(txn, npages);
    if (__builtin_expect(!!(!ret.page), 0)) {
      ret.err = MDBX_ENOMEM;
      return ret;
    }
    mdbx_page_copy(ret.page, mp, pgno2bytes(txn->mt_env, npages));
    if (scan == txn) {



      mdbx_spill_remove(txn, si, npages);
    }


    ret.err = mdbx_page_dirty(txn, ret.page, npages);
    if (__builtin_expect(!!(ret.err != MDBX_SUCCESS), 0))
      return ret;

    txn->mt_env->me_lck->mti_pgop_stat.unspill.weak += npages;

    ret.page->mp_flags |= (scan == txn) ? 0 : 0x2000;
    ret.err = MDBX_SUCCESS;
    return ret;
  } while (__builtin_expect(!!((scan = scan->mt_parent) != 
# 6952 "/libmdbx/src/core.c" 3 4
          ((void *)0) 
# 6952 "/libmdbx/src/core.c"
          && (scan->mt_flags & 0x08) != 0), 1)
                                                          );
  do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 6954, "Page %" 
# 6954 "/libmdbx/src/core.c" 3 4
 "u" 
# 6954 "/libmdbx/src/core.c"
 " mod-txnid %" 
# 6954 "/libmdbx/src/core.c" 3 4
 "l" "i" 
# 6954 "/libmdbx/src/core.c"
 " not found in the spill-list(s), current txn %" 
# 6954 "/libmdbx/src/core.c" 3 4
 "l" "i" 
# 6954 "/libmdbx/src/core.c"
 " front %" 
# 6954 "/libmdbx/src/core.c" 3 4
 "l" "i" 
# 6954 "/libmdbx/src/core.c"
 ", root txn %" 
# 6954 "/libmdbx/src/core.c" 3 4
 "l" "i" 
# 6954 "/libmdbx/src/core.c"
 " front %" 
# 6954 "/libmdbx/src/core.c" 3 4
 "l" "i" 
# 6954 "/libmdbx/src/core.c"
 "\n", mp->mp_pgno, mp->mp_txnid, txn->mt_txnid, txn->mt_front, txn->mt_env->me_txn0->mt_txnid, txn->mt_env->me_txn0->mt_front); } while (0)



                                                                            ;
  ret.err = MDBX_PROBLEM;
  ret.page = 
# 6960 "/libmdbx/src/core.c" 3 4
            ((void *)0)
# 6960 "/libmdbx/src/core.c"
                ;
  return ret;
}







__attribute__((__hot__)) __attribute__((__optimize__("O3"))) static int mdbx_page_touch(MDBX_cursor *mc) {
  const MDBX_page *const mp = mc->mc_pg[mc->mc_top];
  MDBX_page *np;
  MDBX_txn *txn = mc->mc_txn;
  int rc;

  if ((0)) {
    if (mc->mc_flags & 0x04) {
      MDBX_xcursor *mx = ((MDBX_xcursor *)((char *)(mc->mc_db) - 
# 6978 "/libmdbx/src/core.c" 3 4
                        __builtin_offsetof (
# 6978 "/libmdbx/src/core.c"
                        MDBX_xcursor
# 6978 "/libmdbx/src/core.c" 3 4
                        , 
# 6978 "/libmdbx/src/core.c"
                        mx_db
# 6978 "/libmdbx/src/core.c" 3 4
                        )
# 6978 "/libmdbx/src/core.c"
                        ));
      MDBX_cursor_couple *couple = ((MDBX_cursor_couple *)((char *)(mx) - 
# 6979 "/libmdbx/src/core.c" 3 4
                                  __builtin_offsetof (
# 6979 "/libmdbx/src/core.c"
                                  MDBX_cursor_couple
# 6979 "/libmdbx/src/core.c" 3 4
                                  , 
# 6979 "/libmdbx/src/core.c"
                                  inner
# 6979 "/libmdbx/src/core.c" 3 4
                                  )
# 6979 "/libmdbx/src/core.c"
                                  ));
      do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_db == &couple->outer.mc_xcursor->mx_db)), 0)) mdbx_assert_fail((txn)->mt_env, "mc->mc_db == &couple->outer.mc_xcursor->mx_db", __func__, 6980); } while (0); } while (0);
      do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_dbx == &couple->outer.mc_xcursor->mx_dbx)), 0)) mdbx_assert_fail((txn)->mt_env, "mc->mc_dbx == &couple->outer.mc_xcursor->mx_dbx", __func__, 6981); } while (0); } while (0);
      do { if ((0)) do { if (__builtin_expect(!!(!(*couple->outer.mc_dbistate & MDBX_DBI_DIRTY)), 0)) mdbx_assert_fail((txn)->mt_env, "*couple->outer.mc_dbistate & MDBX_DBI_DIRTY", __func__, 6982); } while (0); } while (0);
    } else {
      do { if ((0)) do { if (__builtin_expect(!!(!(*mc->mc_dbistate & MDBX_DBI_DIRTY)), 0)) mdbx_assert_fail((txn)->mt_env, "*mc->mc_dbistate & MDBX_DBI_DIRTY", __func__, 6984); } while (0); } while (0);
    }
    do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_txn->mt_flags & 0x04)), 0)) mdbx_assert_fail((txn)->mt_env, "mc->mc_txn->mt_flags & 0x04", __func__, 6986); } while (0); } while (0);
    do { if ((0)) do { if (__builtin_expect(!!(!(!__builtin_expect(!!(((mp)->mp_flags & 0x04) != 0), 0))), 0)) mdbx_assert_fail((txn)->mt_env, "!__builtin_expect(!!(((mp)->mp_flags & 0x04) != 0), 0)", __func__, 6987); } while (0); } while (0);
    do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_dirtylist_check(txn))), 0)) mdbx_assert_fail((txn)->mt_env, "mdbx_dirtylist_check(txn)", __func__, 6988); } while (0); } while (0);
  }

  if (((mp)->mp_txnid == (txn)->mt_front) || (((mp)->mp_flags & 0x40) != 0))
    return MDBX_SUCCESS;

  if (((mp)->mp_txnid < (txn)->mt_txnid)) {

    rc = mdbx_pnl_need(&txn->tw.retired_pages, 1);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      goto fail;
    const struct page_result par = mdbx_page_alloc(mc, 1, (1 | 2 | 4));
    rc = par.err;
    np = par.page;
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      goto fail;

    const pgno_t pgno = np->mp_pgno;
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 7006, "touched db %d page %" 
# 7006 "/libmdbx/src/core.c" 3 4
   "u" 
# 7006 "/libmdbx/src/core.c"
   " -> %" 
# 7006 "/libmdbx/src/core.c" 3 4
   "u" 
# 7006 "/libmdbx/src/core.c"
   "\n", (((mc)->mc_flags & 0x04) ? -(int)(mc)->mc_dbi : (int)(mc)->mc_dbi), mp->mp_pgno, pgno); } while (0)
                                 ;
    do { if ((0)) do { if (__builtin_expect(!!(!(mp->mp_pgno != pgno)), 0)) mdbx_assert_fail((txn)->mt_env, "mp->mp_pgno != pgno", __func__, 7008); } while (0); } while (0);
    mdbx_pnl_xappend(txn->tw.retired_pages, mp->mp_pgno);

    if (mc->mc_top) {
      MDBX_page *parent = mc->mc_pg[mc->mc_top - 1];
      MDBX_node *node = page_node(parent, mc->mc_ki[mc->mc_top - 1]);
      node_set_pgno(node, pgno);
    } else {
      mc->mc_db->md_root = pgno;
    }


    txn->mt_env->me_lck->mti_pgop_stat.cow.weak += 1;

    mdbx_page_copy(np, mp, txn->mt_env->me_psize);
    np->mp_pgno = pgno;
    np->mp_txnid = txn->mt_front;
  } else if (((mp)->mp_txnid == (txn)->mt_txnid)) {
    struct page_result pur = mdbx_page_unspill(txn, mp);
    np = pur.page;
    rc = pur.err;
    if (__builtin_expect(!!(rc == MDBX_SUCCESS), 1)) {
      do { if ((0)) do { if (__builtin_expect(!!(!(np != 
# 7030 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 7030 "/libmdbx/src/core.c"
     )), 0)) mdbx_assert_fail((txn)->mt_env, "np != ((void *)0)", __func__, 7030); } while (0); } while (0);
      goto done;
    }
    goto fail;
  } else {
    if (__builtin_expect(!!(!txn->mt_parent), 0)) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 7036, "Unexpected not frozen/modifiable/spilled but shadowed %s " "page %" 
# 7036 "/libmdbx/src/core.c" 3 4
     "u" 
# 7036 "/libmdbx/src/core.c"
     " mod-txnid %" 
# 7036 "/libmdbx/src/core.c" 3 4
     "l" "i" 
# 7036 "/libmdbx/src/core.c"
     "," " without parent transaction, current txn %" 
# 7036 "/libmdbx/src/core.c" 3 4
     "l" "i" 
# 7036 "/libmdbx/src/core.c"
     " front %" 
# 7036 "/libmdbx/src/core.c" 3 4
     "l" "i" 
# 7036 "/libmdbx/src/core.c"
     "\n", (((mp)->mp_flags & 0x01) != 0) ? "branch" : "leaf", mp->mp_pgno, mp->mp_txnid, mc->mc_txn->mt_txnid, mc->mc_txn->mt_front); } while (0)




                                                            ;
      rc = MDBX_PROBLEM;
      goto fail;
    }

    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 7046, "clone db %d page %" 
# 7046 "/libmdbx/src/core.c" 3 4
   "u" 
# 7046 "/libmdbx/src/core.c"
   "\n", (((mc)->mc_flags & 0x04) ? -(int)(mc)->mc_dbi : (int)(mc)->mc_dbi), mp->mp_pgno); } while (0);
    do { if ((0)) do { if (__builtin_expect(!!(!(txn->tw.dirtylist->length <= ((size_t)0x7FFFffffU) + 1024)), 0)) mdbx_assert_fail((txn)->mt_env, "txn->tw.dirtylist->length <= ((size_t)0x7FFFffffU) + 1024", __func__, 7047); } while (0); } while (0)
                                                              ;

    np = mdbx_page_malloc(txn, 1);
    if (__builtin_expect(!!(!np), 0)) {
      rc = MDBX_ENOMEM;
      goto fail;
    }
    mdbx_page_copy(np, mp, txn->mt_env->me_psize);


    rc = mdbx_page_dirty(txn, np, 1);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      goto fail;


    txn->mt_env->me_lck->mti_pgop_stat.clone.weak += 1;

  }

done:

  mc->mc_pg[mc->mc_top] = np;
  MDBX_cursor *m2 = txn->mt_cursors[mc->mc_dbi];
  if (mc->mc_flags & 0x04) {
    for (; m2; m2 = m2->mc_next) {
      MDBX_cursor *m3 = &m2->mc_xcursor->mx_cursor;
      if (m3->mc_snum < mc->mc_snum)
        continue;
      if (m3->mc_pg[mc->mc_top] == mp)
        m3->mc_pg[mc->mc_top] = np;
    }
  } else {
    for (; m2; m2 = m2->mc_next) {
      if (m2->mc_snum < mc->mc_snum)
        continue;
      if (m2 == mc)
        continue;
      if (m2->mc_pg[mc->mc_top] == mp) {
        m2->mc_pg[mc->mc_top] = np;
        if (((m2)->mc_xcursor && ((m2)->mc_xcursor->mx_cursor.mc_flags & 0x01)) && (((np)->mp_flags & 0x02) != 0))
          do { MDBX_page *xr_pg = (np); MDBX_node *xr_node = page_node(xr_pg, m2->mc_ki[mc->mc_top]); if ((node_flags(xr_node) & (0x04 | 0x02)) == 0x04) (m2)->mc_xcursor->mx_cursor.mc_pg[0] = node_data(xr_node); } while (0);
      }
    }
  }
  return MDBX_SUCCESS;

fail:
  txn->mt_flags |= 0x02;
  return rc;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static int mdbx_env_sync_internal(MDBX_env *env, _Bool force,
                                         _Bool nonblock) {
  _Bool locked = (0);
  int rc = MDBX_RESULT_TRUE ;

retry:;
  unsigned flags = env->me_flags & ~(MDBX_NOMETASYNC | 0x40000000U);
  if (__builtin_expect(!!((flags & (MDBX_RDONLY | 0x80000000U | 0x20000000U)) != 0x20000000U), 0)
                               ) {
    rc = MDBX_EACCESS;
    if (!(flags & 0x20000000U))
      rc = MDBX_EPERM;
    if (flags & 0x80000000U)
      rc = MDBX_PANIC;
    goto bailout;
  }

  const pgno_t unsynced_pages =
      atomic_load32(&env->me_lck->mti_unsynced_pages, mo_Relaxed);
  volatile const MDBX_meta *head = meta_prefer_last(env);
  const txnid_t head_txnid = meta_txnid(env, head);
  const uint32_t synched_meta_txnid_u32 =
      atomic_load32(&env->me_lck->mti_meta_sync_txnid, mo_Relaxed);
  if (unsynced_pages == 0 && synched_meta_txnid_u32 == (uint32_t)head_txnid &&
      ((unaligned_peek_u64_volatile(4, (head)->mm_datasync_sign)) > 1u))
    goto bailout;

  const pgno_t autosync_threshold =
      atomic_load32(&env->me_lck->mti_autosync_threshold, mo_Relaxed);
  const uint64_t autosync_period =
      atomic_load64(&env->me_lck->mti_autosync_period, mo_Relaxed);
  if (force || (autosync_threshold && unsynced_pages >= autosync_threshold) ||
      (autosync_period &&
       mdbx_osal_monotime() -
               atomic_load64(&env->me_lck->mti_sync_timestamp, mo_Relaxed) >=
           autosync_period))
    flags &= MDBX_WRITEMAP ;

  const _Bool inside_txn = (env->me_txn0->mt_owner == mdbx_thread_self());
  if (!inside_txn) {
    if (!locked) {
      int err;
      unsigned wops = 0;

      if (unsynced_pages > 16 &&
          (flags & MDBX_SAFE_NOSYNC) == 0) {
        do { if ((0)) do { if (__builtin_expect(!!(!(((flags ^ env->me_flags) & MDBX_WRITEMAP) == 0)), 0)) mdbx_assert_fail(env, "((flags ^ env->me_flags) & MDBX_WRITEMAP) == 0", __func__, 7145); } while (0); } while (0);
        if (flags & MDBX_WRITEMAP) {




          err = mdbx_fastmutex_acquire(&env->me_remap_guard);
          if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
            return err;

          const size_t usedbytes = pgno_align2os_bytes(env, head->mm_geo.next);
          err = mdbx_msync(&env->me_dxb_mmap, 0, usedbytes, MDBX_SYNC_DATA);



          int unlock_err = mdbx_fastmutex_release(&env->me_remap_guard);
          if (__builtin_expect(!!(unlock_err != MDBX_SUCCESS), 0) && err == MDBX_SUCCESS)
            err = unlock_err;

        } else
          err = mdbx_fsync(env->me_dxb_mmap.fd, MDBX_SYNC_DATA);

        if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
          return err;


        wops = 1;
        rc = MDBX_SUCCESS ;
      }

      err = mdbx_txn_lock(env, nonblock);
      if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
        return err;

      locked = (1);

      env->me_lck->mti_pgop_stat.wops.weak += wops;

      goto retry;
    }
    env->me_txn0->mt_txnid = head_txnid;
    do { if ((0)) do { if (__builtin_expect(!!(!(head_txnid == meta_txnid(env, head))), 0)) mdbx_assert_fail(env, "head_txnid == meta_txnid(env, head)", __func__, 7186); } while (0); } while (0);
    do { if ((0)) do { if (__builtin_expect(!!(!(head_txnid == mdbx_recent_committed_txnid(env))), 0)) mdbx_assert_fail(env, "head_txnid == mdbx_recent_committed_txnid(env)", __func__, 7187); } while (0); } while (0);
    mdbx_find_oldest(env->me_txn0);
    flags |= 0x40000000U;
  }

  do { if ((0)) do { if (__builtin_expect(!!(!(inside_txn || locked)), 0)) mdbx_assert_fail(env, "inside_txn || locked", __func__, 7192); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(!inside_txn || (flags & 0x40000000U) == 0)), 0)) mdbx_assert_fail(env, "!inside_txn || (flags & 0x40000000U) == 0", __func__, 7193); } while (0); } while (0);

  if (!((unaligned_peek_u64_volatile(4, (head)->mm_datasync_sign)) > 1u) ||
      ((flags & MDBX_SAFE_NOSYNC) == 0 && unsynced_pages)) {
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 7197, "meta-head %" 
# 7197 "/libmdbx/src/core.c" 3 4
   "u" 
# 7197 "/libmdbx/src/core.c"
   ", %s, sync_pending %" 
# 7197 "/libmdbx/src/core.c" 3 4
   "u" 
# 7197 "/libmdbx/src/core.c"
   "\n", data_page((const void *)head)->mp_pgno, mdbx_durable_str(head), unsynced_pages); } while (0)

                              ;
    MDBX_meta meta = *head;
    rc = mdbx_sync_locked(env, flags, &meta);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      goto bailout;
  }



  if (atomic_load32(&env->me_lck->mti_meta_sync_txnid, mo_Relaxed) !=
      (uint32_t)head_txnid) {

    env->me_lck->mti_pgop_stat.wops.weak += 1;

    rc = (flags & MDBX_WRITEMAP)
             ? mdbx_msync(&env->me_dxb_mmap, 0,
                          pgno_align2os_bytes(env, 3),
                          MDBX_SYNC_DATA | MDBX_SYNC_IODQ)
             : mdbx_fsync(env->me_dxb_mmap.fd, MDBX_SYNC_DATA | MDBX_SYNC_IODQ);
    if (__builtin_expect(!!(rc == MDBX_SUCCESS), 1))
      atomic_store32(&env->me_lck->mti_meta_sync_txnid, (uint32_t)head_txnid,
                     mo_Relaxed);
  }

bailout:
  if (locked)
    mdbx_txn_unlock(env);
  return rc;
}

static __inline int check_env(const MDBX_env *env, const _Bool wanna_active) {
  if (__builtin_expect(!!(!env), 0))
    return MDBX_EINVAL;

  if (__builtin_expect(!!(env->me_signature.weak != 0x9A899641U), 0))
    return MDBX_EBADSIGN;
# 7243 "/libmdbx/src/core.c"
  if (__builtin_expect(!!(env->me_flags & 0x80000000U), 0))
    return MDBX_PANIC;

  if (wanna_active) {
    if (__builtin_expect(!!((env->me_flags & 0x20000000U) == 0), 0))
      return MDBX_EPERM;
    do { if ((0)) do { if (__builtin_expect(!!(!(env->me_dxb_mmap.dxb != 
# 7249 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 7249 "/libmdbx/src/core.c"
   )), 0)) mdbx_assert_fail(env, "env->me_dxb_mmap.dxb != ((void *)0)", __func__, 7249); } while (0); } while (0);
  }

  return MDBX_SUCCESS;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_sync_ex(MDBX_env *env, _Bool force, _Bool nonblock) {
  int rc = check_env(env, (1));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  return mdbx_env_sync_internal(env, force, nonblock);
}


__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_sync(MDBX_env *env) { return __inline_mdbx_env_sync(env); }

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_sync_poll(MDBX_env *env) {
  return __inline_mdbx_env_sync_poll(env);
}



static int mdbx_cursor_shadow(MDBX_txn *parent, MDBX_txn *nested) {
  for (int i = parent->mt_numdbs; --i >= 0;) {
    nested->mt_cursors[i] = 
# 7274 "/libmdbx/src/core.c" 3 4
                           ((void *)0)
# 7274 "/libmdbx/src/core.c"
                               ;
    MDBX_cursor *mc = parent->mt_cursors[i];
    if (mc != 
# 7276 "/libmdbx/src/core.c" 3 4
             ((void *)0)
# 7276 "/libmdbx/src/core.c"
                 ) {
      size_t size = mc->mc_xcursor ? sizeof(MDBX_cursor) + sizeof(MDBX_xcursor)
                                   : sizeof(MDBX_cursor);
      for (MDBX_cursor *bk; mc; mc = bk->mc_next) {
        bk = mc;
        if (mc->mc_signature != 0xFE05D5B1U)
          continue;
        bk = malloc(size);
        if (__builtin_expect(!!(!bk), 0))
          return MDBX_ENOMEM;




        *bk = *mc;
        mc->mc_backup = bk;



        mc->mc_txn = nested;
        mc->mc_db = &nested->mt_dbs[i];
        mc->mc_dbistate = &nested->mt_dbistate[i];
        MDBX_xcursor *mx = mc->mc_xcursor;
        if (mx != 
# 7299 "/libmdbx/src/core.c" 3 4
                 ((void *)0)
# 7299 "/libmdbx/src/core.c"
                     ) {
          *(MDBX_xcursor *)(bk + 1) = *mx;
          mx->mx_cursor.mc_txn = nested;
        }
        mc->mc_next = nested->mt_cursors[i];
        nested->mt_cursors[i] = mc;
      }
    }
  }
  return MDBX_SUCCESS;
}







static void mdbx_cursors_eot(MDBX_txn *txn, const _Bool merge) {
  for (int i = txn->mt_numdbs; --i >= 0;) {
    MDBX_cursor *next, *mc = txn->mt_cursors[i];
    if (!mc)
      continue;
    txn->mt_cursors[i] = 
# 7322 "/libmdbx/src/core.c" 3 4
                        ((void *)0)
# 7322 "/libmdbx/src/core.c"
                            ;
    do {
      const unsigned stage = mc->mc_signature;
      MDBX_cursor *bk = mc->mc_backup;
      next = mc->mc_next;
      do { if (__builtin_expect(!!(!(stage == 0xFE05D5B1U || (stage == 0x90E297A7U && bk))), 0)) mdbx_assert_fail(txn->mt_env, "stage == MDBX_MC_LIVE || (stage == MDBX_MC_WAIT4EOT && bk)", __func__, 7327); } while (0)
                                                                             ;
      do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_dbi == (unsigned)i)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mc->mc_dbi == (unsigned)i", __func__, 7329); } while (0); } while (0);
      if (bk) {
        MDBX_xcursor *mx = mc->mc_xcursor;
        do { if ((0)) do { if (__builtin_expect(!!(!(mx == bk->mc_xcursor)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mx == bk->mc_xcursor", __func__, 7332); } while (0); } while (0);
        do { if ((0)) do { if (__builtin_expect(!!(!(txn->mt_parent != 
# 7333 "/libmdbx/src/core.c" 3 4
       ((void *)0)
# 7333 "/libmdbx/src/core.c"
       )), 0)) mdbx_assert_fail((txn)->mt_env, "txn->mt_parent != ((void *)0)", __func__, 7333); } while (0); } while (0);
        do { if (__builtin_expect(!!(!(bk->mc_signature == 0xFE05D5B1U)), 0)) mdbx_assert_fail(txn->mt_env, "bk->mc_signature == MDBX_MC_LIVE", __func__, 7334); } while (0);
        if (stage == 0x90E297A7U )
          mc->mc_signature = stage ;
        else if (merge) {

          mc->mc_next = bk->mc_next;
          mc->mc_backup = bk->mc_backup;
          mc->mc_txn = bk->mc_txn;
          mc->mc_db = bk->mc_db;
          mc->mc_dbistate = bk->mc_dbistate;
          if (mx) {
            if (mx != bk->mc_xcursor) {
              *bk->mc_xcursor = *mx;
              mx = bk->mc_xcursor;
            }
            mx->mx_cursor.mc_txn = bk->mc_txn;
          }
        } else {

          *mc = *bk;
          if (mx)
            *mx = *(MDBX_xcursor *)(bk + 1);
        }
        bk->mc_signature = 0;
        free(bk);
      } else {
        do { if (__builtin_expect(!!(!(stage == 0xFE05D5B1U)), 0)) mdbx_assert_fail(txn->mt_env, "stage == MDBX_MC_LIVE", __func__, 7360); } while (0);
        mc->mc_signature = 0x2817A047U ;
        mc->mc_flags = 0 ;
      }
    } while ((mc = next) != 
# 7364 "/libmdbx/src/core.c" 3 4
                           ((void *)0)
# 7364 "/libmdbx/src/core.c"
                               );
  }
}
# 7448 "/libmdbx/src/core.c"
typedef struct {
  int err;
  MDBX_reader *rslot;
} bind_rslot_result;

static bind_rslot_result bind_rslot(MDBX_env *env, const uintptr_t tid) {
  do { if ((0)) do { if (__builtin_expect(!!(!(env->me_lck_mmap.lck)), 0)) mdbx_assert_fail(env, "env->me_lck_mmap.lck", __func__, 7454); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(env->me_lck->mti_magic_and_version == ((0x59659DBDEF4C11UL << 8) + 4))), 0)) mdbx_assert_fail(env, "env->me_lck->mti_magic_and_version == ((0x59659DBDEF4C11UL << 8) + 4)", __func__, 7455); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(env->me_lck->mti_os_and_format == (0x8017U * 27733 + (unsigned)sizeof(MDBX_reader) * 13 + (unsigned)
# 7456 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 7456 "/libmdbx/src/core.c"
 MDBX_reader
# 7456 "/libmdbx/src/core.c" 3 4
 , 
# 7456 "/libmdbx/src/core.c"
 mr_snapshot_pages_used
# 7456 "/libmdbx/src/core.c" 3 4
 ) 
# 7456 "/libmdbx/src/core.c"
 * 251 + (unsigned)
# 7456 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 7456 "/libmdbx/src/core.c"
 MDBX_lockinfo
# 7456 "/libmdbx/src/core.c" 3 4
 , 
# 7456 "/libmdbx/src/core.c"
 mti_oldest_reader
# 7456 "/libmdbx/src/core.c" 3 4
 ) 
# 7456 "/libmdbx/src/core.c"
 * 83 + (unsigned)
# 7456 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 7456 "/libmdbx/src/core.c"
 MDBX_lockinfo
# 7456 "/libmdbx/src/core.c" 3 4
 , 
# 7456 "/libmdbx/src/core.c"
 mti_numreaders
# 7456 "/libmdbx/src/core.c" 3 4
 ) 
# 7456 "/libmdbx/src/core.c"
 * 37 + (unsigned)
# 7456 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 7456 "/libmdbx/src/core.c"
 MDBX_lockinfo
# 7456 "/libmdbx/src/core.c" 3 4
 , 
# 7456 "/libmdbx/src/core.c"
 mti_readers
# 7456 "/libmdbx/src/core.c" 3 4
 ) 
# 7456 "/libmdbx/src/core.c"
 * 29))), 0)) mdbx_assert_fail(env, "env->me_lck->mti_os_and_format == (0x8017U * 27733 + (unsigned)sizeof(MDBX_reader) * 13 + (unsigned)__builtin_offsetof (MDBX_reader, mr_snapshot_pages_used) * 251 + (unsigned)__builtin_offsetof (MDBX_lockinfo, mti_oldest_reader) * 83 + (unsigned)__builtin_offsetof (MDBX_lockinfo, mti_numreaders) * 37 + (unsigned)__builtin_offsetof (MDBX_lockinfo, mti_readers) * 29)", __func__, 7456); } while (0); } while (0);

  bind_rslot_result result = {mdbx_rdt_lock(env), 
# 7458 "/libmdbx/src/core.c" 3 4
                                                 ((void *)0)
# 7458 "/libmdbx/src/core.c"
                                                        };
  if (__builtin_expect(!!(((result.err) != MDBX_RESULT_TRUE && (result.err) != MDBX_RESULT_FALSE)), 0))
    return result;
  if (__builtin_expect(!!(env->me_flags & 0x80000000U), 0)) {
    mdbx_rdt_unlock(env);
    result.err = MDBX_PANIC;
    return result;
  }
  if (__builtin_expect(!!(!env->me_dxb_mmap.dxb), 0)) {
    mdbx_rdt_unlock(env);
    result.err = MDBX_EPERM;
    return result;
  }

  if (__builtin_expect(!!(env->me_live_reader != env->me_pid), 0)) {
    result.err = mdbx_rpid_set(env);
    if (__builtin_expect(!!(result.err != MDBX_SUCCESS), 0)) {
      mdbx_rdt_unlock(env);
      return result;
    }
    env->me_live_reader = env->me_pid;
  }

  result.err = MDBX_SUCCESS;
  unsigned slot, nreaders;
  while (1) {
    nreaders = atomic_load32(&env->me_lck->mti_numreaders, mo_Relaxed);
    for (slot = 0; slot < nreaders; slot++)
      if (atomic_load32(&env->me_lck->mti_readers[slot].mr_pid, mo_Relaxed) ==
          0)
        break;

    if (__builtin_expect(!!(slot < env->me_maxreaders), 1))
      break;

    result.err = mdbx_cleanup_dead_readers(env, (1), 
# 7493 "/libmdbx/src/core.c" 3 4
                                                     ((void *)0)
# 7493 "/libmdbx/src/core.c"
                                                         );
    if (result.err != MDBX_RESULT_TRUE) {
      mdbx_rdt_unlock(env);
      result.err =
          (result.err == MDBX_SUCCESS) ? MDBX_READERS_FULL : result.err;
      return result;
    }
  }

  result.rslot = &env->me_lck->mti_readers[slot];





  atomic_store32(&result.rslot->mr_pid, 0, mo_Relaxed);
  safe64_reset(&result.rslot->mr_txnid, (1));
  if (slot == nreaders)
    atomic_store32(&env->me_lck->mti_numreaders, ++nreaders, mo_Relaxed);
  atomic_store64(&result.rslot->mr_tid, (env->me_flags & MDBX_NOTLS) ? 0 : tid,
                 mo_Relaxed);
  atomic_store32(&result.rslot->mr_pid, env->me_pid, mo_Relaxed);
  mdbx_rdt_unlock(env);

  if (__builtin_expect(!!(env->me_flags & 0x10000000U), 1)) {
    do { if ((0)) do { if (__builtin_expect(!!(!(env->me_live_reader == env->me_pid)), 0)) mdbx_assert_fail(env, "env->me_live_reader == env->me_pid", __func__, 7518); } while (0); } while (0);
    thread_rthc_set(env->me_txkey, result.rslot);
  }
  return result;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_thread_register(const MDBX_env *env) {
  int rc = check_env(env, (1));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(!env->me_lck_mmap.lck), 0))
    return (env->me_flags & MDBX_EXCLUSIVE) ? MDBX_EINVAL : MDBX_EPERM;

  if (__builtin_expect(!!((env->me_flags & 0x10000000U) == 0), 0)) {
    do { if ((0)) do { if (__builtin_expect(!!(!(!env->me_lck_mmap.lck || (env->me_flags & MDBX_NOTLS))), 0)) mdbx_assert_fail(env, "!env->me_lck_mmap.lck || (env->me_flags & MDBX_NOTLS)", __func__, 7533); } while (0); } while (0);
    return MDBX_EINVAL ;
  }

  do { if ((0)) do { if (__builtin_expect(!!(!((env->me_flags & (MDBX_NOTLS | 0x10000000U | MDBX_EXCLUSIVE)) == 0x10000000U)), 0)) mdbx_assert_fail(env, "(env->me_flags & (MDBX_NOTLS | 0x10000000U | MDBX_EXCLUSIVE)) == 0x10000000U", __func__, 7537); } while (0); } while (0)
                                                                        ;
  MDBX_reader *r = thread_rthc_get(env->me_txkey);
  if (__builtin_expect(!!(r != 
# 7540 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 7540 "/libmdbx/src/core.c"
     ), 0)) {
    do { if ((0)) do { if (__builtin_expect(!!(!(r->mr_pid.weak == env->me_pid)), 0)) mdbx_assert_fail(env, "r->mr_pid.weak == env->me_pid", __func__, 7541); } while (0); } while (0);
    do { if ((0)) do { if (__builtin_expect(!!(!(r->mr_tid.weak == mdbx_thread_self())), 0)) mdbx_assert_fail(env, "r->mr_tid.weak == mdbx_thread_self()", __func__, 7542); } while (0); } while (0);
    if (__builtin_expect(!!(r->mr_pid.weak != env->me_pid), 0))
      return MDBX_BAD_RSLOT;
    return MDBX_RESULT_TRUE ;
  }

  const uintptr_t tid = mdbx_thread_self();
  if (env->me_txn0 && __builtin_expect(!!(env->me_txn0->mt_owner == tid), 0))
    return MDBX_TXN_OVERLAPPING;
  return bind_rslot((MDBX_env *)env, tid).err;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_thread_unregister(const MDBX_env *env) {
  int rc = check_env(env, (1));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(!env->me_lck_mmap.lck), 0))
    return MDBX_RESULT_TRUE;

  if (__builtin_expect(!!((env->me_flags & 0x10000000U) == 0), 0)) {
    do { if ((0)) do { if (__builtin_expect(!!(!(!env->me_lck_mmap.lck || (env->me_flags & MDBX_NOTLS))), 0)) mdbx_assert_fail(env, "!env->me_lck_mmap.lck || (env->me_flags & MDBX_NOTLS)", __func__, 7563); } while (0); } while (0);
    return MDBX_RESULT_TRUE ;
  }

  do { if ((0)) do { if (__builtin_expect(!!(!((env->me_flags & (MDBX_NOTLS | 0x10000000U | MDBX_EXCLUSIVE)) == 0x10000000U)), 0)) mdbx_assert_fail(env, "(env->me_flags & (MDBX_NOTLS | 0x10000000U | MDBX_EXCLUSIVE)) == 0x10000000U", __func__, 7567); } while (0); } while (0)
                                                                        ;
  MDBX_reader *r = thread_rthc_get(env->me_txkey);
  if (__builtin_expect(!!(r == 
# 7570 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 7570 "/libmdbx/src/core.c"
     ), 0))
    return MDBX_RESULT_TRUE ;

  do { if ((0)) do { if (__builtin_expect(!!(!(r->mr_pid.weak == env->me_pid)), 0)) mdbx_assert_fail(env, "r->mr_pid.weak == env->me_pid", __func__, 7573); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(r->mr_tid.weak == mdbx_thread_self())), 0)) mdbx_assert_fail(env, "r->mr_tid.weak == mdbx_thread_self()", __func__, 7574); } while (0); } while (0);
  if (__builtin_expect(!!(r->mr_pid.weak != env->me_pid || r->mr_tid.weak != mdbx_thread_self()), 0)
                                                    )
    return MDBX_BAD_RSLOT;

  if (__builtin_expect(!!(r->mr_txnid.weak < 0xffffFFFF00000000UL), 0))
    return MDBX_BUSY ;

  atomic_store32(&r->mr_pid, 0, mo_Relaxed);
  atomic_store32(&env->me_lck->mti_readers_refresh_flag, (1),
                 mo_AcquireRelease);
  thread_rthc_set(env->me_txkey, 
# 7585 "/libmdbx/src/core.c" 3 4
                                ((void *)0)
# 7585 "/libmdbx/src/core.c"
                                       );
  return MDBX_SUCCESS;
}


static _Bool meta_checktxnid(const MDBX_env *env, const MDBX_meta *meta,
                            _Bool report) {
  const txnid_t meta_txnid = constmeta_txnid(env, meta);
  const txnid_t freedb_mod_txnid = meta->mm_dbs[0].md_mod_txnid;
  const txnid_t maindb_mod_txnid = meta->mm_dbs[1].md_mod_txnid;

  const pgno_t freedb_root_pgno = meta->mm_dbs[0].md_root;
  const MDBX_page *freedb_root = (env->me_dxb_mmap.dxb && freedb_root_pgno != (~(pgno_t)0))
                                     ? pgno2page(env, freedb_root_pgno)
                                     : 
# 7599 "/libmdbx/src/core.c" 3 4
                                      ((void *)0)
# 7599 "/libmdbx/src/core.c"
                                             ;

  const pgno_t maindb_root_pgno = meta->mm_dbs[1].md_root;
  const MDBX_page *maindb_root = (env->me_dxb_mmap.dxb && maindb_root_pgno != (~(pgno_t)0))
                                     ? pgno2page(env, maindb_root_pgno)
                                     : 
# 7604 "/libmdbx/src/core.c" 3 4
                                      ((void *)0)
# 7604 "/libmdbx/src/core.c"
                                             ;

  const uint64_t magic_and_version =
      unaligned_peek_u64(4, &meta->mm_magic_and_version);
  _Bool ok = (1);
  if (__builtin_expect(!!(meta_txnid < freedb_mod_txnid || (!freedb_mod_txnid && freedb_root && __builtin_expect(!!(magic_and_version == ((0x59659DBDEF4C11UL << 8) + 0 * 64 + 3)), 1))), 0)

                                                              ) {
    if (report)
      do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 7613, "catch invalid %sdb_mod_txnid %" 
# 7613 "/libmdbx/src/core.c" 3 4
     "l" "i" 
# 7613 "/libmdbx/src/core.c"
     " for meta_txnid %" 
# 7613 "/libmdbx/src/core.c" 3 4
     "l" "i" 
# 7613 "/libmdbx/src/core.c"
     " %s" "\n", "free", freedb_mod_txnid, meta_txnid, "(workaround for incoherent flaw of unified page/buffer cache)"); } while (0)



                                                                          ;
    ok = (0);
  }
  if (__builtin_expect(!!(meta_txnid < maindb_mod_txnid || (!maindb_mod_txnid && maindb_root && __builtin_expect(!!(magic_and_version == ((0x59659DBDEF4C11UL << 8) + 0 * 64 + 3)), 1))), 0)

                                                              ) {
    if (report)
      do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 7624, "catch invalid %sdb_mod_txnid %" 
# 7624 "/libmdbx/src/core.c" 3 4
     "l" "i" 
# 7624 "/libmdbx/src/core.c"
     " for meta_txnid %" 
# 7624 "/libmdbx/src/core.c" 3 4
     "l" "i" 
# 7624 "/libmdbx/src/core.c"
     " %s" "\n", "main", maindb_mod_txnid, meta_txnid, "(workaround for incoherent flaw of unified page/buffer cache)"); } while (0)



                                                                          ;
    ok = (0);
  }
  if (__builtin_expect(!!(freedb_root && freedb_mod_txnid), 1)) {
    ;
    do { do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 7633, "UNPOISON_MEMORY_REGION(%p, %zu) at %u" "\n", (void *)(freedb_root), (size_t)(sizeof(freedb_root->mp_txnid)), 7633); } while (0); ((void)(freedb_root), (void)(sizeof(freedb_root->mp_txnid))); } while (0)
                                                                   ;
    const txnid_t root_txnid = freedb_root->mp_txnid;
    if (__builtin_expect(!!(root_txnid != freedb_mod_txnid), 0)) {
      if (report)
        do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 7638, "catch invalid root_page_txnid %" 
# 7638 "/libmdbx/src/core.c" 3 4
       "l" "i" 
# 7638 "/libmdbx/src/core.c"
       " for %sdb_mod_txnid %" 
# 7638 "/libmdbx/src/core.c" 3 4
       "l" "i" 
# 7638 "/libmdbx/src/core.c"
       " %s" "\n", root_txnid, "free", maindb_mod_txnid, "(workaround for incoherent flaw of unified page/buffer cache)"); } while (0)



                                                                            ;
      ok = (0);
    }
  }
  if (__builtin_expect(!!(maindb_root && maindb_mod_txnid), 1)) {
    ;
    do { do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 7648, "UNPOISON_MEMORY_REGION(%p, %zu) at %u" "\n", (void *)(maindb_root), (size_t)(sizeof(maindb_root->mp_txnid)), 7648); } while (0); ((void)(maindb_root), (void)(sizeof(maindb_root->mp_txnid))); } while (0)
                                                                   ;
    const txnid_t root_txnid = maindb_root->mp_txnid;
    if (__builtin_expect(!!(root_txnid != maindb_mod_txnid), 0)) {
      if (report)
        do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 7653, "catch invalid root_page_txnid %" 
# 7653 "/libmdbx/src/core.c" 3 4
       "l" "i" 
# 7653 "/libmdbx/src/core.c"
       " for %sdb_mod_txnid %" 
# 7653 "/libmdbx/src/core.c" 3 4
       "l" "i" 
# 7653 "/libmdbx/src/core.c"
       " %s" "\n", root_txnid, "main", maindb_mod_txnid, "(workaround for incoherent flaw of unified page/buffer cache)"); } while (0)



                                                                            ;
      ok = (0);
    }
  }
  return ok;
}



static int meta_waittxnid(const MDBX_env *env, const MDBX_meta *meta,
                          uint64_t *timestamp) {
  if (__builtin_expect(!!(meta_checktxnid(env, (const MDBX_meta *)meta, !*timestamp)), 1))
    return MDBX_SUCCESS;

  if (!*timestamp)
    *timestamp = mdbx_osal_monotime();
  else if (__builtin_expect(!!(mdbx_osal_monotime() - *timestamp > 65536 / 10), 0)) {
    do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 7674, "bailout waiting for valid snapshot %s" "\n", "(workaround for incoherent flaw of unified page/buffer cache)"); } while (0)
                                                                               ;
    return MDBX_CORRUPTED;
  }




  sched_yield();





  return MDBX_RESULT_TRUE;
}


static int mdbx_txn_renew0(MDBX_txn *txn, const unsigned flags) {
  MDBX_env *env = txn->mt_env;
  int rc;
# 7703 "/libmdbx/src/core.c"
  _Static_assert(sizeof(MDBX_reader) == 32, "sizeof(MDBX_reader) == 32");

  _Static_assert(
# 7705 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 7705 "/libmdbx/src/core.c"
 MDBX_lockinfo
# 7705 "/libmdbx/src/core.c" 3 4
 , 
# 7705 "/libmdbx/src/core.c"
 mti_wlock
# 7705 "/libmdbx/src/core.c" 3 4
 ) 
# 7705 "/libmdbx/src/core.c"
 % 64 == 0, "offsetof(MDBX_lockinfo, mti_wlock) % MDBX_CACHELINE_SIZE == 0");
  _Static_assert(
# 7706 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 7706 "/libmdbx/src/core.c"
 MDBX_lockinfo
# 7706 "/libmdbx/src/core.c" 3 4
 , 
# 7706 "/libmdbx/src/core.c"
 mti_rlock
# 7706 "/libmdbx/src/core.c" 3 4
 ) 
# 7706 "/libmdbx/src/core.c"
 % 64 == 0, "offsetof(MDBX_lockinfo, mti_rlock) % MDBX_CACHELINE_SIZE == 0");






  _Static_assert(
# 7713 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 7713 "/libmdbx/src/core.c"
 MDBX_lockinfo
# 7713 "/libmdbx/src/core.c" 3 4
 , 
# 7713 "/libmdbx/src/core.c"
 mti_readers
# 7713 "/libmdbx/src/core.c" 3 4
 ) 
# 7713 "/libmdbx/src/core.c"
 % 64 == 0, "offsetof(MDBX_lockinfo, mti_readers) % MDBX_CACHELINE_SIZE == 0")
                  ;

  const uintptr_t tid = mdbx_thread_self();
  if (flags & MDBX_TXN_RDONLY) {
    do { if ((0)) do { if (__builtin_expect(!!(!((flags & ~((MDBX_TXN_RDONLY | MDBX_TXN_RDONLY_PREPARE) | MDBX_WRITEMAP)) == 0)), 0)) mdbx_assert_fail(env, "(flags & ~((MDBX_TXN_RDONLY | MDBX_TXN_RDONLY_PREPARE) | MDBX_WRITEMAP)) == 0", __func__, 7718); } while (0); } while (0);
    txn->mt_flags =
        MDBX_TXN_RDONLY | (env->me_flags & (MDBX_NOTLS | MDBX_WRITEMAP));
    MDBX_reader *r = txn->to.reader;
    _Static_assert(sizeof(uintptr_t) <= sizeof(r->mr_tid), "sizeof(uintptr_t) <= sizeof(r->mr_tid)");
    if (__builtin_expect(!!(env->me_flags & 0x10000000U), 1)) {
      do { if ((0)) do { if (__builtin_expect(!!(!(!(env->me_flags & MDBX_NOTLS))), 0)) mdbx_assert_fail(env, "!(env->me_flags & MDBX_NOTLS)", __func__, 7724); } while (0); } while (0);
      r = thread_rthc_get(env->me_txkey);
      if (__builtin_expect(!!(r), 1)) {
        if (__builtin_expect(!!(!r->mr_pid.weak), 0) &&
            (mdbx_runtime_flags & MDBX_DBG_LEGACY_MULTIOPEN)) {
          thread_rthc_set(env->me_txkey, 
# 7729 "/libmdbx/src/core.c" 3 4
                                        ((void *)0)
# 7729 "/libmdbx/src/core.c"
                                               );
          r = 
# 7730 "/libmdbx/src/core.c" 3 4
             ((void *)0)
# 7730 "/libmdbx/src/core.c"
                    ;
        } else {
          do { if ((0)) do { if (__builtin_expect(!!(!(r->mr_pid.weak == env->me_pid)), 0)) mdbx_assert_fail(env, "r->mr_pid.weak == env->me_pid", __func__, 7732); } while (0); } while (0);
          do { if ((0)) do { if (__builtin_expect(!!(!(r->mr_tid.weak == mdbx_thread_self())), 0)) mdbx_assert_fail(env, "r->mr_tid.weak == mdbx_thread_self()", __func__, 7733); } while (0); } while (0);
        }
      }
    } else {
      do { if ((0)) do { if (__builtin_expect(!!(!(!env->me_lck_mmap.lck || (env->me_flags & MDBX_NOTLS))), 0)) mdbx_assert_fail(env, "!env->me_lck_mmap.lck || (env->me_flags & MDBX_NOTLS)", __func__, 7737); } while (0); } while (0);
    }

    if (__builtin_expect(!!(r), 1)) {
      if (__builtin_expect(!!(r->mr_pid.weak != env->me_pid || r->mr_txnid.weak < 0xffffFFFF00000000UL), 0)
                                                               )
        return MDBX_BAD_RSLOT;
    } else if (env->me_lck_mmap.lck) {
      bind_rslot_result brs = bind_rslot(env, tid);
      if (__builtin_expect(!!(brs.err != MDBX_SUCCESS), 0))
        return brs.err;
      r = brs.rslot;
    }
    txn->to.reader = r;
    if (flags & (MDBX_TXN_RDONLY_PREPARE - MDBX_TXN_RDONLY)) {
      do { if ((0)) do { if (__builtin_expect(!!(!(txn->mt_txnid == 0)), 0)) mdbx_assert_fail(env, "txn->mt_txnid == 0", __func__, 7752); } while (0); } while (0);
      do { if ((0)) do { if (__builtin_expect(!!(!(txn->mt_owner == 0)), 0)) mdbx_assert_fail(env, "txn->mt_owner == 0", __func__, 7753); } while (0); } while (0);
      do { if ((0)) do { if (__builtin_expect(!!(!(txn->mt_numdbs == 0)), 0)) mdbx_assert_fail(env, "txn->mt_numdbs == 0", __func__, 7754); } while (0); } while (0);
      if (__builtin_expect(!!(r), 1)) {
        do { if ((0)) do { if (__builtin_expect(!!(!(r->mr_snapshot_pages_used.weak == 0)), 0)) mdbx_assert_fail(env, "r->mr_snapshot_pages_used.weak == 0", __func__, 7756); } while (0); } while (0);
        do { if ((0)) do { if (__builtin_expect(!!(!(r->mr_txnid.weak >= 0xffffFFFF00000000UL)), 0)) mdbx_assert_fail(env, "r->mr_txnid.weak >= 0xffffFFFF00000000UL", __func__, 7757); } while (0); } while (0);
        atomic_store32(&r->mr_snapshot_pages_used, 0, mo_Relaxed);
      }
      txn->mt_flags = MDBX_TXN_RDONLY | 0x01;
      return MDBX_SUCCESS;
    }


    if (__builtin_expect(!!(env->me_stuck_meta < 0), 1)) {
      uint64_t timestamp = 0;
      while (1) {
        volatile const MDBX_meta *const meta = meta_prefer_last(env);
        mdbx_jitter4testing((0));
        const txnid_t snap = meta_txnid(env, meta);
        mdbx_jitter4testing((0));
        if (__builtin_expect(!!(r), 1)) {
          safe64_reset(&r->mr_txnid, (0));
          atomic_store32(&r->mr_snapshot_pages_used, meta->mm_geo.next,
                         mo_Relaxed);
          atomic_store64(&r->mr_snapshot_pages_retired,
                         unaligned_peek_u64_volatile(4, meta->mm_pages_retired),
                         mo_Relaxed);
          safe64_write(&r->mr_txnid, snap);
          mdbx_jitter4testing((0));
          do { if ((0)) do { if (__builtin_expect(!!(!(r->mr_pid.weak == mdbx_getpid())), 0)) mdbx_assert_fail(env, "r->mr_pid.weak == mdbx_getpid()", __func__, 7781); } while (0); } while (0);
          do { if ((0)) do { if (__builtin_expect(!!(!(r->mr_tid.weak == ((env->me_flags & MDBX_NOTLS) ? 0 : mdbx_thread_self()))), 0)) mdbx_assert_fail(env, "r->mr_tid.weak == ((env->me_flags & MDBX_NOTLS) ? 0 : mdbx_thread_self())", __func__, 7782); } while (0); } while (0)

                                                                               ;
          do { if ((0)) do { if (__builtin_expect(!!(!(r->mr_txnid.weak == snap)), 0)) mdbx_assert_fail(env, "r->mr_txnid.weak == snap", __func__, 7785); } while (0); } while (0);
          atomic_store32(&env->me_lck->mti_readers_refresh_flag, (1),
                         mo_AcquireRelease);
        } else {

        }
        mdbx_jitter4testing((1));


        txn->mt_txnid = snap;
        txn->mt_geo = meta->mm_geo;
        _Static_assert(2 == 2, "CORE_DBS == 2");
        txn->mt_dbs[0] = meta->mm_dbs[0];
        txn->mt_dbs[1] = meta->mm_dbs[1];
        txn->mt_canary = meta->mm_canary;





        mdbx_compiler_barrier();
        if (__builtin_expect(!!(meta == meta_prefer_last(env) && snap == meta_txnid(env, meta) && snap >= atomic_load64(&env->me_lck->mti_oldest_reader, mo_AcquireRelease)), 1)


                                                            ) {

          rc = meta_waittxnid(env, (const MDBX_meta *)meta, &timestamp);
          mdbx_jitter4testing((0));
          if (__builtin_expect(!!(rc == MDBX_SUCCESS), 1))
            break;
          if (__builtin_expect(!!(rc == MDBX_RESULT_TRUE), 1))
            continue;
          goto bailout;
        }
      }
    } else {

      MDBX_meta *const meta = page_meta(pgno2page(env, env->me_stuck_meta));
      txn->mt_txnid = constmeta_txnid(env, meta);
      txn->mt_geo = meta->mm_geo;
      memcpy(txn->mt_dbs, meta->mm_dbs, 2 * sizeof(MDBX_db));
      txn->mt_canary = meta->mm_canary;
      if (__builtin_expect(!!(r), 1)) {
        atomic_store32(&r->mr_snapshot_pages_used, meta->mm_geo.next,
                       mo_Relaxed);
        atomic_store64(&r->mr_snapshot_pages_retired,
                       unaligned_peek_u64(4, meta->mm_pages_retired),
                       mo_Relaxed);
        atomic_store64(&r->mr_txnid, txn->mt_txnid, mo_Relaxed);
        mdbx_jitter4testing((0));
        do { if ((0)) do { if (__builtin_expect(!!(!(r->mr_pid.weak == mdbx_getpid())), 0)) mdbx_assert_fail(env, "r->mr_pid.weak == mdbx_getpid()", __func__, 7835); } while (0); } while (0);
        do { if ((0)) do { if (__builtin_expect(!!(!(r->mr_tid.weak == ((env->me_flags & MDBX_NOTLS) ? 0 : mdbx_thread_self()))), 0)) mdbx_assert_fail(env, "r->mr_tid.weak == ((env->me_flags & MDBX_NOTLS) ? 0 : mdbx_thread_self())", __func__, 7836); } while (0); } while (0)

                                                                             ;
        do { if ((0)) do { if (__builtin_expect(!!(!(r->mr_txnid.weak == txn->mt_txnid)), 0)) mdbx_assert_fail(env, "r->mr_txnid.weak == txn->mt_txnid", __func__, 7839); } while (0); } while (0);
        atomic_store32(&env->me_lck->mti_readers_refresh_flag, (1),
                       mo_Relaxed);
      }
    }

    if (__builtin_expect(!!(txn->mt_txnid < 1UL || txn->mt_txnid > (0xffffFFFF00000000UL - 1)), 0)) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 7846, "%s" "\n", "environment corrupted by died writer, must shutdown!"); } while (0);
      rc = MDBX_CORRUPTED;
      goto bailout;
    }
    do { if ((0)) do { if (__builtin_expect(!!(!(txn->mt_txnid >= env->me_lck->mti_oldest_reader.weak)), 0)) mdbx_assert_fail(env, "txn->mt_txnid >= env->me_lck->mti_oldest_reader.weak", __func__, 7850); } while (0); } while (0);
    txn->mt_dbxs = env->me_dbxs;
    do { if (__builtin_expect(!!(!(txn->mt_txnid >= env->me_lck ->mti_oldest_reader.weak)), 0)) mdbx_assert_fail(env, "txn->mt_txnid >= env->me_lck ->mti_oldest_reader.weak", __func__, 7852); } while (0)

                                                      ;
    txn->mt_numdbs = env->me_numdbs;
  } else {
    do { if ((0)) do { if (__builtin_expect(!!(!((flags & ~((MDBX_TXN_NOMETASYNC | MDBX_TXN_NOSYNC | MDBX_TXN_TRY) | 0x08 | MDBX_WRITEMAP)) == 0)), 0)) mdbx_assert_fail(env, "(flags & ~((MDBX_TXN_NOMETASYNC | MDBX_TXN_NOSYNC | MDBX_TXN_TRY) | 0x08 | MDBX_WRITEMAP)) == 0", __func__, 7857); } while (0); } while (0)
                                                     ;
    if (__builtin_expect(!!(txn->mt_owner == tid || env->me_stuck_meta >= 0), 0)
                                                                 )
      return MDBX_BUSY;
    MDBX_lockinfo *const lck = env->me_lck_mmap.lck;
    if (lck && (env->me_flags & MDBX_NOTLS) == 0 &&
        (mdbx_runtime_flags & MDBX_DBG_LEGACY_OVERLAP) == 0) {
      const unsigned snap_nreaders =
          atomic_load32(&lck->mti_numreaders, mo_AcquireRelease);
      for (unsigned i = 0; i < snap_nreaders; ++i) {
        if (atomic_load32(&lck->mti_readers[i].mr_pid, mo_Relaxed) ==
                env->me_pid &&
            __builtin_expect(!!(atomic_load64(&lck->mti_readers[i].mr_tid, mo_Relaxed) == tid), 0)
                         ) {
          const txnid_t txnid = safe64_read(&lck->mti_readers[i].mr_txnid);
          if (txnid >= 1UL && txnid <= (0xffffFFFF00000000UL - 1))
            return MDBX_TXN_OVERLAPPING;
        }
      }
    }


    mdbx_jitter4testing((0));
    rc = mdbx_txn_lock(env, (((flags) & (MDBX_TXN_TRY)) == (MDBX_TXN_TRY)));
    if (__builtin_expect(!!(rc), 0))
      return rc;
    if (__builtin_expect(!!(env->me_flags & 0x80000000U), 0)) {
      mdbx_txn_unlock(env);
      return MDBX_PANIC;
    }







    mdbx_jitter4testing((0));
    const MDBX_meta *meta = constmeta_prefer_last(env);
    uint64_t timestamp = 0;
    while ("workaround for https://github.com/erthink/libmdbx/issues/269") {
      rc = meta_waittxnid(env, (const MDBX_meta *)meta, &timestamp);
      if (__builtin_expect(!!(rc == MDBX_SUCCESS), 1))
        break;
      if (__builtin_expect(!!(rc != MDBX_RESULT_TRUE), 0))
        goto bailout;
    }
    mdbx_jitter4testing((0));
    txn->mt_canary = meta->mm_canary;
    const txnid_t snap = constmeta_txnid(env, meta);
    txn->mt_txnid = safe64_txnid_next(snap);
    if (__builtin_expect(!!(txn->mt_txnid > (0xffffFFFF00000000UL - 1)), 0)) {
      rc = MDBX_TXN_FULL;
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 7911, "txnid overflow, raise %d" "\n", rc); } while (0);
      goto bailout;
    }

    txn->mt_flags = flags;
    txn->mt_child = 
# 7916 "/libmdbx/src/core.c" 3 4
                   ((void *)0)
# 7916 "/libmdbx/src/core.c"
                       ;
    txn->tw.loose_pages = 
# 7917 "/libmdbx/src/core.c" 3 4
                         ((void *)0)
# 7917 "/libmdbx/src/core.c"
                             ;
    txn->tw.loose_count = 0;

    txn->tw.loose_refund_wl = 0;

    ((txn->tw.retired_pages)[0]) = 0;
    txn->tw.spill_pages = 
# 7923 "/libmdbx/src/core.c" 3 4
                         ((void *)0)
# 7923 "/libmdbx/src/core.c"
                             ;
    txn->tw.spill_least_removed = 0;
    txn->tw.last_reclaimed = 0;
    if (txn->tw.lifo_reclaimed)
      ((txn->tw.lifo_reclaimed)[0]) = 0;
    env->me_txn = txn;
    txn->mt_numdbs = env->me_numdbs;
    memcpy(txn->mt_dbiseqs, env->me_dbiseqs, txn->mt_numdbs * sizeof(unsigned));

    memcpy(txn->mt_dbs, meta->mm_dbs, 2 * sizeof(MDBX_db));

    txn->mt_geo = meta->mm_geo;

    rc = mdbx_dpl_alloc(txn);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      goto bailout;
    txn->tw.dirtyroom = txn->mt_env->me_options.dp_limit;
    txn->tw.dirtylru = 0 ? ~42u : 0;
  }


  mdbx_compiler_barrier();
  memset(txn->mt_cursors, 0, sizeof(MDBX_cursor *) * txn->mt_numdbs);
  for (unsigned i = 2; i < txn->mt_numdbs; i++) {
    const unsigned db_flags = env->me_dbflags[i];
    txn->mt_dbs[i].md_flags = db_flags & (MDBX_REVERSEKEY | MDBX_DUPSORT | MDBX_INTEGERKEY | MDBX_DUPFIXED | MDBX_INTEGERDUP | MDBX_REVERSEDUP);
    txn->mt_dbistate[i] =
        (db_flags & 0x8000) ? 0x10 | 0x20 | MDBX_DBI_STALE : 0;
  }
  txn->mt_dbistate[1] = 0x10 | 0x20;
  txn->mt_dbistate[0] = 0x10;
  txn->mt_front =
      txn->mt_txnid + ((flags & (MDBX_WRITEMAP | MDBX_RDONLY)) == 0);

  if (__builtin_expect(!!(env->me_flags & 0x80000000U), 0)) {
    do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 7958, "%s" "\n", "environment had fatal error, must shutdown!"); } while (0);
    rc = MDBX_PANIC;
  } else {
    const size_t size =
        pgno2bytes(env, (txn->mt_flags & MDBX_TXN_RDONLY) ? txn->mt_geo.next
                                                          : txn->mt_geo.now);
    if (__builtin_expect(!!(size > env->me_dxb_mmap.limit), 0)) {
      if (txn->mt_geo.upper > 0x7FFFffffU + 1 ||
          bytes2pgno(env, pgno2bytes(env, txn->mt_geo.upper)) !=
              txn->mt_geo.upper) {
        rc = MDBX_UNABLE_EXTEND_MAPSIZE;
        goto bailout;
      }
      rc = mdbx_mapresize(env, txn->mt_geo.next, txn->mt_geo.now,
                          txn->mt_geo.upper,
                          (txn->mt_flags & MDBX_TXN_RDONLY) ? (1) : (0));
      if (rc != MDBX_SUCCESS)
        goto bailout;
    }
    if (txn->mt_flags & MDBX_TXN_RDONLY) {
# 7990 "/libmdbx/src/core.c"
    } else {
      env->me_dxb_mmap.current = size;
      env->me_dxb_mmap.filesize =
          (env->me_dxb_mmap.filesize < size) ? size : env->me_dxb_mmap.filesize;
    }



    txn->mt_owner = tid;
    return MDBX_SUCCESS;
  }
bailout:
  do { if ((0)) do { if (__builtin_expect(!!(!(rc != MDBX_SUCCESS)), 0)) mdbx_assert_fail((txn)->mt_env, "rc != MDBX_SUCCESS", __func__, 8002); } while (0); } while (0);
  mdbx_txn_end(txn, 0x80 | MDBX_END_FAIL_BEGIN);
  return rc;
}

static 
# 8007 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 8007 "/libmdbx/src/core.c"
                      int check_txn(const MDBX_txn *txn, int bad_bits) {
  if (__builtin_expect(!!(!txn), 0))
    return MDBX_EINVAL;

  if (__builtin_expect(!!(txn->mt_signature != 0x93D53A31U), 0))
    return MDBX_EBADSIGN;

  if (__builtin_expect(!!(txn->mt_flags & bad_bits), 0))
    return MDBX_BAD_TXN;


  if ((txn->mt_flags & MDBX_NOTLS) == 0 &&
      __builtin_expect(!!(txn->mt_owner != mdbx_thread_self()), 0))
    return txn->mt_owner ? MDBX_THREAD_MISMATCH : MDBX_BAD_TXN;


  if (__builtin_expect(!!(!txn->mt_env->me_dxb_mmap.dxb), 0))
    return MDBX_EPERM;

  return MDBX_SUCCESS;
}

static 
# 8029 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 8029 "/libmdbx/src/core.c"
                      int check_txn_rw(const MDBX_txn *txn, int bad_bits) {
  int err = check_txn(txn, bad_bits);
  if (__builtin_expect(!!(err), 0))
    return err;

  if (__builtin_expect(!!((((txn->mt_flags) & (MDBX_TXN_RDONLY)) == (MDBX_TXN_RDONLY))), 0))
    return MDBX_EACCESS;

  return MDBX_SUCCESS;
}

int mdbx_txn_renew(MDBX_txn *txn) {
  if (__builtin_expect(!!(!txn), 0))
    return MDBX_EINVAL;

  if (__builtin_expect(!!(txn->mt_signature != 0x93D53A31U), 0))
    return MDBX_EBADSIGN;

  if (__builtin_expect(!!((txn->mt_flags & MDBX_TXN_RDONLY) == 0), 0))
    return MDBX_EINVAL;

  int rc;
  if (__builtin_expect(!!(txn->mt_owner != 0 || !(txn->mt_flags & 0x01)), 0)) {
    rc = mdbx_txn_reset(txn);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      return rc;
  }

  rc = mdbx_txn_renew0(txn, MDBX_TXN_RDONLY);
  if (rc == MDBX_SUCCESS) {
    txn->mt_owner = mdbx_thread_self();
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 8060, "renew txn %" 
# 8060 "/libmdbx/src/core.c" 3 4
   "l" "i" 
# 8060 "/libmdbx/src/core.c"
   "%c %p on env %p, root page %" 
# 8060 "/libmdbx/src/core.c" 3 4
   "u" 
# 8060 "/libmdbx/src/core.c"
   "/%" 
# 8060 "/libmdbx/src/core.c" 3 4
   "u" 
# 8060 "/libmdbx/src/core.c"
   "\n", txn->mt_txnid, (txn->mt_flags & MDBX_TXN_RDONLY) ? 'r' : 'w', (void *)txn, (void *)txn->mt_env, txn->mt_dbs[1].md_root, txn->mt_dbs[0].md_root); } while (0)



                                             ;
  }
  return rc;
}


int mdbx_txn_begin(MDBX_env *env, MDBX_txn *parent, MDBX_txn_flags_t flags,
                   MDBX_txn **ret) {
  return __inline_mdbx_txn_begin(env, parent, flags, ret);
}


int mdbx_txn_set_userctx(MDBX_txn *txn, void *ctx) {
  int rc = check_txn(txn, 0x01);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  txn->mt_userctx = ctx;
  return MDBX_SUCCESS;
}

void *mdbx_txn_get_userctx(const MDBX_txn *txn) {
  return check_txn(txn, 0x01) ? 
# 8086 "/libmdbx/src/core.c" 3 4
                                            ((void *)0) 
# 8086 "/libmdbx/src/core.c"
                                                    : txn->mt_userctx;
}

int mdbx_txn_begin_ex(MDBX_env *env, MDBX_txn *parent, MDBX_txn_flags_t flags,
                      MDBX_txn **ret, void *context) {
  MDBX_txn *txn;
  unsigned size, tsize;

  if (__builtin_expect(!!(!ret), 0))
    return MDBX_EINVAL;
  *ret = 
# 8096 "/libmdbx/src/core.c" 3 4
        ((void *)0)
# 8096 "/libmdbx/src/core.c"
            ;

  if (__builtin_expect(!!((flags & ~(MDBX_TXN_NOMETASYNC | MDBX_TXN_NOSYNC | MDBX_TXN_TRY)) && (flags & ~(MDBX_TXN_RDONLY | MDBX_TXN_RDONLY_PREPARE))), 0)
                                                  )
    return MDBX_EINVAL;

  int rc = check_env(env, (1));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(env->me_flags & MDBX_RDONLY & ~flags), 0)
                      )
    return MDBX_EACCESS;

  flags |= env->me_flags & MDBX_WRITEMAP;

  if (parent) {

    rc = check_txn_rw(parent,
                      MDBX_TXN_RDONLY | MDBX_WRITEMAP | (0x01 | 0x02 | 0x10));
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      return rc;

    if (env->me_options.spill_parent4child_denominator) {

      rc = mdbx_txn_spill(parent, 
# 8121 "/libmdbx/src/core.c" 3 4
                                 ((void *)0)
# 8121 "/libmdbx/src/core.c"
                                        ,
                          parent->tw.dirtylist->length /
                              env->me_options.spill_parent4child_denominator);
      if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
        return rc;
    }
    do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_audit_ex(parent, 0, (0)) == 0)), 0)) mdbx_assert_fail((parent)->mt_env, "mdbx_audit_ex(parent, 0, (0)) == 0", __func__, 8127); } while (0); } while (0);

    flags |= parent->mt_flags & ((MDBX_TXN_NOMETASYNC | MDBX_TXN_NOSYNC | MDBX_TXN_TRY) | 0x08);
  } else if (flags & MDBX_TXN_RDONLY) {
    if (env->me_txn0 &&
        __builtin_expect(!!(env->me_txn0->mt_owner == mdbx_thread_self()), 0) &&
        (mdbx_runtime_flags & MDBX_DBG_LEGACY_OVERLAP) == 0)
      return MDBX_TXN_OVERLAPPING;
  } else {


    txn = env->me_txn0;
    goto renew;
  }

  size = env->me_maxdbs * (sizeof(MDBX_db) + sizeof(MDBX_cursor *) + 1);
  size += tsize = sizeof(MDBX_txn);
  if (__builtin_expect(!!((txn = malloc(size)) == 
# 8144 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 8144 "/libmdbx/src/core.c"
     ), 0)) {
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 8145, "calloc: %s" "\n", "failed"); } while (0);
    return MDBX_ENOMEM;
  }




  memset(txn, 0, tsize);
  txn->mt_dbxs = env->me_dbxs;
  txn->mt_dbs = (MDBX_db *)((char *)txn + tsize);
  txn->mt_cursors = (MDBX_cursor **)(txn->mt_dbs + env->me_maxdbs);
  txn->mt_dbistate = (uint8_t *)txn + size - env->me_maxdbs;
  txn->mt_flags = flags;
  txn->mt_env = env;

  if (parent) {
    do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_dirtylist_check(parent))), 0)) mdbx_assert_fail((parent)->mt_env, "mdbx_dirtylist_check(parent)", __func__, 8161); } while (0); } while (0);
    txn->mt_dbiseqs = parent->mt_dbiseqs;
    txn->mt_geo = parent->mt_geo;
    rc = mdbx_dpl_alloc(txn);
    if (__builtin_expect(!!(rc == MDBX_SUCCESS), 1)) {
      const unsigned len =
          ((parent->tw.reclaimed_pglist)[0]) + parent->tw.loose_count;
      txn->tw.reclaimed_pglist =
          mdbx_pnl_alloc((len > (1024 - 2 - (8 * 2u) / sizeof(pgno_t))) ? len : (1024 - 2 - (8 * 2u) / sizeof(pgno_t)));
      if (__builtin_expect(!!(!txn->tw.reclaimed_pglist), 0))
        rc = MDBX_ENOMEM;
    }
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0)) {
    nested_failed:
      mdbx_pnl_free(txn->tw.reclaimed_pglist);
      mdbx_dpl_free(txn);
      free(txn);
      return rc;
    }


    if (parent->tw.loose_count) {
      do {
        MDBX_page *lp = parent->tw.loose_pages;
        const unsigned di = mdbx_dpl_exist(parent, lp->mp_pgno);
        do { if ((0)) do { if (__builtin_expect(!!(!(di && parent->tw.dirtylist->items[di].ptr == lp)), 0)) mdbx_assert_fail((parent)->mt_env, "di && parent->tw.dirtylist->items[di].ptr == lp", __func__, 8186); } while (0); } while (0);
        do { if ((0)) do { if (__builtin_expect(!!(!(lp->mp_flags == 0x4000)), 0)) mdbx_assert_fail((parent)->mt_env, "lp->mp_flags == 0x4000", __func__, 8187); } while (0); } while (0);
        rc =
            mdbx_pnl_insert_range(&parent->tw.reclaimed_pglist, lp->mp_pgno, 1);
        if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
          goto nested_failed;
        parent->tw.loose_pages = lp->mp_next;

        mdbx_page_wash(parent, di, lp, 1);
      } while (parent->tw.loose_pages);
      parent->tw.loose_count = 0;

      parent->tw.loose_refund_wl = 0;

      do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_dirtylist_check(parent))), 0)) mdbx_assert_fail((parent)->mt_env, "mdbx_dirtylist_check(parent)", __func__, 8200); } while (0); } while (0);
    }
    txn->tw.dirtyroom = parent->tw.dirtyroom;
    txn->tw.dirtylru = parent->tw.dirtylru;

    mdbx_dpl_sort(parent);
    if (parent->tw.spill_pages)
      mdbx_spill_purge(parent);

    do { if ((0)) do { if (__builtin_expect(!!(!(((txn->tw.reclaimed_pglist)[-1]) >= ((parent->tw.reclaimed_pglist)[0]))), 0)) mdbx_assert_fail((txn)->mt_env, "((txn->tw.reclaimed_pglist)[-1]) >= ((parent->tw.reclaimed_pglist)[0])", __func__, 8209); } while (0); } while (0)
                                                                     ;
    memcpy(txn->tw.reclaimed_pglist, parent->tw.reclaimed_pglist,
           ((((parent->tw.reclaimed_pglist)[0]) + 1) * sizeof(pgno_t)));
    do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_pnl_check4assert( txn->tw.reclaimed_pglist, (txn->mt_geo.next = parent->mt_geo.next) - 1))), 0)) mdbx_assert_fail(env, "mdbx_pnl_check4assert( txn->tw.reclaimed_pglist, (txn->mt_geo.next = parent->mt_geo.next) - 1)", __func__, 8213); } while (0); } while (0)




                                                 ;

    txn->tw.last_reclaimed = parent->tw.last_reclaimed;
    if (parent->tw.lifo_reclaimed) {
      txn->tw.lifo_reclaimed = parent->tw.lifo_reclaimed;
      parent->tw.lifo_reclaimed =
          (void *)(intptr_t)((parent->tw.lifo_reclaimed)[0]);
    }

    txn->tw.retired_pages = parent->tw.retired_pages;
    parent->tw.retired_pages =
        (void *)(intptr_t)((parent->tw.retired_pages)[0]);

    txn->mt_txnid = parent->mt_txnid;
    txn->mt_front = parent->mt_front + 1;

    txn->tw.loose_refund_wl = 0;

    txn->mt_canary = parent->mt_canary;
    parent->mt_flags |= 0x10;
    parent->mt_child = txn;
    txn->mt_parent = parent;
    txn->mt_numdbs = parent->mt_numdbs;
    txn->mt_owner = parent->mt_owner;
    memcpy(txn->mt_dbs, parent->mt_dbs, txn->mt_numdbs * sizeof(MDBX_db));

    for (unsigned i = 0; i < txn->mt_numdbs; i++)
      txn->mt_dbistate[i] =
          parent->mt_dbistate[i] & ~(MDBX_DBI_FRESH | MDBX_DBI_CREAT | MDBX_DBI_DIRTY);
    do { if ((0)) do { if (__builtin_expect(!!(!(parent->tw.dirtyroom + parent->tw.dirtylist->length == (parent->mt_parent ? parent->mt_parent->tw.dirtyroom : parent->mt_env->me_options.dp_limit))), 0)) mdbx_assert_fail((parent)->mt_env, "parent->tw.dirtyroom + parent->tw.dirtylist->length == (parent->mt_parent ? parent->mt_parent->tw.dirtyroom : parent->mt_env->me_options.dp_limit)", __func__, 8247); } while (0); } while (0)


                                                                               ;
    do { if ((0)) do { if (__builtin_expect(!!(!(txn->tw.dirtyroom + txn->tw.dirtylist->length == (txn->mt_parent ? txn->mt_parent->tw.dirtyroom : txn->mt_env->me_options.dp_limit))), 0)) mdbx_assert_fail((txn)->mt_env, "txn->tw.dirtyroom + txn->tw.dirtylist->length == (txn->mt_parent ? txn->mt_parent->tw.dirtyroom : txn->mt_env->me_options.dp_limit)", __func__, 8251); } while (0); } while (0)

                                                                              ;
    env->me_txn = txn;
    rc = mdbx_cursor_shadow(parent, txn);
    if ((0) && (0)) {
      txn->mt_signature = 0x93D53A31U;
      do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_audit_ex(txn, 0, (0)) == 0)), 0)) mdbx_assert_fail((txn)->mt_env, "mdbx_audit_ex(txn, 0, (0)) == 0", __func__, 8258); } while (0); } while (0);
    }
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      mdbx_txn_end(txn, MDBX_END_FAIL_BEGINCHILD);
  } else {
    txn->mt_dbiseqs = env->me_dbiseqs;
  renew:
    rc = mdbx_txn_renew0(txn, flags);
  }

  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0)) {
    if (txn != env->me_txn0)
      free(txn);
  } else {
    if (flags & (MDBX_TXN_RDONLY_PREPARE - MDBX_TXN_RDONLY))
      do { if ((0)) do { if (__builtin_expect(!!(!(txn->mt_flags == (MDBX_TXN_RDONLY | 0x01))), 0)) mdbx_assert_fail(env, "txn->mt_flags == (MDBX_TXN_RDONLY | 0x01)", __func__, 8273); } while (0); } while (0);
    else if (flags & MDBX_TXN_RDONLY)
      do { if ((0)) do { if (__builtin_expect(!!(!((txn->mt_flags & ~(MDBX_NOTLS | MDBX_TXN_RDONLY | MDBX_WRITEMAP | 0x40000000U)) == 0)), 0)) mdbx_assert_fail(env, "(txn->mt_flags & ~(MDBX_NOTLS | MDBX_TXN_RDONLY | MDBX_WRITEMAP | 0x40000000U)) == 0", __func__, 8275); } while (0); } while (0)

                                                                            ;
    else {
      do { if ((0)) do { if (__builtin_expect(!!(!((txn->mt_flags & ~(MDBX_WRITEMAP | 0x40000000U | MDBX_NOMETASYNC | MDBX_SAFE_NOSYNC | 0x08)) == 0)), 0)) mdbx_assert_fail(env, "(txn->mt_flags & ~(MDBX_WRITEMAP | 0x40000000U | MDBX_NOMETASYNC | MDBX_SAFE_NOSYNC | 0x08)) == 0", __func__, 8279); } while (0); } while (0)

                                                                 ;
      do { if ((0)) do { if (__builtin_expect(!!(!(!txn->tw.spill_pages && !txn->tw.spill_least_removed)), 0)) mdbx_assert_fail(
# 8282 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 8282 "/libmdbx/src/core.c"
     , "!txn->tw.spill_pages && !txn->tw.spill_least_removed", __func__, 8282); } while (0); } while (0);
    }
    txn->mt_signature = 0x93D53A31U;
    txn->mt_userctx = context;
    *ret = txn;
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 8287, "begin txn %" 
# 8287 "/libmdbx/src/core.c" 3 4
   "l" "i" 
# 8287 "/libmdbx/src/core.c"
   "%c %p on env %p, root page %" 
# 8287 "/libmdbx/src/core.c" 3 4
   "u" 
# 8287 "/libmdbx/src/core.c"
   "/%" 
# 8287 "/libmdbx/src/core.c" 3 4
   "u" 
# 8287 "/libmdbx/src/core.c"
   "\n", txn->mt_txnid, (flags & MDBX_TXN_RDONLY) ? 'r' : 'w', (void *)txn, (void *)env, txn->mt_dbs[1].md_root, txn->mt_dbs[0].md_root); } while (0)



                                             ;
  }

  return rc;
}

int mdbx_txn_info(const MDBX_txn *txn, MDBX_txn_info *info, _Bool scan_rlt) {
  int rc = check_txn(txn, 0x01);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(!info), 0))
    return MDBX_EINVAL;

  MDBX_env *const env = txn->mt_env;







  info->txn_id = txn->mt_txnid;
  info->txn_space_used = pgno2bytes(env, txn->mt_geo.next);

  if (txn->mt_flags & MDBX_TXN_RDONLY) {
    volatile const MDBX_meta *head_meta;
    txnid_t head_txnid;
    uint64_t head_retired;
    do {

      head_meta = meta_prefer_last(env);
      head_txnid = meta_txnid(env, head_meta);
      head_retired =
          unaligned_peek_u64_volatile(4, head_meta->mm_pages_retired);
      info->txn_space_limit_soft = pgno2bytes(env, head_meta->mm_geo.now);
      info->txn_space_limit_hard = pgno2bytes(env, head_meta->mm_geo.upper);
      info->txn_space_leftover =
          pgno2bytes(env, head_meta->mm_geo.now - head_meta->mm_geo.next);
      mdbx_compiler_barrier();
    } while (__builtin_expect(!!(head_meta != meta_prefer_last(env) || head_txnid != meta_txnid(env, head_meta)), 0)
                                                               );

    info->txn_reader_lag = head_txnid - info->txn_id;
    info->txn_space_dirty = info->txn_space_retired = 0;
    uint64_t reader_snapshot_pages_retired;
    if (txn->to.reader &&
        head_retired >
            (reader_snapshot_pages_retired = atomic_load64(
                 &txn->to.reader->mr_snapshot_pages_retired, mo_Relaxed))) {
      info->txn_space_dirty = info->txn_space_retired = pgno2bytes(
          env, (pgno_t)(head_retired - reader_snapshot_pages_retired));

      size_t retired_next_reader = 0;
      MDBX_lockinfo *const lck = env->me_lck_mmap.lck;
      if (scan_rlt && info->txn_reader_lag > 1 && lck) {

        txnid_t next_reader = head_txnid;
        const unsigned snap_nreaders =
            atomic_load32(&lck->mti_numreaders, mo_AcquireRelease);
        for (unsigned i = 0; i < snap_nreaders; ++i) {
        retry:
          if (atomic_load32(&lck->mti_readers[i].mr_pid, mo_AcquireRelease)) {
            mdbx_jitter4testing((1));
            const txnid_t snap_txnid =
                safe64_read(&lck->mti_readers[i].mr_txnid);
            const uint64_t snap_retired =
                atomic_load64(&lck->mti_readers[i].mr_snapshot_pages_retired,
                              mo_AcquireRelease);
            if (__builtin_expect(!!(snap_retired != atomic_load64( &lck->mti_readers[i].mr_snapshot_pages_retired, mo_Relaxed)), 0)


                                          ||
                snap_txnid != safe64_read(&lck->mti_readers[i].mr_txnid))
              goto retry;
            if (snap_txnid <= txn->mt_txnid) {
              retired_next_reader = 0;
              break;
            }
            if (snap_txnid < next_reader) {
              next_reader = snap_txnid;
              retired_next_reader = pgno2bytes(
                  env, (pgno_t)(snap_retired -
                                atomic_load64(
                                    &txn->to.reader->mr_snapshot_pages_retired,
                                    mo_Relaxed)));
            }
          }
        }
      }
      info->txn_space_dirty = retired_next_reader;
    }
  } else {
    info->txn_space_limit_soft = pgno2bytes(env, txn->mt_geo.now);
    info->txn_space_limit_hard = pgno2bytes(env, txn->mt_geo.upper);
    info->txn_space_retired = pgno2bytes(
        env, txn->mt_child ? (unsigned)(uintptr_t)txn->tw.retired_pages
                           : ((txn->tw.retired_pages)[0]));
    info->txn_space_leftover = pgno2bytes(env, txn->tw.dirtyroom);
    info->txn_space_dirty =
        pgno2bytes(env, txn->mt_env->me_options.dp_limit - txn->tw.dirtyroom);
    info->txn_reader_lag = 
# 8392 "/libmdbx/src/core.c" 3 4
                          (9223372036854775807L)
# 8392 "/libmdbx/src/core.c"
                                   ;
    MDBX_lockinfo *const lck = env->me_lck_mmap.lck;
    if (scan_rlt && lck) {
      txnid_t oldest_snapshot = txn->mt_txnid;
      const unsigned snap_nreaders =
          atomic_load32(&lck->mti_numreaders, mo_AcquireRelease);
      if (snap_nreaders) {
        oldest_snapshot = mdbx_find_oldest(txn);
        if (oldest_snapshot == txn->mt_txnid - 1) {

          _Bool exists = (0);
          for (unsigned i = 0; i < snap_nreaders; ++i) {
            if (atomic_load32(&lck->mti_readers[i].mr_pid, mo_Relaxed) &&
                txn->mt_txnid > safe64_read(&lck->mti_readers[i].mr_txnid)) {
              exists = (1);
              break;
            }
          }
          oldest_snapshot += !exists;
        }
      }
      info->txn_reader_lag = txn->mt_txnid - oldest_snapshot;
    }
  }

  return MDBX_SUCCESS;
}

MDBX_env *mdbx_txn_env(const MDBX_txn *txn) {
  if (__builtin_expect(!!(!txn || txn->mt_signature != 0x93D53A31U || txn->mt_env->me_signature.weak != 0x9A899641U), 0)
                                                                   )
    return 
# 8423 "/libmdbx/src/core.c" 3 4
          ((void *)0)
# 8423 "/libmdbx/src/core.c"
              ;
  return txn->mt_env;
}

uint64_t mdbx_txn_id(const MDBX_txn *txn) {
  if (__builtin_expect(!!(!txn || txn->mt_signature != 0x93D53A31U), 0))
    return 0;
  return txn->mt_txnid;
}

int mdbx_txn_flags(const MDBX_txn *txn) {
  if (__builtin_expect(!!(!txn || txn->mt_signature != 0x93D53A31U), 0))
    return -1;
  return txn->mt_flags;
}





static void dbi_import_locked(MDBX_txn *txn) {
  MDBX_env *const env = txn->mt_env;
  const unsigned n = env->me_numdbs;
  for (unsigned i = 2; i < n; ++i) {
    if (i >= txn->mt_numdbs) {
      txn->mt_dbistate[i] = 0;
      txn->mt_cursors[i] = 
# 8449 "/libmdbx/src/core.c" 3 4
                          ((void *)0)
# 8449 "/libmdbx/src/core.c"
                              ;
    }
    if ((env->me_dbflags[i] & 0x8000) &&
        !(txn->mt_dbistate[i] & 0x20)) {
      txn->mt_dbiseqs[i] = env->me_dbiseqs[i];
      txn->mt_dbs[i].md_flags = env->me_dbflags[i] & (MDBX_REVERSEKEY | MDBX_DUPSORT | MDBX_INTEGERKEY | MDBX_DUPFIXED | MDBX_INTEGERDUP | MDBX_REVERSEDUP);
      txn->mt_dbistate[i] = 0x10 | 0x20 | MDBX_DBI_STALE;
      do { if ((0)) do { if (__builtin_expect(!!(!(txn->mt_dbxs[i].md_cmp != 
# 8456 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 8456 "/libmdbx/src/core.c"
     )), 0)) mdbx_assert_fail((txn)->mt_env, "txn->mt_dbxs[i].md_cmp != ((void *)0)", __func__, 8456); } while (0); } while (0);
      do { if ((0)) do { if (__builtin_expect(!!(!(txn->mt_dbxs[i].md_name.iov_base != 
# 8457 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 8457 "/libmdbx/src/core.c"
     )), 0)) mdbx_assert_fail((txn)->mt_env, "txn->mt_dbxs[i].md_name.iov_base != ((void *)0)", __func__, 8457); } while (0); } while (0);
    }
  }
  txn->mt_numdbs = n;
}


__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static _Bool dbi_import(MDBX_txn *txn, MDBX_dbi dbi) {
  if (dbi < 2 || dbi >= txn->mt_env->me_numdbs)
    return (0);

  do { if (__builtin_expect(!!(!(mdbx_fastmutex_acquire(&txn->mt_env->me_dbi_lock) == MDBX_SUCCESS)), 0)) mdbx_assert_fail(txn->mt_env, "mdbx_fastmutex_acquire(&txn->mt_env->me_dbi_lock) == MDBX_SUCCESS", __func__, 8468); } while (0)
                                            ;
  dbi_import_locked(txn);
  do { if (__builtin_expect(!!(!(mdbx_fastmutex_release(&txn->mt_env->me_dbi_lock) == MDBX_SUCCESS)), 0)) mdbx_assert_fail(txn->mt_env, "mdbx_fastmutex_release(&txn->mt_env->me_dbi_lock) == MDBX_SUCCESS", __func__, 8471); } while (0)
                                            ;
  return txn->mt_dbistate[dbi] & 0x20;
}


static void dbi_update(MDBX_txn *txn, int keep) {
  do { if ((0)) do { if (__builtin_expect(!!(!(!txn->mt_parent && txn == txn->mt_env->me_txn0)), 0)) mdbx_assert_fail((txn)->mt_env, "!txn->mt_parent && txn == txn->mt_env->me_txn0", __func__, 8478); } while (0); } while (0);
  MDBX_dbi n = txn->mt_numdbs;
  if (n) {
    _Bool locked = (0);
    MDBX_env *const env = txn->mt_env;

    for (unsigned i = n; --i >= 2;) {
      if (__builtin_expect(!!((txn->mt_dbistate[i] & MDBX_DBI_CREAT) == 0), 1))
        continue;
      if (!locked) {
        do { if (__builtin_expect(!!(!(mdbx_fastmutex_acquire(&env->me_dbi_lock) == MDBX_SUCCESS)), 0)) mdbx_assert_fail(env, "mdbx_fastmutex_acquire(&env->me_dbi_lock) == MDBX_SUCCESS", __func__, 8488); } while (0)
                                                                              ;
        locked = (1);
      }
      if (env->me_numdbs <= i || txn->mt_dbiseqs[i] != env->me_dbiseqs[i])
        continue ;
      if (keep) {
        env->me_dbflags[i] = txn->mt_dbs[i].md_flags | 0x8000;
      } else {
        char *ptr = env->me_dbxs[i].md_name.iov_base;
        if (ptr) {
          env->me_dbxs[i].md_name.iov_len = 0;
          mdbx_memory_fence(mo_AcquireRelease, (1));
          do { if ((0)) do { if (__builtin_expect(!!(!(env->me_dbflags[i] == 0)), 0)) mdbx_assert_fail(env, "env->me_dbflags[i] == 0", __func__, 8501); } while (0); } while (0);
          env->me_dbiseqs[i]++;
          env->me_dbxs[i].md_name.iov_base = 
# 8503 "/libmdbx/src/core.c" 3 4
                                            ((void *)0)
# 8503 "/libmdbx/src/core.c"
                                                ;
          free(ptr);
        }
      }
    }

    n = env->me_numdbs;
    if (n > 2 && __builtin_expect(!!(!(env->me_dbflags[n - 1] & 0x8000)), 0)) {
      if (!locked) {
        do { if (__builtin_expect(!!(!(mdbx_fastmutex_acquire(&env->me_dbi_lock) == MDBX_SUCCESS)), 0)) mdbx_assert_fail(env, "mdbx_fastmutex_acquire(&env->me_dbi_lock) == MDBX_SUCCESS", __func__, 8512); } while (0)
                                                                              ;
        locked = (1);
      }

      n = env->me_numdbs;
      while (n > 2 && !(env->me_dbflags[n - 1] & 0x8000))
        --n;
      env->me_numdbs = n;
    }

    if (__builtin_expect(!!(locked), 0))
      do { if (__builtin_expect(!!(!(mdbx_fastmutex_release(&env->me_dbi_lock) == MDBX_SUCCESS)), 0)) mdbx_assert_fail(env, "mdbx_fastmutex_release(&env->me_dbi_lock) == MDBX_SUCCESS", __func__, 8524); } while (0)
                                                                            ;
  }
}


static void mdbx_dpl_sift(MDBX_txn *const txn, MDBX_PNL pl,
                          const _Bool spilled) {
  if (((pl)[0]) && txn->tw.dirtylist->length) {
    do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_pnl_check4assert(pl, (size_t)txn->mt_geo.next << spilled))), 0)) mdbx_assert_fail((txn)->mt_env, "mdbx_pnl_check4assert(pl, (size_t)txn->mt_geo.next << spilled)", __func__, 8533); } while (0); } while (0)
                                                                             ;
    MDBX_dpl *dl = mdbx_dpl_sort(txn);


    const int step = 0 ? 1 : -1;
    const int begin = 0 ? 1 : ((pl)[0]);
    const int end = 0 ? ((pl)[0]) + 1 : 0;
    do { if ((0)) do { if (__builtin_expect(!!(!(pl[begin] <= pl[end - step])), 0)) mdbx_assert_fail((txn)->mt_env, "pl[begin] <= pl[end - step]", __func__, 8541); } while (0); } while (0);

    unsigned r = mdbx_dpl_search(txn, pl[begin] >> spilled);
    do { if ((0)) do { if (__builtin_expect(!!(!(dl->sorted == dl->length)), 0)) mdbx_assert_fail((txn)->mt_env, "dl->sorted == dl->length", __func__, 8544); } while (0); } while (0);
    for (int i = begin; r <= dl->length;) {
      do { if ((0)) do { if (__builtin_expect(!!(!(i != end)), 0)) mdbx_assert_fail(
# 8546 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 8546 "/libmdbx/src/core.c"
     , "i != end", __func__, 8546); } while (0); } while (0);
      do { if ((0)) do { if (__builtin_expect(!!(!(!spilled || (pl[i] & 1) == 0)), 0)) mdbx_assert_fail((txn)->mt_env, "!spilled || (pl[i] & 1) == 0", __func__, 8547); } while (0); } while (0);
      pgno_t pl_pgno = pl[i] >> spilled;
      pgno_t dp_pgno = dl->items[r].pgno;
      if (__builtin_expect(!!(dp_pgno != pl_pgno), 1)) {
        const _Bool cmp = dp_pgno < pl_pgno;
        r += cmp;
        i += cmp ? 0 : step;
        if (__builtin_expect(!!(i != end), 1))
          continue;
        return;
      }


      unsigned w = r;
    remove_dl:
      if ((txn->mt_env->me_flags & MDBX_WRITEMAP) == 0) {
        MDBX_page *dp = dl->items[r].ptr;
        mdbx_dpage_free(txn->mt_env, dp, dpl_npages(dl, r));
      }
      ++r;
    next_i:
      i += step;
      if (__builtin_expect(!!(i == end), 0)) {
        while (r <= dl->length)
          dl->items[w++] = dl->items[r++];
      } else {
        while (r <= dl->length) {
          do { if ((0)) do { if (__builtin_expect(!!(!(i != end)), 0)) mdbx_assert_fail(
# 8574 "/libmdbx/src/core.c" 3 4
         ((void *)0)
# 8574 "/libmdbx/src/core.c"
         , "i != end", __func__, 8574); } while (0); } while (0);
          do { if ((0)) do { if (__builtin_expect(!!(!(!spilled || (pl[i] & 1) == 0)), 0)) mdbx_assert_fail((txn)->mt_env, "!spilled || (pl[i] & 1) == 0", __func__, 8575); } while (0); } while (0);
          pl_pgno = pl[i] >> spilled;
          dp_pgno = dl->items[r].pgno;
          if (dp_pgno < pl_pgno)
            dl->items[w++] = dl->items[r++];
          else if (dp_pgno > pl_pgno)
            goto next_i;
          else
            goto remove_dl;
        }
      }
      dl->sorted = dpl_setlen(dl, w - 1);
      txn->tw.dirtyroom += r - w;
      do { if ((0)) do { if (__builtin_expect(!!(!(txn->tw.dirtyroom + txn->tw.dirtylist->length == (txn->mt_parent ? txn->mt_parent->tw.dirtyroom : txn->mt_env->me_options.dp_limit))), 0)) mdbx_assert_fail((txn)->mt_env, "txn->tw.dirtyroom + txn->tw.dirtylist->length == (txn->mt_parent ? txn->mt_parent->tw.dirtyroom : txn->mt_env->me_options.dp_limit)", __func__, 8588); } while (0); } while (0)


                                                                           ;
      return;
    }
  }
}





static int mdbx_txn_end(MDBX_txn *txn, const unsigned mode) {
  MDBX_env *env = txn->mt_env;
  static const char *const names[] = { "committed", "empty-commit", "abort", "reset", "reset-tmp", "fail-begin", "fail-beginchild" };
# 8612 "/libmdbx/src/core.c"
  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 8612, "%s txn %" 
# 8612 "/libmdbx/src/core.c" 3 4
 "l" "i" 
# 8612 "/libmdbx/src/core.c"
 "%c %p on mdbenv %p, root page %" 
# 8612 "/libmdbx/src/core.c" 3 4
 "u" 
# 8612 "/libmdbx/src/core.c"
 "/%" 
# 8612 "/libmdbx/src/core.c" 3 4
 "u" 
# 8612 "/libmdbx/src/core.c"
 "\n", names[mode & 0x0F], txn->mt_txnid, (txn->mt_flags & MDBX_TXN_RDONLY) ? 'r' : 'w', (void *)txn, (void *)env, txn->mt_dbs[1].md_root, txn->mt_dbs[0].md_root); } while (0)




                                           ;

  do { if (__builtin_expect(!!(!(txn->mt_txnid >= env->me_lck ->mti_oldest_reader.weak)), 0)) mdbx_assert_fail(env, "txn->mt_txnid >= env->me_lck ->mti_oldest_reader.weak", __func__, 8619); } while (0)

                                                    ;

  if (!(mode & 0x40))
    mdbx_cursors_eot(txn, (0));

  int rc = MDBX_SUCCESS;
  if ((((txn->mt_flags) & (MDBX_TXN_RDONLY)) == (MDBX_TXN_RDONLY))) {
    if (txn->to.reader) {
      MDBX_reader *slot = txn->to.reader;
      do { if ((0)) do { if (__builtin_expect(!!(!(slot->mr_pid.weak == env->me_pid)), 0)) mdbx_assert_fail(env, "slot->mr_pid.weak == env->me_pid", __func__, 8630); } while (0); } while (0);
      if (__builtin_expect(!!(!(((txn->mt_flags) & (0x01)) == (0x01))), 1)) {
        do { if ((0)) do { if (__builtin_expect(!!(!(txn->mt_txnid == slot->mr_txnid.weak && slot->mr_txnid.weak >= env->me_lck->mti_oldest_reader.weak)), 0)) mdbx_assert_fail(env, "txn->mt_txnid == slot->mr_txnid.weak && slot->mr_txnid.weak >= env->me_lck->mti_oldest_reader.weak", __func__, 8632); } while (0); } while (0)

                                                                     ;



        atomic_store32(&slot->mr_snapshot_pages_used, 0, mo_Relaxed);
        safe64_reset(&slot->mr_txnid, (0));
        atomic_store32(&env->me_lck->mti_readers_refresh_flag, (1),
                       mo_Relaxed);
      } else {
        do { if ((0)) do { if (__builtin_expect(!!(!(slot->mr_pid.weak == env->me_pid)), 0)) mdbx_assert_fail(env, "slot->mr_pid.weak == env->me_pid", __func__, 8643); } while (0); } while (0);
        do { if ((0)) do { if (__builtin_expect(!!(!(slot->mr_txnid.weak >= 0xffffFFFF00000000UL)), 0)) mdbx_assert_fail(env, "slot->mr_txnid.weak >= 0xffffFFFF00000000UL", __func__, 8644); } while (0); } while (0);
      }
      if (mode & 0x80) {
        if ((env->me_flags & 0x10000000U) == 0)
          atomic_store32(&slot->mr_pid, 0, mo_Relaxed);
        txn->to.reader = 
# 8649 "/libmdbx/src/core.c" 3 4
                        ((void *)0)
# 8649 "/libmdbx/src/core.c"
                            ;
      }
    }




    txn->mt_numdbs = 0;
    txn->mt_flags = MDBX_TXN_RDONLY | 0x01;
    txn->mt_owner = 0;
  } else if (!(((txn->mt_flags) & (0x01)) == (0x01))) {





    txn->mt_flags = 0x01;
    txn->mt_owner = 0;
    env->me_txn = txn->mt_parent;
    mdbx_pnl_free(txn->tw.spill_pages);
    txn->tw.spill_pages = 
# 8669 "/libmdbx/src/core.c" 3 4
                         ((void *)0)
# 8669 "/libmdbx/src/core.c"
                                ;
    if (txn == env->me_txn0) {
      do { if ((0)) do { if (__builtin_expect(!!(!(txn->mt_parent == 
# 8671 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 8671 "/libmdbx/src/core.c"
     )), 0)) mdbx_assert_fail(env, "txn->mt_parent == ((void *)0)", __func__, 8671); } while (0); } while (0);

      dbi_update(txn, mode & 0x10);
      mdbx_pnl_shrink(&txn->tw.retired_pages);
      mdbx_pnl_shrink(&txn->tw.reclaimed_pglist);
      if (!(env->me_flags & MDBX_WRITEMAP))
        mdbx_dlist_free(txn);

      mdbx_txn_unlock(env);
    } else {
      do { if ((0)) do { if (__builtin_expect(!!(!(txn->mt_parent != 
# 8681 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 8681 "/libmdbx/src/core.c"
     )), 0)) mdbx_assert_fail(env, "txn->mt_parent != ((void *)0)", __func__, 8681); } while (0); } while (0);
      MDBX_txn *const parent = txn->mt_parent;
      do { if ((0)) do { if (__builtin_expect(!!(!(parent->mt_signature == 0x93D53A31U)), 0)) mdbx_assert_fail(env, "parent->mt_signature == 0x93D53A31U", __func__, 8683); } while (0); } while (0);
      do { if ((0)) do { if (__builtin_expect(!!(!(parent->mt_child == txn && (parent->mt_flags & 0x10) != 0)), 0)) mdbx_assert_fail(env, "parent->mt_child == txn && (parent->mt_flags & 0x10) != 0", __func__, 8684); } while (0); } while (0)
                                                                        ;
      do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_pnl_check4assert(txn->tw.reclaimed_pglist, txn->mt_geo.next - 1))), 0)) mdbx_assert_fail(env, "mdbx_pnl_check4assert(txn->tw.reclaimed_pglist, txn->mt_geo.next - 1)", __func__, 8686); } while (0); } while (0)

                                                                             ;

      if (txn->tw.lifo_reclaimed) {
        do { if ((0)) do { if (__builtin_expect(!!(!(((txn->tw.lifo_reclaimed)[0]) >= (unsigned)(uintptr_t)parent->tw.lifo_reclaimed)), 0)) mdbx_assert_fail(env, "((txn->tw.lifo_reclaimed)[0]) >= (unsigned)(uintptr_t)parent->tw.lifo_reclaimed", __func__, 8691); } while (0); } while (0)
                                                                            ;
        ((txn->tw.lifo_reclaimed)[0]) =
            (unsigned)(uintptr_t)parent->tw.lifo_reclaimed;
        parent->tw.lifo_reclaimed = txn->tw.lifo_reclaimed;
      }

      if (txn->tw.retired_pages) {
        do { if ((0)) do { if (__builtin_expect(!!(!(((txn->tw.retired_pages)[0]) >= (unsigned)(uintptr_t)parent->tw.retired_pages)), 0)) mdbx_assert_fail(env, "((txn->tw.retired_pages)[0]) >= (unsigned)(uintptr_t)parent->tw.retired_pages", __func__, 8699); } while (0); } while (0)
                                                                           ;
        ((txn->tw.retired_pages)[0]) =
            (unsigned)(uintptr_t)parent->tw.retired_pages;
        parent->tw.retired_pages = txn->tw.retired_pages;
      }

      parent->mt_child = 
# 8706 "/libmdbx/src/core.c" 3 4
                        ((void *)0)
# 8706 "/libmdbx/src/core.c"
                               ;
      parent->mt_flags &= ~0x10;
      parent->tw.dirtylru = txn->tw.dirtylru;
      do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_dirtylist_check(parent))), 0)) mdbx_assert_fail((parent)->mt_env, "mdbx_dirtylist_check(parent)", __func__, 8709); } while (0); } while (0);
      do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_audit_ex(parent, 0, (0)) == 0)), 0)) mdbx_assert_fail((parent)->mt_env, "mdbx_audit_ex(parent, 0, (0)) == 0", __func__, 8710); } while (0); } while (0);
      if (!(env->me_flags & MDBX_WRITEMAP))
        mdbx_dlist_free(txn);
      mdbx_dpl_free(txn);
      mdbx_pnl_free(txn->tw.reclaimed_pglist);

      if (parent->mt_geo.upper != txn->mt_geo.upper ||
          parent->mt_geo.now != txn->mt_geo.now) {

        rc = mdbx_mapresize_implicit(env, parent->mt_geo.next,
                                     parent->mt_geo.now, parent->mt_geo.upper);
        if (rc == MDBX_EPERM) {


          do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 8724, "unable undo resize performed by child txn, promote to " "the parent (%u->%u, %u->%u)" "\n", txn->mt_geo.now, parent->mt_geo.now, txn->mt_geo.upper, parent->mt_geo.upper); } while (0)


                                            ;
          parent->mt_geo.now = txn->mt_geo.now;
          parent->mt_geo.upper = txn->mt_geo.upper;
          parent->mt_flags |= 0x04;
          rc = MDBX_SUCCESS;
        } else if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0)) {
          do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 8733, "error %d while undo resize performed by child txn, fail " "the parent" "\n", rc); } while (0)

                        ;
          parent->mt_flags |= 0x02;
          if (!env->me_dxb_mmap.address)
            env->me_flags |= 0x80000000U;
        }
      }
    }
  }

  do { if ((0)) do { if (__builtin_expect(!!(!(txn == env->me_txn0 || txn->mt_owner == 0)), 0)) mdbx_assert_fail(env, "txn == env->me_txn0 || txn->mt_owner == 0", __func__, 8744); } while (0); } while (0);
  if ((mode & 0x20) != 0 && txn != env->me_txn0) {
    txn->mt_signature = 0;
    free(txn);
  }

  return rc;
}

int mdbx_txn_reset(MDBX_txn *txn) {
  int rc = check_txn(txn, 0);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;


  if (__builtin_expect(!!((txn->mt_flags & MDBX_TXN_RDONLY) == 0), 0))
    return MDBX_EINVAL;


  rc = mdbx_txn_end(txn, MDBX_END_RESET | 0x10);
  if (rc == MDBX_SUCCESS) {
    do { if ((0)) do { if (__builtin_expect(!!(!(txn->mt_signature == 0x93D53A31U)), 0)) mdbx_assert_fail((txn)->mt_env, "txn->mt_signature == 0x93D53A31U", __func__, 8765); } while (0); } while (0);
    do { if ((0)) do { if (__builtin_expect(!!(!(txn->mt_owner == 0)), 0)) mdbx_assert_fail((txn)->mt_env, "txn->mt_owner == 0", __func__, 8766); } while (0); } while (0);
  }
  return rc;
}

int mdbx_txn_break(MDBX_txn *txn) {
  do {
    int rc = check_txn(txn, 0);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      return rc;
    txn->mt_flags |= 0x02;
    if (txn->mt_flags & MDBX_TXN_RDONLY)
      break;
    txn = txn->mt_child;
  } while (txn);
  return MDBX_SUCCESS;
}

int mdbx_txn_abort(MDBX_txn *txn) {
  int rc = check_txn(txn, 0);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if ((((txn->mt_flags) & (MDBX_TXN_RDONLY)) == (MDBX_TXN_RDONLY)))

    return mdbx_txn_end(txn, MDBX_END_ABORT | 0x10 | 0x80 |
                                 0x20);

  if (txn->mt_child)
    mdbx_txn_abort(txn->mt_child);

  do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_dirtylist_check(txn))), 0)) mdbx_assert_fail((txn)->mt_env, "mdbx_dirtylist_check(txn)", __func__, 8797); } while (0); } while (0);
  return mdbx_txn_end(txn, MDBX_END_ABORT | 0x80 | 0x20);
}



__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static int mdbx_audit_ex(MDBX_txn *txn, unsigned retired_stored,
                                _Bool dont_filter_gc) {
  pgno_t pending = 0;
  if ((txn->mt_flags & MDBX_TXN_RDONLY) == 0) {
    pending = txn->tw.loose_count + ((txn->tw.reclaimed_pglist)[0]) +
              (((txn->tw.retired_pages)[0]) - retired_stored);
  }

  MDBX_cursor_couple cx;
  int rc = mdbx_cursor_init(&cx.outer, txn, 0);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  pgno_t gc = 0;
  MDBX_val key, data;
  while ((rc = mdbx_cursor_get(&cx.outer, &key, &data, MDBX_NEXT)) == 0) {
    if (!dont_filter_gc) {
      if (__builtin_expect(!!(key.iov_len != sizeof(txnid_t)), 0))
        return MDBX_CORRUPTED;
      txnid_t id = unaligned_peek_u64(4, key.iov_base);
      if (txn->tw.lifo_reclaimed) {
        for (unsigned i = 1; i <= ((txn->tw.lifo_reclaimed)[0]); ++i)
          if (id == txn->tw.lifo_reclaimed[i])
            goto skip;
      } else if (id <= txn->tw.last_reclaimed)
        goto skip;
    }

    gc += *(pgno_t *)data.iov_base;
  skip:;
  }
  do { if ((0)) do { if (__builtin_expect(!!(!(rc == MDBX_NOTFOUND)), 0)) mdbx_assert_fail((txn)->mt_env, "rc == MDBX_NOTFOUND", __func__, 8834); } while (0); } while (0);

  for (MDBX_dbi i = 0; i < txn->mt_numdbs; i++)
    txn->mt_dbistate[i] &= ~0x40;

  pgno_t used = 3;
  for (MDBX_dbi i = 0; i <= 1; i++) {
    if (!(txn->mt_dbistate[i] & 0x10))
      continue;
    rc = mdbx_cursor_init(&cx.outer, txn, i);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      return rc;
    txn->mt_dbistate[i] |= 0x40;
    if (txn->mt_dbs[i].md_root == (~(pgno_t)0))
      continue;
    used += txn->mt_dbs[i].md_branch_pages + txn->mt_dbs[i].md_leaf_pages +
            txn->mt_dbs[i].md_overflow_pages;

    if (i != 1)
      continue;
    rc = mdbx_page_search(&cx.outer, 
# 8854 "/libmdbx/src/core.c" 3 4
                                    ((void *)0)
# 8854 "/libmdbx/src/core.c"
                                        , 4);
    while (rc == MDBX_SUCCESS) {
      MDBX_page *mp = cx.outer.mc_pg[cx.outer.mc_top];
      for (unsigned j = 0; j < page_numkeys(mp); j++) {
        MDBX_node *node = page_node(mp, j);
        if (node_flags(node) == 0x02) {
          if (__builtin_expect(!!(node_ds(node) != sizeof(MDBX_db)), 0))
            return MDBX_CORRUPTED;
          MDBX_db db_copy, *db;
          memcpy(db = &db_copy, node_data(node), sizeof(db_copy));
          if ((txn->mt_flags & MDBX_TXN_RDONLY) == 0) {
            for (MDBX_dbi k = txn->mt_numdbs; --k > 1;) {
              if ((txn->mt_dbistate[k] & 0x10) &&

                  node_ks(node) == txn->mt_dbxs[k].md_name.iov_len &&
                  memcmp(node_key(node), txn->mt_dbxs[k].md_name.iov_base,
                         node_ks(node)) == 0) {
                txn->mt_dbistate[k] |= 0x40;
                if (!(txn->mt_dbistate[k] & MDBX_DBI_STALE))
                  db = txn->mt_dbs + k;
                break;
              }
            }
          }
          used +=
              db->md_branch_pages + db->md_leaf_pages + db->md_overflow_pages;
        }
      }
      rc = mdbx_cursor_sibling(&cx.outer, 2);
    }
    do { if ((0)) do { if (__builtin_expect(!!(!(rc == MDBX_NOTFOUND)), 0)) mdbx_assert_fail((txn)->mt_env, "rc == MDBX_NOTFOUND", __func__, 8884); } while (0); } while (0);
  }

  for (MDBX_dbi i = 0; i < txn->mt_numdbs; i++) {
    if ((txn->mt_dbistate[i] & (0x10 | 0x40 | MDBX_DBI_STALE)) !=
        0x10)
      continue;
    for (MDBX_txn *t = txn; t; t = t->mt_parent)
      if ((((t->mt_dbistate[i]) & (MDBX_DBI_DIRTY | MDBX_DBI_CREAT)) == (MDBX_DBI_DIRTY | MDBX_DBI_CREAT))) {
        used += t->mt_dbs[i].md_branch_pages + t->mt_dbs[i].md_leaf_pages +
                t->mt_dbs[i].md_overflow_pages;
        txn->mt_dbistate[i] |= 0x40;
        break;
      }
    if (!(txn->mt_dbistate[i] & 0x40)) {
      do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 8899, "audit %s@%" 
# 8899 "/libmdbx/src/core.c" 3 4
     "l" "i" 
# 8899 "/libmdbx/src/core.c"
     ": unable account dbi %d / \"%*s\", state 0x%02x" "\n", txn->mt_parent ? "nested-" : "", txn->mt_txnid, i, (int)txn->mt_dbxs[i].md_name.iov_len, (const char *)txn->mt_dbxs[i].md_name.iov_base, txn->mt_dbistate[i]); } while (0)




                                       ;
    }
  }

  if (pending + gc + used == txn->mt_geo.next)
    return MDBX_SUCCESS;

  if ((txn->mt_flags & MDBX_TXN_RDONLY) == 0)
    do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 8912, "audit @%" 
# 8912 "/libmdbx/src/core.c" 3 4
   "l" "i" 
# 8912 "/libmdbx/src/core.c"
   ": %u(pending) = %u(loose) + " "%u(reclaimed) + %u(retired-pending) - %u(retired-stored)" "\n", txn->mt_txnid, pending, txn->tw.loose_count, ((txn->tw.reclaimed_pglist)[0]), txn->tw.retired_pages ? ((txn->tw.retired_pages)[0]) : 0, retired_stored); } while (0)




                              ;
  do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 8918, "audit @%" 
# 8918 "/libmdbx/src/core.c" 3 4
 "l" "i" 
# 8918 "/libmdbx/src/core.c"
 ": %" 
# 8918 "/libmdbx/src/core.c" 3 4
 "u" 
# 8918 "/libmdbx/src/core.c"
 "(pending) + %" 
# 8918 "/libmdbx/src/core.c" 3 4
 "u" 
# 8918 "/libmdbx/src/core.c"
 "(gc) + %" 
# 8918 "/libmdbx/src/core.c" 3 4
 "u" 
# 8918 "/libmdbx/src/core.c"
 "(count) = %" 
# 8918 "/libmdbx/src/core.c" 3 4
 "u" 
# 8918 "/libmdbx/src/core.c"
 "(total) <> %" 
# 8918 "/libmdbx/src/core.c" 3 4
 "u" 
# 8918 "/libmdbx/src/core.c"
 "(allocated)" "\n", txn->mt_txnid, pending, gc, used, pending + gc + used, txn->mt_geo.next); } while (0)



                               ;
  return MDBX_PROBLEM;
}

static 
# 8926 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 8926 "/libmdbx/src/core.c"
                      unsigned backlog_size(MDBX_txn *txn) {
  return ((txn->tw.reclaimed_pglist)[0]) + txn->tw.loose_count;
}




static int mdbx_prep_backlog(MDBX_txn *txn, MDBX_cursor *gc_cursor,
                             const size_t pnl_bytes, unsigned *retired_stored) {
  const unsigned linear4list = number_of_ovpages(txn->mt_env, pnl_bytes);
  const unsigned backlog4cow = txn->mt_dbs[0].md_depth;
  const unsigned backlog4rebalance = backlog4cow + 1;

  if (__builtin_expect(!!(linear4list == 1 && backlog_size(txn) > (pnl_bytes ? backlog4rebalance : (backlog4cow + backlog4rebalance))), 1)


                                                                           )
    return MDBX_SUCCESS;

  do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 8945, ">> pnl_bytes %zu, backlog %u, 4list %u, 4cow %u, 4rebalance %u" "\n", pnl_bytes, backlog_size(txn), linear4list, backlog4cow, backlog4rebalance); } while (0)

                               ;

  MDBX_val gc_key, fake_val;
  int err;
  if (__builtin_expect(!!(linear4list > 2), 0)) {
    gc_key.iov_base = fake_val.iov_base = 
# 8952 "/libmdbx/src/core.c" 3 4
                                         ((void *)0)
# 8952 "/libmdbx/src/core.c"
                                                ;
    gc_key.iov_len = sizeof(txnid_t);
    fake_val.iov_len = pnl_bytes;
    err = mdbx_cursor_spill(gc_cursor, &gc_key, &fake_val);
    if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
      return err;
  }

  gc_cursor->mc_flags &= ~0x20;
  err = mdbx_cursor_touch(gc_cursor);
  do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 8962, "== after-touch, backlog %u, err %d" "\n", backlog_size(txn), err); } while (0);

  if (__builtin_expect(!!(linear4list > 1), 0) && err == MDBX_SUCCESS) {
    if (retired_stored) {
      gc_key.iov_base = &txn->mt_txnid;
      gc_key.iov_len = sizeof(txn->mt_txnid);
      const struct cursor_set_result csr =
          mdbx_cursor_set(gc_cursor, &gc_key, &fake_val, MDBX_SET);
      if (csr.err == MDBX_SUCCESS && csr.exact) {
        *retired_stored = 0;
        err = mdbx_cursor_del(gc_cursor, 0);
        do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 8973, "== clear-4linear, backlog %u, err %d" "\n", backlog_size(txn), err); } while (0)
                       ;
      }
    }
    err =
        mdbx_page_alloc(gc_cursor, linear4list, 2 | 16)
            .err;
    do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 8980, "== after-4linear, backlog %u, err %d" "\n", backlog_size(txn), err); } while (0);
    do { if ((0)) do { if (__builtin_expect(!!(!(backlog_size(txn) >= linear4list || err != MDBX_SUCCESS)), 0)) mdbx_assert_fail((gc_cursor)->mc_txn->mt_env, "backlog_size(txn) >= linear4list || err != MDBX_SUCCESS", __func__, 8981); } while (0); } while (0)
                                                                         ;
  }

  while (backlog_size(txn) < backlog4cow + linear4list && err == MDBX_SUCCESS)
    err = mdbx_page_alloc(gc_cursor, 0,
                          2 | 8 | 16)
              .err;

  gc_cursor->mc_flags |= 0x20;
  do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 8991, "<< backlog %u, err %d" "\n", backlog_size(txn), err); } while (0);
  return (err != MDBX_NOTFOUND) ? err : MDBX_SUCCESS;
}

static __inline void clean_reserved_gc_pnl(MDBX_env *env, MDBX_val pnl) {

  memset(pnl.iov_base, 0, sizeof(pgno_t));
  if ((env->me_flags & (MDBX_WRITEMAP | MDBX_NOMEMINIT)) == 0)



    memset(pnl.iov_base, 0, pnl.iov_len);
}
# 9014 "/libmdbx/src/core.c"
static int mdbx_update_gc(MDBX_txn *txn) {



  MDBX_env *const env = txn->mt_env;
  const _Bool lifo = (env->me_flags & MDBX_LIFORECLAIM) != 0;
  const char *dbg_prefix_mode = lifo ? "    lifo" : "    fifo";
  (void)dbg_prefix_mode;
  do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 9022, "\n>>> @%" 
# 9022 "/libmdbx/src/core.c" 3 4
 "l" "i" 
# 9022 "/libmdbx/src/core.c"
 "\n", txn->mt_txnid); } while (0);

  unsigned retired_stored = 0, loop = 0;
  MDBX_cursor_couple couple;
  int rc = mdbx_cursor_init(&couple.outer, txn, 0);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    goto bailout_notracking;

  couple.outer.mc_flags |= 0x20;
  couple.outer.mc_next = txn->mt_cursors[0];
  txn->mt_cursors[0] = &couple.outer;
  _Bool dense_gc = (0);

retry:
  ++loop;
  do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 9037, "%s" "\n", " >> restart"); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_pnl_check4assert(txn->tw.reclaimed_pglist, txn->mt_geo.next - 1))), 0)) mdbx_assert_fail((txn)->mt_env, "mdbx_pnl_check4assert(txn->tw.reclaimed_pglist, txn->mt_geo.next - 1)", __func__, 9038); } while (0); } while (0)

                                                                             ;
  do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_dirtylist_check(txn))), 0)) mdbx_assert_fail((txn)->mt_env, "mdbx_dirtylist_check(txn)", __func__, 9041); } while (0); } while (0);
  if (__builtin_expect(!!(loop > ((0 > 0) ? 12 : 42)), 0)) {
    do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 9043, "too more loops %u, bailout" "\n", loop); } while (0);
    rc = MDBX_PROBLEM;
    goto bailout;
  }

  if (__builtin_expect(!!(dense_gc), 0) && retired_stored) {
    rc = mdbx_prep_backlog(txn, &couple.outer,
                           ((((txn->tw.retired_pages)[0]) + 1) * sizeof(pgno_t)),
                           &retired_stored);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      goto bailout;
  }

  unsigned settled = 0, cleaned_gc_slot = 0, reused_gc_slot = 0,
           filled_gc_slot = ~0u;
  txnid_t cleaned_gc_id = 0, gc_rid = txn->tw.last_reclaimed;
  while ((1)) {

    MDBX_val key, data;
    do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 9062, "%s" "\n", " >> continue"); } while (0);

    if (retired_stored != ((txn->tw.retired_pages)[0]) &&
        ((txn->tw.retired_pages)[0]) > env->me_maxgc_ov1page) {
      rc = mdbx_prep_backlog(txn, &couple.outer,
                             ((((txn->tw.retired_pages)[0]) + 1) * sizeof(pgno_t)),
                             &retired_stored);
      if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
        goto bailout;
    }

    do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_pnl_check4assert(txn->tw.reclaimed_pglist, txn->mt_geo.next - 1))), 0)) mdbx_assert_fail((txn)->mt_env, "mdbx_pnl_check4assert(txn->tw.reclaimed_pglist, txn->mt_geo.next - 1)", __func__, 9073); } while (0); } while (0)

                                                                               ;
    if (lifo) {
      if (cleaned_gc_slot < (txn->tw.lifo_reclaimed
                                 ? ((txn->tw.lifo_reclaimed)[0])
                                 : 0)) {
        settled = 0;
        cleaned_gc_slot = 0;
        reused_gc_slot = 0;
        filled_gc_slot = ~0u;

        do {
          cleaned_gc_id = txn->tw.lifo_reclaimed[++cleaned_gc_slot];
          do { if ((0)) do { if (__builtin_expect(!!(!(cleaned_gc_slot > 0 && cleaned_gc_id < env->me_lck->mti_oldest_reader.weak)), 0)) mdbx_assert_fail((txn)->mt_env, "cleaned_gc_slot > 0 && cleaned_gc_id < env->me_lck->mti_oldest_reader.weak", __func__, 9087); } while (0); } while (0)

                                                                               ;
          key.iov_base = &cleaned_gc_id;
          key.iov_len = sizeof(cleaned_gc_id);
          rc = mdbx_cursor_get(&couple.outer, &key, 
# 9092 "/libmdbx/src/core.c" 3 4
                                                   ((void *)0)
# 9092 "/libmdbx/src/core.c"
                                                       , MDBX_SET);
          if (rc == MDBX_NOTFOUND)
            continue;
          if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
            goto bailout;
          if (__builtin_expect(!!(!dense_gc), 1)) {
            rc = mdbx_prep_backlog(txn, &couple.outer, 0, 
# 9098 "/libmdbx/src/core.c" 3 4
                                                         ((void *)0)
# 9098 "/libmdbx/src/core.c"
                                                                );
            if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
              goto bailout;
          }
          do { if ((0)) do { if (__builtin_expect(!!(!(cleaned_gc_id < env->me_lck->mti_oldest_reader.weak)), 0)) mdbx_assert_fail((txn)->mt_env, "cleaned_gc_id < env->me_lck->mti_oldest_reader.weak", __func__, 9102); } while (0); } while (0)
                                                                           ;
          do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 9104, "%s: cleanup-reclaimed-id [%u]%" 
# 9104 "/libmdbx/src/core.c" 3 4
         "l" "i" 
# 9104 "/libmdbx/src/core.c"
         "\n", dbg_prefix_mode, cleaned_gc_slot, cleaned_gc_id); } while (0)
                                                    ;
          do { if ((0)) do { if (__builtin_expect(!!(!(*txn->mt_cursors == &couple.outer)), 0)) mdbx_assert_fail((txn)->mt_env, "*txn->mt_cursors == &couple.outer", __func__, 9106); } while (0); } while (0);
          rc = mdbx_cursor_del(&couple.outer, 0);
          if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
            goto bailout;
        } while (cleaned_gc_slot < ((txn->tw.lifo_reclaimed)[0]));
        mdbx_txl_sort(txn->tw.lifo_reclaimed);
      }
    } else {


      while (cleaned_gc_id <= txn->tw.last_reclaimed) {
        rc = mdbx_cursor_first(&couple.outer, &key, 
# 9117 "/libmdbx/src/core.c" 3 4
                                                   ((void *)0)
# 9117 "/libmdbx/src/core.c"
                                                       );
        if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0)) {
          if (rc == MDBX_NOTFOUND)
            break;
          goto bailout;
        }
        if (!0 &&
            __builtin_expect(!!(key.iov_len != sizeof(txnid_t)), 0)) {
          rc = MDBX_CORRUPTED;
          goto bailout;
        }
        gc_rid = cleaned_gc_id;
        settled = 0;
        reused_gc_slot = 0;
        cleaned_gc_id = unaligned_peek_u64(4, key.iov_base);
        if (!0 &&
            __builtin_expect(!!(cleaned_gc_id < 1UL || cleaned_gc_id > (0xffffFFFF00000000UL - 1)), 0)) {
          rc = MDBX_CORRUPTED;
          goto bailout;
        }
        if (cleaned_gc_id > txn->tw.last_reclaimed)
          break;
        if (__builtin_expect(!!(!dense_gc), 1)) {
          rc = mdbx_prep_backlog(txn, &couple.outer, 0, 
# 9140 "/libmdbx/src/core.c" 3 4
                                                       ((void *)0)
# 9140 "/libmdbx/src/core.c"
                                                              );
          if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
            goto bailout;
        }
        do { if ((0)) do { if (__builtin_expect(!!(!(cleaned_gc_id <= txn->tw.last_reclaimed)), 0)) mdbx_assert_fail((txn)->mt_env, "cleaned_gc_id <= txn->tw.last_reclaimed", __func__, 9144); } while (0); } while (0);
        do { if ((0)) do { if (__builtin_expect(!!(!(cleaned_gc_id < env->me_lck->mti_oldest_reader.weak)), 0)) mdbx_assert_fail((txn)->mt_env, "cleaned_gc_id < env->me_lck->mti_oldest_reader.weak", __func__, 9145); } while (0); } while (0);
        do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 9146, "%s: cleanup-reclaimed-id %" 
# 9146 "/libmdbx/src/core.c" 3 4
       "l" "i" 
# 9146 "/libmdbx/src/core.c"
       "\n", dbg_prefix_mode, cleaned_gc_id); } while (0)
                                 ;
        do { if ((0)) do { if (__builtin_expect(!!(!(*txn->mt_cursors == &couple.outer)), 0)) mdbx_assert_fail((txn)->mt_env, "*txn->mt_cursors == &couple.outer", __func__, 9148); } while (0); } while (0);
        rc = mdbx_cursor_del(&couple.outer, 0);
        if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
          goto bailout;
      }
    }

    do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_pnl_check4assert(txn->tw.reclaimed_pglist, txn->mt_geo.next - 1))), 0)) mdbx_assert_fail((txn)->mt_env, "mdbx_pnl_check4assert(txn->tw.reclaimed_pglist, txn->mt_geo.next - 1)", __func__, 9155); } while (0); } while (0)

                                                                               ;
    do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_dirtylist_check(txn))), 0)) mdbx_assert_fail((txn)->mt_env, "mdbx_dirtylist_check(txn)", __func__, 9158); } while (0); } while (0);
    if ((0)) {
      rc = mdbx_audit_ex(txn, retired_stored, (0));
      if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
        goto bailout;
    }


    if (mdbx_refund(txn)) {
      do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_pnl_check4assert(txn->tw.reclaimed_pglist, txn->mt_geo.next - 1))), 0)) mdbx_assert_fail((txn)->mt_env, "mdbx_pnl_check4assert(txn->tw.reclaimed_pglist, txn->mt_geo.next - 1)", __func__, 9167); } while (0); } while (0)

                                                                             ;
      if ((0)) {
        rc = mdbx_audit_ex(txn, retired_stored, (0));
        if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
          goto bailout;
      }
    }


    if (txn->tw.loose_pages) {



      if (__builtin_expect(!!(!txn->tw.lifo_reclaimed && txn->tw.last_reclaimed < 1), 0)) {
        if (txn->tw.loose_count > 0) {


          if (__builtin_expect(!!((rc = mdbx_pnl_need(&txn->tw.retired_pages, txn->tw.loose_count)) != 0), 0)
                                                                      )
            goto bailout;
          for (MDBX_page *mp = txn->tw.loose_pages; mp; mp = mp->mp_next)
            mdbx_pnl_xappend(txn->tw.retired_pages, mp->mp_pgno);
          do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 9191, "%s: append %u loose-pages to retired-pages" "\n", dbg_prefix_mode, txn->tw.loose_count); } while (0)
                                                          ;
        }
      } else {

        rc = mdbx_pnl_need(&txn->tw.reclaimed_pglist,
                           2 * txn->tw.loose_count + 2);
        if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
          goto bailout;
        MDBX_PNL loose = txn->tw.reclaimed_pglist +
                         ((txn->tw.reclaimed_pglist)[-1]) -
                         txn->tw.loose_count - 1;
        unsigned count = 0;
        for (MDBX_page *mp = txn->tw.loose_pages; mp; mp = mp->mp_next) {
          do { if ((0)) do { if (__builtin_expect(!!(!(mp->mp_flags == 0x4000)), 0)) mdbx_assert_fail((txn)->mt_env, "mp->mp_flags == 0x4000", __func__, 9205); } while (0); } while (0);
          loose[++count] = mp->mp_pgno;
        }
        do { if ((0)) do { if (__builtin_expect(!!(!(count == txn->tw.loose_count)), 0)) mdbx_assert_fail((txn)->mt_env, "count == txn->tw.loose_count", __func__, 9208); } while (0); } while (0);
        ((loose)[0]) = count;
        mdbx_pnl_sort(loose, txn->mt_geo.next);
        mdbx_pnl_xmerge(txn->tw.reclaimed_pglist, loose);
        do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 9212, "%s: append %u loose-pages to reclaimed-pages" "\n", dbg_prefix_mode, txn->tw.loose_count); } while (0)
                                                        ;
      }


      MDBX_dpl *const dl = txn->tw.dirtylist;
      unsigned w = 0;
      for (unsigned r = w; ++r <= dl->length;) {
        MDBX_page *dp = dl->items[r].ptr;
        do { if ((0)) do { if (__builtin_expect(!!(!(dp->mp_flags == 0x4000 || ((dp)->mp_txnid == (txn)->mt_front))), 0)) mdbx_assert_fail((txn)->mt_env, "dp->mp_flags == 0x4000 || ((dp)->mp_txnid == (txn)->mt_front)", __func__, 9221); } while (0); } while (0);
        do { if ((0)) do { if (__builtin_expect(!!(!(dpl_endpgno(dl, r) <= txn->mt_geo.next)), 0)) mdbx_assert_fail((txn)->mt_env, "dpl_endpgno(dl, r) <= txn->mt_geo.next", __func__, 9222); } while (0); } while (0);
        if ((dp->mp_flags & 0x4000) == 0) {
          if (++w != r)
            dl->items[w] = dl->items[r];
        } else {
          do { if ((0)) do { if (__builtin_expect(!!(!(dp->mp_flags == 0x4000)), 0)) mdbx_assert_fail((txn)->mt_env, "dp->mp_flags == 0x4000", __func__, 9227); } while (0); } while (0);
          if ((env->me_flags & MDBX_WRITEMAP) == 0)
            mdbx_dpage_free(env, dp, 1);
        }
      }
      do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 9232, "%s: filtered-out loose-pages from %u -> %u dirty-pages" "\n", dbg_prefix_mode, dl->length, w); } while (0)
                                                ;
      do { if ((0)) do { if (__builtin_expect(!!(!(txn->tw.loose_count == dl->length - w)), 0)) mdbx_assert_fail((txn)->mt_env, "txn->tw.loose_count == dl->length - w", __func__, 9234); } while (0); } while (0);
      dpl_setlen(dl, w);
      dl->sorted = 0;
      txn->tw.dirtyroom += txn->tw.loose_count;
      do { if ((0)) do { if (__builtin_expect(!!(!(txn->tw.dirtyroom + txn->tw.dirtylist->length == (txn->mt_parent ? txn->mt_parent->tw.dirtyroom : txn->mt_env->me_options.dp_limit))), 0)) mdbx_assert_fail((txn)->mt_env, "txn->tw.dirtyroom + txn->tw.dirtylist->length == (txn->mt_parent ? txn->mt_parent->tw.dirtyroom : txn->mt_env->me_options.dp_limit)", __func__, 9238); } while (0); } while (0)


                                                                           ;
      txn->tw.loose_pages = 
# 9242 "/libmdbx/src/core.c" 3 4
                           ((void *)0)
# 9242 "/libmdbx/src/core.c"
                               ;
      txn->tw.loose_count = 0;

      txn->tw.loose_refund_wl = 0;

    }

    const unsigned amount = (unsigned)((txn->tw.reclaimed_pglist)[0]);

    if (retired_stored < ((txn->tw.retired_pages)[0])) {
      if (__builtin_expect(!!(!retired_stored), 0)) {

        couple.outer.mc_flags &= ~0x20;
        rc = mdbx_page_search(&couple.outer, 
# 9255 "/libmdbx/src/core.c" 3 4
                                            ((void *)0)
# 9255 "/libmdbx/src/core.c"
                                                ,
                              8 | 1);
        couple.outer.mc_flags |= 0x20;
        if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0) && rc != MDBX_NOTFOUND)
          goto bailout;
      }

      key.iov_len = sizeof(txn->mt_txnid);
      key.iov_base = &txn->mt_txnid;
      do {
        data.iov_len = ((((txn->tw.retired_pages)[0]) + 1) * sizeof(pgno_t));
        mdbx_prep_backlog(txn, &couple.outer, data.iov_len, &retired_stored);
        rc = mdbx_cursor_put(&couple.outer, &key, &data, MDBX_RESERVE);
        if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
          goto bailout;

      } while (data.iov_len < ((((txn->tw.retired_pages)[0]) + 1) * sizeof(pgno_t)));

      retired_stored = (unsigned)((txn->tw.retired_pages)[0]);
      mdbx_pnl_sort(txn->tw.retired_pages, txn->mt_geo.next);
      do { if ((0)) do { if (__builtin_expect(!!(!(data.iov_len == ((((txn->tw.retired_pages)[0]) + 1) * sizeof(pgno_t)))), 0)) mdbx_assert_fail(env, "data.iov_len == ((((txn->tw.retired_pages)[0]) + 1) * sizeof(pgno_t))", __func__, 9275); } while (0); } while (0);
      memcpy(data.iov_base, txn->tw.retired_pages, data.iov_len);

      do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 9278, "%s: put-retired #%u @ %" 
# 9278 "/libmdbx/src/core.c" 3 4
     "l" "i" 
# 9278 "/libmdbx/src/core.c"
     "\n", dbg_prefix_mode, retired_stored, txn->mt_txnid); } while (0)
                                               ;

      if ((MDBX_LOG_EXTRA < MDBX_LOG_VERBOSE && MDBX_LOG_EXTRA <= mdbx_loglevel)) {
        unsigned i = retired_stored;
        do { if ((MDBX_LOG_EXTRA < MDBX_LOG_VERBOSE && MDBX_LOG_EXTRA <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_EXTRA, __func__, 9283, "PNL write txn %" 
# 9283 "/libmdbx/src/core.c" 3 4
       "l" "i" 
# 9283 "/libmdbx/src/core.c"
       " root %" 
# 9283 "/libmdbx/src/core.c" 3 4
       "u" 
# 9283 "/libmdbx/src/core.c"
       " num %u, PNL", txn->mt_txnid, txn->mt_dbs[0].md_root, i); } while (0)

                                                                         ;
        for (; i; i--)
          do { if ((MDBX_LOG_EXTRA < MDBX_LOG_VERBOSE && MDBX_LOG_EXTRA <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_EXTRA, 
# 9287 "/libmdbx/src/core.c" 3 4
         ((void *)0)
# 9287 "/libmdbx/src/core.c"
         , 0, " %" 
# 9287 "/libmdbx/src/core.c" 3 4
         "u"
# 9287 "/libmdbx/src/core.c"
         , txn->tw.retired_pages[i]); } while (0);
        do { if ((MDBX_LOG_EXTRA < MDBX_LOG_VERBOSE && MDBX_LOG_EXTRA <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_EXTRA, 
# 9288 "/libmdbx/src/core.c" 3 4
       ((void *)0)
# 9288 "/libmdbx/src/core.c"
       , 0, "%s\n", "."); } while (0);
      }
      if (__builtin_expect(!!(amount != ((txn->tw.reclaimed_pglist)[0]) && settled), 0)
                           ) {
        do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 9292, "%s: reclaimed-list changed %u -> %u, retry" "\n", dbg_prefix_mode, amount, (unsigned)((txn->tw.reclaimed_pglist)[0])); } while (0)

                                                                     ;
        goto retry

            ;
      }
      continue;
    }


    do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_pnl_check4assert(txn->tw.reclaimed_pglist, txn->mt_geo.next - 1))), 0)) mdbx_assert_fail((txn)->mt_env, "mdbx_pnl_check4assert(txn->tw.reclaimed_pglist, txn->mt_geo.next - 1)", __func__, 9303); } while (0); } while (0)

                                                                               ;
    do { if ((0)) do { if (__builtin_expect(!!(!(txn->tw.loose_count == 0)), 0)) mdbx_assert_fail((txn)->mt_env, "txn->tw.loose_count == 0", __func__, 9306); } while (0); } while (0);

    do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 9308, "%s" "\n", " >> reserving"); } while (0);
    if ((0)) {
      rc = mdbx_audit_ex(txn, retired_stored, (0));
      if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
        goto bailout;
    }
    const unsigned left = amount - settled;
    do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 9315, "%s: amount %u, settled %d, left %d, lifo-reclaimed-slots %u, " "reused-gc-slots %u" "\n", dbg_prefix_mode, amount, settled, (int)left, txn->tw.lifo_reclaimed ? (unsigned)((txn->tw.lifo_reclaimed)[0]) : 0, reused_gc_slot); } while (0)





                              ;
    if (0 >= (int)left)
      break;

    const unsigned prefer_max_scatter = 257;
    txnid_t reservation_gc_id;
    if (lifo) {
      if (txn->tw.lifo_reclaimed == 
# 9328 "/libmdbx/src/core.c" 3 4
                                   ((void *)0)
# 9328 "/libmdbx/src/core.c"
                                          ) {
        txn->tw.lifo_reclaimed = mdbx_txl_alloc();
        if (__builtin_expect(!!(!txn->tw.lifo_reclaimed), 0)) {
          rc = MDBX_ENOMEM;
          goto bailout;
        }
      }
      if ((unsigned)((txn->tw.lifo_reclaimed)[0]) <
              prefer_max_scatter &&
          left > ((unsigned)((txn->tw.lifo_reclaimed)[0]) -
                  reused_gc_slot) *
                     env->me_maxgc_ov1page &&
          !dense_gc) {

        _Bool need_cleanup = (0);
        txnid_t snap_oldest;
      retry_rid:
        couple.outer.mc_flags &= ~0x20;
        do {
          snap_oldest = mdbx_find_oldest(txn);
          rc =
              mdbx_page_alloc(&couple.outer, 0,
                              2 | 8 | 16)
                  .err;
          if (__builtin_expect(!!(rc == MDBX_SUCCESS), 1)) {
            do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 9353, "%s: took @%" 
# 9353 "/libmdbx/src/core.c" 3 4
           "l" "i" 
# 9353 "/libmdbx/src/core.c"
           " from GC" "\n", dbg_prefix_mode, ((txn->tw.lifo_reclaimed)[((txn->tw.lifo_reclaimed)[0])])); } while (0)
                                                             ;
            need_cleanup = (1);
          }
        } while (rc == MDBX_SUCCESS &&
                 (unsigned)((txn->tw.lifo_reclaimed)[0]) <
                     prefer_max_scatter &&
                 left > ((unsigned)((txn->tw.lifo_reclaimed)[0]) -
                         reused_gc_slot) *
                            env->me_maxgc_ov1page);
        couple.outer.mc_flags |= 0x20;

        if (__builtin_expect(!!(rc == MDBX_SUCCESS), 1)) {
          do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 9366, "%s: got enough from GC." "\n", dbg_prefix_mode); } while (0);
          continue;
        } else if (__builtin_expect(!!(rc != MDBX_NOTFOUND), 0))

          goto bailout;

        if (((txn->tw.lifo_reclaimed)[0])) {
          if (need_cleanup) {
            mdbx_txl_sort(txn->tw.lifo_reclaimed);
            cleaned_gc_slot = 0;
          }
          gc_rid = ((txn->tw.lifo_reclaimed)[((txn->tw.lifo_reclaimed)[0])]);
        } else {
          do { if ((0)) do { if (__builtin_expect(!!(!(txn->tw.last_reclaimed == 0)), 0)) mdbx_assert_fail((txn)->mt_env, "txn->tw.last_reclaimed == 0", __func__, 9379); } while (0); } while (0);
          if (__builtin_expect(!!(mdbx_find_oldest(txn) != snap_oldest), 0))


            goto retry_rid;


          txn->tw.last_reclaimed = gc_rid = snap_oldest - 1;
          do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 9387, "%s: none recycled yet, set rid to @%" 
# 9387 "/libmdbx/src/core.c" 3 4
         "l" "i" 
# 9387 "/libmdbx/src/core.c"
         "\n", dbg_prefix_mode, gc_rid); } while (0)
                                             ;
        }


        while (((txn->tw.lifo_reclaimed)[0]) < prefer_max_scatter &&
               left > ((unsigned)((txn->tw.lifo_reclaimed)[0]) -
                       reused_gc_slot) *
                          env->me_maxgc_ov1page) {
          if (__builtin_expect(!!(gc_rid <= 1UL), 0)) {
            if (__builtin_expect(!!(((txn->tw.lifo_reclaimed)[0]) <= reused_gc_slot), 0)
                                        ) {
              do { if ((MDBX_LOG_NOTICE < MDBX_LOG_VERBOSE && MDBX_LOG_NOTICE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_NOTICE, __func__, 9399, "** restart: reserve depleted (reused_gc_slot %u >= " "lifo_reclaimed %u" 
# 9399 "/libmdbx/src/core.c" 3 4
             "l" "i" 
# 9399 "/libmdbx/src/core.c"
             "\n", reused_gc_slot, (unsigned)((txn->tw.lifo_reclaimed)[0])); } while (0)


                                                                          ;
              goto retry;
            }
            break;
          }

          do { if ((0)) do { if (__builtin_expect(!!(!(gc_rid >= 1UL && gc_rid <= (0xffffFFFF00000000UL - 1))), 0)) mdbx_assert_fail((txn)->mt_env, "gc_rid >= 1UL && gc_rid <= (0xffffFFFF00000000UL - 1)", __func__, 9408); } while (0); } while (0);
          --gc_rid;
          key.iov_base = &gc_rid;
          key.iov_len = sizeof(gc_rid);
          rc = mdbx_cursor_get(&couple.outer, &key, &data, MDBX_SET_KEY);
          if (__builtin_expect(!!(rc == MDBX_SUCCESS), 0)) {
            do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 9414, "%s: GC's id %" 
# 9414 "/libmdbx/src/core.c" 3 4
           "l" "i" 
# 9414 "/libmdbx/src/core.c"
           " is used, continue bottom-up search" "\n", dbg_prefix_mode, gc_rid); } while (0)

                                               ;
            ++gc_rid;
            rc = mdbx_cursor_get(&couple.outer, &key, &data, MDBX_FIRST);
            if (rc == MDBX_NOTFOUND) {
              do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 9420, "%s: GC is empty (going dense-mode)" "\n", dbg_prefix_mode); } while (0);
              dense_gc = (1);
              break;
            }
            if (__builtin_expect(!!(rc != MDBX_SUCCESS || key.iov_len != sizeof(mdbx_tid_t)), 0)
                                                           ) {
              rc = MDBX_CORRUPTED;
              goto bailout;
            }
            txnid_t gc_first = unaligned_peek_u64(4, key.iov_base);
            if (!0 &&
                __builtin_expect(!!(gc_first < 1UL || gc_first > (0xffffFFFF00000000UL - 1)), 0)) {
              rc = MDBX_CORRUPTED;
              goto bailout;
            }
            if (gc_first <= 1UL) {
              do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 9436, "%s: no free GC's id(s) less than %" 
# 9436 "/libmdbx/src/core.c" 3 4
             "l" "i" 
# 9436 "/libmdbx/src/core.c"
             " (going dense-mode)" "\n", dbg_prefix_mode, gc_rid); } while (0)

                                                 ;
              dense_gc = (1);
              break;
            }
            gc_rid = gc_first - 1;
          }

          do { if ((0)) do { if (__builtin_expect(!!(!(!dense_gc)), 0)) mdbx_assert_fail(env, "!dense_gc", __func__, 9445); } while (0); } while (0);
          rc = mdbx_txl_append(&txn->tw.lifo_reclaimed, gc_rid);
          if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
            goto bailout;

          if (reused_gc_slot)


            need_cleanup = (1);
          else
            cleaned_gc_slot +=
                1 ;

          do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 9458, "%s: append @%" 
# 9458 "/libmdbx/src/core.c" 3 4
         "l" "i" 
# 9458 "/libmdbx/src/core.c"
         " to lifo-reclaimed, cleaned-gc-slot = %u" "\n", dbg_prefix_mode, gc_rid, cleaned_gc_slot); } while (0)

                                                              ;
        }

        if (need_cleanup || dense_gc) {
          if (cleaned_gc_slot)
            do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 9465, "%s: restart inner-loop to clear and re-create GC entries" "\n", dbg_prefix_mode); } while (0)

                                ;
          cleaned_gc_slot = 0;
          continue;
        }
      }

      const unsigned i =
          (unsigned)((txn->tw.lifo_reclaimed)[0]) - reused_gc_slot;
      do { if ((0)) do { if (__builtin_expect(!!(!(i > 0 && i <= ((txn->tw.lifo_reclaimed)[0]))), 0)) mdbx_assert_fail((txn)->mt_env, "i > 0 && i <= ((txn->tw.lifo_reclaimed)[0])", __func__, 9475); } while (0); } while (0);
      reservation_gc_id = txn->tw.lifo_reclaimed[i];
      do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 9477, "%s: take @%" 
# 9477 "/libmdbx/src/core.c" 3 4
     "l" "i" 
# 9477 "/libmdbx/src/core.c"
     " from lifo-reclaimed[%u]" "\n", dbg_prefix_mode, reservation_gc_id, i); } while (0)
                                                       ;
    } else {
      do { if ((0)) do { if (__builtin_expect(!!(!(txn->tw.lifo_reclaimed == 
# 9480 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 9480 "/libmdbx/src/core.c"
     )), 0)) mdbx_assert_fail((txn)->mt_env, "txn->tw.lifo_reclaimed == ((void *)0)", __func__, 9480); } while (0); } while (0);
      if (__builtin_expect(!!(gc_rid == 0), 0)) {
        gc_rid = mdbx_find_oldest(txn) - 1;
        rc = mdbx_cursor_get(&couple.outer, &key, 
# 9483 "/libmdbx/src/core.c" 3 4
                                                 ((void *)0)
# 9483 "/libmdbx/src/core.c"
                                                     , MDBX_FIRST);
        if (rc == MDBX_SUCCESS) {
          if (!0 &&
              __builtin_expect(!!(key.iov_len != sizeof(txnid_t)), 0)) {
            rc = MDBX_CORRUPTED;
            goto bailout;
          }
          txnid_t gc_first = unaligned_peek_u64(4, key.iov_base);
          if (!0 &&
              __builtin_expect(!!(gc_first < 1UL || gc_first > (0xffffFFFF00000000UL - 1)), 0)) {
            rc = MDBX_CORRUPTED;
            goto bailout;
          }
          if (gc_rid >= gc_first)
            gc_rid = gc_first - 1;
          if (__builtin_expect(!!(gc_rid == 0), 0)) {
            do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 9499, "%s" "\n", "** no GC tail-space to store (going dense-mode)"); } while (0);
            dense_gc = (1);
            goto retry;
          }
        } else if (rc != MDBX_NOTFOUND)
          goto bailout;
        txn->tw.last_reclaimed = gc_rid;
        cleaned_gc_id = gc_rid + 1;
      }
      reservation_gc_id = gc_rid--;
      do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 9509, "%s: take @%" 
# 9509 "/libmdbx/src/core.c" 3 4
     "l" "i" 
# 9509 "/libmdbx/src/core.c"
     " from head-gc-id" "\n", dbg_prefix_mode, reservation_gc_id); } while (0)
                                   ;
    }
    ++reused_gc_slot;

    unsigned chunk = left;
    if (__builtin_expect(!!(chunk > env->me_maxgc_ov1page), 0)) {
      const unsigned avail_gc_slots =
          txn->tw.lifo_reclaimed
              ? (unsigned)((txn->tw.lifo_reclaimed)[0]) -
                    reused_gc_slot + 1
          : (gc_rid < 
# 9520 "/libmdbx/src/core.c" 3 4
                     (32767)
# 9520 "/libmdbx/src/core.c"
                              ) ? (unsigned)gc_rid
                                 : 
# 9521 "/libmdbx/src/core.c" 3 4
                                  (32767)
# 9521 "/libmdbx/src/core.c"
                                           ;
      if (avail_gc_slots > 1) {
        if (chunk < env->me_maxgc_ov1page * 2)
          chunk /= 2;
        else {
          const unsigned threshold =
              env->me_maxgc_ov1page * ((avail_gc_slots < prefer_max_scatter)
                                           ? avail_gc_slots
                                           : prefer_max_scatter);
          if (left < threshold)
            chunk = env->me_maxgc_ov1page;
          else {
            const unsigned tail = left - threshold + env->me_maxgc_ov1page + 1;
            unsigned span = 1;
            unsigned avail = (unsigned)((pgno2bytes(env, span) - ((unsigned)
# 9535 "/libmdbx/src/core.c" 3 4
                                                                __builtin_offsetof (
# 9535 "/libmdbx/src/core.c"
                                                                MDBX_page
# 9535 "/libmdbx/src/core.c" 3 4
                                                                , 
# 9535 "/libmdbx/src/core.c"
                                                                mp_ptrs
# 9535 "/libmdbx/src/core.c" 3 4
                                                                )
# 9535 "/libmdbx/src/core.c"
                                                                )) /
                                        sizeof(pgno_t)) ;
            if (tail > avail) {
              for (unsigned i = amount - span; i > 0; --i) {
                if (0
                        ? (txn->tw.reclaimed_pglist[i] + span)
                        : (txn->tw.reclaimed_pglist[i] - span) ==
                              txn->tw.reclaimed_pglist[i + span]) {
                  span += 1;
                  avail = (unsigned)((pgno2bytes(env, span) - ((unsigned)
# 9544 "/libmdbx/src/core.c" 3 4
                                                             __builtin_offsetof (
# 9544 "/libmdbx/src/core.c"
                                                             MDBX_page
# 9544 "/libmdbx/src/core.c" 3 4
                                                             , 
# 9544 "/libmdbx/src/core.c"
                                                             mp_ptrs
# 9544 "/libmdbx/src/core.c" 3 4
                                                             )
# 9544 "/libmdbx/src/core.c"
                                                             )) /
                                     sizeof(pgno_t)) -
                          1 + span;
                  if (avail >= tail)
                    break;
                }
              }
            }

            chunk = (avail >= tail) ? tail - span
                    : (avail_gc_slots > 3 &&
                       reused_gc_slot < prefer_max_scatter - 3)
                        ? avail - span
                        : tail;
          }
        }
      }
    }
    do { if ((0)) do { if (__builtin_expect(!!(!(chunk > 0)), 0)) mdbx_assert_fail((txn)->mt_env, "chunk > 0", __func__, 9562); } while (0); } while (0);

    do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 9564, "%s: gc_rid %" 
# 9564 "/libmdbx/src/core.c" 3 4
   "l" "i" 
# 9564 "/libmdbx/src/core.c"
   ", reused_gc_slot %u, reservation-id " "%" 
# 9564 "/libmdbx/src/core.c" 3 4
   "l" "i" 
# 9564 "/libmdbx/src/core.c"
   "\n", dbg_prefix_mode, gc_rid, reused_gc_slot, reservation_gc_id); } while (0)

                                                                          ;

    do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 9568, "%s: chunk %u, gc-per-ovpage %u" "\n", dbg_prefix_mode, chunk, env->me_maxgc_ov1page); } while (0)
                                     ;

    do { if ((0)) do { if (__builtin_expect(!!(!(reservation_gc_id < env->me_lck->mti_oldest_reader.weak)), 0)) mdbx_assert_fail((txn)->mt_env, "reservation_gc_id < env->me_lck->mti_oldest_reader.weak", __func__, 9571); } while (0); } while (0);
    if (__builtin_expect(!!(reservation_gc_id < 1UL || reservation_gc_id >= atomic_load64(&env->me_lck->mti_oldest_reader, mo_Relaxed)), 0)


                                                                           ) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 9576, "** internal error (reservation_gc_id %" 
# 9576 "/libmdbx/src/core.c" 3 4
     "l" "i" 
# 9576 "/libmdbx/src/core.c"
     ")" "\n", reservation_gc_id); } while (0)
                                   ;
      rc = MDBX_PROBLEM;
      goto bailout;
    }

    key.iov_len = sizeof(reservation_gc_id);
    key.iov_base = &reservation_gc_id;
    data.iov_len = (chunk + 1) * sizeof(pgno_t);
    do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 9585, "%s: reserve %u [%u...%u) @%" 
# 9585 "/libmdbx/src/core.c" 3 4
   "l" "i" 
# 9585 "/libmdbx/src/core.c"
   "\n", dbg_prefix_mode, chunk, settled + 1, settled + chunk + 1, reservation_gc_id); } while (0)
                                                                   ;
    mdbx_prep_backlog(txn, &couple.outer, data.iov_len, 
# 9587 "/libmdbx/src/core.c" 3 4
                                                       ((void *)0)
# 9587 "/libmdbx/src/core.c"
                                                              );
    rc = mdbx_cursor_put(&couple.outer, &key, &data,
                         MDBX_RESERVE | MDBX_NOOVERWRITE);
    do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_pnl_check4assert(txn->tw.reclaimed_pglist, txn->mt_geo.next - 1))), 0)) mdbx_assert_fail((txn)->mt_env, "mdbx_pnl_check4assert(txn->tw.reclaimed_pglist, txn->mt_geo.next - 1)", __func__, 9590); } while (0); } while (0)

                                                                               ;
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      goto bailout;

    clean_reserved_gc_pnl(env, data);
    settled += chunk;
    do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 9598, "%s: settled %u (+%u), continue" "\n", dbg_prefix_mode, settled, chunk); } while (0)
                     ;

    if (txn->tw.lifo_reclaimed &&
        __builtin_expect(!!(amount < ((txn->tw.reclaimed_pglist)[0])), 0) &&
        (loop < 5 || ((txn->tw.reclaimed_pglist)[0]) - amount >
                         env->me_maxgc_ov1page)) {
      do { if ((MDBX_LOG_NOTICE < MDBX_LOG_VERBOSE && MDBX_LOG_NOTICE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_NOTICE, __func__, 9605, "** restart: reclaimed-list growth %u -> %u" "\n", amount, (unsigned)((txn->tw.reclaimed_pglist)[0])); } while (0)
                                                                    ;
      goto retry;
    }

    continue;
  }

  do { if ((0)) do { if (__builtin_expect(!!(!(cleaned_gc_slot == (txn->tw.lifo_reclaimed ? ((txn->tw.lifo_reclaimed)[0]) : 0))), 0)) mdbx_assert_fail((txn)->mt_env, "cleaned_gc_slot == (txn->tw.lifo_reclaimed ? ((txn->tw.lifo_reclaimed)[0]) : 0)", __func__, 9613); } while (0); } while (0)


                                                                               ;

  do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 9618, "%s" "\n", " >> filling"); } while (0);

  filled_gc_slot =
      txn->tw.lifo_reclaimed
          ? (unsigned)((txn->tw.lifo_reclaimed)[0]) - reused_gc_slot
          : reused_gc_slot;
  rc = MDBX_SUCCESS;
  do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_pnl_check4assert(txn->tw.reclaimed_pglist, txn->mt_geo.next - 1))), 0)) mdbx_assert_fail((txn)->mt_env, "mdbx_pnl_check4assert(txn->tw.reclaimed_pglist, txn->mt_geo.next - 1)", __func__, 9625); } while (0); } while (0)

                                                                             ;
  do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_dirtylist_check(txn))), 0)) mdbx_assert_fail((txn)->mt_env, "mdbx_dirtylist_check(txn)", __func__, 9628); } while (0); } while (0);
  if (((txn->tw.reclaimed_pglist)[0])) {
    MDBX_val key, data;
    key.iov_len = data.iov_len = 0;
    key.iov_base = data.iov_base = 
# 9632 "/libmdbx/src/core.c" 3 4
                                  ((void *)0)
# 9632 "/libmdbx/src/core.c"
                                      ;

    const unsigned amount = ((txn->tw.reclaimed_pglist)[0]);
    unsigned left = amount;
    if (txn->tw.lifo_reclaimed == 
# 9636 "/libmdbx/src/core.c" 3 4
                                 ((void *)0)
# 9636 "/libmdbx/src/core.c"
                                        ) {
      do { if ((0)) do { if (__builtin_expect(!!(!(lifo == 0)), 0)) mdbx_assert_fail((txn)->mt_env, "lifo == 0", __func__, 9637); } while (0); } while (0);
      rc = mdbx_cursor_first(&couple.outer, &key, &data);
      if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
        goto bailout;
    } else {
      do { if ((0)) do { if (__builtin_expect(!!(!(lifo != 0)), 0)) mdbx_assert_fail((txn)->mt_env, "lifo != 0", __func__, 9642); } while (0); } while (0);
    }

    while ((1)) {
      txnid_t fill_gc_id;
      do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 9647, "%s: left %u of %u" "\n", dbg_prefix_mode, left, (unsigned)((txn->tw.reclaimed_pglist)[0])); } while (0)
                                                                   ;
      if (txn->tw.lifo_reclaimed == 
# 9649 "/libmdbx/src/core.c" 3 4
                                   ((void *)0)
# 9649 "/libmdbx/src/core.c"
                                          ) {
        do { if ((0)) do { if (__builtin_expect(!!(!(lifo == 0)), 0)) mdbx_assert_fail((txn)->mt_env, "lifo == 0", __func__, 9650); } while (0); } while (0);
        fill_gc_id = unaligned_peek_u64(4, key.iov_base);
        if (filled_gc_slot-- == 0 || fill_gc_id > txn->tw.last_reclaimed) {
          do { if ((MDBX_LOG_NOTICE < MDBX_LOG_VERBOSE && MDBX_LOG_NOTICE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_NOTICE, __func__, 9653, "** restart: reserve depleted (filled_slot %u, fill_id %" 
# 9653 "/libmdbx/src/core.c" 3 4
         "l" "i" 
# 9653 "/libmdbx/src/core.c"
         " > last_reclaimed %" 
# 9653 "/libmdbx/src/core.c" 3 4
         "l" "i" 
# 9653 "/libmdbx/src/core.c"
         "\n", filled_gc_slot, fill_gc_id, txn->tw.last_reclaimed); } while (0)


                                                                 ;
          goto retry;
        }
      } else {
        do { if ((0)) do { if (__builtin_expect(!!(!(lifo != 0)), 0)) mdbx_assert_fail((txn)->mt_env, "lifo != 0", __func__, 9660); } while (0); } while (0);
        if (++filled_gc_slot >
            (unsigned)((txn->tw.lifo_reclaimed)[0])) {
          do { if ((MDBX_LOG_NOTICE < MDBX_LOG_VERBOSE && MDBX_LOG_NOTICE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_NOTICE, __func__, 9663, "** restart: reserve depleted (filled_gc_slot %u > " "lifo_reclaimed %u" 
# 9663 "/libmdbx/src/core.c" 3 4
         "l" "i" 
# 9663 "/libmdbx/src/core.c"
         "\n", filled_gc_slot, (unsigned)((txn->tw.lifo_reclaimed)[0])); } while (0)


                                                                      ;
          goto retry;
        }
        fill_gc_id = txn->tw.lifo_reclaimed[filled_gc_slot];
        do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 9670, "%s: seek-reservation @%" 
# 9670 "/libmdbx/src/core.c" 3 4
       "l" "i" 
# 9670 "/libmdbx/src/core.c"
       " at lifo_reclaimed[%u]" "\n", dbg_prefix_mode, fill_gc_id, filled_gc_slot); } while (0)
                                                               ;
        key.iov_base = &fill_gc_id;
        key.iov_len = sizeof(fill_gc_id);
        rc = mdbx_cursor_get(&couple.outer, &key, &data, MDBX_SET_KEY);
        if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
          goto bailout;
      }
      do { if ((0)) do { if (__builtin_expect(!!(!(cleaned_gc_slot == (txn->tw.lifo_reclaimed ? ((txn->tw.lifo_reclaimed)[0]) : 0))), 0)) mdbx_assert_fail((txn)->mt_env, "cleaned_gc_slot == (txn->tw.lifo_reclaimed ? ((txn->tw.lifo_reclaimed)[0]) : 0)", __func__, 9678); } while (0); } while (0)


                                      ;
      do { if ((0)) do { if (__builtin_expect(!!(!(fill_gc_id > 0 && fill_gc_id < env->me_lck->mti_oldest_reader.weak)), 0)) mdbx_assert_fail((txn)->mt_env, "fill_gc_id > 0 && fill_gc_id < env->me_lck->mti_oldest_reader.weak", __func__, 9682); } while (0); } while (0)
                                                                             ;
      key.iov_base = &fill_gc_id;
      key.iov_len = sizeof(fill_gc_id);

      do { if ((0)) do { if (__builtin_expect(!!(!(data.iov_len >= sizeof(pgno_t) * 2)), 0)) mdbx_assert_fail((txn)->mt_env, "data.iov_len >= sizeof(pgno_t) * 2", __func__, 9687); } while (0); } while (0);
      couple.outer.mc_flags |= 0x40;
      unsigned chunk = (unsigned)(data.iov_len / sizeof(pgno_t)) - 1;
      if (__builtin_expect(!!(chunk > left), 0)) {
        do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 9691, "%s: chunk %u > left %u, @%" 
# 9691 "/libmdbx/src/core.c" 3 4
       "l" "i" 
# 9691 "/libmdbx/src/core.c"
       "\n", dbg_prefix_mode, chunk, left, fill_gc_id); } while (0)
                                    ;
        if ((loop < 5 && chunk - left > loop / 2) ||
            chunk - left > env->me_maxgc_ov1page) {
          data.iov_len = (left + 1) * sizeof(pgno_t);
          if (loop < 7)
            couple.outer.mc_flags &= ~0x40;
        }
        chunk = left;
      }
      rc = mdbx_cursor_put(&couple.outer, &key, &data,
                           MDBX_CURRENT | MDBX_RESERVE);
      couple.outer.mc_flags &= ~0x40;
      if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
        goto bailout;
      clean_reserved_gc_pnl(env, data);

      if (__builtin_expect(!!(txn->tw.loose_count || amount != ((txn->tw.reclaimed_pglist)[0])), 0)
                                                                     ) {
        do { if ((MDBX_LOG_NOTICE < MDBX_LOG_VERBOSE && MDBX_LOG_NOTICE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_NOTICE, __func__, 9710, "** restart: reclaimed-list growth (%u -> %u, loose +%u)" "\n", amount, ((txn->tw.reclaimed_pglist)[0]), txn->tw.loose_count); } while (0)

                                        ;
        goto retry;
      }
      if (__builtin_expect(!!(txn->tw.lifo_reclaimed ? cleaned_gc_slot < ((txn->tw.lifo_reclaimed)[0]) : cleaned_gc_id < txn->tw.last_reclaimed), 0)

                                                                ) {
        do { if ((MDBX_LOG_NOTICE < MDBX_LOG_VERBOSE && MDBX_LOG_NOTICE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_NOTICE, __func__, 9718, "%s" "\n", "** restart: reclaimed-slots changed"); } while (0);
        goto retry;
      }
      if (__builtin_expect(!!(retired_stored != ((txn->tw.retired_pages)[0])), 0)) {
        do { if ((0)) do { if (__builtin_expect(!!(!(retired_stored < ((txn->tw.retired_pages)[0]))), 0)) mdbx_assert_fail((txn)->mt_env, "retired_stored < ((txn->tw.retired_pages)[0])", __func__, 9722); } while (0); } while (0)
                                                                           ;
        do { if ((MDBX_LOG_NOTICE < MDBX_LOG_VERBOSE && MDBX_LOG_NOTICE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_NOTICE, __func__, 9724, "** restart: retired-list growth (%u -> %u)" "\n", retired_stored, ((txn->tw.retired_pages)[0])); } while (0)
                                                                         ;
        goto retry;
      }

      pgno_t *dst = data.iov_base;
      *dst++ = chunk;
      pgno_t *src = (&(txn->tw.reclaimed_pglist)[1]) + left - chunk;
      memcpy(dst, src, chunk * sizeof(pgno_t));
      pgno_t *from = src, *to = src + chunk;
      do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 9734, "%s: fill %u [ %u:%" 
# 9734 "/libmdbx/src/core.c" 3 4
     "u" 
# 9734 "/libmdbx/src/core.c"
     "...%u:%" 
# 9734 "/libmdbx/src/core.c" 3 4
     "u" 
# 9734 "/libmdbx/src/core.c"
     "] @%" 
# 9734 "/libmdbx/src/core.c" 3 4
     "l" "i" 
# 9734 "/libmdbx/src/core.c"
     "\n", dbg_prefix_mode, chunk, (unsigned)(from - txn->tw.reclaimed_pglist), from[0], (unsigned)(to - txn->tw.reclaimed_pglist), to[-1], fill_gc_id); } while (0)



                                                                               ;

      left -= chunk;
      if ((0)) {
        rc = mdbx_audit_ex(txn, retired_stored + amount - left, (1));
        if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
          goto bailout;
      }
      if (left == 0) {
        rc = MDBX_SUCCESS;
        break;
      }

      if (txn->tw.lifo_reclaimed == 
# 9751 "/libmdbx/src/core.c" 3 4
                                   ((void *)0)
# 9751 "/libmdbx/src/core.c"
                                          ) {
        do { if ((0)) do { if (__builtin_expect(!!(!(lifo == 0)), 0)) mdbx_assert_fail((txn)->mt_env, "lifo == 0", __func__, 9752); } while (0); } while (0);
        rc = mdbx_cursor_next(&couple.outer, &key, &data, MDBX_NEXT);
        if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
          goto bailout;
      } else {
        do { if ((0)) do { if (__builtin_expect(!!(!(lifo != 0)), 0)) mdbx_assert_fail((txn)->mt_env, "lifo != 0", __func__, 9757); } while (0); } while (0);
      }
    }
  }

  do { if ((0)) do { if (__builtin_expect(!!(!(rc == MDBX_SUCCESS)), 0)) mdbx_assert_fail((txn)->mt_env, "rc == MDBX_SUCCESS", __func__, 9762); } while (0); } while (0);
  if (__builtin_expect(!!(txn->tw.loose_count != 0), 0)) {
    do { if ((MDBX_LOG_NOTICE < MDBX_LOG_VERBOSE && MDBX_LOG_NOTICE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_NOTICE, __func__, 9764, "** restart: got %u loose pages" "\n", txn->tw.loose_count); } while (0);
    goto retry;
  }
  if (__builtin_expect(!!(filled_gc_slot != (txn->tw.lifo_reclaimed ? (unsigned)((txn->tw.lifo_reclaimed)[0]) : 0)), 0)


                         ) {

    const _Bool will_retry = loop < 9;
    do { if ((MDBX_LOG_NOTICE < MDBX_LOG_VERBOSE && MDBX_LOG_NOTICE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_NOTICE, __func__, 9773, "** %s: reserve excess (filled-slot %u, loop %u)" "\n", will_retry ? "restart" : "ignore", filled_gc_slot, loop); } while (0)
                                                                        ;
    if (will_retry)
      goto retry;
  }

  do { if ((0)) do { if (__builtin_expect(!!(!(txn->tw.lifo_reclaimed == 
# 9779 "/libmdbx/src/core.c" 3 4
 ((void *)0) 
# 9779 "/libmdbx/src/core.c"
 || cleaned_gc_slot == ((txn->tw.lifo_reclaimed)[0]))), 0)) mdbx_assert_fail((txn)->mt_env, "txn->tw.lifo_reclaimed == ((void *)0) || cleaned_gc_slot == ((txn->tw.lifo_reclaimed)[0])", __func__, 9779); } while (0); } while (0)

                                                                            ;

bailout:
  txn->mt_cursors[0] = couple.outer.mc_next;

bailout_notracking:
  ((txn->tw.reclaimed_pglist)[0]) = 0;
  do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 9788, "<<< %u loops, rc = %d" "\n", loop, rc); } while (0);
  return rc;
}

static int mdbx_txn_write(MDBX_txn *txn, struct mdbx_iov_ctx *ctx) {
  MDBX_dpl *const dl =
      (txn->mt_flags & MDBX_WRITEMAP) ? txn->tw.dirtylist : mdbx_dpl_sort(txn);
  int rc = MDBX_SUCCESS;
  unsigned r, w;
  for (w = 0, r = 1; r <= dl->length; ++r) {
    MDBX_page *dp = dl->items[r].ptr;
    if (dp->mp_flags & 0x4000) {
      dl->items[++w] = dl->items[r];
      continue;
    }
    unsigned npages = dpl_npages(dl, r);
    rc = iov_page(txn, ctx, dp, npages);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      break;
  }

  if (ctx->iov_items)
    rc = mdbx_iov_write(txn, ctx);

  while (r <= dl->length)
    dl->items[++w] = dl->items[r++];

  dl->sorted = dpl_setlen(dl, w);
  txn->tw.dirtyroom += r - 1 - w;
  do { if ((0)) do { if (__builtin_expect(!!(!(txn->tw.dirtyroom + txn->tw.dirtylist->length == (txn->mt_parent ? txn->mt_parent->tw.dirtyroom : txn->mt_env->me_options.dp_limit))), 0)) mdbx_assert_fail((txn)->mt_env, "txn->tw.dirtyroom + txn->tw.dirtylist->length == (txn->mt_parent ? txn->mt_parent->tw.dirtyroom : txn->mt_env->me_options.dp_limit)", __func__, 9817); } while (0); } while (0)

                                                                            ;
  return rc;
}


static 
# 9824 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 9824 "/libmdbx/src/core.c"
                      _Bool check_dbi(MDBX_txn *txn, MDBX_dbi dbi,
                                      unsigned validity) {
  if (__builtin_expect(!!(dbi < txn->mt_numdbs), 1))
    return __builtin_expect(!!((txn->mt_dbistate[dbi] & validity) && !((txn)->mt_dbiseqs[dbi] != (txn)->mt_env->me_dbiseqs[dbi]) && (txn->mt_dbxs[dbi].md_name.iov_base || dbi < 2)), 1)

                                                                         ;

  return dbi_import(txn, dbi);
}


int mdbx_txn_commit(MDBX_txn *txn) { return __inline_mdbx_txn_commit(txn); }



static __inline void mdbx_txn_merge(MDBX_txn *const parent, MDBX_txn *const txn,
                                    const unsigned parent_retired_len) {
  MDBX_dpl *const src = mdbx_dpl_sort(txn);


  MDBX_dpl *const dst = mdbx_dpl_sort(parent);
  if (1) {
    unsigned n = dst->length;
    while (n && dst->items[n].pgno >= parent->mt_geo.next) {
      if (!(txn->mt_env->me_flags & MDBX_WRITEMAP)) {
        MDBX_page *dp = dst->items[n].ptr;
        mdbx_dpage_free(txn->mt_env, dp, dpl_npages(dst, n));
      }
      --n;
    }
    parent->tw.dirtyroom += dst->sorted - n;
    dst->sorted = dpl_setlen(dst, n);
    do { if ((0)) do { if (__builtin_expect(!!(!(parent->tw.dirtyroom + parent->tw.dirtylist->length == (parent->mt_parent ? parent->mt_parent->tw.dirtyroom : parent->mt_env->me_options.dp_limit))), 0)) mdbx_assert_fail((parent)->mt_env, "parent->tw.dirtyroom + parent->tw.dirtylist->length == (parent->mt_parent ? parent->mt_parent->tw.dirtyroom : parent->mt_env->me_options.dp_limit)", __func__, 9856); } while (0); } while (0)


                                                                               ;
  }


  const MDBX_PNL reclaimed_list = parent->tw.reclaimed_pglist;
  mdbx_dpl_sift(parent, reclaimed_list, (0));


  unsigned r, w, d, s, l;
  for (r = w = parent_retired_len;
       ++r <= ((parent->tw.retired_pages)[0]);) {
    const pgno_t pgno = parent->tw.retired_pages[r];
    const unsigned di = mdbx_dpl_exist(parent, pgno);
    const unsigned si = !di ? mdbx_search_spilled(parent, pgno) : 0;
    unsigned npages;
    const char *kind;
    if (di) {
      MDBX_page *dp = dst->items[di].ptr;
      do { if ((0)) do { if (__builtin_expect(!!(!((dp->mp_flags & ~(0x02 | 0x20 | 0x01 | 0x04 | 0x2000)) == 0)), 0)) mdbx_assert_fail((parent)->mt_env, "(dp->mp_flags & ~(0x02 | 0x20 | 0x01 | 0x04 | 0x2000)) == 0", __func__, 9877); } while (0); } while (0)
                                                                           ;
      npages = dpl_npages(dst, di);
      mdbx_page_wash(parent, di, dp, npages);
      kind = "dirty";
      l = 1;
      if (__builtin_expect(!!(npages > l), 0)) {
# 9902 "/libmdbx/src/core.c"
        while (w > parent_retired_len &&
               parent->tw.retired_pages[w - 1] == pgno + l) {
          --w;
          if (++l == npages)
            break;
        }

      }
    } else if (__builtin_expect(!!(si), 0)) {
      l = npages = 1;
      mdbx_spill_remove(parent, si, 1);
      kind = "spilled";
    } else {
      parent->tw.retired_pages[++w] = pgno;
      continue;
    }

    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 9919, "reclaim retired parent's %u->%u %s page %" 
# 9919 "/libmdbx/src/core.c" 3 4
   "u" 
# 9919 "/libmdbx/src/core.c"
   "\n", npages, l, kind, pgno); } while (0)
                          ;
    int err = mdbx_pnl_insert_range(&parent->tw.reclaimed_pglist, pgno, l);
    do { if (__builtin_expect(!!(!(err == MDBX_SUCCESS)), 0)) mdbx_assert_fail(txn->mt_env, "err == MDBX_SUCCESS", __func__, 9922); } while (0);
  }
  ((parent->tw.retired_pages)[0]) = w;


  if (parent->tw.spill_pages && ((parent->tw.spill_pages)[0]) > 0) {
    const MDBX_PNL sl = mdbx_spill_purge(parent);
    unsigned len = ((sl)[0]);
    if (len) {

      if (1 &&
          ((sl)[1]) >= (parent->mt_geo.next << 1)) {
# 9944 "/libmdbx/src/core.c"
        do { if ((0)) do { if (__builtin_expect(!!(!(((sl)[1]) == ((sl)[1]))), 0)) mdbx_assert_fail(
# 9944 "/libmdbx/src/core.c" 3 4
       ((void *)0)
# 9944 "/libmdbx/src/core.c"
       , "((sl)[1]) == ((sl)[1])", __func__, 9944); } while (0); } while (0);
        unsigned i = 0;
        do {
          ++i;
          if ((sl[i] & 1) == 0)
            do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 9949, "refund parent's spilled page %" 
# 9949 "/libmdbx/src/core.c" 3 4
           "u" 
# 9949 "/libmdbx/src/core.c"
           "\n", sl[i] >> 1); } while (0);
        } while (i < len && sl[i + 1] >= (parent->mt_geo.next << 1));
        ((sl)[0]) = len -= i;
        memmove(sl + 1, sl + 1 + i, len * sizeof(sl[0]));

      }
      do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_pnl_check4assert(sl, (size_t)parent->mt_geo.next << 1))), 0)) mdbx_assert_fail((txn)->mt_env, "mdbx_pnl_check4assert(sl, (size_t)parent->mt_geo.next << 1)", __func__, 9955); } while (0); } while (0)
                                                                            ;


      s = ((sl)[0]), r = ((reclaimed_list)[0]);

      while (s && r) {
        if (sl[s] & 1) {
          --s;
          continue;
        }
        const pgno_t spilled_pgno = sl[s] >> 1;
        const pgno_t reclaimed_pgno = reclaimed_list[r];
        if (reclaimed_pgno != spilled_pgno) {
          const _Bool cmp = ((spilled_pgno) > (reclaimed_pgno));
          s -= !cmp;
          r -= cmp;
        } else {
          do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 9973, "remove reclaimed parent's spilled page %" 
# 9973 "/libmdbx/src/core.c" 3 4
         "u" 
# 9973 "/libmdbx/src/core.c"
         "\n", reclaimed_pgno); } while (0)
                                    ;
          mdbx_spill_remove(parent, s, 1);
          --s;
          --r;
        }
      }



      const int step = 0 ? -1 : 1;
      s = 0 ? ((sl)[0]) : 1;
      d = src->length;
      while (d && (0 ? s > 0 : s <= ((sl)[0]))) {
        if (sl[s] & 1) {
          s += step;
          continue;
        }
        const pgno_t spilled_pgno = sl[s] >> 1;
        const pgno_t dirty_pgno_form = src->items[d].pgno;
        const unsigned npages = dpl_npages(src, d);
        const pgno_t dirty_pgno_to = dirty_pgno_form + npages;
        if (dirty_pgno_form > spilled_pgno) {
          --d;
          continue;
        }
        if (dirty_pgno_to <= spilled_pgno) {
          s += step;
          continue;
        }

        do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 10004, "remove dirtied parent's spilled %u page %" 
# 10004 "/libmdbx/src/core.c" 3 4
       "u" 
# 10004 "/libmdbx/src/core.c"
       "\n", npages, dirty_pgno_form); } while (0)
                                   ;
        mdbx_spill_remove(parent, s, 1);
        s += step;
      }


      mdbx_spill_purge(parent);
    }
  }


  if (txn->tw.spill_pages) {
    do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_pnl_check4assert(txn->tw.spill_pages, (size_t)parent->mt_geo.next << 1))), 0)) mdbx_assert_fail((txn)->mt_env, "mdbx_pnl_check4assert(txn->tw.spill_pages, (size_t)parent->mt_geo.next << 1)", __func__, 10017); } while (0); } while (0)
                                                                               ;
    mdbx_dpl_sift(parent, txn->tw.spill_pages, (1));
    do { if ((0)) do { if (__builtin_expect(!!(!(parent->tw.dirtyroom + parent->tw.dirtylist->length == (parent->mt_parent ? parent->mt_parent->tw.dirtyroom : parent->mt_env->me_options.dp_limit))), 0)) mdbx_assert_fail((parent)->mt_env, "parent->tw.dirtyroom + parent->tw.dirtylist->length == (parent->mt_parent ? parent->mt_parent->tw.dirtyroom : parent->mt_env->me_options.dp_limit)", __func__, 10020); } while (0); } while (0)


                                                                               ;
  }



  for (l = 0, d = dst->length, s = src->length; d > 0 && s > 0;) {
    MDBX_page *sp = src->items[s].ptr;
    do { if ((0)) do { if (__builtin_expect(!!(!((sp->mp_flags & ~(0x02 | 0x20 | 0x01 | 0x04 | 0x4000 | 0x2000)) == 0)), 0)) mdbx_assert_fail((parent)->mt_env, "(sp->mp_flags & ~(0x02 | 0x20 | 0x01 | 0x04 | 0x4000 | 0x2000)) == 0", __func__, 10030); } while (0); } while (0)

                                                              ;
    const unsigned s_npages = dpl_npages(src, s);
    const pgno_t s_pgno = src->items[s].pgno;

    MDBX_page *dp = dst->items[d].ptr;
    do { if ((0)) do { if (__builtin_expect(!!(!((dp->mp_flags & ~(0x02 | 0x20 | 0x01 | 0x04 | 0x2000)) == 0)), 0)) mdbx_assert_fail((parent)->mt_env, "(dp->mp_flags & ~(0x02 | 0x20 | 0x01 | 0x04 | 0x2000)) == 0", __func__, 10037); } while (0); } while (0)
                                                                         ;
    const unsigned d_npages = dpl_npages(dst, d);
    const pgno_t d_pgno = dst->items[d].pgno;

    if (d_pgno >= s_pgno + s_npages) {
      --d;
      ++l;
    } else if (d_pgno + d_npages <= s_pgno) {
      if (sp->mp_flags != 0x4000) {
        sp->mp_txnid = parent->mt_front;
        sp->mp_flags &= ~0x2000;
      }
      --s;
      ++l;
    } else {
      dst->items[d--].ptr = 
# 10053 "/libmdbx/src/core.c" 3 4
                           ((void *)0)
# 10053 "/libmdbx/src/core.c"
                                  ;
      if ((txn->mt_flags & MDBX_WRITEMAP) == 0)
        mdbx_dpage_free(txn->mt_env, dp, d_npages);
    }
  }
  do { if ((0)) do { if (__builtin_expect(!!(!(dst->sorted == dst->length)), 0)) mdbx_assert_fail(
# 10058 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 10058 "/libmdbx/src/core.c"
 , "dst->sorted == dst->length", __func__, 10058); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(dst->detent >= l + d + s)), 0)) mdbx_assert_fail((parent)->mt_env, "dst->detent >= l + d + s", __func__, 10059); } while (0); } while (0);
  dst->sorted = l + d + s;

  while (s > 0) {
    MDBX_page *sp = src->items[s].ptr;
    do { if ((0)) do { if (__builtin_expect(!!(!((sp->mp_flags & ~(0x02 | 0x20 | 0x01 | 0x04 | 0x4000 | 0x2000)) == 0)), 0)) mdbx_assert_fail((parent)->mt_env, "(sp->mp_flags & ~(0x02 | 0x20 | 0x01 | 0x04 | 0x4000 | 0x2000)) == 0", __func__, 10064); } while (0); } while (0)

                                                              ;
    if (sp->mp_flags != 0x4000) {
      sp->mp_txnid = parent->mt_front;
      sp->mp_flags &= ~0x2000;
    }
    --s;
  }


  if (dst->sorted >= dst->length) {

    for (l = dst->sorted, s = src->length, d = dst->length; s > 0 && d > 0;) {
      if (__builtin_expect(!!(l <= d), 0)) {

        for (r = w = 1; r <= d; ++r)
          if (dst->items[r].ptr) {
            if (w != r) {
              dst->items[w] = dst->items[r];
              dst->items[r].ptr = 
# 10084 "/libmdbx/src/core.c" 3 4
                                 ((void *)0)
# 10084 "/libmdbx/src/core.c"
                                        ;
            }
            ++w;
          }
        do { if ((MDBX_LOG_NOTICE < MDBX_LOG_VERBOSE && MDBX_LOG_NOTICE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_NOTICE, __func__, 10088, "squash to begin for extending-merge %u -> %u" "\n", d, w - 1); } while (0);
        d = w - 1;
        continue;
      }
      do { if ((0)) do { if (__builtin_expect(!!(!(l > d)), 0)) mdbx_assert_fail(
# 10092 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 10092 "/libmdbx/src/core.c"
     , "l > d", __func__, 10092); } while (0); } while (0);
      if (dst->items[d].ptr) {
        dst->items[l--] = (dst->items[d].pgno > src->items[s].pgno)
                              ? dst->items[d--]
                              : src->items[s--];
      } else
        --d;
    }
    if (s > 0) {
      do { if ((0)) do { if (__builtin_expect(!!(!(l == s)), 0)) mdbx_assert_fail(
# 10101 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 10101 "/libmdbx/src/core.c"
     , "l == s", __func__, 10101); } while (0); } while (0);
      while (d > 0) {
        do { if ((0)) do { if (__builtin_expect(!!(!(dst->items[d].ptr == 
# 10103 "/libmdbx/src/core.c" 3 4
       ((void *)0)
# 10103 "/libmdbx/src/core.c"
       )), 0)) mdbx_assert_fail(
# 10103 "/libmdbx/src/core.c" 3 4
       ((void *)0)
# 10103 "/libmdbx/src/core.c"
       , "dst->items[d].ptr == ((void *)0)", __func__, 10103); } while (0); } while (0);
        --d;
      }
      do {
        do { if ((0)) do { if (__builtin_expect(!!(!(l > 0)), 0)) mdbx_assert_fail(
# 10107 "/libmdbx/src/core.c" 3 4
       ((void *)0)
# 10107 "/libmdbx/src/core.c"
       , "l > 0", __func__, 10107); } while (0); } while (0);
        dst->items[l--] = src->items[s--];
      } while (s > 0);
    } else {
      do { if ((0)) do { if (__builtin_expect(!!(!(l == d)), 0)) mdbx_assert_fail(
# 10111 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 10111 "/libmdbx/src/core.c"
     , "l == d", __func__, 10111); } while (0); } while (0);
      while (l > 0) {
        do { if ((0)) do { if (__builtin_expect(!!(!(dst->items[l].ptr != 
# 10113 "/libmdbx/src/core.c" 3 4
       ((void *)0)
# 10113 "/libmdbx/src/core.c"
       )), 0)) mdbx_assert_fail(
# 10113 "/libmdbx/src/core.c" 3 4
       ((void *)0)
# 10113 "/libmdbx/src/core.c"
       , "dst->items[l].ptr != ((void *)0)", __func__, 10113); } while (0); } while (0);
        --l;
      }
    }
  } else {

    for (l = s = d = 1; s <= src->length && d <= dst->length;) {
      if (__builtin_expect(!!(l >= d), 0)) {

        for (r = w = dst->length; r >= d; --r)
          if (dst->items[r].ptr) {
            if (w != r) {
              dst->items[w] = dst->items[r];
              dst->items[r].ptr = 
# 10126 "/libmdbx/src/core.c" 3 4
                                 ((void *)0)
# 10126 "/libmdbx/src/core.c"
                                        ;
            }
            --w;
          }
        do { if ((MDBX_LOG_NOTICE < MDBX_LOG_VERBOSE && MDBX_LOG_NOTICE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_NOTICE, __func__, 10130, "squash to end for shrinking-merge %u -> %u" "\n", d, w + 1); } while (0);
        d = w + 1;
        continue;
      }
      do { if ((0)) do { if (__builtin_expect(!!(!(l < d)), 0)) mdbx_assert_fail(
# 10134 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 10134 "/libmdbx/src/core.c"
     , "l < d", __func__, 10134); } while (0); } while (0);
      if (dst->items[d].ptr) {
        dst->items[l++] = (dst->items[d].pgno < src->items[s].pgno)
                              ? dst->items[d++]
                              : src->items[s++];
      } else
        ++d;
    }
    if (s <= src->length) {
      do { if ((0)) do { if (__builtin_expect(!!(!(dst->sorted - l == src->length - s)), 0)) mdbx_assert_fail(
# 10143 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 10143 "/libmdbx/src/core.c"
     , "dst->sorted - l == src->length - s", __func__, 10143); } while (0); } while (0);
      while (d <= dst->length) {
        do { if ((0)) do { if (__builtin_expect(!!(!(dst->items[d].ptr == 
# 10145 "/libmdbx/src/core.c" 3 4
       ((void *)0)
# 10145 "/libmdbx/src/core.c"
       )), 0)) mdbx_assert_fail(
# 10145 "/libmdbx/src/core.c" 3 4
       ((void *)0)
# 10145 "/libmdbx/src/core.c"
       , "dst->items[d].ptr == ((void *)0)", __func__, 10145); } while (0); } while (0);
        --d;
      }
      do {
        do { if ((0)) do { if (__builtin_expect(!!(!(l <= dst->sorted)), 0)) mdbx_assert_fail(
# 10149 "/libmdbx/src/core.c" 3 4
       ((void *)0)
# 10149 "/libmdbx/src/core.c"
       , "l <= dst->sorted", __func__, 10149); } while (0); } while (0);
        dst->items[l++] = src->items[s++];
      } while (s <= src->length);
    } else {
      do { if ((0)) do { if (__builtin_expect(!!(!(dst->sorted - l == dst->length - d)), 0)) mdbx_assert_fail(
# 10153 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 10153 "/libmdbx/src/core.c"
     , "dst->sorted - l == dst->length - d", __func__, 10153); } while (0); } while (0);
      while (l <= dst->sorted) {
        do { if ((0)) do { if (__builtin_expect(!!(!(l <= d && d <= dst->length && dst->items[d].ptr)), 0)) mdbx_assert_fail(
# 10155 "/libmdbx/src/core.c" 3 4
       ((void *)0)
# 10155 "/libmdbx/src/core.c"
       , "l <= d && d <= dst->length && dst->items[d].ptr", __func__, 10155); } while (0); } while (0);
        dst->items[l++] = dst->items[d++];
      }
    }
  }
  parent->tw.dirtyroom -= dst->sorted - dst->length;
  do { if ((0)) do { if (__builtin_expect(!!(!(parent->tw.dirtyroom <= parent->mt_env->me_options.dp_limit)), 0)) mdbx_assert_fail(
# 10161 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 10161 "/libmdbx/src/core.c"
 , "parent->tw.dirtyroom <= parent->mt_env->me_options.dp_limit", __func__, 10161); } while (0); } while (0);
  dpl_setlen(dst, dst->sorted);
  parent->tw.dirtylru = txn->tw.dirtylru;
  do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_dirtylist_check(parent))), 0)) mdbx_assert_fail((parent)->mt_env, "mdbx_dirtylist_check(parent)", __func__, 10164); } while (0); } while (0);
  mdbx_dpl_free(txn);

  if (txn->tw.spill_pages) {
    if (parent->tw.spill_pages) {

      mdbx_pnl_xmerge(parent->tw.spill_pages, txn->tw.spill_pages);
      mdbx_pnl_free(txn->tw.spill_pages);
    } else {
      parent->tw.spill_pages = txn->tw.spill_pages;
      parent->tw.spill_least_removed = txn->tw.spill_least_removed;
    }
    do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_dirtylist_check(parent))), 0)) mdbx_assert_fail((parent)->mt_env, "mdbx_dirtylist_check(parent)", __func__, 10176); } while (0); } while (0);
  }

  parent->mt_flags &= ~0x10;
  if (parent->tw.spill_pages) {
    do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_pnl_check4assert(parent->tw.spill_pages, (size_t)parent->mt_geo.next << 1))), 0)) mdbx_assert_fail(
# 10181 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 10181 "/libmdbx/src/core.c"
   , "mdbx_pnl_check4assert(parent->tw.spill_pages, (size_t)parent->mt_geo.next << 1)", __func__, 10181); } while (0); } while (0)
                                                                    ;
    if (((parent->tw.spill_pages)[0]))
      parent->mt_flags |= 0x08;
  }
}

int mdbx_txn_commit_ex(MDBX_txn *txn, MDBX_commit_latency *latency) {
  _Static_assert(0x01 == (0x01 | 0x02 | 0x10) - 0x10 - 0x02, "MDBX_TXN_FINISHED == MDBX_TXN_BLOCKED - MDBX_TXN_HAS_CHILD - MDBX_TXN_ERROR")
                                                                       ;
  const uint64_t ts_0 = latency ? mdbx_osal_monotime() : 0;
  uint64_t ts_1 = 0, ts_2 = 0, ts_3 = 0, ts_4 = 0;
  uint32_t audit_duration = 0;

  int rc = check_txn(txn, 0x01);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    goto provide_latency;

  if (__builtin_expect(!!(txn->mt_flags & 0x02), 0)) {
    rc = MDBX_RESULT_TRUE;
    goto fail;
  }

  MDBX_env *env = txn->mt_env;
# 10214 "/libmdbx/src/core.c"
  unsigned end_mode =
      MDBX_END_PURE_COMMIT | 0x10 | 0x80 | 0x20;
  if (__builtin_expect(!!((((txn->mt_flags) & (MDBX_TXN_RDONLY)) == (MDBX_TXN_RDONLY))), 0))
    goto done;

  if (txn->mt_child) {
    rc = mdbx_txn_commit_ex(txn->mt_child, 
# 10220 "/libmdbx/src/core.c" 3 4
                                          ((void *)0)
# 10220 "/libmdbx/src/core.c"
                                              );
    do { if ((0)) do { if (__builtin_expect(!!(!(txn->mt_child == 
# 10221 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 10221 "/libmdbx/src/core.c"
   )), 0)) mdbx_assert_fail((txn)->mt_env, "txn->mt_child == ((void *)0)", __func__, 10221); } while (0); } while (0);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      goto fail;
  }

  if (__builtin_expect(!!(txn != env->me_txn), 0)) {
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 10227, "%s" "\n", "attempt to commit unknown transaction"); } while (0);
    rc = MDBX_EINVAL;
    goto fail;
  }

  if (txn->mt_parent) {
    do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_audit_ex(txn, 0, (0)) == 0)), 0)) mdbx_assert_fail((txn)->mt_env, "mdbx_audit_ex(txn, 0, (0)) == 0", __func__, 10233); } while (0); } while (0);
    do { if ((0)) do { if (__builtin_expect(!!(!(txn != env->me_txn0)), 0)) mdbx_assert_fail(env, "txn != env->me_txn0", __func__, 10234); } while (0); } while (0);
    MDBX_txn *const parent = txn->mt_parent;
    do { if ((0)) do { if (__builtin_expect(!!(!(parent->mt_signature == 0x93D53A31U)), 0)) mdbx_assert_fail(env, "parent->mt_signature == 0x93D53A31U", __func__, 10236); } while (0); } while (0);
    do { if ((0)) do { if (__builtin_expect(!!(!(parent->mt_child == txn && (parent->mt_flags & 0x10) != 0)), 0)) mdbx_assert_fail(env, "parent->mt_child == txn && (parent->mt_flags & 0x10) != 0", __func__, 10237); } while (0); } while (0)
                                                                      ;
    do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_dirtylist_check(txn))), 0)) mdbx_assert_fail(env, "mdbx_dirtylist_check(txn)", __func__, 10239); } while (0); } while (0);

    if (txn->tw.dirtylist->length == 0 && !(txn->mt_flags & 0x04) &&
        parent->mt_numdbs == txn->mt_numdbs) {
      for (int i = txn->mt_numdbs; --i >= 0;) {
        do { if ((0)) do { if (__builtin_expect(!!(!((txn->mt_dbistate[i] & MDBX_DBI_DIRTY) == 0)), 0)) mdbx_assert_fail((txn)->mt_env, "(txn->mt_dbistate[i] & MDBX_DBI_DIRTY) == 0", __func__, 10244); } while (0); } while (0);
        if ((txn->mt_dbistate[i] & MDBX_DBI_STALE) &&
            !(parent->mt_dbistate[i] & MDBX_DBI_STALE))
          do { if ((0)) do { if (__builtin_expect(!!(!(memcmp(&parent->mt_dbs[i], &txn->mt_dbs[i], sizeof(MDBX_db)) == 0)), 0)) mdbx_assert_fail((txn)->mt_env, "memcmp(&parent->mt_dbs[i], &txn->mt_dbs[i], sizeof(MDBX_db)) == 0", __func__, 10247); } while (0); } while (0)
                                                         ;
      }

      do { if ((0)) do { if (__builtin_expect(!!(!(memcmp(&parent->mt_geo, &txn->mt_geo, sizeof(parent->mt_geo)) == 0)), 0)) mdbx_assert_fail((txn)->mt_env, "memcmp(&parent->mt_geo, &txn->mt_geo, sizeof(parent->mt_geo)) == 0", __func__, 10251); } while (0); } while (0)
                                                            ;
      do { if ((0)) do { if (__builtin_expect(!!(!(memcmp(&parent->mt_canary, &txn->mt_canary, sizeof(parent->mt_canary)) == 0)), 0)) mdbx_assert_fail((txn)->mt_env, "memcmp(&parent->mt_canary, &txn->mt_canary, sizeof(parent->mt_canary)) == 0", __func__, 10253); } while (0); } while (0)
                                                               ;
      do { if ((0)) do { if (__builtin_expect(!!(!(!txn->tw.spill_pages || ((txn->tw.spill_pages)[0]) == 0)), 0)) mdbx_assert_fail((txn)->mt_env, "!txn->tw.spill_pages || ((txn->tw.spill_pages)[0]) == 0", __func__, 10255); } while (0); } while (0)
                                                                    ;
      do { if ((0)) do { if (__builtin_expect(!!(!(txn->tw.loose_count == 0)), 0)) mdbx_assert_fail((txn)->mt_env, "txn->tw.loose_count == 0", __func__, 10257); } while (0); } while (0);


      end_mode = MDBX_END_PURE_COMMIT | 0x80 | 0x20;
      goto done;
    }



    const unsigned parent_retired_len =
        (unsigned)(uintptr_t)parent->tw.retired_pages;
    do { if ((0)) do { if (__builtin_expect(!!(!(parent_retired_len <= ((txn->tw.retired_pages)[0]))), 0)) mdbx_assert_fail((txn)->mt_env, "parent_retired_len <= ((txn->tw.retired_pages)[0])", __func__, 10268); } while (0); } while (0)
                                                                            ;
    const unsigned retired_delta =
        ((txn->tw.retired_pages)[0]) - parent_retired_len;
    if (retired_delta) {
      rc = mdbx_pnl_need(&txn->tw.reclaimed_pglist, retired_delta);
      if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
        goto fail;
    }

    if (txn->tw.spill_pages) {
      if (parent->tw.spill_pages) {
        rc = mdbx_pnl_need(&parent->tw.spill_pages,
                           ((txn->tw.spill_pages)[0]));
        if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
          goto fail;
      }
      mdbx_spill_purge(txn);
    }

    if (__builtin_expect(!!(txn->tw.dirtylist->length + parent->tw.dirtylist->length > parent->tw.dirtylist->detent && !mdbx_dpl_reserve(parent, txn->tw.dirtylist->length + parent->tw.dirtylist->length)), 0)


                                                                             ) {
      rc = MDBX_ENOMEM;
      goto fail;
    }



    parent->tw.lifo_reclaimed = txn->tw.lifo_reclaimed;
    txn->tw.lifo_reclaimed = 
# 10299 "/libmdbx/src/core.c" 3 4
                            ((void *)0)
# 10299 "/libmdbx/src/core.c"
                                ;

    parent->tw.retired_pages = txn->tw.retired_pages;
    txn->tw.retired_pages = 
# 10302 "/libmdbx/src/core.c" 3 4
                           ((void *)0)
# 10302 "/libmdbx/src/core.c"
                               ;

    mdbx_pnl_free(parent->tw.reclaimed_pglist);
    parent->tw.reclaimed_pglist = txn->tw.reclaimed_pglist;
    txn->tw.reclaimed_pglist = 
# 10306 "/libmdbx/src/core.c" 3 4
                              ((void *)0)
# 10306 "/libmdbx/src/core.c"
                                  ;
    parent->tw.last_reclaimed = txn->tw.last_reclaimed;

    parent->mt_geo = txn->mt_geo;
    parent->mt_canary = txn->mt_canary;
    parent->mt_flags |= txn->mt_flags & 0x04;



    parent->tw.loose_refund_wl = txn->tw.loose_refund_wl;

    parent->tw.loose_count = txn->tw.loose_count;
    parent->tw.loose_pages = txn->tw.loose_pages;


    mdbx_cursors_eot(txn, (1));
    end_mode |= 0x40;


    memcpy(parent->mt_dbs, txn->mt_dbs, txn->mt_numdbs * sizeof(MDBX_db));
    parent->mt_numdbs = txn->mt_numdbs;
    for (unsigned i = 0; i < txn->mt_numdbs; i++) {

      const uint8_t state =
          txn->mt_dbistate[i] |
          (parent->mt_dbistate[i] & (MDBX_DBI_CREAT | MDBX_DBI_FRESH | MDBX_DBI_DIRTY));
      do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 10332, "db %u dbi-state %s 0x%02x -> 0x%02x" "\n", i, (parent->mt_dbistate[i] != state) ? "update" : "still", parent->mt_dbistate[i], state); } while (0)

                                               ;
      parent->mt_dbistate[i] = state;
    }

    ts_1 = latency ? mdbx_osal_monotime() : 0;
    mdbx_txn_merge(parent, txn, parent_retired_len);
    ts_2 = latency ? mdbx_osal_monotime() : 0;
    env->me_txn = parent;
    parent->mt_child = 
# 10342 "/libmdbx/src/core.c" 3 4
                      ((void *)0)
# 10342 "/libmdbx/src/core.c"
                          ;
    do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_dirtylist_check(parent))), 0)) mdbx_assert_fail((parent)->mt_env, "mdbx_dirtylist_check(parent)", __func__, 10343); } while (0); } while (0);


    mdbx_refund(parent);
    if ((0)) {

      for (MDBX_page *lp = parent->tw.loose_pages; lp; lp = lp->mp_next)
        do { if ((0)) do { if (__builtin_expect(!!(!(lp->mp_pgno < parent->tw.loose_refund_wl && lp->mp_pgno + 1 < parent->mt_geo.next)), 0)) mdbx_assert_fail((parent)->mt_env, "lp->mp_pgno < parent->tw.loose_refund_wl && lp->mp_pgno + 1 < parent->mt_geo.next", __func__, 10350); } while (0); } while (0)
                                                                        ;

      if (((parent->tw.reclaimed_pglist)[0]))
        do { if ((0)) do { if (__builtin_expect(!!(!(((parent->tw.reclaimed_pglist)[1]) + 1 < parent->mt_geo.next)), 0)) mdbx_assert_fail((parent)->mt_env, "((parent->tw.reclaimed_pglist)[1]) + 1 < parent->mt_geo.next", __func__, 10354); } while (0); } while (0)
                                                      ;
    }


    ts_4 = ts_3 = latency ? mdbx_osal_monotime() : 0;
    txn->mt_signature = 0;
    free(txn);
    do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_audit_ex(parent, 0, (0)) == 0)), 0)) mdbx_assert_fail((parent)->mt_env, "mdbx_audit_ex(parent, 0, (0)) == 0", __func__, 10362); } while (0); } while (0);
    rc = MDBX_SUCCESS;
    goto provide_latency;
  }

  do { if ((0)) do { if (__builtin_expect(!!(!(txn->tw.dirtyroom + txn->tw.dirtylist->length == (txn->mt_parent ? txn->mt_parent->tw.dirtyroom : txn->mt_env->me_options.dp_limit))), 0)) mdbx_assert_fail((txn)->mt_env, "txn->tw.dirtyroom + txn->tw.dirtylist->length == (txn->mt_parent ? txn->mt_parent->tw.dirtyroom : txn->mt_env->me_options.dp_limit)", __func__, 10367); } while (0); } while (0)

                                                                            ;
  mdbx_cursors_eot(txn, (0));
  end_mode |= 0x40;

  if (txn->tw.dirtylist->length == 0 &&
      (txn->mt_flags & (0x04 | 0x08)) == 0) {
    for (int i = txn->mt_numdbs; --i >= 0;)
      do { if ((0)) do { if (__builtin_expect(!!(!((txn->mt_dbistate[i] & MDBX_DBI_DIRTY) == 0)), 0)) mdbx_assert_fail((txn)->mt_env, "(txn->mt_dbistate[i] & MDBX_DBI_DIRTY) == 0", __func__, 10376); } while (0); } while (0);
    rc = MDBX_SUCCESS;
    goto done;
  }

  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 10381, "committing txn %" 
# 10381 "/libmdbx/src/core.c" 3 4
 "l" "i" 
# 10381 "/libmdbx/src/core.c"
 " %p on mdbenv %p, root page %" 
# 10381 "/libmdbx/src/core.c" 3 4
 "u" 
# 10381 "/libmdbx/src/core.c"
 "/%" 
# 10381 "/libmdbx/src/core.c" 3 4
 "u" 
# 10381 "/libmdbx/src/core.c"
 "\n", txn->mt_txnid, (void *)txn, (void *)env, txn->mt_dbs[1].md_root, txn->mt_dbs[0].md_root); } while (0)


                                                                          ;


  if (txn->mt_numdbs > 2) {
    MDBX_cursor_couple couple;
    MDBX_val data;
    data.iov_len = sizeof(MDBX_db);

    rc = mdbx_cursor_init(&couple.outer, txn, 1);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      goto fail;
    for (MDBX_dbi i = 2; i < txn->mt_numdbs; i++) {
      if (txn->mt_dbistate[i] & MDBX_DBI_DIRTY) {
        if (__builtin_expect(!!(((txn)->mt_dbiseqs[i] != (txn)->mt_env->me_dbiseqs[i])), 0)) {
          rc = MDBX_BAD_DBI;
          goto fail;
        }
        MDBX_db *db = &txn->mt_dbs[i];
        do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 10402, "update main's entry for sub-db %u, mod_txnid %" 
# 10402 "/libmdbx/src/core.c" 3 4
       "l" "i" 
# 10402 "/libmdbx/src/core.c"
       " -> %" 
# 10402 "/libmdbx/src/core.c" 3 4
       "l" "i" 
# 10402 "/libmdbx/src/core.c"
       "\n", i, db->md_mod_txnid, txn->mt_txnid); } while (0)

                                                      ;
        db->md_mod_txnid = txn->mt_txnid;
        data.iov_base = db;
        do { do { if ((0)) do { if (__builtin_expect(!!(!(couple.outer.mc_txn->mt_cursors != 
# 10407 "/libmdbx/src/core.c" 3 4
       ((void *)0)
# 10407 "/libmdbx/src/core.c"
       )), 0)) mdbx_assert_fail((&(couple.outer))->mc_txn->mt_env, "couple.outer.mc_txn->mt_cursors != ((void *)0)", __func__, 10407); } while (0); } while (0); do { if ((0)) do { if (__builtin_expect(!!(!(!cursor_is_tracked(&(couple.outer)))), 0)) mdbx_assert_fail((&(couple.outer))->mc_txn->mt_env, "!cursor_is_tracked(&(couple.outer))", __func__, 10407); } while (0); } while (0); MDBX_cursor mc_dummy; MDBX_cursor **tracking_head = &(couple.outer).mc_txn->mt_cursors[couple.outer.mc_dbi]; MDBX_cursor *tracked = &(couple.outer); if ((couple.outer).mc_flags & 0x04) { mc_dummy.mc_flags = 0x01; mc_dummy.mc_top = 0; mc_dummy.mc_snum = 0; mc_dummy.mc_xcursor = (MDBX_xcursor *)&(couple.outer); tracked = &mc_dummy; } tracked->mc_next = *tracking_head; *tracking_head = tracked; { rc = mdbx_cursor_put(&couple.outer, &txn->mt_dbxs[i].md_name, &data, 0x02); } *tracking_head = tracked->mc_next; } while (0)


                                                                    ;
        if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
          goto fail;
      }
    }
  }

  ts_1 = latency ? mdbx_osal_monotime() : 0;
  rc = mdbx_update_gc(txn);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    goto fail;

  txn->mt_dbs[0].md_mod_txnid = (txn->mt_dbistate[0] & MDBX_DBI_DIRTY)
                                           ? txn->mt_txnid
                                           : txn->mt_dbs[0].md_mod_txnid;

  txn->mt_dbs[1].md_mod_txnid = (txn->mt_dbistate[1] & MDBX_DBI_DIRTY)
                                           ? txn->mt_txnid
                                           : txn->mt_dbs[1].md_mod_txnid;

  ts_2 = latency ? mdbx_osal_monotime() : 0;
  if ((0)) {
    rc = mdbx_audit_ex(txn, ((txn->tw.retired_pages)[0]), (1));
    const uint64_t audit_end = mdbx_osal_monotime();
    audit_duration = mdbx_osal_monotime_to_16dot16(audit_end - ts_2);
    ts_2 = audit_end;
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      goto fail;
  }

  struct mdbx_iov_ctx ctx;
  mdbx_iov_init(txn, &ctx);
  rc = mdbx_txn_write(txn, &ctx);
  if (__builtin_expect(!!(rc == MDBX_SUCCESS), 1))
    mdbx_iov_done(txn, &ctx);

  ts_3 = latency ? mdbx_osal_monotime() : 0;

  if (__builtin_expect(!!(rc == MDBX_SUCCESS), 1)) {
    const MDBX_meta *head = constmeta_prefer_last(env);
    MDBX_meta meta;
    memcpy(meta.mm_magic_and_version, head->mm_magic_and_version, 8);
    meta.mm_extra_flags = head->mm_extra_flags;
    meta.mm_validator_id = head->mm_validator_id;
    meta.mm_extra_pagehdr = head->mm_extra_pagehdr;
    unaligned_poke_u64(4, meta.mm_pages_retired,
                       unaligned_peek_u64(4, head->mm_pages_retired) +
                           ((txn->tw.retired_pages)[0]));
    meta.mm_geo = txn->mt_geo;
    meta.mm_dbs[0] = txn->mt_dbs[0];
    meta.mm_dbs[1] = txn->mt_dbs[1];
    meta.mm_canary = txn->mt_canary;
    meta_set_txnid(env, &meta, txn->mt_txnid);

    rc = mdbx_sync_locked(
        env, env->me_flags | txn->mt_flags | 0x40000000U, &meta);
  }
  ts_4 = latency ? mdbx_osal_monotime() : 0;
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0)) {
    env->me_flags |= 0x80000000U;
    goto fail;
  }

  end_mode = MDBX_END_COMMITTED | 0x10 | 0x40;

done:
  rc = mdbx_txn_end(txn, end_mode);

provide_latency:
  if (latency) {
    latency->audit = audit_duration;
    latency->preparation =
        ts_1 ? mdbx_osal_monotime_to_16dot16(ts_1 - ts_0) : 0;
    latency->gc =
        (ts_1 && ts_2) ? mdbx_osal_monotime_to_16dot16(ts_2 - ts_1) : 0;
    latency->write =
        (ts_2 && ts_3) ? mdbx_osal_monotime_to_16dot16(ts_3 - ts_2) : 0;
    latency->sync =
        (ts_3 && ts_4) ? mdbx_osal_monotime_to_16dot16(ts_4 - ts_3) : 0;
    const uint64_t ts_5 = mdbx_osal_monotime();
    latency->ending = ts_4 ? mdbx_osal_monotime_to_16dot16(ts_5 - ts_4) : 0;
    latency->whole = mdbx_osal_monotime_to_16dot16(ts_5 - ts_0);
  }
  return rc;

fail:
  mdbx_txn_abort(txn);
  goto provide_latency;
}

static int mdbx_validate_meta(MDBX_env *env, MDBX_meta *const meta,
                              const MDBX_page *const page,
                              const unsigned meta_number,
                              unsigned *guess_pagesize) {
  const uint64_t magic_and_version =
      unaligned_peek_u64(4, &meta->mm_magic_and_version);
  if (__builtin_expect(!!(magic_and_version != ((0x59659DBDEF4C11UL << 8) + 0 * 64 + 3) && magic_and_version != ((0x59659DBDEF4C11UL << 8) + 0 * 64 + 2) && magic_and_version != ((0x59659DBDEF4C11UL << 8) + 255)), 0)

                                                                 ) {
    do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 10509, "meta[%u] has invalid magic/version %" 
# 10509 "/libmdbx/src/core.c" 3 4
   "l" "x" 
# 10509 "/libmdbx/src/core.c"
   "\n", meta_number, magic_and_version); } while (0)
                                 ;
    return ((magic_and_version >> 8) != 0x59659DBDEF4C11UL) ? MDBX_INVALID
                                                    : MDBX_VERSION_MISMATCH;
  }

  if (__builtin_expect(!!(page->mp_pgno != meta_number), 0)) {
    do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 10516, "meta[%u] has invalid pageno %" 
# 10516 "/libmdbx/src/core.c" 3 4
   "u" 
# 10516 "/libmdbx/src/core.c"
   "\n", meta_number, page->mp_pgno); } while (0)
                             ;
    return MDBX_INVALID;
  }

  if (__builtin_expect(!!(page->mp_flags != 0x08), 0)) {
    do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 10522, "page #%u not a meta-page" "\n", meta_number); } while (0);
    return MDBX_INVALID;
  }


  if (__builtin_expect(!!(!is_powerof2(meta->mm_dbs[0].md_xsize) || meta->mm_dbs[0].md_xsize < MDBX_MIN_PAGESIZE || meta->mm_dbs[0].md_xsize > MDBX_MAX_PAGESIZE), 0)
                                             ) {
    do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 10529, "meta[%u] has invalid pagesize (%u), skip it" "\n", meta_number, meta->mm_dbs[0].md_xsize); } while (0)
                                ;
    return is_powerof2(meta->mm_dbs[0].md_xsize) ? MDBX_VERSION_MISMATCH : MDBX_INVALID;
  }

  if (guess_pagesize && *guess_pagesize != meta->mm_dbs[0].md_xsize) {
    *guess_pagesize = meta->mm_dbs[0].md_xsize;
    do { if ((MDBX_LOG_VERBOSE < MDBX_LOG_VERBOSE && MDBX_LOG_VERBOSE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_VERBOSE, __func__, 10536, "meta[%u] took pagesize %u" "\n", meta_number, meta->mm_dbs[0].md_xsize); } while (0);
  }

  const txnid_t txnid = unaligned_peek_u64(4, &meta->mm_txnid_a);
  if (__builtin_expect(!!(txnid != unaligned_peek_u64(4, &meta->mm_txnid_b)), 0)) {
    do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 10541, "meta[%u] not completely updated, skip it" "\n", meta_number); } while (0);
    return MDBX_RESULT_TRUE;
  }


  if (((unaligned_peek_u64_volatile(4, (meta)->mm_datasync_sign)) > 1u) &&
      __builtin_expect(!!(unaligned_peek_u64(4, &meta->mm_datasync_sign) != meta_sign(meta)), 0)
                               ) {
    do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 10549, "meta[%u] has invalid steady-checksum (0x%" 
# 10549 "/libmdbx/src/core.c" 3 4
   "l" "x" 
# 10549 "/libmdbx/src/core.c"
   " != 0x%" 
# 10549 "/libmdbx/src/core.c" 3 4
   "l" "x" 
# 10549 "/libmdbx/src/core.c"
   "), skip it" "\n", meta_number, unaligned_peek_u64(4, &meta->mm_datasync_sign), meta_sign(meta)); } while (0)


                                 ;
    return MDBX_RESULT_TRUE;
  }

  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 10556, "checking meta%" 
# 10556 "/libmdbx/src/core.c" 3 4
 "u" 
# 10556 "/libmdbx/src/core.c"
 " = root %" 
# 10556 "/libmdbx/src/core.c" 3 4
 "u" 
# 10556 "/libmdbx/src/core.c"
 "/%" 
# 10556 "/libmdbx/src/core.c" 3 4
 "u" 
# 10556 "/libmdbx/src/core.c"
 ", geo %" 
# 10556 "/libmdbx/src/core.c" 3 4
 "u" 
# 10556 "/libmdbx/src/core.c"
 "/%" 
# 10556 "/libmdbx/src/core.c" 3 4
 "u" 
# 10556 "/libmdbx/src/core.c"
 "-%" 
# 10556 "/libmdbx/src/core.c" 3 4
 "u" 
# 10556 "/libmdbx/src/core.c"
 "/%" 
# 10556 "/libmdbx/src/core.c" 3 4
 "u" 
# 10556 "/libmdbx/src/core.c"
 " +%u -%u, txn_id %" 
# 10556 "/libmdbx/src/core.c" 3 4
 "l" "i" 
# 10556 "/libmdbx/src/core.c"
 ", %s" "\n", page->mp_pgno, meta->mm_dbs[1].md_root, meta->mm_dbs[0].md_root, meta->mm_geo.lower, meta->mm_geo.next, meta->mm_geo.now, meta->mm_geo.upper, pv2pages(meta->mm_geo.grow_pv), pv2pages(meta->mm_geo.shrink_pv), txnid, mdbx_durable_str(meta)); } while (0)






                                           ;

  if (__builtin_expect(!!(txnid < 1UL || txnid > (0xffffFFFF00000000UL - 1)), 0)) {
    do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 10566, "meta[%u] has invalid txnid %" 
# 10566 "/libmdbx/src/core.c" 3 4
   "l" "i" 
# 10566 "/libmdbx/src/core.c"
   ", skip it" "\n", meta_number, txnid); } while (0)
                                    ;
    return MDBX_RESULT_TRUE;
  }


  if (__builtin_expect(!!(meta->mm_geo.lower < 3 || meta->mm_geo.lower > 0x7FFFffffU + 1), 0)
                                                   ) {
    do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 10574, "meta[%u] has invalid min-pages (%" 
# 10574 "/libmdbx/src/core.c" 3 4
   "u" 
# 10574 "/libmdbx/src/core.c"
   "), skip it" "\n", meta_number, meta->mm_geo.lower); } while (0)
                                                 ;
    return MDBX_INVALID;
  }


  if (__builtin_expect(!!(meta->mm_geo.upper < 3 || meta->mm_geo.upper > 0x7FFFffffU + 1 || meta->mm_geo.upper < meta->mm_geo.lower), 0)

                                                       ) {
    do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 10583, "meta[%u] has invalid max-pages (%" 
# 10583 "/libmdbx/src/core.c" 3 4
   "u" 
# 10583 "/libmdbx/src/core.c"
   "), skip it" "\n", meta_number, meta->mm_geo.upper); } while (0)
                                                 ;
    return MDBX_INVALID;
  }


  if (__builtin_expect(!!(meta->mm_geo.next < 3 || meta->mm_geo.next - 1 > 0x7FFFffffU), 0)
                                                  ) {
    do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 10591, "meta[%u] has invalid next-pageno (%" 
# 10591 "/libmdbx/src/core.c" 3 4
   "u" 
# 10591 "/libmdbx/src/core.c"
   "), skip it" "\n", meta_number, meta->mm_geo.next); } while (0)
                                                ;
    return MDBX_CORRUPTED;
  }


  const uint64_t used_bytes = meta->mm_geo.next * (uint64_t)meta->mm_dbs[0].md_xsize;
  if (__builtin_expect(!!(used_bytes > env->me_dxb_mmap.filesize), 0)) {

    int err = mdbx_filesize(env->me_dxb_mmap.fd, &env->me_dxb_mmap.filesize);
    if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
      return err;
    if (__builtin_expect(!!(used_bytes > env->me_dxb_mmap.filesize), 0)) {
      do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 10604, "meta[%u] used-bytes (%" 
# 10604 "/libmdbx/src/core.c" 3 4
     "l" "u" 
# 10604 "/libmdbx/src/core.c"
     ") beyond filesize (%" 
# 10604 "/libmdbx/src/core.c" 3 4
     "l" "u" 
# 10604 "/libmdbx/src/core.c"
     "), skip it" "\n", meta_number, used_bytes, env->me_dxb_mmap.filesize); } while (0)

                                                                      ;
      return MDBX_CORRUPTED;
    }
  }
  if (__builtin_expect(!!(meta->mm_geo.next - 1 > 0x7FFFffffU || used_bytes > ((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE)), 0)
                                        ) {
    do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 10612, "meta[%u] has too large used-space (%" 
# 10612 "/libmdbx/src/core.c" 3 4
   "l" "u" 
# 10612 "/libmdbx/src/core.c"
   "), skip it" "\n", meta_number, used_bytes); } while (0)
                                         ;
    return MDBX_TOO_LARGE;
  }


  pgno_t geo_lower = meta->mm_geo.lower;
  uint64_t mapsize_min = geo_lower * (uint64_t)meta->mm_dbs[0].md_xsize;
  _Static_assert(((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE) < 
# 10620 "/libmdbx/src/core.c" 3 4
 (9223372036854775807L) 
# 10620 "/libmdbx/src/core.c"
 - MDBX_MAX_PAGESIZE, "MAX_MAPSIZE < PTRDIFF_MAX - MAX_PAGESIZE");
  _Static_assert((MDBX_MIN_PAGESIZE * 3) < ((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE), "MIN_MAPSIZE < MAX_MAPSIZE");
  _Static_assert((uint64_t)(0x7FFFffffU + 1) * MDBX_MIN_PAGESIZE % (4ul << 20) == 0, "(uint64_t)(MAX_PAGENO + 1) * MIN_PAGESIZE % (4ul << 20) == 0");
  if (__builtin_expect(!!(mapsize_min < (MDBX_MIN_PAGESIZE * 3) || mapsize_min > ((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE)), 0)) {
    if (((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE) != ((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE) && mapsize_min > ((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE) &&
        mapsize_min <= ((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE)) {
      do { if ((0)) do { if (__builtin_expect(!!(!(meta->mm_geo.next - 1 <= 0x7FFFffffU && used_bytes <= ((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE))), 0)) mdbx_assert_fail(env, "meta->mm_geo.next - 1 <= 0x7FFFffffU && used_bytes <= ((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE)", __func__, 10626); } while (0); } while (0)
                                                     ;
      do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 10628, "meta[%u] has too large min-mapsize (%" 
# 10628 "/libmdbx/src/core.c" 3 4
     "l" "u" 
# 10628 "/libmdbx/src/core.c"
     "), " "but size of used space still acceptable (%" 
# 10628 "/libmdbx/src/core.c" 3 4
     "l" "u" 
# 10628 "/libmdbx/src/core.c"
     ")" "\n", meta_number, mapsize_min, used_bytes); } while (0)

                                                        ;
      geo_lower = (pgno_t)((mapsize_min = ((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE)) / meta->mm_dbs[0].md_xsize);
      if (geo_lower > 0x7FFFffffU + 1) {
        geo_lower = 0x7FFFffffU + 1;
        mapsize_min = geo_lower * (uint64_t)meta->mm_dbs[0].md_xsize;
      }
      do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 10636, "meta[%u] consider get-%s pageno is %" 
# 10636 "/libmdbx/src/core.c" 3 4
     "u" 
# 10636 "/libmdbx/src/core.c"
     " instead of wrong %" 
# 10636 "/libmdbx/src/core.c" 3 4
     "u" 
# 10636 "/libmdbx/src/core.c"
     ", will be corrected on next commit(s)" "\n", meta_number, "lower", geo_lower, meta->mm_geo.lower); } while (0)


                                                                       ;
      meta->mm_geo.lower = geo_lower;
    } else {
      do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 10642, "meta[%u] has invalid min-mapsize (%" 
# 10642 "/libmdbx/src/core.c" 3 4
     "l" "u" 
# 10642 "/libmdbx/src/core.c"
     "), skip it" "\n", meta_number, mapsize_min); } while (0)
                                            ;
      return MDBX_VERSION_MISMATCH;
    }
  }

  pgno_t geo_upper = meta->mm_geo.upper;
  uint64_t mapsize_max = geo_upper * (uint64_t)meta->mm_dbs[0].md_xsize;
  _Static_assert((MDBX_MIN_PAGESIZE * 3) < ((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE), "MIN_MAPSIZE < MAX_MAPSIZE");
  if (__builtin_expect(!!(mapsize_max > ((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE) || (0x7FFFffffU + 1) < ceil_powerof2((size_t)mapsize_max, env->me_os_psize) / (size_t)meta->mm_dbs[0].md_xsize), 0)


                                              ) {
    if (mapsize_max > ((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE)) {
      do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 10656, "meta[%u] has invalid max-mapsize (%" 
# 10656 "/libmdbx/src/core.c" 3 4
     "l" "u" 
# 10656 "/libmdbx/src/core.c"
     "), skip it" "\n", meta_number, mapsize_max); } while (0)
                                            ;
      return MDBX_VERSION_MISMATCH;
    }

    do { if ((0)) do { if (__builtin_expect(!!(!(meta->mm_geo.next - 1 <= 0x7FFFffffU && used_bytes <= ((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE))), 0)) mdbx_assert_fail(env, "meta->mm_geo.next - 1 <= 0x7FFFffffU && used_bytes <= ((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE)", __func__, 10661); } while (0); } while (0)
                                                   ;
    do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 10663, "meta[%u] has too large max-mapsize (%" 
# 10663 "/libmdbx/src/core.c" 3 4
   "l" "u" 
# 10663 "/libmdbx/src/core.c"
   "), " "but size of used space still acceptable (%" 
# 10663 "/libmdbx/src/core.c" 3 4
   "l" "u" 
# 10663 "/libmdbx/src/core.c"
   ")" "\n", meta_number, mapsize_max, used_bytes); } while (0)

                                                      ;
    geo_upper = (pgno_t)((mapsize_max = ((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE)) / meta->mm_dbs[0].md_xsize);
    if (geo_upper > 0x7FFFffffU + 1) {
      geo_upper = 0x7FFFffffU + 1;
      mapsize_max = geo_upper * (uint64_t)meta->mm_dbs[0].md_xsize;
    }
    do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 10671, "meta[%u] consider get-%s pageno is %" 
# 10671 "/libmdbx/src/core.c" 3 4
   "u" 
# 10671 "/libmdbx/src/core.c"
   " instead of wrong %" 
# 10671 "/libmdbx/src/core.c" 3 4
   "u" 
# 10671 "/libmdbx/src/core.c"
   ", will be corrected on next commit(s)" "\n", meta_number, "upper", geo_upper, meta->mm_geo.upper); } while (0)


                                                                     ;
    meta->mm_geo.upper = geo_upper;
  }
# 10685 "/libmdbx/src/core.c"
  pgno_t geo_now = meta->mm_geo.now;
  if (geo_now < geo_lower)
    geo_now = geo_lower;
  if (geo_now > geo_upper && meta->mm_geo.next <= geo_upper)
    geo_now = geo_upper;

  if (__builtin_expect(!!(meta->mm_geo.next > geo_now), 0)) {
    do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 10692, "meta[%u] next-pageno (%" 
# 10692 "/libmdbx/src/core.c" 3 4
   "u" 
# 10692 "/libmdbx/src/core.c"
   ") is beyond end-pgno (%" 
# 10692 "/libmdbx/src/core.c" 3 4
   "u" 
# 10692 "/libmdbx/src/core.c"
   "), skip it" "\n", meta_number, meta->mm_geo.next, geo_now); } while (0)

                                                         ;
    return MDBX_CORRUPTED;
  }
  if (meta->mm_geo.now != geo_now) {
    do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 10698, "meta[%u] consider geo-%s pageno is %" 
# 10698 "/libmdbx/src/core.c" 3 4
   "u" 
# 10698 "/libmdbx/src/core.c"
   " instead of wrong %" 
# 10698 "/libmdbx/src/core.c" 3 4
   "u" 
# 10698 "/libmdbx/src/core.c"
   ", will be corrected on next commit(s)" "\n", meta_number, "now", geo_now, meta->mm_geo.now); } while (0)


                                                               ;
    meta->mm_geo.now = geo_now;
  }


  if (meta->mm_dbs[0].md_root == (~(pgno_t)0)) {
    if (__builtin_expect(!!(meta->mm_dbs[0].md_branch_pages || meta->mm_dbs[0].md_depth || meta->mm_dbs[0].md_entries || meta->mm_dbs[0].md_leaf_pages || meta->mm_dbs[0].md_overflow_pages), 0)



                                                          ) {
      do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 10712, "meta[%u] has false-empty %s, skip it" "\n", meta_number, "GC"); } while (0);
      return MDBX_CORRUPTED;
    }
  } else if (__builtin_expect(!!(meta->mm_dbs[0].md_root >= meta->mm_geo.next), 0)) {
    do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 10716, "meta[%u] has invalid %s-root %" 
# 10716 "/libmdbx/src/core.c" 3 4
   "u" 
# 10716 "/libmdbx/src/core.c"
   ", skip it" "\n", meta_number, "GC", meta->mm_dbs[0].md_root); } while (0)
                                                                   ;
    return MDBX_CORRUPTED;
  }


  if (meta->mm_dbs[1].md_root == (~(pgno_t)0)) {
    if (__builtin_expect(!!(meta->mm_dbs[1].md_branch_pages || meta->mm_dbs[1].md_depth || meta->mm_dbs[1].md_entries || meta->mm_dbs[1].md_leaf_pages || meta->mm_dbs[1].md_overflow_pages), 0)



                                                          ) {
      do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 10728, "meta[%u] has false-empty %s" "\n", meta_number, "MainDB"); } while (0);
      return MDBX_CORRUPTED;
    }
  } else if (__builtin_expect(!!(meta->mm_dbs[1].md_root >= meta->mm_geo.next), 0)) {
    do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 10732, "meta[%u] has invalid %s-root %" 
# 10732 "/libmdbx/src/core.c" 3 4
   "u" 
# 10732 "/libmdbx/src/core.c"
   ", skip it" "\n", meta_number, "MainDB", meta->mm_dbs[1].md_root); } while (0)
                                                                       ;
    return MDBX_CORRUPTED;
  }

  if (__builtin_expect(!!(meta->mm_dbs[0].md_mod_txnid > txnid), 0)) {
    do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 10738, "meta[%u] has wrong md_mod_txnid %" 
# 10738 "/libmdbx/src/core.c" 3 4
   "l" "i" 
# 10738 "/libmdbx/src/core.c"
   " for %s, skip it" "\n", meta_number, meta->mm_dbs[0].md_mod_txnid, "GC"); } while (0)
                                                                        ;
    return MDBX_CORRUPTED;
  }

  if (__builtin_expect(!!(meta->mm_dbs[1].md_mod_txnid > txnid), 0)) {
    do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 10744, "meta[%u] has wrong md_mod_txnid %" 
# 10744 "/libmdbx/src/core.c" 3 4
   "l" "i" 
# 10744 "/libmdbx/src/core.c"
   " for %s, skip it" "\n", meta_number, meta->mm_dbs[1].md_mod_txnid, "MainDB"); } while (0)
                                                                            ;
    return MDBX_CORRUPTED;
  }

  return MDBX_SUCCESS;
}

static int mdbx_validate_meta_copy(MDBX_env *env, const MDBX_meta *meta,
                                   MDBX_meta *dest) {
  *dest = *meta;
  return mdbx_validate_meta(env, dest, data_page(meta),
                            bytes2pgno(env, (uint8_t *)meta - env->me_dxb_mmap.dxb),
                            
# 10757 "/libmdbx/src/core.c" 3 4
                           ((void *)0)
# 10757 "/libmdbx/src/core.c"
                                  );
}



__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static int mdbx_read_header(MDBX_env *env, MDBX_meta *dest,
                                   const int lck_exclusive,
                                   const mdbx_mode_t mode_bits) {
  int rc = mdbx_filesize(env->me_dxb_mmap.fd, &env->me_dxb_mmap.filesize);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  memset(dest, 0, sizeof(MDBX_meta));
  unaligned_poke_u64(4, dest->mm_datasync_sign, 1u);
  rc = MDBX_CORRUPTED;


  unsigned loop_limit = 3 * 2;

  unsigned guess_pagesize = 0;
  for (unsigned loop_count = 0; loop_count < loop_limit; ++loop_count) {
    const unsigned meta_number = loop_count % 3;
    const unsigned offset = (guess_pagesize ? guess_pagesize
                             : (loop_count > 3) ? env->me_psize
                                                        : env->me_os_psize) *
                            meta_number;

    char buffer[MDBX_MIN_PAGESIZE];
    unsigned retryleft = 42;
    while (1) {
      do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 10787, "reading meta[%d]: offset %u, bytes %u, retry-left %u" "\n", meta_number, offset, MDBX_MIN_PAGESIZE, retryleft); } while (0)
                                                              ;
      int err = mdbx_pread(env->me_dxb_mmap.fd, buffer, MDBX_MIN_PAGESIZE, offset);
      if (err != MDBX_SUCCESS) {
        if (err == MDBX_ENODATA && offset == 0 && loop_count == 0 &&
            env->me_dxb_mmap.filesize == 0 &&
            mode_bits != 0)
          do { if ((MDBX_LOG_NOTICE < MDBX_LOG_VERBOSE && MDBX_LOG_NOTICE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_NOTICE, __func__, 10794, "read meta: empty file (%d, %s)" "\n", err, mdbx_strerror(err)); } while (0)
                                         ;
        else
          do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 10797, "read meta[%u,%u]: %i, %s" "\n", offset, MDBX_MIN_PAGESIZE, err, mdbx_strerror(err)); } while (0)
                                        ;
        return err;
      }

      char again[MDBX_MIN_PAGESIZE];
      err = mdbx_pread(env->me_dxb_mmap.fd, again, MDBX_MIN_PAGESIZE, offset);
      if (err != MDBX_SUCCESS) {
        do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 10805, "read meta[%u,%u]: %i, %s" "\n", offset, MDBX_MIN_PAGESIZE, err, mdbx_strerror(err)); } while (0)
                                      ;
        return err;
      }

      if (memcmp(buffer, again, MDBX_MIN_PAGESIZE) == 0 || --retryleft == 0)
        break;

      do { if ((MDBX_LOG_VERBOSE < MDBX_LOG_VERBOSE && MDBX_LOG_VERBOSE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_VERBOSE, __func__, 10813, "meta[%u] was updated, re-read it" "\n", meta_number); } while (0);
    }

    if (!retryleft) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 10817, "meta[%u] is too volatile, skip it" "\n", meta_number); } while (0);
      continue;
    }

    MDBX_page *const page = (MDBX_page *)buffer;
    MDBX_meta *const meta = page_meta(page);
    rc = mdbx_validate_meta(env, meta, page, meta_number, &guess_pagesize);
    if (rc != MDBX_SUCCESS)
      continue;

    if ((env->me_stuck_meta < 0)
            ? meta_ot(meta_bootid_match(meta) ? prefer_last : prefer_steady,
                      env, dest, meta)
            : (meta_number == (unsigned)env->me_stuck_meta)) {
      *dest = *meta;
      if (!lck_exclusive && !((unaligned_peek_u64_volatile(4, (dest)->mm_datasync_sign)) > 1u))
        loop_limit += 1;
      do { if ((MDBX_LOG_VERBOSE < MDBX_LOG_VERBOSE && MDBX_LOG_VERBOSE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_VERBOSE, __func__, 10834, "latch meta[%u]" "\n", meta_number); } while (0);
    }
  }

  if (dest->mm_dbs[0].md_xsize == 0 ||
      (env->me_stuck_meta < 0 &&
       !(((unaligned_peek_u64_volatile(4, (dest)->mm_datasync_sign)) > 1u) ||
         meta_weak_acceptable(env, dest, lck_exclusive)))) {
    do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 10842, "%s" "\n", "no usable meta-pages, database is corrupted"); } while (0);
    if (rc == MDBX_SUCCESS) {


      return MDBX_CORRUPTED;
    }
    return rc;
  }

  return MDBX_SUCCESS;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static MDBX_page *mdbx_meta_model(const MDBX_env *env, MDBX_page *model,
                                         unsigned num) {
  do { if (__builtin_expect(!!(!(is_powerof2(env->me_psize))), 0)) mdbx_assert_fail(env, "is_powerof2(env->me_psize)", __func__, 10856); } while (0);
  do { if (__builtin_expect(!!(!(env->me_psize >= MDBX_MIN_PAGESIZE)), 0)) mdbx_assert_fail(env, "env->me_psize >= MIN_PAGESIZE", __func__, 10857); } while (0);
  do { if (__builtin_expect(!!(!(env->me_psize <= MDBX_MAX_PAGESIZE)), 0)) mdbx_assert_fail(env, "env->me_psize <= MAX_PAGESIZE", __func__, 10858); } while (0);
  do { if (__builtin_expect(!!(!(env->me_dbgeo.lower >= (MDBX_MIN_PAGESIZE * 3))), 0)) mdbx_assert_fail(env, "env->me_dbgeo.lower >= MIN_MAPSIZE", __func__, 10859); } while (0);
  do { if (__builtin_expect(!!(!(env->me_dbgeo.upper <= ((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE))), 0)) mdbx_assert_fail(env, "env->me_dbgeo.upper <= MAX_MAPSIZE", __func__, 10860); } while (0);
  do { if (__builtin_expect(!!(!(env->me_dbgeo.now >= env->me_dbgeo.lower)), 0)) mdbx_assert_fail(env, "env->me_dbgeo.now >= env->me_dbgeo.lower", __func__, 10861); } while (0);
  do { if (__builtin_expect(!!(!(env->me_dbgeo.now <= env->me_dbgeo.upper)), 0)) mdbx_assert_fail(env, "env->me_dbgeo.now <= env->me_dbgeo.upper", __func__, 10862); } while (0);

  memset(model, 0, env->me_psize);
  model->mp_pgno = num;
  model->mp_flags = 0x08;
  MDBX_meta *const model_meta = page_meta(model);
  unaligned_poke_u64(4, model_meta->mm_magic_and_version, ((0x59659DBDEF4C11UL << 8) + 0 * 64 + 3));

  model_meta->mm_geo.lower = bytes2pgno(env, env->me_dbgeo.lower);
  model_meta->mm_geo.upper = bytes2pgno(env, env->me_dbgeo.upper);
  model_meta->mm_geo.grow_pv = pages2pv(bytes2pgno(env, env->me_dbgeo.grow));
  model_meta->mm_geo.shrink_pv =
      pages2pv(bytes2pgno(env, env->me_dbgeo.shrink));
  model_meta->mm_geo.now = bytes2pgno(env, env->me_dbgeo.now);
  model_meta->mm_geo.next = 3;

  do { if (__builtin_expect(!!(!(model_meta->mm_geo.lower >= 3)), 0)) mdbx_assert_fail(env, "model_meta->mm_geo.lower >= MIN_PAGENO", __func__, 10878); } while (0);
  do { if (__builtin_expect(!!(!(model_meta->mm_geo.upper <= 0x7FFFffffU + 1)), 0)) mdbx_assert_fail(env, "model_meta->mm_geo.upper <= MAX_PAGENO + 1", __func__, 10879); } while (0);
  do { if (__builtin_expect(!!(!(model_meta->mm_geo.now >= model_meta->mm_geo.lower)), 0)) mdbx_assert_fail(env, "model_meta->mm_geo.now >= model_meta->mm_geo.lower", __func__, 10880); } while (0);
  do { if (__builtin_expect(!!(!(model_meta->mm_geo.now <= model_meta->mm_geo.upper)), 0)) mdbx_assert_fail(env, "model_meta->mm_geo.now <= model_meta->mm_geo.upper", __func__, 10881); } while (0);
  do { if (__builtin_expect(!!(!(model_meta->mm_geo.next >= 3)), 0)) mdbx_assert_fail(env, "model_meta->mm_geo.next >= MIN_PAGENO", __func__, 10882); } while (0);
  do { if (__builtin_expect(!!(!(model_meta->mm_geo.next <= model_meta->mm_geo.now)), 0)) mdbx_assert_fail(env, "model_meta->mm_geo.next <= model_meta->mm_geo.now", __func__, 10883); } while (0);
  do { if (__builtin_expect(!!(!(model_meta->mm_geo.grow_pv == pages2pv(pv2pages(model_meta->mm_geo.grow_pv)))), 0)) mdbx_assert_fail(env, "model_meta->mm_geo.grow_pv == pages2pv(pv2pages(model_meta->mm_geo.grow_pv))", __func__, 10884); } while (0)
                                                                      ;
  do { if (__builtin_expect(!!(!(model_meta->mm_geo.shrink_pv == pages2pv(pv2pages(model_meta->mm_geo.shrink_pv)))), 0)) mdbx_assert_fail(env, "model_meta->mm_geo.shrink_pv == pages2pv(pv2pages(model_meta->mm_geo.shrink_pv))", __func__, 10886); } while (0)
                                                                        ;

  model_meta->mm_dbs[0].md_xsize = env->me_psize;
  model_meta->mm_dbs[0].md_flags = MDBX_INTEGERKEY;
  model_meta->mm_dbs[0].md_root = (~(pgno_t)0);
  model_meta->mm_dbs[1].md_root = (~(pgno_t)0);
  meta_set_txnid(env, model_meta, 1UL + num);
  unaligned_poke_u64(4, model_meta->mm_datasync_sign, meta_sign(model_meta));
  do { if ((0)) do { if (__builtin_expect(!!(!(meta_checktxnid(env, model_meta, (1)))), 0)) mdbx_assert_fail(env, "meta_checktxnid(env, model_meta, (1))", __func__, 10895); } while (0); } while (0);
  return (MDBX_page *)((uint8_t *)model + env->me_psize);
}



__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static MDBX_meta *mdbx_init_metas(const MDBX_env *env, void *buffer) {
  MDBX_page *page0 = (MDBX_page *)buffer;
  MDBX_page *page1 = mdbx_meta_model(env, page0, 0);
  MDBX_page *page2 = mdbx_meta_model(env, page1, 1);
  mdbx_meta_model(env, page2, 2);
  do { if ((0)) do { if (__builtin_expect(!!(!(!meta_eq(env, page_meta(page0), page_meta(page1)))), 0)) mdbx_assert_fail(env, "!meta_eq(env, page_meta(page0), page_meta(page1))", __func__, 10906); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(!meta_eq(env, page_meta(page1), page_meta(page2)))), 0)) mdbx_assert_fail(env, "!meta_eq(env, page_meta(page1), page_meta(page2))", __func__, 10907); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(!meta_eq(env, page_meta(page2), page_meta(page0)))), 0)) mdbx_assert_fail(env, "!meta_eq(env, page_meta(page2), page_meta(page0))", __func__, 10908); } while (0); } while (0);
  return page_meta(page2);
}


static size_t mdbx_madvise_threshold(const MDBX_env *env,
                                     const size_t largest_bytes) {

  const unsigned factor = 9;
  const size_t threshold = (largest_bytes < (65536ul << factor))
                               ? 65536
                           : (largest_bytes > (((size_t)1 << 20) * 4 << factor))
                               ? ((size_t)1 << 20) * 4
                               : largest_bytes >> factor;
  return bytes_align2os_bytes(env, threshold);
}


static int mdbx_sync_locked(MDBX_env *env, unsigned flags,
                            MDBX_meta *const pending) {
  do { if ((0)) do { if (__builtin_expect(!!(!(((env->me_flags ^ flags) & MDBX_WRITEMAP) == 0)), 0)) mdbx_assert_fail(env, "((env->me_flags ^ flags) & MDBX_WRITEMAP) == 0", __func__, 10928); } while (0); } while (0);
  const MDBX_meta *const meta0 = page_meta(pgno2page(env, 0));
  const MDBX_meta *const meta1 = page_meta(pgno2page(env, 1));
  const MDBX_meta *const meta2 = page_meta(pgno2page(env, 2));
  const MDBX_meta *const head = constmeta_prefer_last(env);
  int rc;

  do { if ((0)) do { if (__builtin_expect(!!(!(meta_eq_mask(env) == 0)), 0)) mdbx_assert_fail(env, "meta_eq_mask(env) == 0", __func__, 10935); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(pending < page_meta(pgno2page(env, 0)) || pending > page_meta(pgno2page(env, 3)))), 0)) mdbx_assert_fail(env, "pending < page_meta(pgno2page(env, 0)) || pending > page_meta(pgno2page(env, 3))", __func__, 10936); } while (0); } while (0)
                                                                               ;
  do { if ((0)) do { if (__builtin_expect(!!(!((env->me_flags & (MDBX_RDONLY | 0x80000000U)) == 0)), 0)) mdbx_assert_fail(env, "(env->me_flags & (MDBX_RDONLY | 0x80000000U)) == 0", __func__, 10938); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(pending->mm_geo.next <= pending->mm_geo.now)), 0)) mdbx_assert_fail(env, "pending->mm_geo.next <= pending->mm_geo.now", __func__, 10939); } while (0); } while (0);

  if (flags & MDBX_SAFE_NOSYNC) {

    const pgno_t autosync_threshold =
        atomic_load32(&env->me_lck->mti_autosync_threshold, mo_Relaxed);
    const uint64_t autosync_period =
        atomic_load64(&env->me_lck->mti_autosync_period, mo_Relaxed);
    if ((autosync_threshold &&
         atomic_load32(&env->me_lck->mti_unsynced_pages, mo_Relaxed) >=
             autosync_threshold) ||
        (autosync_period &&
         mdbx_osal_monotime() -
                 atomic_load64(&env->me_lck->mti_sync_timestamp, mo_Relaxed) >=
             autosync_period))
      flags &= MDBX_WRITEMAP | 0x40000000U;
  }

  pgno_t shrink = 0;
  if (flags & 0x40000000U) {

    const pgno_t largest_pgno = mdbx_find_largest(
        env, (head->mm_geo.next > pending->mm_geo.next) ? head->mm_geo.next
                                                        : pending->mm_geo.next);
    do { if ((0)) do { if (__builtin_expect(!!(!(largest_pgno >= 3)), 0)) mdbx_assert_fail(env, "largest_pgno >= 3", __func__, 10963); } while (0); } while (0);
# 10977 "/libmdbx/src/core.c"
    const size_t largest_bytes = pgno2bytes(env, largest_pgno);

    const size_t madvise_threshold = mdbx_madvise_threshold(env, largest_bytes);
    const size_t discard_edge_bytes = bytes_align2os_bytes(
        env, ((MDBX_RDONLY &
               (env->me_lck_mmap.lck ? env->me_lck_mmap.lck->mti_envmode.weak
                                     : env->me_flags))
                  ? largest_bytes
                  : largest_bytes + madvise_threshold));
    const pgno_t discard_edge_pgno = bytes2pgno(env, discard_edge_bytes);
    const pgno_t prev_discarded_pgno =
        atomic_load32(&env->me_lck->mti_discarded_tail, mo_Relaxed);
    if (prev_discarded_pgno >=
        discard_edge_pgno + bytes2pgno(env, madvise_threshold)) {
      do { if ((MDBX_LOG_NOTICE < MDBX_LOG_VERBOSE && MDBX_LOG_NOTICE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_NOTICE, __func__, 10991, "open-MADV_%s %u..%u" "\n", "DONTNEED", largest_pgno, prev_discarded_pgno); } while (0)
                                      ;
      atomic_store32(&env->me_lck->mti_discarded_tail, discard_edge_pgno,
                     mo_Relaxed);
      const size_t prev_discarded_bytes =
          ceil_powerof2(pgno2bytes(env, prev_discarded_pgno), env->me_os_psize);
      do { if (__builtin_expect(!!(!(prev_discarded_bytes > discard_edge_bytes)), 0)) mdbx_assert_fail(env, "prev_discarded_bytes > discard_edge_bytes", __func__, 10997); } while (0);

      int advise = 
# 10999 "/libmdbx/src/core.c" 3 4
                  4
# 10999 "/libmdbx/src/core.c"
                               ;






      int err = madvise(env->me_dxb_mmap.dxb + discard_edge_bytes,
                        prev_discarded_bytes - discard_edge_bytes, advise)
                    ? ignore_enosys(
# 11008 "/libmdbx/src/core.c" 3 4
                                   (*__errno_location ())
# 11008 "/libmdbx/src/core.c"
                                        )
                    : MDBX_SUCCESS;





      if (__builtin_expect(!!(((err) != MDBX_RESULT_TRUE && (err) != MDBX_RESULT_FALSE)), 0))
        return err;
    }



    const pgno_t backlog_gap = 3 + pending->mm_dbs[0].md_depth * 3;
    pgno_t shrink_step = 0;
    if (pending->mm_geo.shrink_pv &&
        pending->mm_geo.now - pending->mm_geo.next >
            (shrink_step = pv2pages(pending->mm_geo.shrink_pv)) + backlog_gap) {
      if (pending->mm_geo.now > largest_pgno &&
          pending->mm_geo.now - largest_pgno > shrink_step + backlog_gap) {
        pgno_t grow_step = 0;
        const pgno_t aligner =
            pending->mm_geo.grow_pv
                ? (grow_step = pv2pages(pending->mm_geo.grow_pv))
                : shrink_step;
        const pgno_t with_backlog_gap = largest_pgno + backlog_gap;
        const pgno_t aligned = pgno_align2os_pgno(
            env, with_backlog_gap + aligner - with_backlog_gap % aligner);
        const pgno_t bottom =
            (aligned > pending->mm_geo.lower) ? aligned : pending->mm_geo.lower;
        if (pending->mm_geo.now > bottom) {
          if (((unaligned_peek_u64_volatile(4, (meta_prefer_steady(env))->mm_datasync_sign)) > 1u))

            flags &= MDBX_WRITEMAP | 0x40000000U;
          shrink = pending->mm_geo.now - bottom;
          pending->mm_geo.now = bottom;
          if (__builtin_expect(!!(constmeta_txnid(env, head) == unaligned_peek_u64(4, pending->mm_txnid_a)), 0)
                                                                  ) {
            const txnid_t txnid =
                safe64_txnid_next(unaligned_peek_u64(4, pending->mm_txnid_a));
            do { if ((MDBX_LOG_NOTICE < MDBX_LOG_VERBOSE && MDBX_LOG_NOTICE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_NOTICE, __func__, 11048, "force-forward pending-txn %" 
# 11048 "/libmdbx/src/core.c" 3 4
           "l" "i" 
# 11048 "/libmdbx/src/core.c"
           " -> %" 
# 11048 "/libmdbx/src/core.c" 3 4
           "l" "i" 
# 11048 "/libmdbx/src/core.c"
           "\n", unaligned_peek_u64(4, pending->mm_txnid_a), txnid); } while (0)
                                                                          ;
            do { if (__builtin_expect(!!(!(env->me_txn0->mt_owner != mdbx_thread_self() && !env->me_txn)), 0)) mdbx_assert_fail(env, "env->me_txn0->mt_owner != mdbx_thread_self() && !env->me_txn", __func__, 11050); } while (0)
                                              ;
            if (__builtin_expect(!!(txnid > (0xffffFFFF00000000UL - 1)), 0)) {
              rc = MDBX_TXN_FULL;
              do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 11054, "txnid overflow, raise %d" "\n", rc); } while (0);
              goto fail;
            }
            meta_set_txnid(env, pending, txnid);
            do { if ((0)) do { if (__builtin_expect(!!(!(meta_checktxnid(env, pending, (1)))), 0)) mdbx_assert_fail(env, "meta_checktxnid(env, pending, (1))", __func__, 11058); } while (0); } while (0);
          }
        }
      }
    }
  }


  rc = MDBX_RESULT_FALSE ;
  if (atomic_load32(&env->me_lck->mti_unsynced_pages, mo_Relaxed)) {
    do { if ((0)) do { if (__builtin_expect(!!(!(((flags ^ env->me_flags) & MDBX_WRITEMAP) == 0)), 0)) mdbx_assert_fail(env, "((flags ^ env->me_flags) & MDBX_WRITEMAP) == 0", __func__, 11068); } while (0); } while (0);
    enum mdbx_syncmode_bits mode_bits = MDBX_SYNC_NONE;
    if ((flags & MDBX_SAFE_NOSYNC) == 0) {
      mode_bits = MDBX_SYNC_DATA;
      if (pending->mm_geo.next > meta_prefer_steady(env)->mm_geo.now)
        mode_bits |= MDBX_SYNC_SIZE;
      if (flags & MDBX_NOMETASYNC)
        mode_bits |= MDBX_SYNC_IODQ;
    }

    env->me_lck->mti_pgop_stat.wops.weak += 1;

    if (flags & MDBX_WRITEMAP)
      rc =
          mdbx_msync(&env->me_dxb_mmap, 0,
                     pgno_align2os_bytes(env, pending->mm_geo.next), mode_bits);
    else
      rc = mdbx_fsync(env->me_dxb_mmap.fd, mode_bits);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      goto fail;
    rc = (flags & MDBX_SAFE_NOSYNC) ? MDBX_RESULT_TRUE
                                    : MDBX_RESULT_FALSE ;
  }
  do { if ((0)) do { if (__builtin_expect(!!(!(meta_checktxnid(env, pending, (1)))), 0)) mdbx_assert_fail(env, "meta_checktxnid(env, pending, (1))", __func__, 11091); } while (0); } while (0);


  if (rc == MDBX_RESULT_FALSE ) {
    atomic_store64(&env->me_lck->mti_sync_timestamp, mdbx_osal_monotime(),
                   mo_Relaxed);
    unaligned_poke_u64(4, pending->mm_datasync_sign, meta_sign(pending));
    atomic_store32(&env->me_lck->mti_unsynced_pages, 0, mo_Relaxed);
  } else {
    do { if ((0)) do { if (__builtin_expect(!!(!(rc == MDBX_RESULT_TRUE)), 0)) mdbx_assert_fail(
# 11100 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 11100 "/libmdbx/src/core.c"
   , "rc == MDBX_RESULT_TRUE", __func__, 11100); } while (0); } while (0);
    unaligned_poke_u64(4, pending->mm_datasync_sign, 1u);
  }

  MDBX_meta *target = 
# 11104 "/libmdbx/src/core.c" 3 4
                     ((void *)0)
# 11104 "/libmdbx/src/core.c"
                            ;
  if (constmeta_txnid(env, head) ==
      unaligned_peek_u64(4, pending->mm_txnid_a)) {
    do { if ((0)) do { if (__builtin_expect(!!(!(memcmp(&head->mm_dbs, &pending->mm_dbs, sizeof(head->mm_dbs)) == 0)), 0)) mdbx_assert_fail(env, "memcmp(&head->mm_dbs, &pending->mm_dbs, sizeof(head->mm_dbs)) == 0", __func__, 11107); } while (0); } while (0)
                                                       ;
    do { if ((0)) do { if (__builtin_expect(!!(!(memcmp(&head->mm_canary, &pending->mm_canary, sizeof(head->mm_canary)) == 0)), 0)) mdbx_assert_fail(env, "memcmp(&head->mm_canary, &pending->mm_canary, sizeof(head->mm_canary)) == 0", __func__, 11109); } while (0); } while (0)
                                                          ;
    do { if ((0)) do { if (__builtin_expect(!!(!(memcmp(&head->mm_geo, &pending->mm_geo, sizeof(pending->mm_geo)) == 0)), 0)) mdbx_assert_fail(env, "memcmp(&head->mm_geo, &pending->mm_geo, sizeof(pending->mm_geo)) == 0", __func__, 11111); } while (0); } while (0)
                                                          ;
    if (!((unaligned_peek_u64_volatile(4, (head)->mm_datasync_sign)) > 1u) && ((unaligned_peek_u64_volatile(4, (pending)->mm_datasync_sign)) > 1u))
      target = (MDBX_meta *)head;
    else {
      do { if (__builtin_expect(!!(!(meta_eq(env, head, pending))), 0)) mdbx_assert_fail(env, "meta_eq(env, head, pending)", __func__, 11116); } while (0);
      do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 11117, "%s" "\n", "skip update meta"); } while (0);
      return MDBX_SUCCESS;
    }
  } else if (head == meta0)
    target = (MDBX_meta *)meta_ancient_prefer_weak(env, meta1, meta2);
  else if (head == meta1)
    target = (MDBX_meta *)meta_ancient_prefer_weak(env, meta0, meta2);
  else {
    do { if ((0)) do { if (__builtin_expect(!!(!(head == meta2)), 0)) mdbx_assert_fail(env, "head == meta2", __func__, 11125); } while (0); } while (0);
    target = (MDBX_meta *)meta_ancient_prefer_weak(env, meta0, meta1);
  }


  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 11130, "writing meta%" 
# 11130 "/libmdbx/src/core.c" 3 4
 "u" 
# 11130 "/libmdbx/src/core.c"
 " = root %" 
# 11130 "/libmdbx/src/core.c" 3 4
 "u" 
# 11130 "/libmdbx/src/core.c"
 "/%" 
# 11130 "/libmdbx/src/core.c" 3 4
 "u" 
# 11130 "/libmdbx/src/core.c"
 ", geo %" 
# 11130 "/libmdbx/src/core.c" 3 4
 "u" 
# 11130 "/libmdbx/src/core.c"
 "/%" 
# 11130 "/libmdbx/src/core.c" 3 4
 "u" 
# 11130 "/libmdbx/src/core.c"
 "-%" 
# 11130 "/libmdbx/src/core.c" 3 4
 "u" 
# 11130 "/libmdbx/src/core.c"
 "/%" 
# 11130 "/libmdbx/src/core.c" 3 4
 "u" 
# 11130 "/libmdbx/src/core.c"
 " +%u -%u, txn_id %" 
# 11130 "/libmdbx/src/core.c" 3 4
 "l" "i" 
# 11130 "/libmdbx/src/core.c"
 ", %s" "\n", data_page(target)->mp_pgno, pending->mm_dbs[1].md_root, pending->mm_dbs[0].md_root, pending->mm_geo.lower, pending->mm_geo.next, pending->mm_geo.now, pending->mm_geo.upper, pv2pages(pending->mm_geo.grow_pv), pv2pages(pending->mm_geo.shrink_pv), unaligned_peek_u64(4, pending->mm_txnid_a), mdbx_durable_str(pending)); } while (0)







                                                                            ;

  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 11140, "meta0: %s, %s, txn_id %" 
# 11140 "/libmdbx/src/core.c" 3 4
 "l" "i" 
# 11140 "/libmdbx/src/core.c"
 ", root %" 
# 11140 "/libmdbx/src/core.c" 3 4
 "u" 
# 11140 "/libmdbx/src/core.c"
 "/%" 
# 11140 "/libmdbx/src/core.c" 3 4
 "u" 
# 11140 "/libmdbx/src/core.c"
 "\n", (meta0 == head) ? "head" : (meta0 == target) ? "tail" : "stay", mdbx_durable_str(meta0), meta_txnid(env, meta0), meta0->mm_dbs[1].md_root, meta0->mm_dbs[0].md_root); } while (0)





                                                                              ;
  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 11147, "meta1: %s, %s, txn_id %" 
# 11147 "/libmdbx/src/core.c" 3 4
 "l" "i" 
# 11147 "/libmdbx/src/core.c"
 ", root %" 
# 11147 "/libmdbx/src/core.c" 3 4
 "u" 
# 11147 "/libmdbx/src/core.c"
 "/%" 
# 11147 "/libmdbx/src/core.c" 3 4
 "u" 
# 11147 "/libmdbx/src/core.c"
 "\n", (meta1 == head) ? "head" : (meta1 == target) ? "tail" : "stay", mdbx_durable_str(meta1), meta_txnid(env, meta1), meta1->mm_dbs[1].md_root, meta1->mm_dbs[0].md_root); } while (0)





                                                                              ;
  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 11154, "meta2: %s, %s, txn_id %" 
# 11154 "/libmdbx/src/core.c" 3 4
 "l" "i" 
# 11154 "/libmdbx/src/core.c"
 ", root %" 
# 11154 "/libmdbx/src/core.c" 3 4
 "u" 
# 11154 "/libmdbx/src/core.c"
 "/%" 
# 11154 "/libmdbx/src/core.c" 3 4
 "u" 
# 11154 "/libmdbx/src/core.c"
 "\n", (meta2 == head) ? "head" : (meta2 == target) ? "tail" : "stay", mdbx_durable_str(meta2), meta_txnid(env, meta2), meta2->mm_dbs[1].md_root, meta2->mm_dbs[0].md_root); } while (0)





                                                                              ;

  do { if ((0)) do { if (__builtin_expect(!!(!(!meta_eq(env, pending, meta0))), 0)) mdbx_assert_fail(env, "!meta_eq(env, pending, meta0)", __func__, 11162); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(!meta_eq(env, pending, meta1))), 0)) mdbx_assert_fail(env, "!meta_eq(env, pending, meta1)", __func__, 11163); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(!meta_eq(env, pending, meta2))), 0)) mdbx_assert_fail(env, "!meta_eq(env, pending, meta2)", __func__, 11164); } while (0); } while (0);

  do { if ((0)) do { if (__builtin_expect(!!(!(((env->me_flags ^ flags) & MDBX_WRITEMAP) == 0)), 0)) mdbx_assert_fail(env, "((env->me_flags ^ flags) & MDBX_WRITEMAP) == 0", __func__, 11166); } while (0); } while (0);
  do { if (__builtin_expect(!!(!(target == head || constmeta_txnid(env, target) < unaligned_peek_u64(4, pending->mm_txnid_a))), 0)) mdbx_assert_fail(env, "target == head || constmeta_txnid(env, target) < unaligned_peek_u64(4, pending->mm_txnid_a)", __func__, 11167); } while (0)

                                                                               ;

  env->me_lck->mti_pgop_stat.wops.weak += 1;

  if (flags & MDBX_WRITEMAP) {
    mdbx_jitter4testing((1));
    if (__builtin_expect(!!(target != head), 1)) {

      meta_update_begin(env, target,
                        unaligned_peek_u64(4, pending->mm_txnid_a));
      unaligned_poke_u64(4, target->mm_datasync_sign, 1u);
# 11190 "/libmdbx/src/core.c"
      target->mm_geo = pending->mm_geo;
      target->mm_dbs[0] = pending->mm_dbs[0];
      target->mm_dbs[1] = pending->mm_dbs[1];
      target->mm_canary = pending->mm_canary;
      memcpy(target->mm_pages_retired, pending->mm_pages_retired, 8);
      mdbx_jitter4testing((1));


      meta_update_end(env, target, unaligned_peek_u64(4, pending->mm_txnid_b));
      mdbx_jitter4testing((1));
      do { if ((0)) do { if (__builtin_expect(!!(!(meta_checktxnid(env, target, (1)))), 0)) mdbx_assert_fail(env, "meta_checktxnid(env, target, (1))", __func__, 11200); } while (0); } while (0);
    } else {


      do { if (__builtin_expect(!!(!(constmeta_txnid(env, head) == unaligned_peek_u64(4, pending->mm_txnid_a) && !((unaligned_peek_u64_volatile(4, (head)->mm_datasync_sign)) > 1u) && ((unaligned_peek_u64_volatile(4, (pending)->mm_datasync_sign)) > 1u))), 0)) mdbx_assert_fail(env, "constmeta_txnid(env, head) == unaligned_peek_u64(4, pending->mm_txnid_a) && !META_IS_STEADY(head) && META_IS_STEADY(pending)", __func__, 11204); } while (0)

                                                                            ;
      do { if (__builtin_expect(!!(!(memcmp(&head->mm_geo, &pending->mm_geo, sizeof(head->mm_geo)) == 0)), 0)) mdbx_assert_fail(env, "memcmp(&head->mm_geo, &pending->mm_geo, sizeof(head->mm_geo)) == 0", __func__, 11207); } while (0)
                                                         ;
      do { if (__builtin_expect(!!(!(memcmp(&head->mm_dbs, &pending->mm_dbs, sizeof(head->mm_dbs)) == 0)), 0)) mdbx_assert_fail(env, "memcmp(&head->mm_dbs, &pending->mm_dbs, sizeof(head->mm_dbs)) == 0", __func__, 11209); } while (0)
                                                         ;
      do { if (__builtin_expect(!!(!(memcmp(&head->mm_canary, &pending->mm_canary, sizeof(head->mm_canary)) == 0)), 0)) mdbx_assert_fail(env, "memcmp(&head->mm_canary, &pending->mm_canary, sizeof(head->mm_canary)) == 0", __func__, 11211); } while (0)
                                                            ;
    }
    memcpy(target->mm_datasync_sign, pending->mm_datasync_sign, 8);
    mdbx_memory_barrier();
    mdbx_jitter4testing((1));

    rc =
        mdbx_msync(&env->me_dxb_mmap, 0, pgno_align2os_bytes(env, 3),
                   (flags & MDBX_NOMETASYNC) ? MDBX_SYNC_NONE
                                             : MDBX_SYNC_DATA | MDBX_SYNC_IODQ);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      goto fail;
  } else {
    const MDBX_meta undo_meta = *target;
    const mdbx_filehandle_t fd = (env->me_dsync_fd != (-1))
                                     ? env->me_dsync_fd
                                     : env->me_dxb_mmap.fd;

    env->me_lck->mti_pgop_stat.wops.weak += 1;

    rc = mdbx_pwrite(fd, pending, sizeof(MDBX_meta),
                     (uint8_t *)target - env->me_dxb_mmap.dxb);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0)) {
    undo:
      do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 11236, "%s" "\n", "write failed, disk error?"); } while (0);


      mdbx_pwrite(fd, &undo_meta, sizeof(MDBX_meta),
                  (uint8_t *)target - env->me_dxb_mmap.dxb);
      goto fail;
    }
    mdbx_flush_incoherent_mmap(target, sizeof(MDBX_meta), env->me_os_psize);

    if ((flags & MDBX_NOMETASYNC) == 0 && fd == env->me_dxb_mmap.fd) {
      rc = mdbx_fsync(env->me_dxb_mmap.fd, MDBX_SYNC_DATA | MDBX_SYNC_IODQ);
      if (rc != MDBX_SUCCESS)
        goto undo;
    }
    do { if ((0)) do { if (__builtin_expect(!!(!(meta_checktxnid(env, target, (1)))), 0)) mdbx_assert_fail(env, "meta_checktxnid(env, target, (1))", __func__, 11250); } while (0); } while (0);
  }
  env->me_lck->mti_meta_sync_txnid.weak =
      (uint32_t)unaligned_peek_u64(4, pending->mm_txnid_a) -
      ((flags & MDBX_NOMETASYNC) ? 
# 11254 "/libmdbx/src/core.c" 3 4
                                  (4294967295U) 
# 11254 "/libmdbx/src/core.c"
                                             / 3 : 0);


  if (__builtin_expect(!!(shrink), 0)) {
    do { if ((MDBX_LOG_VERBOSE < MDBX_LOG_VERBOSE && MDBX_LOG_VERBOSE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_VERBOSE, __func__, 11258, "shrink to %" 
# 11258 "/libmdbx/src/core.c" 3 4
   "u" 
# 11258 "/libmdbx/src/core.c"
   " pages (-%" 
# 11258 "/libmdbx/src/core.c" 3 4
   "u" 
# 11258 "/libmdbx/src/core.c"
   ")" "\n", pending->mm_geo.now, shrink); } while (0)
                                             ;
    rc = mdbx_mapresize_implicit(env, pending->mm_geo.next, pending->mm_geo.now,
                                 pending->mm_geo.upper);
    if (rc != MDBX_SUCCESS && rc != MDBX_EPERM)
      goto fail;
    do { if ((0)) do { if (__builtin_expect(!!(!(meta_checktxnid(env, target, (1)))), 0)) mdbx_assert_fail(env, "meta_checktxnid(env, target, (1))", __func__, 11264); } while (0); } while (0);
  }

  MDBX_lockinfo *const lck = env->me_lck_mmap.lck;
  if (__builtin_expect(!!(lck), 1))

    atomic_store32(&lck->mti_readers_refresh_flag, (0), mo_Relaxed);

  return MDBX_SUCCESS;

fail:
  env->me_flags |= 0x80000000U;
  return rc;
}

static void recalculate_merge_threshold(MDBX_env *env) {
  const unsigned bytes = page_space(env);
  env->me_merge_threshold =
      (uint16_t)(bytes -
                 (bytes * env->me_options.merge_threshold_16dot16_percent >>
                  16));
  env->me_merge_threshold_gc =
      (uint16_t)(bytes -
                 ((env->me_options.merge_threshold_16dot16_percent > 19005)
                      ? bytes / 3
                      : bytes / 4 ));
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static void mdbx_setup_pagesize(MDBX_env *env, const size_t pagesize) {
  _Static_assert(
# 11293 "/libmdbx/src/core.c" 3 4
 (9223372036854775807L) 
# 11293 "/libmdbx/src/core.c"
 > ((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE), "PTRDIFF_MAX > MAX_MAPSIZE");
  _Static_assert(MDBX_MIN_PAGESIZE > sizeof(MDBX_page) + sizeof(MDBX_meta), "MIN_PAGESIZE > sizeof(MDBX_page) + sizeof(MDBX_meta)");
  do { if (__builtin_expect(!!(!(is_powerof2(pagesize))), 0)) mdbx_assert_fail(env, "is_powerof2(pagesize)", __func__, 11295); } while (0);
  do { if (__builtin_expect(!!(!(pagesize >= MDBX_MIN_PAGESIZE)), 0)) mdbx_assert_fail(env, "pagesize >= MIN_PAGESIZE", __func__, 11296); } while (0);
  do { if (__builtin_expect(!!(!(pagesize <= MDBX_MAX_PAGESIZE)), 0)) mdbx_assert_fail(env, "pagesize <= MAX_PAGESIZE", __func__, 11297); } while (0);
  env->me_psize = (unsigned)pagesize;
  if (env->me_pbuf) {
    mdbx_memalign_free(env->me_pbuf);
    env->me_pbuf = 
# 11301 "/libmdbx/src/core.c" 3 4
                  ((void *)0)
# 11301 "/libmdbx/src/core.c"
                         ;
  }

  _Static_assert((((MDBX_MIN_PAGESIZE)-((unsigned)
# 11304 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 11304 "/libmdbx/src/core.c"
 MDBX_page
# 11304 "/libmdbx/src/core.c" 3 4
 , 
# 11304 "/libmdbx/src/core.c"
 mp_ptrs
# 11304 "/libmdbx/src/core.c" 3 4
 )
# 11304 "/libmdbx/src/core.c"
 )) / sizeof(pgno_t) - 1) > 4, "MAX_GC1OVPAGE(MIN_PAGESIZE) > 4");
  _Static_assert((((MDBX_MAX_PAGESIZE)-((unsigned)
# 11305 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 11305 "/libmdbx/src/core.c"
 MDBX_page
# 11305 "/libmdbx/src/core.c" 3 4
 , 
# 11305 "/libmdbx/src/core.c"
 mp_ptrs
# 11305 "/libmdbx/src/core.c" 3 4
 )
# 11305 "/libmdbx/src/core.c"
 )) / sizeof(pgno_t) - 1) < ((size_t)0x7FFFffffU), "MAX_GC1OVPAGE(MAX_PAGESIZE) < MDBX_PGL_LIMIT");
  const intptr_t maxgc_ov1page = (pagesize - ((unsigned)
# 11306 "/libmdbx/src/core.c" 3 4
                                            __builtin_offsetof (
# 11306 "/libmdbx/src/core.c"
                                            MDBX_page
# 11306 "/libmdbx/src/core.c" 3 4
                                            , 
# 11306 "/libmdbx/src/core.c"
                                            mp_ptrs
# 11306 "/libmdbx/src/core.c" 3 4
                                            )
# 11306 "/libmdbx/src/core.c"
                                            )) / sizeof(pgno_t) - 1;
  do { if (__builtin_expect(!!(!(maxgc_ov1page > 42 && maxgc_ov1page < (intptr_t)((size_t)0x7FFFffffU) / 4)), 0)) mdbx_assert_fail(env, "maxgc_ov1page > 42 && maxgc_ov1page < (intptr_t)MDBX_PGL_LIMIT / 4", __func__, 11307); } while (0)
                                                                    ;
  env->me_maxgc_ov1page = (unsigned)maxgc_ov1page;

  _Static_assert((((((MDBX_MIN_PAGESIZE)-((unsigned)
# 11311 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 11311 "/libmdbx/src/core.c"
 MDBX_page
# 11311 "/libmdbx/src/core.c" 3 4
 , 
# 11311 "/libmdbx/src/core.c"
 mp_ptrs
# 11311 "/libmdbx/src/core.c" 3 4
 )
# 11311 "/libmdbx/src/core.c"
 )) / 2) & ~(size_t)1) - sizeof(indx_t)) > sizeof(MDBX_db) + 
# 11311 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 11311 "/libmdbx/src/core.c"
 MDBX_node
# 11311 "/libmdbx/src/core.c" 3 4
 , 
# 11311 "/libmdbx/src/core.c"
 mn_data
# 11311 "/libmdbx/src/core.c" 3 4
 ) 
# 11311 "/libmdbx/src/core.c"
 + 42, "LEAF_NODE_MAX(MIN_PAGESIZE) > sizeof(MDBX_db) + NODESIZE + 42");
  _Static_assert((((((MDBX_MAX_PAGESIZE)-((unsigned)
# 11312 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 11312 "/libmdbx/src/core.c"
 MDBX_page
# 11312 "/libmdbx/src/core.c" 3 4
 , 
# 11312 "/libmdbx/src/core.c"
 mp_ptrs
# 11312 "/libmdbx/src/core.c" 3 4
 )
# 11312 "/libmdbx/src/core.c"
 )) / 2) & ~(size_t)1) - sizeof(indx_t)) < 
# 11312 "/libmdbx/src/core.c" 3 4
 (65535)
# 11312 "/libmdbx/src/core.c"
 , "LEAF_NODE_MAX(MAX_PAGESIZE) < UINT16_MAX");
  _Static_assert((((((MDBX_MIN_PAGESIZE)-((unsigned)
# 11313 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 11313 "/libmdbx/src/core.c"
 MDBX_page
# 11313 "/libmdbx/src/core.c" 3 4
 , 
# 11313 "/libmdbx/src/core.c"
 mp_ptrs
# 11313 "/libmdbx/src/core.c" 3 4
 )
# 11313 "/libmdbx/src/core.c"
 )) / 2) & ~(size_t)1) - sizeof(indx_t)) >= ((((((MDBX_MIN_PAGESIZE)-((unsigned)
# 11313 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 11313 "/libmdbx/src/core.c"
 MDBX_page
# 11313 "/libmdbx/src/core.c" 3 4
 , 
# 11313 "/libmdbx/src/core.c"
 mp_ptrs
# 11313 "/libmdbx/src/core.c" 3 4
 )
# 11313 "/libmdbx/src/core.c"
 )) - sizeof(indx_t) - 
# 11313 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 11313 "/libmdbx/src/core.c"
 MDBX_node
# 11313 "/libmdbx/src/core.c" 3 4
 , 
# 11313 "/libmdbx/src/core.c"
 mn_data
# 11313 "/libmdbx/src/core.c" 3 4
 )
# 11313 "/libmdbx/src/core.c"
 ) / (3 - 1) - sizeof(indx_t)) & ~(size_t)1)), "LEAF_NODE_MAX(MIN_PAGESIZE) >= BRANCH_NODE_MAX(MIN_PAGESIZE)");
  _Static_assert(((((((MDBX_MAX_PAGESIZE)-((unsigned)
# 11314 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 11314 "/libmdbx/src/core.c"
 MDBX_page
# 11314 "/libmdbx/src/core.c" 3 4
 , 
# 11314 "/libmdbx/src/core.c"
 mp_ptrs
# 11314 "/libmdbx/src/core.c" 3 4
 )
# 11314 "/libmdbx/src/core.c"
 )) - sizeof(indx_t) - 
# 11314 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 11314 "/libmdbx/src/core.c"
 MDBX_node
# 11314 "/libmdbx/src/core.c" 3 4
 , 
# 11314 "/libmdbx/src/core.c"
 mn_data
# 11314 "/libmdbx/src/core.c" 3 4
 )
# 11314 "/libmdbx/src/core.c"
 ) / (3 - 1) - sizeof(indx_t)) & ~(size_t)1)) > 
# 11314 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 11314 "/libmdbx/src/core.c"
 MDBX_node
# 11314 "/libmdbx/src/core.c" 3 4
 , 
# 11314 "/libmdbx/src/core.c"
 mn_data
# 11314 "/libmdbx/src/core.c" 3 4
 ) 
# 11314 "/libmdbx/src/core.c"
 + 42, "BRANCH_NODE_MAX(MAX_PAGESIZE) > NODESIZE + 42");
  _Static_assert(((((((MDBX_MAX_PAGESIZE)-((unsigned)
# 11315 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 11315 "/libmdbx/src/core.c"
 MDBX_page
# 11315 "/libmdbx/src/core.c" 3 4
 , 
# 11315 "/libmdbx/src/core.c"
 mp_ptrs
# 11315 "/libmdbx/src/core.c" 3 4
 )
# 11315 "/libmdbx/src/core.c"
 )) - sizeof(indx_t) - 
# 11315 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 11315 "/libmdbx/src/core.c"
 MDBX_node
# 11315 "/libmdbx/src/core.c" 3 4
 , 
# 11315 "/libmdbx/src/core.c"
 mn_data
# 11315 "/libmdbx/src/core.c" 3 4
 )
# 11315 "/libmdbx/src/core.c"
 ) / (3 - 1) - sizeof(indx_t)) & ~(size_t)1)) < 
# 11315 "/libmdbx/src/core.c" 3 4
 (65535)
# 11315 "/libmdbx/src/core.c"
 , "BRANCH_NODE_MAX(MAX_PAGESIZE) < UINT16_MAX");
  const intptr_t branch_nodemax = ((((((pagesize)-((unsigned)
# 11316 "/libmdbx/src/core.c" 3 4
                                 __builtin_offsetof (
# 11316 "/libmdbx/src/core.c"
                                 MDBX_page
# 11316 "/libmdbx/src/core.c" 3 4
                                 , 
# 11316 "/libmdbx/src/core.c"
                                 mp_ptrs
# 11316 "/libmdbx/src/core.c" 3 4
                                 )
# 11316 "/libmdbx/src/core.c"
                                 )) - sizeof(indx_t) - 
# 11316 "/libmdbx/src/core.c" 3 4
                                 __builtin_offsetof (
# 11316 "/libmdbx/src/core.c"
                                 MDBX_node
# 11316 "/libmdbx/src/core.c" 3 4
                                 , 
# 11316 "/libmdbx/src/core.c"
                                 mn_data
# 11316 "/libmdbx/src/core.c" 3 4
                                 )
# 11316 "/libmdbx/src/core.c"
                                 ) / (3 - 1) - sizeof(indx_t)) & ~(size_t)1));
  const intptr_t leaf_nodemax = (((((pagesize)-((unsigned)
# 11317 "/libmdbx/src/core.c" 3 4
                               __builtin_offsetof (
# 11317 "/libmdbx/src/core.c"
                               MDBX_page
# 11317 "/libmdbx/src/core.c" 3 4
                               , 
# 11317 "/libmdbx/src/core.c"
                               mp_ptrs
# 11317 "/libmdbx/src/core.c" 3 4
                               )
# 11317 "/libmdbx/src/core.c"
                               )) / 2) & ~(size_t)1) - sizeof(indx_t));
  do { if (__builtin_expect(!!(!(branch_nodemax > (intptr_t)(
# 11318 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 11318 "/libmdbx/src/core.c"
 MDBX_node
# 11318 "/libmdbx/src/core.c" 3 4
 , 
# 11318 "/libmdbx/src/core.c"
 mn_data
# 11318 "/libmdbx/src/core.c" 3 4
 ) 
# 11318 "/libmdbx/src/core.c"
 + 42) && branch_nodemax % 2 == 0 && leaf_nodemax > (intptr_t)(sizeof(MDBX_db) + 
# 11318 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 11318 "/libmdbx/src/core.c"
 MDBX_node
# 11318 "/libmdbx/src/core.c" 3 4
 , 
# 11318 "/libmdbx/src/core.c"
 mn_data
# 11318 "/libmdbx/src/core.c" 3 4
 ) 
# 11318 "/libmdbx/src/core.c"
 + 42) && leaf_nodemax >= branch_nodemax && leaf_nodemax < (int)
# 11318 "/libmdbx/src/core.c" 3 4
 (65535) 
# 11318 "/libmdbx/src/core.c"
 && leaf_nodemax % 2 == 0)), 0)) mdbx_assert_fail(env, "branch_nodemax > (intptr_t)(NODESIZE + 42) && branch_nodemax % 2 == 0 && leaf_nodemax > (intptr_t)(sizeof(MDBX_db) + NODESIZE + 42) && leaf_nodemax >= branch_nodemax && leaf_nodemax < (int)UINT16_MAX && leaf_nodemax % 2 == 0", __func__, 11318); } while (0)




                                                                          ;
  env->me_leaf_nodemax = (unsigned)leaf_nodemax;
  env->me_psize2log = (uint8_t)log2n_powerof2(pagesize);
  do { if ((0)) do { if (__builtin_expect(!!(!(pgno2bytes(env, 1) == pagesize)), 0)) mdbx_assert_fail(env, "pgno2bytes(env, 1) == pagesize", __func__, 11326); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(bytes2pgno(env, pagesize + pagesize) == 2)), 0)) mdbx_assert_fail(env, "bytes2pgno(env, pagesize + pagesize) == 2", __func__, 11327); } while (0); } while (0);
  recalculate_merge_threshold(env);

  const pgno_t max_pgno = bytes2pgno(env, ((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE));
  if (!env->me_options.flags.non_auto.dp_limit) {

    intptr_t total_ram_pages, avail_ram_pages;
    int err = mdbx_get_sysraminfo(
# 11334 "/libmdbx/src/core.c" 3 4
                                 ((void *)0)
# 11334 "/libmdbx/src/core.c"
                                        , &total_ram_pages, &avail_ram_pages);
    if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 11336, "mdbx_get_sysraminfo(), rc %d" "\n", err); } while (0);
    else {
      size_t reasonable_dpl_limit =
          (size_t)(total_ram_pages + avail_ram_pages) / 42;
      if (pagesize > env->me_os_psize)
        reasonable_dpl_limit /= pagesize / env->me_os_psize;
      else if (pagesize < env->me_os_psize)
        reasonable_dpl_limit *= env->me_os_psize / pagesize;
      reasonable_dpl_limit = (reasonable_dpl_limit < ((size_t)0x7FFFffffU))
                                 ? reasonable_dpl_limit
                                 : ((size_t)0x7FFFffffU);
      reasonable_dpl_limit = (reasonable_dpl_limit > 32 * 4)
                                 ? reasonable_dpl_limit
                                 : 32 * 4;
      env->me_options.dp_limit = (unsigned)reasonable_dpl_limit;
    }
  }
  if (env->me_options.dp_limit > max_pgno - 3)
    env->me_options.dp_limit = max_pgno - 3;
  if (env->me_options.dp_initial > env->me_options.dp_limit)
    env->me_options.dp_initial = env->me_options.dp_limit;
}

static __inline __attribute__((__const__)) MDBX_lockinfo *
lckless_stub(const MDBX_env *env) {
  uintptr_t stub = (uintptr_t)&env->x_lckless_stub;

  stub = (stub + 64 - 1) & ~(64 - 1);
  return (MDBX_lockinfo *)stub;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_create(MDBX_env **penv) {
  MDBX_env *env = calloc(1, sizeof(MDBX_env));
  if (__builtin_expect(!!(!env), 0))
    return MDBX_ENOMEM;

  env->me_maxreaders = 61;
  env->me_maxdbs = env->me_numdbs = 2;
  env->me_dxb_mmap.fd = (-1);
  env->me_dsync_fd = (-1);
  env->me_lck_mmap.fd = (-1);
  env->me_pid = mdbx_getpid();
  env->me_stuck_meta = -1;

  env->me_options.dp_reserve_limit = 1024;
  env->me_options.rp_augment_limit = 256 * 1024;
  env->me_options.dp_limit = 64 * 1024;
  if (env->me_options.dp_limit > 0x7FFFffffU + 1 - 3)
    env->me_options.dp_limit = 0x7FFFffffU + 1 - 3;
  env->me_options.dp_initial = (1024 - 2 - (8 * 2u) / sizeof(pgno_t));
  if (env->me_options.dp_initial > env->me_options.dp_limit)
    env->me_options.dp_initial = env->me_options.dp_limit;
  env->me_options.spill_max_denominator = 8;
  env->me_options.spill_min_denominator = 8;
  env->me_options.spill_parent4child_denominator = 0;
  env->me_options.dp_loose_limit = 64;
  env->me_options.merge_threshold_16dot16_percent = 65536 / 4 ;

  int rc;
  const size_t os_psize = mdbx_syspagesize();
  if (__builtin_expect(!!(!is_powerof2(os_psize) || os_psize < MDBX_MIN_PAGESIZE), 0)) {
    do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 11397, "unsuitable system pagesize %" 
# 11397 "/libmdbx/src/core.c" 3 4
   "l" "u" 
# 11397 "/libmdbx/src/core.c"
   "\n", os_psize); } while (0);
    rc = MDBX_INCOMPATIBLE;
    goto bailout;
  }
  env->me_os_psize = (unsigned)os_psize;
  mdbx_setup_pagesize(env, (env->me_os_psize < MDBX_MAX_PAGESIZE) ? env->me_os_psize
                                                             : MDBX_MAX_PAGESIZE);

  rc = mdbx_fastmutex_init(&env->me_dbi_lock);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    goto bailout;





  rc = mdbx_fastmutex_init(&env->me_remap_guard);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0)) {
    mdbx_fastmutex_destroy(&env->me_dbi_lock);
    goto bailout;
  }


  MDBX_lockinfo *const stub = lckless_stub(env);
  rc = mdbx_ipclock_stub(&stub->mti_wlock);

  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0)) {
    mdbx_fastmutex_destroy(&env->me_remap_guard);
    mdbx_fastmutex_destroy(&env->me_dbi_lock);
    goto bailout;
  }


  ;
  env->me_signature.weak = 0x9A899641U;
  *penv = env;
  return MDBX_SUCCESS;

bailout:
  free(env);
  *penv = 
# 11437 "/libmdbx/src/core.c" 3 4
         ((void *)0)
# 11437 "/libmdbx/src/core.c"
                ;
  return rc;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static intptr_t get_reasonable_db_maxsize(intptr_t *cached_result) {
  if (*cached_result == 0) {
    intptr_t pagesize, total_ram_pages;
    if (__builtin_expect(!!(mdbx_get_sysraminfo(&pagesize, &total_ram_pages, 
# 11444 "/libmdbx/src/core.c" 3 4
       ((void *)0)
# 11444 "/libmdbx/src/core.c"
       ) != MDBX_SUCCESS), 0)
                              )
      return *cached_result = 0x7f000000U

          ;

    if (__builtin_expect(!!((size_t)total_ram_pages * 2 > ((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE) / (size_t)pagesize), 0))
      return *cached_result = ((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE);
    do { if ((0)) do { if (__builtin_expect(!!(!(((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE) >= (size_t)(total_ram_pages * pagesize * 2))), 0)) mdbx_assert_fail(
# 11452 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 11452 "/libmdbx/src/core.c"
   , "((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE) >= (size_t)(total_ram_pages * pagesize * 2)", __func__, 11452); } while (0); } while (0);


    *cached_result = (intptr_t)((size_t)total_ram_pages * 207 >> 7) * pagesize;


    for (size_t unit = ((size_t)1 << 20); unit; unit <<= 5) {
      const size_t floor = floor_powerof2(*cached_result, unit);
      const size_t ceil = ceil_powerof2(*cached_result, unit);
      const size_t threshold = (size_t)*cached_result >> 4;
      const _Bool down =
          *cached_result - floor < ceil - *cached_result || ceil > ((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE);
      if (threshold < (down ? *cached_result - floor : ceil - *cached_result))
        break;
      *cached_result = down ? floor : ceil;
    }
  }
  return *cached_result;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) __attribute__((__visibility__("default"))) int
mdbx_env_set_geometry(MDBX_env *env, intptr_t size_lower, intptr_t size_now,
                      intptr_t size_upper, intptr_t growth_step,
                      intptr_t shrink_threshold, intptr_t pagesize) {
  int rc = check_env(env, (0));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  const _Bool inside_txn =
      (env->me_txn0 && env->me_txn0->mt_owner == mdbx_thread_self());
# 11491 "/libmdbx/src/core.c"
  intptr_t reasonable_maxsize = 0;
  _Bool need_unlock = (0);
  if (env->me_dxb_mmap.dxb) {

    if (__builtin_expect(!!(env->me_flags & MDBX_RDONLY), 0))
      return MDBX_EACCESS;

    if (!inside_txn) {
      int err = mdbx_txn_lock(env, (0));
      if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
        return err;
      need_unlock = (1);
    }
    const MDBX_meta *head = constmeta_prefer_last(env);
    if (!inside_txn) {
      env->me_txn0->mt_txnid = constmeta_txnid(env, head);
      mdbx_find_oldest(env->me_txn0);
    }


    if (pagesize <= 0 || pagesize >= 0x7fffffff)
      pagesize = env->me_psize;
    if (size_lower < 0)
      size_lower = pgno2bytes(env, head->mm_geo.lower);
    if (size_now < 0)
      size_now = pgno2bytes(env, head->mm_geo.now);
    if (size_upper < 0)
      size_upper = pgno2bytes(env, head->mm_geo.upper);
    if (growth_step < 0)
      growth_step = pgno2bytes(env, pv2pages(head->mm_geo.grow_pv));
    if (shrink_threshold < 0)
      shrink_threshold = pgno2bytes(env, pv2pages(head->mm_geo.shrink_pv));

    if (pagesize != (intptr_t)env->me_psize) {
      rc = MDBX_EINVAL;
      goto bailout;
    }
    const size_t usedbytes =
        pgno2bytes(env, mdbx_find_largest(env, head->mm_geo.next));
    if ((size_t)size_upper < usedbytes) {
      rc = MDBX_MAP_FULL;
      goto bailout;
    }
    if ((size_t)size_now < usedbytes)
      size_now = usedbytes;
  } else {

    if (__builtin_expect(!!(inside_txn), 0))
      return MDBX_PANIC;


    if (pagesize >= 0x7fffffff )
      pagesize = MDBX_MAX_PAGESIZE;
    else if (pagesize <= 0) {
      if (pagesize < 0 ) {
        pagesize = env->me_os_psize;
        if ((uintptr_t)pagesize > MDBX_MAX_PAGESIZE)
          pagesize = MDBX_MAX_PAGESIZE;
        do { if ((0)) do { if (__builtin_expect(!!(!((uintptr_t)pagesize >= MDBX_MIN_PAGESIZE)), 0)) mdbx_assert_fail(env, "(uintptr_t)pagesize >= MDBX_MIN_PAGESIZE", __func__, 11549); } while (0); } while (0);
      } else if (pagesize == 0 )
        pagesize = MDBX_MIN_PAGESIZE;


      intptr_t max_size = (size_now > size_lower) ? size_now : size_lower;
      max_size = (size_upper > max_size) ? size_upper : max_size;
      if (max_size < 0 )
        max_size = ((size_t)1 << 20);
      else if (max_size == 0 )
        max_size = (MDBX_MIN_PAGESIZE * 3);
      else if (max_size >= (intptr_t)((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE) )
        max_size = get_reasonable_db_maxsize(&reasonable_maxsize);

      while (max_size > pagesize * (int64_t)(0x7FFFffffU + 1) &&
             pagesize < MDBX_MAX_PAGESIZE)
        pagesize <<= 1;
    }
  }

  if (pagesize < (intptr_t)MDBX_MIN_PAGESIZE || pagesize > (intptr_t)MDBX_MAX_PAGESIZE ||
      !is_powerof2(pagesize)) {
    rc = MDBX_EINVAL;
    goto bailout;
  }

  if (size_lower <= 0) {
    size_lower = (MDBX_MIN_PAGESIZE * 3);
    if ((MDBX_MIN_PAGESIZE * 3) / pagesize < 3)
      size_lower = 3 * pagesize;
  }
  if (size_lower >= 
# 11580 "/libmdbx/src/core.c" 3 4
                   (9223372036854775807L)
# 11580 "/libmdbx/src/core.c"
                             ) {
    size_lower = get_reasonable_db_maxsize(&reasonable_maxsize);
    if ((size_t)size_lower / pagesize > 0x7FFFffffU + 1)
      size_lower = pagesize * (0x7FFFffffU + 1);
  }

  if (size_now <= 0) {
    size_now = size_lower;
    if (size_upper >= size_lower && size_now > size_upper)
      size_now = size_upper;
  }
  if (size_now >= 
# 11591 "/libmdbx/src/core.c" 3 4
                 (9223372036854775807L)
# 11591 "/libmdbx/src/core.c"
                           ) {
    size_now = get_reasonable_db_maxsize(&reasonable_maxsize);
    if ((size_t)size_now / pagesize > 0x7FFFffffU + 1)
      size_now = pagesize * (0x7FFFffffU + 1);
  }

  if (size_upper <= 0) {
    if (size_now >= get_reasonable_db_maxsize(&reasonable_maxsize) / 2)
      size_upper = get_reasonable_db_maxsize(&reasonable_maxsize);
    else if (((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE) != 0x7f000000U &&
             (size_t)size_now >= 0x7f000000U / 2 &&
             (size_t)size_now <= 0x7f000000U / 4 * 3)
      size_upper = 0x7f000000U;
    else {
      size_upper = size_now + size_now;
      if ((size_t)size_upper < ((size_t)1 << 20) * 2)
        size_upper = ((size_t)1 << 20) * 2;
    }
    if ((size_t)size_upper / pagesize > (0x7FFFffffU + 1))
      size_upper = pagesize * (0x7FFFffffU + 1);
  } else if (size_upper >= 
# 11611 "/libmdbx/src/core.c" 3 4
                          (9223372036854775807L)
# 11611 "/libmdbx/src/core.c"
                                    ) {
    size_upper = get_reasonable_db_maxsize(&reasonable_maxsize);
    if ((size_t)size_upper / pagesize > 0x7FFFffffU + 1)
      size_upper = pagesize * (0x7FFFffffU + 1);
  }

  if (__builtin_expect(!!(size_lower < (intptr_t)(MDBX_MIN_PAGESIZE * 3) || size_lower > size_upper), 0)) {
    rc = MDBX_EINVAL;
    goto bailout;
  }

  if ((uint64_t)size_lower / pagesize < 3) {
    rc = MDBX_EINVAL;
    goto bailout;
  }

  if (__builtin_expect(!!((size_t)size_upper > ((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE) || (uint64_t)size_upper / pagesize > 0x7FFFffffU + 1), 0)
                                                                ) {
    rc = MDBX_TOO_LARGE;
    goto bailout;
  }

  const size_t unit = (env->me_os_psize > (size_t)pagesize) ? env->me_os_psize
                                                            : (size_t)pagesize;
  size_lower = ceil_powerof2(size_lower, unit);
  size_upper = ceil_powerof2(size_upper, unit);
  size_now = ceil_powerof2(size_now, unit);




  while (__builtin_expect(!!((size_t)size_upper > ((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE) || (uint64_t)size_upper / pagesize > 0x7FFFffffU + 1), 0)
                                                                   ) {
    if ((size_t)size_upper < unit + (MDBX_MIN_PAGESIZE * 3) ||
        (size_t)size_upper < (size_t)pagesize * (3 + 1)) {

      rc = MDBX_EINVAL;
      goto bailout;
    }
    size_upper -= unit;
    if ((size_t)size_upper < (size_t)size_lower)
      size_lower = size_upper;
  }
  do { if ((0)) do { if (__builtin_expect(!!(!((size_upper - size_lower) % env->me_os_psize == 0)), 0)) mdbx_assert_fail(env, "(size_upper - size_lower) % env->me_os_psize == 0", __func__, 11654); } while (0); } while (0);

  if (size_now < size_lower)
    size_now = size_lower;
  if (size_now > size_upper)
    size_now = size_upper;

  if (growth_step < 0) {
    growth_step = ((size_t)(size_upper - size_lower)) / 42;
    if (growth_step > size_lower && size_lower < (intptr_t)((size_t)1 << 20))
      growth_step = size_lower;
    if (growth_step < 65536)
      growth_step = 65536;
    if ((size_t)growth_step > ((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE) / 64)
      growth_step = ((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE) / 64;
  }
  if (growth_step == 0 && shrink_threshold > 0)
    growth_step = 1;
  growth_step = ceil_powerof2(growth_step, unit);

  if (shrink_threshold < 0)
    shrink_threshold = growth_step + growth_step;
  shrink_threshold = ceil_powerof2(shrink_threshold, unit);



  if (!env->me_dxb_mmap.dxb) {

    if (pagesize != (intptr_t)env->me_psize)
      mdbx_setup_pagesize(env, pagesize);
    env->me_dbgeo.lower = size_lower;
    env->me_dbgeo.now = size_now;
    env->me_dbgeo.upper = size_upper;
    env->me_dbgeo.grow =
        pgno2bytes(env, pv2pages(pages2pv(bytes2pgno(env, growth_step))));
    env->me_dbgeo.shrink =
        pgno2bytes(env, pv2pages(pages2pv(bytes2pgno(env, shrink_threshold))));

    do { if (__builtin_expect(!!(!(env->me_dbgeo.lower >= (MDBX_MIN_PAGESIZE * 3))), 0)) mdbx_assert_fail(env, "env->me_dbgeo.lower >= MIN_MAPSIZE", __func__, 11692); } while (0);
    do { if (__builtin_expect(!!(!(env->me_dbgeo.lower / (unsigned)pagesize >= 3)), 0)) mdbx_assert_fail(env, "env->me_dbgeo.lower / (unsigned)pagesize >= MIN_PAGENO", __func__, 11693); } while (0);
    do { if (__builtin_expect(!!(!(env->me_dbgeo.lower % (unsigned)pagesize == 0)), 0)) mdbx_assert_fail(env, "env->me_dbgeo.lower % (unsigned)pagesize == 0", __func__, 11694); } while (0);
    do { if (__builtin_expect(!!(!(env->me_dbgeo.lower % env->me_os_psize == 0)), 0)) mdbx_assert_fail(env, "env->me_dbgeo.lower % env->me_os_psize == 0", __func__, 11695); } while (0);

    do { if (__builtin_expect(!!(!(env->me_dbgeo.upper <= ((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE))), 0)) mdbx_assert_fail(env, "env->me_dbgeo.upper <= MAX_MAPSIZE", __func__, 11697); } while (0);
    do { if (__builtin_expect(!!(!(env->me_dbgeo.upper / (unsigned)pagesize <= 0x7FFFffffU + 1)), 0)) mdbx_assert_fail(env, "env->me_dbgeo.upper / (unsigned)pagesize <= MAX_PAGENO + 1", __func__, 11698); } while (0)
                                                                           ;
    do { if (__builtin_expect(!!(!(env->me_dbgeo.upper % (unsigned)pagesize == 0)), 0)) mdbx_assert_fail(env, "env->me_dbgeo.upper % (unsigned)pagesize == 0", __func__, 11700); } while (0);
    do { if (__builtin_expect(!!(!(env->me_dbgeo.upper % env->me_os_psize == 0)), 0)) mdbx_assert_fail(env, "env->me_dbgeo.upper % env->me_os_psize == 0", __func__, 11701); } while (0);

    do { if (__builtin_expect(!!(!(env->me_dbgeo.now >= env->me_dbgeo.lower)), 0)) mdbx_assert_fail(env, "env->me_dbgeo.now >= env->me_dbgeo.lower", __func__, 11703); } while (0);
    do { if (__builtin_expect(!!(!(env->me_dbgeo.now <= env->me_dbgeo.upper)), 0)) mdbx_assert_fail(env, "env->me_dbgeo.now <= env->me_dbgeo.upper", __func__, 11704); } while (0);
    do { if (__builtin_expect(!!(!(env->me_dbgeo.now % (unsigned)pagesize == 0)), 0)) mdbx_assert_fail(env, "env->me_dbgeo.now % (unsigned)pagesize == 0", __func__, 11705); } while (0);
    do { if (__builtin_expect(!!(!(env->me_dbgeo.now % env->me_os_psize == 0)), 0)) mdbx_assert_fail(env, "env->me_dbgeo.now % env->me_os_psize == 0", __func__, 11706); } while (0);

    do { if (__builtin_expect(!!(!(env->me_dbgeo.grow % (unsigned)pagesize == 0)), 0)) mdbx_assert_fail(env, "env->me_dbgeo.grow % (unsigned)pagesize == 0", __func__, 11708); } while (0);
    do { if (__builtin_expect(!!(!(env->me_dbgeo.grow % env->me_os_psize == 0)), 0)) mdbx_assert_fail(env, "env->me_dbgeo.grow % env->me_os_psize == 0", __func__, 11709); } while (0);
    do { if (__builtin_expect(!!(!(env->me_dbgeo.shrink % (unsigned)pagesize == 0)), 0)) mdbx_assert_fail(env, "env->me_dbgeo.shrink % (unsigned)pagesize == 0", __func__, 11710); } while (0);
    do { if (__builtin_expect(!!(!(env->me_dbgeo.shrink % env->me_os_psize == 0)), 0)) mdbx_assert_fail(env, "env->me_dbgeo.shrink % env->me_os_psize == 0", __func__, 11711); } while (0);

    rc = MDBX_SUCCESS;
  } else {

    do { if (__builtin_expect(!!(!(pagesize == (intptr_t)env->me_psize)), 0)) mdbx_assert_fail(env, "pagesize == (intptr_t)env->me_psize", __func__, 11716); } while (0);
    MDBX_meta meta;
    memset(&meta, 0, sizeof(meta));
    const MDBX_geo *current_geo;
    if (!inside_txn) {
      do { if ((0)) do { if (__builtin_expect(!!(!(need_unlock)), 0)) mdbx_assert_fail(env, "need_unlock", __func__, 11721); } while (0); } while (0);
      const MDBX_meta *head = constmeta_prefer_last(env);

      uint64_t timestamp = 0;
      while ("workaround for https://github.com/erthink/libmdbx/issues/269") {
        meta = *head;
        rc = meta_waittxnid(env, &meta, &timestamp);
        if (__builtin_expect(!!(rc == MDBX_SUCCESS), 1))
          break;
        if (__builtin_expect(!!(rc != MDBX_RESULT_TRUE), 0))
          goto bailout;
      }
      const txnid_t txnid = safe64_txnid_next(constmeta_txnid(env, &meta));
      if (__builtin_expect(!!(txnid > (0xffffFFFF00000000UL - 1)), 0)) {
        rc = MDBX_TXN_FULL;
        do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 11736, "txnid overflow, raise %d" "\n", rc); } while (0);
        goto bailout;
      }
      meta_set_txnid(env, &meta, txnid);
      current_geo = &meta.mm_geo;
    } else {
      current_geo = &env->me_txn->mt_geo;
    }

    MDBX_geo new_geo;
    new_geo.lower = bytes2pgno(env, size_lower);
    new_geo.now = bytes2pgno(env, size_now);
    new_geo.upper = bytes2pgno(env, size_upper);
    new_geo.grow_pv = pages2pv(bytes2pgno(env, growth_step));
    new_geo.shrink_pv = pages2pv(bytes2pgno(env, shrink_threshold));
    new_geo.next = current_geo->next;

    do { if (__builtin_expect(!!(!(pgno_align2os_bytes(env, new_geo.lower) == (size_t)size_lower)), 0)) mdbx_assert_fail(env, "pgno_align2os_bytes(env, new_geo.lower) == (size_t)size_lower", __func__, 11753); } while (0)
                                                                              ;
    do { if (__builtin_expect(!!(!(pgno_align2os_bytes(env, new_geo.upper) == (size_t)size_upper)), 0)) mdbx_assert_fail(env, "pgno_align2os_bytes(env, new_geo.upper) == (size_t)size_upper", __func__, 11755); } while (0)
                                                                              ;
    do { if (__builtin_expect(!!(!(pgno_align2os_bytes(env, new_geo.now) == (size_t)size_now)), 0)) mdbx_assert_fail(env, "pgno_align2os_bytes(env, new_geo.now) == (size_t)size_now", __func__, 11757); } while (0);
    do { if (__builtin_expect(!!(!(new_geo.grow_pv == pages2pv(pv2pages(new_geo.grow_pv)))), 0)) mdbx_assert_fail(env, "new_geo.grow_pv == pages2pv(pv2pages(new_geo.grow_pv))", __func__, 11758); } while (0);
    do { if (__builtin_expect(!!(!(new_geo.shrink_pv == pages2pv(pv2pages(new_geo.shrink_pv)))), 0)) mdbx_assert_fail(env, "new_geo.shrink_pv == pages2pv(pv2pages(new_geo.shrink_pv))", __func__, 11759); } while (0)
                                                                           ;

    do { if (__builtin_expect(!!(!((size_t)size_lower >= (MDBX_MIN_PAGESIZE * 3))), 0)) mdbx_assert_fail(env, "(size_t)size_lower >= MIN_MAPSIZE", __func__, 11762); } while (0);
    do { if (__builtin_expect(!!(!(new_geo.lower >= 3)), 0)) mdbx_assert_fail(env, "new_geo.lower >= MIN_PAGENO", __func__, 11763); } while (0);
    do { if (__builtin_expect(!!(!((size_t)size_upper <= ((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE))), 0)) mdbx_assert_fail(env, "(size_t)size_upper <= MAX_MAPSIZE", __func__, 11764); } while (0);
    do { if (__builtin_expect(!!(!(new_geo.upper <= 0x7FFFffffU + 1)), 0)) mdbx_assert_fail(env, "new_geo.upper <= MAX_PAGENO + 1", __func__, 11765); } while (0);
    do { if (__builtin_expect(!!(!(new_geo.now >= new_geo.next)), 0)) mdbx_assert_fail(env, "new_geo.now >= new_geo.next", __func__, 11766); } while (0);
    do { if (__builtin_expect(!!(!(new_geo.upper >= new_geo.now)), 0)) mdbx_assert_fail(env, "new_geo.upper >= new_geo.now", __func__, 11767); } while (0);
    do { if (__builtin_expect(!!(!(new_geo.now >= new_geo.lower)), 0)) mdbx_assert_fail(env, "new_geo.now >= new_geo.lower", __func__, 11768); } while (0);

    if (memcmp(current_geo, &new_geo, sizeof(MDBX_geo)) != 0) {
# 11807 "/libmdbx/src/core.c"
      if (new_geo.now != current_geo->now ||
          new_geo.upper != current_geo->upper) {
        rc = mdbx_mapresize(env, current_geo->next, new_geo.now, new_geo.upper,
                            (0));
        if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
          goto bailout;
      }
      if (inside_txn) {
        env->me_txn->mt_geo = new_geo;
        env->me_txn->mt_flags |= 0x04;
      } else {
        meta.mm_geo = new_geo;
        rc = mdbx_sync_locked(env, env->me_flags, &meta);
      }

      if (__builtin_expect(!!(rc == MDBX_SUCCESS), 1)) {

        env->me_dbgeo.now = pgno2bytes(env, new_geo.now);
        env->me_dbgeo.lower = pgno2bytes(env, new_geo.lower);
        env->me_dbgeo.upper = pgno2bytes(env, new_geo.upper);
        env->me_dbgeo.grow = pgno2bytes(env, pv2pages(new_geo.grow_pv));
        env->me_dbgeo.shrink = pgno2bytes(env, pv2pages(new_geo.shrink_pv));
      }
    }
  }

bailout:
  if (need_unlock)
    mdbx_txn_unlock(env);
  return rc;
}


__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_set_mapsize(MDBX_env *env, size_t size) {
  return __inline_mdbx_env_set_mapsize(env, size);
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_set_maxdbs(MDBX_env *env, MDBX_dbi dbs) {
  return __inline_mdbx_env_set_maxdbs(env, dbs);
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_get_maxdbs(const MDBX_env *env, MDBX_dbi *dbs) {
  return __inline_mdbx_env_get_maxdbs(env, dbs);
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_set_maxreaders(MDBX_env *env, unsigned readers) {
  return __inline_mdbx_env_set_maxreaders(env, readers);
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_get_maxreaders(const MDBX_env *env, unsigned *readers) {
  return __inline_mdbx_env_get_maxreaders(env, readers);
}


__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static int alloc_page_buf(MDBX_env *env) {
  return env->me_pbuf
             ? MDBX_SUCCESS
             : mdbx_memalign_alloc(env->me_os_psize, env->me_psize * 3,
                                   &env->me_pbuf);
}


__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static int mdbx_setup_dxb(MDBX_env *env, const int lck_rc,
                                 const mdbx_mode_t mode_bits) {
  MDBX_meta meta;
  int rc = MDBX_RESULT_FALSE;
  int err = mdbx_read_header(env, &meta, lck_rc, mode_bits);
  if (__builtin_expect(!!(err != MDBX_SUCCESS), 0)) {
    if (lck_rc != MDBX_RESULT_TRUE || err != MDBX_ENODATA ||
        (env->me_flags & MDBX_RDONLY) != 0 ||
                            env->me_stuck_meta >= 0)
      return err;

    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 11880, "%s" "\n", "create new database"); } while (0);
    rc = MDBX_RESULT_TRUE;

    if (!env->me_dbgeo.now) {

      err = mdbx_env_set_geometry(env, 0, -1, ((size_t)1 << 20), -1, -1, -1);
      if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
        return err;
    }

    err = alloc_page_buf(env);
    if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
      return err;

    meta = *mdbx_init_metas(env, env->me_pbuf);
    err = mdbx_pwrite(env->me_dxb_mmap.fd, env->me_pbuf, env->me_psize * 3,
                      0);
    if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
      return err;

    err = mdbx_ftruncate(env->me_dxb_mmap.fd,
                         env->me_dxb_mmap.filesize = env->me_dbgeo.now);
    if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
      return err;






  }

  do { if ((MDBX_LOG_VERBOSE < MDBX_LOG_VERBOSE && MDBX_LOG_VERBOSE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_VERBOSE, __func__, 11912, "header: root %" 
# 11912 "/libmdbx/src/core.c" 3 4
 "u" 
# 11912 "/libmdbx/src/core.c"
 "/%" 
# 11912 "/libmdbx/src/core.c" 3 4
 "u" 
# 11912 "/libmdbx/src/core.c"
 ", geo %" 
# 11912 "/libmdbx/src/core.c" 3 4
 "u" 
# 11912 "/libmdbx/src/core.c"
 "/%" 
# 11912 "/libmdbx/src/core.c" 3 4
 "u" 
# 11912 "/libmdbx/src/core.c"
 "-%" 
# 11912 "/libmdbx/src/core.c" 3 4
 "u" 
# 11912 "/libmdbx/src/core.c"
 "/%" 
# 11912 "/libmdbx/src/core.c" 3 4
 "u" 
# 11912 "/libmdbx/src/core.c"
 " +%u -%u, txn_id %" 
# 11912 "/libmdbx/src/core.c" 3 4
 "l" "i" 
# 11912 "/libmdbx/src/core.c"
 ", %s" "\n", meta.mm_dbs[1].md_root, meta.mm_dbs[0].md_root, meta.mm_geo.lower, meta.mm_geo.next, meta.mm_geo.now, meta.mm_geo.upper, pv2pages(meta.mm_geo.grow_pv), pv2pages(meta.mm_geo.shrink_pv), unaligned_peek_u64(4, meta.mm_txnid_a), mdbx_durable_str(&meta)); } while (0)





                                                                      ;

  if (env->me_psize != meta.mm_dbs[0].md_xsize)
    mdbx_setup_pagesize(env, meta.mm_dbs[0].md_xsize);
  const size_t used_bytes = pgno2bytes(env, meta.mm_geo.next);
  const size_t used_aligned2os_bytes =
      ceil_powerof2(used_bytes, env->me_os_psize);
  if ((env->me_flags & MDBX_RDONLY)
      || lck_rc != MDBX_RESULT_TRUE
      || env->me_stuck_meta >= 0) {

    const size_t pagesize = meta.mm_dbs[0].md_xsize;
    err = mdbx_env_set_geometry(
        env, meta.mm_geo.lower * pagesize, meta.mm_geo.now * pagesize,
        meta.mm_geo.upper * pagesize, pv2pages(meta.mm_geo.grow_pv) * pagesize,
        pv2pages(meta.mm_geo.shrink_pv) * pagesize, meta.mm_dbs[0].md_xsize);
    if (__builtin_expect(!!(err != MDBX_SUCCESS), 0)) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 11935, "%s: err %d" "\n", "could not apply preconfigured geometry from db", err); } while (0)
                     ;
      return (err == MDBX_EINVAL) ? MDBX_INCOMPATIBLE : err;
    }
  } else if (env->me_dbgeo.now) {

    if (env->me_dbgeo.now < used_aligned2os_bytes)
      env->me_dbgeo.now = used_aligned2os_bytes;
    if (env->me_dbgeo.upper < used_aligned2os_bytes)
      env->me_dbgeo.upper = used_aligned2os_bytes;





    if (bytes_align2os_bytes(env, env->me_dbgeo.upper) !=
            pgno2bytes(env, meta.mm_geo.upper) ||
        bytes_align2os_bytes(env, env->me_dbgeo.lower) !=
            pgno2bytes(env, meta.mm_geo.lower) ||
        bytes_align2os_bytes(env, env->me_dbgeo.shrink) !=
            pgno2bytes(env, pv2pages(meta.mm_geo.shrink_pv)) ||
        bytes_align2os_bytes(env, env->me_dbgeo.grow) !=
            pgno2bytes(env, pv2pages(meta.mm_geo.grow_pv))) {

      if (env->me_dbgeo.shrink && env->me_dbgeo.now > used_bytes)

        env->me_dbgeo.now = used_bytes + env->me_dbgeo.shrink -
                            used_bytes % env->me_dbgeo.shrink;

      err = mdbx_env_set_geometry(env, env->me_dbgeo.lower, env->me_dbgeo.now,
                                  env->me_dbgeo.upper, env->me_dbgeo.grow,
                                  env->me_dbgeo.shrink, meta.mm_dbs[0].md_xsize);
      if (__builtin_expect(!!(err != MDBX_SUCCESS), 0)) {
        do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 11968, "%s: err %d" "\n", "could not apply preconfigured db-geometry", err); } while (0)
                       ;
        return (err == MDBX_EINVAL) ? MDBX_INCOMPATIBLE : err;
      }


      meta.mm_geo.now = bytes2pgno(env, env->me_dbgeo.now);
      meta.mm_geo.lower = bytes2pgno(env, env->me_dbgeo.lower);
      meta.mm_geo.upper = bytes2pgno(env, env->me_dbgeo.upper);
      meta.mm_geo.grow_pv = pages2pv(bytes2pgno(env, env->me_dbgeo.grow));
      meta.mm_geo.shrink_pv = pages2pv(bytes2pgno(env, env->me_dbgeo.shrink));

      do { if ((MDBX_LOG_VERBOSE < MDBX_LOG_VERBOSE && MDBX_LOG_VERBOSE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_VERBOSE, __func__, 11980, "amended: root %" 
# 11980 "/libmdbx/src/core.c" 3 4
     "u" 
# 11980 "/libmdbx/src/core.c"
     "/%" 
# 11980 "/libmdbx/src/core.c" 3 4
     "u" 
# 11980 "/libmdbx/src/core.c"
     ", geo %" 
# 11980 "/libmdbx/src/core.c" 3 4
     "u" 
# 11980 "/libmdbx/src/core.c"
     "/%" 
# 11980 "/libmdbx/src/core.c" 3 4
     "u" 
# 11980 "/libmdbx/src/core.c"
     "-%" 
# 11980 "/libmdbx/src/core.c" 3 4
     "u" 
# 11980 "/libmdbx/src/core.c"
     "/%" 
# 11980 "/libmdbx/src/core.c" 3 4
     "u" 
# 11980 "/libmdbx/src/core.c"
     " +%u -%u, txn_id %" 
# 11980 "/libmdbx/src/core.c" 3 4
     "l" "i" 
# 11980 "/libmdbx/src/core.c"
     ", %s" "\n", meta.mm_dbs[1].md_root, meta.mm_dbs[0].md_root, meta.mm_geo.lower, meta.mm_geo.next, meta.mm_geo.now, meta.mm_geo.upper, pv2pages(meta.mm_geo.grow_pv), pv2pages(meta.mm_geo.shrink_pv), unaligned_peek_u64(4, meta.mm_txnid_a), mdbx_durable_str(&meta)); } while (0)







                                           ;
    } else {


      env->me_dbgeo.now = pgno_align2os_bytes(env, meta.mm_geo.now);
    }
    do { if (__builtin_expect(!!(!(meta.mm_geo.now >= meta.mm_geo.next)), 0)) mdbx_assert_fail(env, "meta.mm_geo.now >= meta.mm_geo.next", __func__, 11994); } while (0);
  } else {


    env->me_dbgeo.now = pgno2bytes(env, meta.mm_geo.now);
    env->me_dbgeo.lower = pgno2bytes(env, meta.mm_geo.lower);
    env->me_dbgeo.upper = pgno2bytes(env, meta.mm_geo.upper);
    env->me_dbgeo.grow = pgno2bytes(env, pv2pages(meta.mm_geo.grow_pv));
    env->me_dbgeo.shrink = pgno2bytes(env, pv2pages(meta.mm_geo.shrink_pv));
  }

  do { if (__builtin_expect(!!(!(pgno_align2os_bytes(env, meta.mm_geo.now) == env->me_dbgeo.now)), 0)) mdbx_assert_fail(env, "pgno_align2os_bytes(env, meta.mm_geo.now) == env->me_dbgeo.now", __func__, 12005); } while (0)
                                                                             ;
  do { if (__builtin_expect(!!(!(env->me_dbgeo.now >= used_bytes)), 0)) mdbx_assert_fail(env, "env->me_dbgeo.now >= used_bytes", __func__, 12007); } while (0);
  const uint64_t filesize_before = env->me_dxb_mmap.filesize;
  if (__builtin_expect(!!(filesize_before != env->me_dbgeo.now), 0)) {
    if (lck_rc != MDBX_RESULT_TRUE) {
      do { if ((MDBX_LOG_VERBOSE < MDBX_LOG_VERBOSE && MDBX_LOG_VERBOSE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_VERBOSE, __func__, 12011, "filesize mismatch (expect %" 
# 12011 "/libmdbx/src/core.c" 3 4
     "l" "u" 
# 12011 "/libmdbx/src/core.c"
     "b/%" 
# 12011 "/libmdbx/src/core.c" 3 4
     "u" 
# 12011 "/libmdbx/src/core.c"
     "p, have %" 
# 12011 "/libmdbx/src/core.c" 3 4
     "l" "u" 
# 12011 "/libmdbx/src/core.c"
     "b/%" 
# 12011 "/libmdbx/src/core.c" 3 4
     "u" 
# 12011 "/libmdbx/src/core.c"
     "p), " "assume other process working" "\n", env->me_dbgeo.now, bytes2pgno(env, env->me_dbgeo.now), filesize_before, bytes2pgno(env, (size_t)filesize_before)); } while (0)



                                                                             ;
    } else {
      do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 12017, "filesize mismatch (expect %" 
# 12017 "/libmdbx/src/core.c" 3 4
     "l" "u" 
# 12017 "/libmdbx/src/core.c"
     "b/%" 
# 12017 "/libmdbx/src/core.c" 3 4
     "u" 
# 12017 "/libmdbx/src/core.c"
     "p, have %" 
# 12017 "/libmdbx/src/core.c" 3 4
     "l" "u" 
# 12017 "/libmdbx/src/core.c"
     "b/%" 
# 12017 "/libmdbx/src/core.c" 3 4
     "u" 
# 12017 "/libmdbx/src/core.c"
     "p)" "\n", env->me_dbgeo.now, bytes2pgno(env, env->me_dbgeo.now), filesize_before, bytes2pgno(env, (size_t)filesize_before)); } while (0)


                                                                             ;
      if (filesize_before < used_bytes) {
        do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 12022, "last-page beyond end-of-file (last %" 
# 12022 "/libmdbx/src/core.c" 3 4
       "u" 
# 12022 "/libmdbx/src/core.c"
       ", have %" 
# 12022 "/libmdbx/src/core.c" 3 4
       "u" 
# 12022 "/libmdbx/src/core.c"
       ")" "\n", meta.mm_geo.next, bytes2pgno(env, (size_t)filesize_before)); } while (0)

                                                                              ;
        return MDBX_CORRUPTED;
      }

      if (env->me_flags & MDBX_RDONLY) {
        if (filesize_before & (env->me_os_psize - 1)) {
          do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 12030, "%s" "\n", "filesize should be rounded-up to system page"); } while (0);
          return MDBX_WANNA_RECOVERY;
        }
        do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 12033, "%s" "\n", "ignore filesize mismatch in readonly-mode"); } while (0);
      } else {
        do { if ((MDBX_LOG_VERBOSE < MDBX_LOG_VERBOSE && MDBX_LOG_VERBOSE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_VERBOSE, __func__, 12035, "will resize datafile to %" 
# 12035 "/libmdbx/src/core.c" 3 4
       "l" "u" 
# 12035 "/libmdbx/src/core.c"
       " bytes, %" 
# 12035 "/libmdbx/src/core.c" 3 4
       "u" 
# 12035 "/libmdbx/src/core.c"
       " pages" "\n", env->me_dbgeo.now, bytes2pgno(env, env->me_dbgeo.now)); } while (0)

                                                                           ;
      }
    }
  }

  do { if ((MDBX_LOG_VERBOSE < MDBX_LOG_VERBOSE && MDBX_LOG_VERBOSE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_VERBOSE, __func__, 12042, "current boot-id %" 
# 12042 "/libmdbx/src/core.c" 3 4
 "l" "x" 
# 12042 "/libmdbx/src/core.c"
 "-%" 
# 12042 "/libmdbx/src/core.c" 3 4
 "l" "x" 
# 12042 "/libmdbx/src/core.c"
 " (%savailable)" "\n", bootid.x, bootid.y, (bootid.x | bootid.y) ? "" : "not-"); } while (0)
                                                                       ;



  const _Bool readahead =
      !(env->me_flags & MDBX_NORDAHEAD) &&
      mdbx_is_readahead_reasonable(used_bytes, 0) == MDBX_RESULT_TRUE;


  err = mdbx_mmap(env->me_flags, &env->me_dxb_mmap, env->me_dbgeo.now,
                  env->me_dbgeo.upper, lck_rc ? 1 : 0);
  if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
    return err;



  err = madvise(env->me_dxb_mmap.dxb, env->me_dxb_mmap.limit, 
# 12059 "/libmdbx/src/core.c" 3 4
                                                    16
# 12059 "/libmdbx/src/core.c"
                                                                 )
            ? ignore_enosys(
# 12060 "/libmdbx/src/core.c" 3 4
                           (*__errno_location ())
# 12060 "/libmdbx/src/core.c"
                                )
            : MDBX_SUCCESS;
  if (__builtin_expect(!!(((err) != MDBX_RESULT_TRUE && (err) != MDBX_RESULT_FALSE)), 0))
    return err;


  if (mdbx_runtime_flags & MDBX_DBG_DUMP) {
    const size_t meta_length_aligned2os = pgno_align2os_bytes(env, 3);
    err = madvise(env->me_dxb_mmap.dxb, meta_length_aligned2os, 
# 12068 "/libmdbx/src/core.c" 3 4
                                                      17
# 12068 "/libmdbx/src/core.c"
                                                                 )
              ? ignore_enosys(
# 12069 "/libmdbx/src/core.c" 3 4
                             (*__errno_location ())
# 12069 "/libmdbx/src/core.c"
                                  )
              : MDBX_SUCCESS;
    if (__builtin_expect(!!(((err) != MDBX_RESULT_TRUE && (err) != MDBX_RESULT_FALSE)), 0))
      return err;
  }
# 12082 "/libmdbx/src/core.c"
  do { if ((0)) do { if (__builtin_expect(!!(!(used_bytes >= pgno2bytes(env, 3) && used_bytes <= env->me_dxb_mmap.limit)), 0)) mdbx_assert_fail(env, "used_bytes >= pgno2bytes(env, 3) && used_bytes <= env->me_dxb_mmap.limit", __func__, 12082); } while (0); } while (0)
                                                            ;
# 12099 "/libmdbx/src/core.c"
  if (__builtin_expect(!!(env->me_stuck_meta >= 0), 0)) {

    MDBX_meta clone;
    MDBX_meta const *const target = page_meta(pgno2page(env, env->me_stuck_meta));
    err = mdbx_validate_meta_copy(env, target, &clone);
    if (__builtin_expect(!!(err != MDBX_SUCCESS), 0)) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 12105, "target meta[%u] is corrupted" "\n", bytes2pgno(env, (uint8_t *)data_page(target) - env->me_dxb_mmap.dxb)); } while (0)
                                                                             ;
      return MDBX_CORRUPTED;
    }
  } else
    while (1) {
      const unsigned meta_clash_mask = meta_eq_mask(env);
      if (__builtin_expect(!!(meta_clash_mask), 0)) {
        do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 12113, "meta-pages are clashed: mask 0x%d" "\n", meta_clash_mask); } while (0);
        return MDBX_CORRUPTED;
      }

      if (lck_rc != MDBX_RESULT_TRUE) {


        volatile const MDBX_meta *const head = meta_prefer_last(env);
        volatile const MDBX_meta *const steady = meta_prefer_steady(env);
        const txnid_t head_txnid = meta_txnid(env, head);
        const txnid_t steady_txnid = meta_txnid(env, steady);
        if (head_txnid == steady_txnid)
          break;

        if (!env->me_lck_mmap.lck) {


          do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 12130, "%s" "\n", "without-lck, unable recovery/rollback"); } while (0);
          return MDBX_WANNA_RECOVERY;
        }



        do { if ((MDBX_LOG_VERBOSE < MDBX_LOG_VERBOSE && MDBX_LOG_VERBOSE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_VERBOSE, __func__, 12136, "%s" "\n", "assume collision or online weak checkpoint"); } while (0);
        break;
      }
      do { if ((0)) do { if (__builtin_expect(!!(!(lck_rc == MDBX_RESULT_TRUE)), 0)) mdbx_assert_fail(env, "lck_rc == MDBX_RESULT_TRUE", __func__, 12139); } while (0); } while (0);


      MDBX_meta clone;
      const MDBX_meta *const steady = constmeta_prefer_steady(env);
      const MDBX_meta *const head = constmeta_prefer_last(env);
      const txnid_t steady_txnid = meta_txnid(env, steady);
      if (((unaligned_peek_u64_volatile(4, (steady)->mm_datasync_sign)) > 1u)) {
        err = mdbx_validate_meta_copy(env, steady, &clone);
        if (__builtin_expect(!!(err != MDBX_SUCCESS), 0)) {
          do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 12149, "meta[%u] with %s txnid %" 
# 12149 "/libmdbx/src/core.c" 3 4
         "l" "i" 
# 12149 "/libmdbx/src/core.c"
         " is corrupted, %s needed" "\n", bytes2pgno(env, (uint8_t *)steady - env->me_dxb_mmap.dxb), "steady", steady_txnid, "manual recovery"); } while (0)


                                                     ;
          return MDBX_CORRUPTED;
        }
        if (steady == head)
          break;
      }

      const pgno_t pgno = bytes2pgno(env, (uint8_t *)head - env->me_dxb_mmap.dxb);
      const txnid_t head_txnid = meta_txnid(env, head);
      const _Bool head_valid =
          mdbx_validate_meta_copy(env, head, &clone) == MDBX_SUCCESS;
      do { if ((0)) do { if (__builtin_expect(!!(!(!((unaligned_peek_u64_volatile(4, (steady)->mm_datasync_sign)) > 1u) || head_txnid != steady_txnid)), 0)) mdbx_assert_fail(env, "!((unaligned_peek_u64_volatile(4, (steady)->mm_datasync_sign)) > 1u) || head_txnid != steady_txnid", __func__, 12163); } while (0); } while (0);
      if (__builtin_expect(!!(!head_valid), 0)) {
        if (__builtin_expect(!!(!((unaligned_peek_u64_volatile(4, (steady)->mm_datasync_sign)) > 1u)), 0)) {
          do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 12166, "%s for open or automatic rollback, %s" "\n", "there are no suitable meta-pages", "manual recovery is required"); } while (0)

                                                   ;
          return MDBX_CORRUPTED;
        }
        do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 12171, "meta[%u] with last txnid %" 
# 12171 "/libmdbx/src/core.c" 3 4
       "l" "i" 
# 12171 "/libmdbx/src/core.c"
       " is corrupted, rollback needed" "\n", pgno, head_txnid); } while (0)

                                      ;
        goto purge_meta_head;
      }

      if (meta_bootid_match(head)) {
        if (env->me_flags & MDBX_RDONLY) {
          do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 12179, "%s, but boot-id(%016" 
# 12179 "/libmdbx/src/core.c" 3 4
         "l" "x" 
# 12179 "/libmdbx/src/core.c"
         "-%016" 
# 12179 "/libmdbx/src/core.c" 3 4
         "l" "x" 
# 12179 "/libmdbx/src/core.c"
         ") is MATCH: " "rollback NOT needed, steady-sync NEEDED%s" "\n", "opening after an unclean shutdown", bootid.x, bootid.y, ", but unable in read-only mode"); } while (0)


                                                      ;
          return MDBX_WANNA_RECOVERY;
        }
        do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 12185, "%s, but boot-id(%016" 
# 12185 "/libmdbx/src/core.c" 3 4
       "l" "x" 
# 12185 "/libmdbx/src/core.c"
       "-%016" 
# 12185 "/libmdbx/src/core.c" 3 4
       "l" "x" 
# 12185 "/libmdbx/src/core.c"
       ") is MATCH: " "rollback NOT needed, steady-sync NEEDED%s" "\n", "opening after an unclean shutdown", bootid.x, bootid.y, ""); } while (0)


                        ;
        meta = clone;
        atomic_store32(&env->me_lck->mti_unsynced_pages, meta.mm_geo.next,
                       mo_Relaxed);
        break;
      }
      if (__builtin_expect(!!(!((unaligned_peek_u64_volatile(4, (steady)->mm_datasync_sign)) > 1u)), 0)) {
        do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 12195, "%s, but %s for automatic rollback: %s" "\n", "opening after an unclean shutdown", "there are no suitable meta-pages", "manual recovery is required"); } while (0)


                                                 ;
        return MDBX_CORRUPTED;
      }
      if (env->me_flags & MDBX_RDONLY) {
        do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 12202, "%s and rollback needed: (from head %" 
# 12202 "/libmdbx/src/core.c" 3 4
       "l" "i" 
# 12202 "/libmdbx/src/core.c"
       " to steady %" 
# 12202 "/libmdbx/src/core.c" 3 4
       "l" "i" 
# 12202 "/libmdbx/src/core.c"
       ")%s" "\n", "opening after an unclean shutdown", head_txnid, steady_txnid, ", but unable in read-only mode"); } while (0)


                                                                  ;
        return MDBX_WANNA_RECOVERY;
      }

    purge_meta_head:
      do { if ((MDBX_LOG_NOTICE < MDBX_LOG_VERBOSE && MDBX_LOG_NOTICE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_NOTICE, __func__, 12210, "%s and doing automatic rollback: " "purge%s meta[%u] with%s txnid %" 
# 12210 "/libmdbx/src/core.c" 3 4
     "l" "i" 
# 12210 "/libmdbx/src/core.c"
     "\n", "opening after an unclean shutdown", head_valid ? "" : " invalid", pgno, head_valid ? " weak" : "", head_txnid); } while (0)



                             ;
      do { if (__builtin_expect(!!(!(((unaligned_peek_u64_volatile(4, (steady)->mm_datasync_sign)) > 1u))), 0)) mdbx_assert_fail(env, "META_IS_STEADY(steady)", __func__, 12215); } while (0);
      err = mdbx_override_meta(env, pgno, 0, head_valid ? head : steady);
      if (err) {
        do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 12218, "rollback: overwrite meta[%u] with txnid %" 
# 12218 "/libmdbx/src/core.c" 3 4
       "l" "i" 
# 12218 "/libmdbx/src/core.c"
       ", error %d" "\n", pgno, head_txnid, err); } while (0)

                                         ;
        return err;
      }
      do { if (__builtin_expect(!!(!(0 == meta_txnid(env, head))), 0)) mdbx_assert_fail(env, "0 == meta_txnid(env, head)", __func__, 12223); } while (0);
      do { if (__builtin_expect(!!(!(0 == meta_eq_mask(env))), 0)) mdbx_assert_fail(env, "0 == meta_eq_mask(env)", __func__, 12224); } while (0);
    }

  if (lck_rc == MDBX_RESULT_TRUE) {

    const MDBX_meta *head = constmeta_prefer_last(env);

    if ((env->me_dxb_mmap.current & (env->me_os_psize - 1)) != 0 ||
        env->me_dxb_mmap.current < used_bytes) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 12233, "unacceptable/unexpected datafile size %" 
# 12233 "/libmdbx/src/core.c" 3 4
     "l" "u" 
# 12233 "/libmdbx/src/core.c"
     "\n", env->me_dxb_mmap.current); } while (0)
                                          ;
      return MDBX_PROBLEM;
    }
    if (env->me_dxb_mmap.current != env->me_dbgeo.now) {
      meta.mm_geo.now = bytes2pgno(env, env->me_dxb_mmap.current);
      do { if ((MDBX_LOG_NOTICE < MDBX_LOG_VERBOSE && MDBX_LOG_NOTICE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_NOTICE, __func__, 12239, "need update meta-geo to filesize %" 
# 12239 "/libmdbx/src/core.c" 3 4
     "l" "u" 
# 12239 "/libmdbx/src/core.c"
     " bytes, %" 
# 12239 "/libmdbx/src/core.c" 3 4
     "u" 
# 12239 "/libmdbx/src/core.c"
     " pages" "\n", env->me_dxb_mmap.current, meta.mm_geo.now); } while (0)

                                                            ;
    }

    if (memcmp(&meta.mm_geo, &head->mm_geo, sizeof(meta.mm_geo))) {
      if ((env->me_flags & MDBX_RDONLY) != 0 ||
                              env->me_stuck_meta >= 0) {
        do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 12247, "skipped update meta.geo in %s mode: from l%" 
# 12247 "/libmdbx/src/core.c" 3 4
       "u" 
# 12247 "/libmdbx/src/core.c"
       "-n%" 
# 12247 "/libmdbx/src/core.c" 3 4
       "u" 
# 12247 "/libmdbx/src/core.c"
       "-u%" 
# 12247 "/libmdbx/src/core.c" 3 4
       "u" 
# 12247 "/libmdbx/src/core.c"
       "/s%u-g%u, to l%" 
# 12247 "/libmdbx/src/core.c" 3 4
       "u" 
# 12247 "/libmdbx/src/core.c"
       "-n%" 
# 12247 "/libmdbx/src/core.c" 3 4
       "u" 
# 12247 "/libmdbx/src/core.c"
       "-u%" 
# 12247 "/libmdbx/src/core.c" 3 4
       "u" 
# 12247 "/libmdbx/src/core.c"
       "/s%u-g%u" "\n", (env->me_stuck_meta < 0) ? "read-only" : "recovery", head->mm_geo.lower, head->mm_geo.now, head->mm_geo.upper, pv2pages(head->mm_geo.shrink_pv), pv2pages(head->mm_geo.grow_pv), meta.mm_geo.lower, meta.mm_geo.now, meta.mm_geo.upper, pv2pages(meta.mm_geo.shrink_pv), pv2pages(meta.mm_geo.grow_pv)); } while (0)







                                                                           ;
      } else {
        const txnid_t txnid = constmeta_txnid(env, head);
        const txnid_t next_txnid = safe64_txnid_next(txnid);
        if (__builtin_expect(!!(txnid > (0xffffFFFF00000000UL - 1)), 0)) {
          do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 12260, "txnid overflow, raise %d" "\n", MDBX_TXN_FULL); } while (0);
          return MDBX_TXN_FULL;
        }
        do { if ((MDBX_LOG_NOTICE < MDBX_LOG_VERBOSE && MDBX_LOG_NOTICE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_NOTICE, __func__, 12263, "updating meta.geo: " "from l%" 
# 12263 "/libmdbx/src/core.c" 3 4
       "u" 
# 12263 "/libmdbx/src/core.c"
       "-n%" 
# 12263 "/libmdbx/src/core.c" 3 4
       "u" 
# 12263 "/libmdbx/src/core.c"
       "-u%" 
# 12263 "/libmdbx/src/core.c" 3 4
       "u" 
# 12263 "/libmdbx/src/core.c"
       "/s%u-g%u (txn#%" 
# 12263 "/libmdbx/src/core.c" 3 4
       "l" "i" 
# 12263 "/libmdbx/src/core.c"
       "), " "to l%" 
# 12263 "/libmdbx/src/core.c" 3 4
       "u" 
# 12263 "/libmdbx/src/core.c"
       "-n%" 
# 12263 "/libmdbx/src/core.c" 3 4
       "u" 
# 12263 "/libmdbx/src/core.c"
       "-u%" 
# 12263 "/libmdbx/src/core.c" 3 4
       "u" 
# 12263 "/libmdbx/src/core.c"
       "/s%u-g%u (txn#%" 
# 12263 "/libmdbx/src/core.c" 3 4
       "l" "i" 
# 12263 "/libmdbx/src/core.c"
       ")" "\n", head->mm_geo.lower, head->mm_geo.now, head->mm_geo.upper, pv2pages(head->mm_geo.shrink_pv), pv2pages(head->mm_geo.grow_pv), txnid, meta.mm_geo.lower, meta.mm_geo.now, meta.mm_geo.upper, pv2pages(meta.mm_geo.shrink_pv), pv2pages(meta.mm_geo.grow_pv), next_txnid); } while (0)
# 12273 "/libmdbx/src/core.c"
                                                              ;

        do { if (__builtin_expect(!!(!(meta_eq(env, &meta, head))), 0)) mdbx_assert_fail(env, "meta_eq(env, &meta, head)", __func__, 12275); } while (0);
        meta_set_txnid(env, &meta, next_txnid);
        err = mdbx_sync_locked(env, env->me_flags | 0x40000000U, &meta);
        if (err) {
          do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 12279, "error %d, while updating meta.geo: " "from l%" 
# 12279 "/libmdbx/src/core.c" 3 4
         "u" 
# 12279 "/libmdbx/src/core.c"
         "-n%" 
# 12279 "/libmdbx/src/core.c" 3 4
         "u" 
# 12279 "/libmdbx/src/core.c"
         "-u%" 
# 12279 "/libmdbx/src/core.c" 3 4
         "u" 
# 12279 "/libmdbx/src/core.c"
         "/s%u-g%u (txn#%" 
# 12279 "/libmdbx/src/core.c" 3 4
         "l" "i" 
# 12279 "/libmdbx/src/core.c"
         "), " "to l%" 
# 12279 "/libmdbx/src/core.c" 3 4
         "u" 
# 12279 "/libmdbx/src/core.c"
         "-n%" 
# 12279 "/libmdbx/src/core.c" 3 4
         "u" 
# 12279 "/libmdbx/src/core.c"
         "-u%" 
# 12279 "/libmdbx/src/core.c" 3 4
         "u" 
# 12279 "/libmdbx/src/core.c"
         "/s%u-g%u (txn#%" 
# 12279 "/libmdbx/src/core.c" 3 4
         "l" "i" 
# 12279 "/libmdbx/src/core.c"
         ")" "\n", err, head->mm_geo.lower, head->mm_geo.now, head->mm_geo.upper, pv2pages(head->mm_geo.shrink_pv), pv2pages(head->mm_geo.grow_pv), txnid, meta.mm_geo.lower, meta.mm_geo.now, meta.mm_geo.upper, pv2pages(meta.mm_geo.shrink_pv), pv2pages(meta.mm_geo.grow_pv), next_txnid); } while (0)
# 12289 "/libmdbx/src/core.c"
                                                               ;
          return err;
        }
      }
    }

    atomic_store32(&env->me_lck->mti_discarded_tail,
                   bytes2pgno(env, used_aligned2os_bytes), mo_Relaxed);

    if ((env->me_flags & MDBX_RDONLY) == 0 && env->me_stuck_meta < 0 &&
        (mdbx_runtime_flags & MDBX_DBG_DONT_UPGRADE) == 0) {
      for (int n = 0; n < 3; ++n) {
        MDBX_meta *const pmeta = page_meta(pgno2page(env, n));
        if (__builtin_expect(!!(unaligned_peek_u64(4, &pmeta->mm_magic_and_version) != ((0x59659DBDEF4C11UL << 8) + 0 * 64 + 3)), 0)
                                     ) {
          const txnid_t txnid = meta_txnid(env, pmeta);
          do { if ((MDBX_LOG_NOTICE < MDBX_LOG_VERBOSE && MDBX_LOG_NOTICE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_NOTICE, __func__, 12305, "%s %s" "meta[%u], txnid %" 
# 12305 "/libmdbx/src/core.c" 3 4
         "l" "i" 
# 12305 "/libmdbx/src/core.c"
         "\n", "updating db-format signature for", ((unaligned_peek_u64_volatile(4, (pmeta)->mm_datasync_sign)) > 1u) ? "stead-" : "weak-", n, txnid); } while (0)


                                                                           ;
          err = mdbx_override_meta(env, n, txnid, pmeta);
          if (__builtin_expect(!!(err != MDBX_SUCCESS), 0) &&




              err != MDBX_PROBLEM) {
            do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 12316, "%s meta[%u], txnid %" 
# 12316 "/libmdbx/src/core.c" 3 4
           "l" "i" 
# 12316 "/libmdbx/src/core.c"
           ", error %d" "\n", "updating db-format signature for", n, txnid, err); } while (0)
                                                                         ;
            return err;
          }
        }
      }
    }
  }



  if (used_aligned2os_bytes < env->me_dxb_mmap.current) {

    if (lck_rc && (env->me_flags & MDBX_WRITEMAP) != 0 &&
                                env->me_stuck_meta < 0) {
      do { if ((MDBX_LOG_NOTICE < MDBX_LOG_VERBOSE && MDBX_LOG_NOTICE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_NOTICE, __func__, 12331, "open-MADV_%s %u..%u" "\n", "REMOVE (deallocate file space)", env->me_lck->mti_discarded_tail.weak, bytes2pgno(env, env->me_dxb_mmap.current)); } while (0)

                                                            ;
      err =
          madvise(env->me_dxb_mmap.dxb + used_aligned2os_bytes,
                  env->me_dxb_mmap.current - used_aligned2os_bytes, 
# 12336 "/libmdbx/src/core.c" 3 4
                                                                   9
# 12336 "/libmdbx/src/core.c"
                                                                              )
              ? ignore_enosys(
# 12337 "/libmdbx/src/core.c" 3 4
                             (*__errno_location ())
# 12337 "/libmdbx/src/core.c"
                                  )
              : MDBX_SUCCESS;
      if (__builtin_expect(!!(((err) != MDBX_RESULT_TRUE && (err) != MDBX_RESULT_FALSE)), 0))
        return err;
    }


    do { if ((MDBX_LOG_NOTICE < MDBX_LOG_VERBOSE && MDBX_LOG_NOTICE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_NOTICE, __func__, 12344, "open-MADV_%s %u..%u" "\n", "DONTNEED", env->me_lck->mti_discarded_tail.weak, bytes2pgno(env, env->me_dxb_mmap.current)); } while (0)

                                                          ;
    err =
        madvise(env->me_dxb_mmap.dxb + used_aligned2os_bytes,
                env->me_dxb_mmap.current - used_aligned2os_bytes, 
# 12349 "/libmdbx/src/core.c" 3 4
                                                                 4
# 12349 "/libmdbx/src/core.c"
                                                                              )
            ? ignore_enosys(
# 12350 "/libmdbx/src/core.c" 3 4
                           (*__errno_location ())
# 12350 "/libmdbx/src/core.c"
                                )
            : MDBX_SUCCESS;
    if (__builtin_expect(!!(((err) != MDBX_RESULT_TRUE && (err) != MDBX_RESULT_FALSE)), 0))
      return err;
# 12367 "/libmdbx/src/core.c"
  }

  err = mdbx_set_readahead(env, bytes2pgno(env, used_bytes), readahead, (1));
  if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
    return err;


  return rc;
}




__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static int mdbx_setup_lck(MDBX_env *env, char *lck_pathname,
                                 mdbx_mode_t mode) {
  do { if ((0)) do { if (__builtin_expect(!!(!(env->me_dxb_mmap.fd != (-1))), 0)) mdbx_assert_fail(env, "env->me_dxb_mmap.fd != (-1)", __func__, 12382); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(env->me_lck_mmap.fd == (-1))), 0)) mdbx_assert_fail(env, "env->me_lck_mmap.fd == (-1)", __func__, 12383); } while (0); } while (0);

  int err = mdbx_openfile(MDBX_OPEN_LCK, env, lck_pathname, &env->me_lck_mmap.fd, mode);
  if (err != MDBX_SUCCESS) {
    if (!(err == MDBX_ENOFILE && (env->me_flags & MDBX_EXCLUSIVE)) &&
        !((err == MDBX_EROFS || err == MDBX_EACCESS || err == MDBX_EPERM) &&
          (env->me_flags & MDBX_RDONLY)))
      return err;


    err = mdbx_check_fs_rdonly(env->me_dxb_mmap.fd, lck_pathname, err);
    if (err != MDBX_SUCCESS &&

        !(err == MDBX_ENOSYS && (env->me_flags & MDBX_EXCLUSIVE)))
      return err;



    lcklist_lock();
    do { if ((0)) do { if (__builtin_expect(!!(!(env->me_lcklist_next == 
# 12402 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 12402 "/libmdbx/src/core.c"
   )), 0)) mdbx_assert_fail(env, "env->me_lcklist_next == ((void *)0)", __func__, 12402); } while (0); } while (0);
    env->me_lck_mmap.fd = (-1);
    const int rc = mdbx_lck_seize(env);
    if (((rc) != MDBX_RESULT_TRUE && (rc) != MDBX_RESULT_FALSE)) {


      lcklist_unlock();
      return rc;
    }

    env->me_lcklist_next = inprocess_lcklist_head;
    inprocess_lcklist_head = env;
    lcklist_unlock();


    env->me_lck = lckless_stub(env);
    env->me_maxreaders = 
# 12418 "/libmdbx/src/core.c" 3 4
                        (0x7fffffff * 2U + 1U)
# 12418 "/libmdbx/src/core.c"
                                ;
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 12419, "lck-setup:%s%s%s" "\n", " lck-less", (env->me_flags & MDBX_RDONLY) ? " readonly" : "", (rc == MDBX_RESULT_TRUE) ? " exclusive" : " cooperative"); } while (0)

                                                                        ;
    return rc;
  }


  lcklist_lock();
  do { if ((0)) do { if (__builtin_expect(!!(!(env->me_lcklist_next == 
# 12427 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 12427 "/libmdbx/src/core.c"
 )), 0)) mdbx_assert_fail(env, "env->me_lcklist_next == ((void *)0)", __func__, 12427); } while (0); } while (0);



  err = mdbx_lck_seize(env);
  if (((err) != MDBX_RESULT_TRUE && (err) != MDBX_RESULT_FALSE)) {
  bailout:


    lcklist_unlock();
    return err;
  }

  MDBX_env *inprocess_neighbor = 
# 12440 "/libmdbx/src/core.c" 3 4
                                ((void *)0)
# 12440 "/libmdbx/src/core.c"
                                       ;
  if (err == MDBX_RESULT_TRUE) {
    err = uniq_check(&env->me_lck_mmap, &inprocess_neighbor);
    if (((err) != MDBX_RESULT_TRUE && (err) != MDBX_RESULT_FALSE))
      goto bailout;
    if (inprocess_neighbor &&
        ((mdbx_runtime_flags & MDBX_DBG_LEGACY_MULTIOPEN) == 0 ||
         (inprocess_neighbor->me_flags & MDBX_EXCLUSIVE) != 0)) {
      err = MDBX_BUSY;
      goto bailout;
    }
  }
  const int lck_seize_rc = err;

  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 12454, "lck-setup:%s%s%s" "\n", " with-lck", (env->me_flags & MDBX_RDONLY) ? " readonly" : "", (lck_seize_rc == MDBX_RESULT_TRUE) ? " exclusive" : " cooperative"); } while (0)


                                                                 ;

  uint64_t size = 0;
  err = mdbx_filesize(env->me_lck_mmap.fd, &size);
  if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
    goto bailout;

  if (lck_seize_rc == MDBX_RESULT_TRUE) {
    size = ceil_powerof2(env->me_maxreaders * sizeof(MDBX_reader) +
                             sizeof(MDBX_lockinfo),
                         env->me_os_psize);
    mdbx_jitter4testing((0));
  } else {
    if (env->me_flags & MDBX_EXCLUSIVE) {
      err = MDBX_BUSY;
      goto bailout;
    }
    if (size > 0x7fffffff || (size & (env->me_os_psize - 1)) != 0 ||
        size < env->me_os_psize) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 12476, "lck-file has invalid size %" 
# 12476 "/libmdbx/src/core.c" 3 4
     "l" "u" 
# 12476 "/libmdbx/src/core.c"
     " bytes" "\n", size); } while (0);
      err = MDBX_PROBLEM;
      goto bailout;
    }
  }

  const size_t maxreaders =
      ((size_t)size - sizeof(MDBX_lockinfo)) / sizeof(MDBX_reader);
  if (maxreaders < 4) {
    do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 12485, "lck-size too small (up to %" 
# 12485 "/libmdbx/src/core.c" 3 4
   "l" "u" 
# 12485 "/libmdbx/src/core.c"
   " readers)" "\n", maxreaders); } while (0);
    err = MDBX_PROBLEM;
    goto bailout;
  }
  env->me_maxreaders = (maxreaders <= 32767)
                           ? (unsigned)maxreaders
                           : (unsigned)32767;

  err = mdbx_mmap((env->me_flags & MDBX_EXCLUSIVE) | MDBX_WRITEMAP,
                  &env->me_lck_mmap, (size_t)size, (size_t)size,
                  lck_seize_rc ? 1 | 2
                               : 2);
  if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
    goto bailout;



  err = madvise(env->me_lck_mmap.lck, size, 
# 12502 "/libmdbx/src/core.c" 3 4
                                           17
# 12502 "/libmdbx/src/core.c"
                                                      ) ? ignore_enosys(
# 12502 "/libmdbx/src/core.c" 3 4
                                                                        (*__errno_location ())
# 12502 "/libmdbx/src/core.c"
                                                                             )
                                                         : MDBX_SUCCESS;
  if (__builtin_expect(!!(((err) != MDBX_RESULT_TRUE && (err) != MDBX_RESULT_FALSE)), 0))
    goto bailout;



  err = madvise(env->me_lck_mmap.lck, size, 
# 12509 "/libmdbx/src/core.c" 3 4
                                           3
# 12509 "/libmdbx/src/core.c"
                                                        )
            ? ignore_enosys(
# 12510 "/libmdbx/src/core.c" 3 4
                           (*__errno_location ())
# 12510 "/libmdbx/src/core.c"
                                )
            : MDBX_SUCCESS;
  if (__builtin_expect(!!(((err) != MDBX_RESULT_TRUE && (err) != MDBX_RESULT_FALSE)), 0))
    goto bailout;
# 12522 "/libmdbx/src/core.c"
  struct MDBX_lockinfo *const lck = env->me_lck_mmap.lck;
  if (lck_seize_rc == MDBX_RESULT_TRUE) {

    memset(lck, 0, (size_t)size);
    mdbx_jitter4testing((0));
    lck->mti_magic_and_version = ((0x59659DBDEF4C11UL << 8) + 4);
    lck->mti_os_and_format = (0x8017U * 27733 + (unsigned)sizeof(MDBX_reader) * 13 + (unsigned)
# 12528 "/libmdbx/src/core.c" 3 4
                            __builtin_offsetof (
# 12528 "/libmdbx/src/core.c"
                            MDBX_reader
# 12528 "/libmdbx/src/core.c" 3 4
                            , 
# 12528 "/libmdbx/src/core.c"
                            mr_snapshot_pages_used
# 12528 "/libmdbx/src/core.c" 3 4
                            ) 
# 12528 "/libmdbx/src/core.c"
                            * 251 + (unsigned)
# 12528 "/libmdbx/src/core.c" 3 4
                            __builtin_offsetof (
# 12528 "/libmdbx/src/core.c"
                            MDBX_lockinfo
# 12528 "/libmdbx/src/core.c" 3 4
                            , 
# 12528 "/libmdbx/src/core.c"
                            mti_oldest_reader
# 12528 "/libmdbx/src/core.c" 3 4
                            ) 
# 12528 "/libmdbx/src/core.c"
                            * 83 + (unsigned)
# 12528 "/libmdbx/src/core.c" 3 4
                            __builtin_offsetof (
# 12528 "/libmdbx/src/core.c"
                            MDBX_lockinfo
# 12528 "/libmdbx/src/core.c" 3 4
                            , 
# 12528 "/libmdbx/src/core.c"
                            mti_numreaders
# 12528 "/libmdbx/src/core.c" 3 4
                            ) 
# 12528 "/libmdbx/src/core.c"
                            * 37 + (unsigned)
# 12528 "/libmdbx/src/core.c" 3 4
                            __builtin_offsetof (
# 12528 "/libmdbx/src/core.c"
                            MDBX_lockinfo
# 12528 "/libmdbx/src/core.c" 3 4
                            , 
# 12528 "/libmdbx/src/core.c"
                            mti_readers
# 12528 "/libmdbx/src/core.c" 3 4
                            ) 
# 12528 "/libmdbx/src/core.c"
                            * 29);

    lck->mti_pgop_stat.wops.weak = 1;

    err = mdbx_msync(&env->me_lck_mmap, 0, (size_t)size, MDBX_SYNC_NONE);
    if (__builtin_expect(!!(err != MDBX_SUCCESS), 0)) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 12534, "initial-%s for lck-file failed" "\n", "msync"); } while (0);
      goto bailout;
    }
    err = mdbx_fsync(env->me_lck_mmap.fd, MDBX_SYNC_SIZE);
    if (__builtin_expect(!!(err != MDBX_SUCCESS), 0)) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 12539, "initial-%s for lck-file failed" "\n", "fsync"); } while (0);
      goto bailout;
    }
  } else {
    if (lck->mti_magic_and_version != ((0x59659DBDEF4C11UL << 8) + 4)) {
      const _Bool invalid = (lck->mti_magic_and_version >> 8) != 0x59659DBDEF4C11UL;
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 12545, "lock region has %s" "\n", invalid ? "invalid magic" : "incompatible version (only applications with nearly or the " "same versions of libmdbx can share the same database)"); } while (0)




                                                                        ;
      err = invalid ? MDBX_INVALID : MDBX_VERSION_MISMATCH;
      goto bailout;
    }
    if (lck->mti_os_and_format != (0x8017U * 27733 + (unsigned)sizeof(MDBX_reader) * 13 + (unsigned)
# 12554 "/libmdbx/src/core.c" 3 4
                                 __builtin_offsetof (
# 12554 "/libmdbx/src/core.c"
                                 MDBX_reader
# 12554 "/libmdbx/src/core.c" 3 4
                                 , 
# 12554 "/libmdbx/src/core.c"
                                 mr_snapshot_pages_used
# 12554 "/libmdbx/src/core.c" 3 4
                                 ) 
# 12554 "/libmdbx/src/core.c"
                                 * 251 + (unsigned)
# 12554 "/libmdbx/src/core.c" 3 4
                                 __builtin_offsetof (
# 12554 "/libmdbx/src/core.c"
                                 MDBX_lockinfo
# 12554 "/libmdbx/src/core.c" 3 4
                                 , 
# 12554 "/libmdbx/src/core.c"
                                 mti_oldest_reader
# 12554 "/libmdbx/src/core.c" 3 4
                                 ) 
# 12554 "/libmdbx/src/core.c"
                                 * 83 + (unsigned)
# 12554 "/libmdbx/src/core.c" 3 4
                                 __builtin_offsetof (
# 12554 "/libmdbx/src/core.c"
                                 MDBX_lockinfo
# 12554 "/libmdbx/src/core.c" 3 4
                                 , 
# 12554 "/libmdbx/src/core.c"
                                 mti_numreaders
# 12554 "/libmdbx/src/core.c" 3 4
                                 ) 
# 12554 "/libmdbx/src/core.c"
                                 * 37 + (unsigned)
# 12554 "/libmdbx/src/core.c" 3 4
                                 __builtin_offsetof (
# 12554 "/libmdbx/src/core.c"
                                 MDBX_lockinfo
# 12554 "/libmdbx/src/core.c" 3 4
                                 , 
# 12554 "/libmdbx/src/core.c"
                                 mti_readers
# 12554 "/libmdbx/src/core.c" 3 4
                                 ) 
# 12554 "/libmdbx/src/core.c"
                                 * 29)) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 12555, "lock region has os/format signature 0x%" 
# 12555 "/libmdbx/src/core.c" 3 4
     "x" 
# 12555 "/libmdbx/src/core.c"
     ", expected 0x%" 
# 12555 "/libmdbx/src/core.c" 3 4
     "x" 
# 12555 "/libmdbx/src/core.c"
     "\n", lck->mti_os_and_format, (0x8017U * 27733 + (unsigned)sizeof(MDBX_reader) * 13 + (unsigned)
# 12555 "/libmdbx/src/core.c" 3 4
     __builtin_offsetof (
# 12555 "/libmdbx/src/core.c"
     MDBX_reader
# 12555 "/libmdbx/src/core.c" 3 4
     , 
# 12555 "/libmdbx/src/core.c"
     mr_snapshot_pages_used
# 12555 "/libmdbx/src/core.c" 3 4
     ) 
# 12555 "/libmdbx/src/core.c"
     * 251 + (unsigned)
# 12555 "/libmdbx/src/core.c" 3 4
     __builtin_offsetof (
# 12555 "/libmdbx/src/core.c"
     MDBX_lockinfo
# 12555 "/libmdbx/src/core.c" 3 4
     , 
# 12555 "/libmdbx/src/core.c"
     mti_oldest_reader
# 12555 "/libmdbx/src/core.c" 3 4
     ) 
# 12555 "/libmdbx/src/core.c"
     * 83 + (unsigned)
# 12555 "/libmdbx/src/core.c" 3 4
     __builtin_offsetof (
# 12555 "/libmdbx/src/core.c"
     MDBX_lockinfo
# 12555 "/libmdbx/src/core.c" 3 4
     , 
# 12555 "/libmdbx/src/core.c"
     mti_numreaders
# 12555 "/libmdbx/src/core.c" 3 4
     ) 
# 12555 "/libmdbx/src/core.c"
     * 37 + (unsigned)
# 12555 "/libmdbx/src/core.c" 3 4
     __builtin_offsetof (
# 12555 "/libmdbx/src/core.c"
     MDBX_lockinfo
# 12555 "/libmdbx/src/core.c" 3 4
     , 
# 12555 "/libmdbx/src/core.c"
     mti_readers
# 12555 "/libmdbx/src/core.c" 3 4
     ) 
# 12555 "/libmdbx/src/core.c"
     * 29)); } while (0)

                                                          ;
      err = MDBX_VERSION_MISMATCH;
      goto bailout;
    }
  }

  err = mdbx_lck_init(env, inprocess_neighbor, lck_seize_rc);
  if (((err) != MDBX_RESULT_TRUE && (err) != MDBX_RESULT_FALSE))
    goto bailout;

  do { if (__builtin_expect(!!(!(env->me_lcklist_next == 
# 12567 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 12567 "/libmdbx/src/core.c"
 )), 0)) mdbx_assert_fail(env, "env->me_lcklist_next == nullptr", __func__, 12567); } while (0);

  env->me_lcklist_next = inprocess_lcklist_head;
  inprocess_lcklist_head = env;
  lcklist_unlock();


  do { if ((0)) do { if (__builtin_expect(!!(!(!((lck_seize_rc) != MDBX_RESULT_TRUE && (lck_seize_rc) != MDBX_RESULT_FALSE))), 0)) mdbx_assert_fail(env, "!((lck_seize_rc) != MDBX_RESULT_TRUE && (lck_seize_rc) != MDBX_RESULT_FALSE)", __func__, 12574); } while (0); } while (0);
  env->me_lck = lck;
  return lck_seize_rc;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_is_readahead_reasonable(size_t volume, intptr_t redundancy) {
  if (volume <= 1024 * 1024 * 4ul)
    return MDBX_RESULT_TRUE;

  intptr_t pagesize, total_ram_pages;
  int err = mdbx_get_sysraminfo(&pagesize, &total_ram_pages, 
# 12584 "/libmdbx/src/core.c" 3 4
                                                            ((void *)0)
# 12584 "/libmdbx/src/core.c"
                                                                   );
  if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
    return err;

  const int log2page = log2n_powerof2(pagesize);
  const intptr_t volume_pages = (volume + pagesize - 1) >> log2page;
  const intptr_t redundancy_pages =
      (redundancy < 0) ? -(intptr_t)((-redundancy + pagesize - 1) >> log2page)
                       : (intptr_t)(redundancy + pagesize - 1) >> log2page;
  if (volume_pages >= total_ram_pages ||
      volume_pages + redundancy_pages >= total_ram_pages)
    return MDBX_RESULT_FALSE;

  intptr_t avail_ram_pages;
  err = mdbx_get_sysraminfo(
# 12598 "/libmdbx/src/core.c" 3 4
                           ((void *)0)
# 12598 "/libmdbx/src/core.c"
                                  , 
# 12598 "/libmdbx/src/core.c" 3 4
                                    ((void *)0)
# 12598 "/libmdbx/src/core.c"
                                           , &avail_ram_pages);
  if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
    return err;

  return (volume_pages + redundancy_pages >= avail_ram_pages)
             ? MDBX_RESULT_FALSE
             : MDBX_RESULT_TRUE;
}


static uint32_t merge_sync_flags(const uint32_t a, const uint32_t b) {
  uint32_t r = a | b;


  if ((((r) & (MDBX_UTTERLY_NOSYNC)) == (MDBX_UTTERLY_NOSYNC)) && !(((a) & (MDBX_UTTERLY_NOSYNC)) == (MDBX_UTTERLY_NOSYNC)) &&
      !(((b) & (MDBX_UTTERLY_NOSYNC)) == (MDBX_UTTERLY_NOSYNC)))
    r = (r - MDBX_UTTERLY_NOSYNC) | MDBX_SAFE_NOSYNC;


  if ((r & (MDBX_WRITEMAP | 0x100000U)) ==
          (MDBX_WRITEMAP | 0x100000U) &&
      !(((r) & (MDBX_UTTERLY_NOSYNC)) == (MDBX_UTTERLY_NOSYNC)))
    r = (r - 0x100000U) | MDBX_SAFE_NOSYNC;


  if (r & MDBX_SAFE_NOSYNC)
    r |= MDBX_NOMETASYNC;

  do { if ((0)) do { if (__builtin_expect(!!(!(!((((r) & (MDBX_UTTERLY_NOSYNC)) == (MDBX_UTTERLY_NOSYNC)) && !(((a) & (MDBX_UTTERLY_NOSYNC)) == (MDBX_UTTERLY_NOSYNC)) && !(((b) & (MDBX_UTTERLY_NOSYNC)) == (MDBX_UTTERLY_NOSYNC))))), 0)) mdbx_assert_fail(
# 12626 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 12626 "/libmdbx/src/core.c"
 , "!((((r) & (MDBX_UTTERLY_NOSYNC)) == (MDBX_UTTERLY_NOSYNC)) && !(((a) & (MDBX_UTTERLY_NOSYNC)) == (MDBX_UTTERLY_NOSYNC)) && !(((b) & (MDBX_UTTERLY_NOSYNC)) == (MDBX_UTTERLY_NOSYNC)))", __func__, 12626); } while (0); } while (0)

                                             ;
  return r;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static int __attribute__((__warn_unused_result__)) mdbx_override_meta(
    MDBX_env *env, unsigned target, txnid_t txnid, const MDBX_meta *shape) {
  int rc = alloc_page_buf(env);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;
  MDBX_page *const page = env->me_pbuf;
  mdbx_meta_model(env, page, target);
  MDBX_meta *const model = page_meta(page);
  meta_set_txnid(env, model, txnid);
  do { if ((0)) do { if (__builtin_expect(!!(!(meta_checktxnid(env, model, (1)))), 0)) mdbx_assert_fail(env, "meta_checktxnid(env, model, (1))", __func__, 12641); } while (0); } while (0);
  if (shape) {
    if (txnid && __builtin_expect(!!(!meta_checktxnid(env, shape, (0))), 0)) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 12644, "bailout overriding meta-%u since model failed " "freedb/maindb %s-check for txnid #%" 
# 12644 "/libmdbx/src/core.c" 3 4
     "l" "i" 
# 12644 "/libmdbx/src/core.c"
     "\n", target, "pre", constmeta_txnid(env, shape)); } while (0)

                                                            ;
      return MDBX_PROBLEM;
    }
    if (mdbx_runtime_flags & MDBX_DBG_DONT_UPGRADE)
      memcpy(&model->mm_magic_and_version, &shape->mm_magic_and_version,
             sizeof(model->mm_magic_and_version));
    model->mm_extra_flags = shape->mm_extra_flags;
    model->mm_validator_id = shape->mm_validator_id;
    model->mm_extra_pagehdr = shape->mm_extra_pagehdr;
    memcpy(&model->mm_geo, &shape->mm_geo, sizeof(model->mm_geo));
    memcpy(&model->mm_dbs, &shape->mm_dbs, sizeof(model->mm_dbs));
    memcpy(&model->mm_canary, &shape->mm_canary, sizeof(model->mm_canary));
    memcpy(&model->mm_pages_retired, &shape->mm_pages_retired,
           sizeof(model->mm_pages_retired));
    if (txnid) {
      if ((!model->mm_dbs[0].md_mod_txnid &&
           model->mm_dbs[0].md_root != (~(pgno_t)0)) ||
          (!model->mm_dbs[1].md_mod_txnid &&
           model->mm_dbs[1].md_root != (~(pgno_t)0)))
        memcpy(&model->mm_magic_and_version, &shape->mm_magic_and_version,
               sizeof(model->mm_magic_and_version));
      if (__builtin_expect(!!(!meta_checktxnid(env, model, (0))), 0)) {
        do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 12668, "bailout overriding meta-%u since model failed " "freedb/maindb %s-check for txnid #%" 
# 12668 "/libmdbx/src/core.c" 3 4
       "l" "i" 
# 12668 "/libmdbx/src/core.c"
       "\n", target, "post", txnid); } while (0)

                                         ;
        return MDBX_PROBLEM;
      }
    }
  }
  unaligned_poke_u64(4, model->mm_datasync_sign, meta_sign(model));
  rc = mdbx_validate_meta(env, model, page, target, 
# 12676 "/libmdbx/src/core.c" 3 4
                                                   ((void *)0)
# 12676 "/libmdbx/src/core.c"
                                                          );
  if (__builtin_expect(!!(((rc) != MDBX_RESULT_TRUE && (rc) != MDBX_RESULT_FALSE)), 0))
    return MDBX_PROBLEM;

  if (shape && memcmp(model, shape, sizeof(MDBX_meta)) == 0)
    return MDBX_SUCCESS;


  env->me_lck->mti_pgop_stat.wops.weak += 1;

  if (env->me_flags & MDBX_WRITEMAP) {
    rc = mdbx_msync(&env->me_dxb_mmap, 0,
                    pgno_align2os_bytes(env, model->mm_geo.next),
                    MDBX_SYNC_DATA | MDBX_SYNC_IODQ);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      return rc;



    memcpy(pgno2page(env, target), page, env->me_psize);
    mdbx_memory_barrier();
    rc = mdbx_msync(&env->me_dxb_mmap, 0, pgno_align2os_bytes(env, target + 1),
                    MDBX_SYNC_DATA | MDBX_SYNC_IODQ);
  } else {
    const mdbx_filehandle_t fd = (env->me_dsync_fd != (-1))
                                     ? env->me_dsync_fd
                                     : env->me_dxb_mmap.fd;
    rc = mdbx_pwrite(fd, page, env->me_psize, pgno2bytes(env, target));
    if (rc == MDBX_SUCCESS && fd == env->me_dxb_mmap.fd)
      rc = mdbx_fsync(env->me_dxb_mmap.fd, MDBX_SYNC_DATA | MDBX_SYNC_IODQ);
  }
  mdbx_flush_incoherent_mmap(env->me_dxb_mmap.dxb, pgno2bytes(env, 3),
                             env->me_os_psize);
  return rc;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_turn_for_recovery(MDBX_env *env, unsigned target) {
  if (__builtin_expect(!!(target >= 3), 0))
    return MDBX_EINVAL;
  int rc = check_env(env, (1));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!((env->me_flags & (MDBX_EXCLUSIVE | MDBX_RDONLY)) != MDBX_EXCLUSIVE), 0)
                              )
    return MDBX_EPERM;

  const MDBX_meta *target_meta = page_meta(pgno2page(env, target));
  txnid_t new_txnid = safe64_txnid_next(constmeta_txnid(env, target_meta));
  for (unsigned n = 0; n < 3; ++n) {
    MDBX_page *page = pgno2page(env, n);
    MDBX_meta meta = *page_meta(page);
    if (n == target)
      continue;
    if (mdbx_validate_meta(env, &meta, page, n, 
# 12730 "/libmdbx/src/core.c" 3 4
                                               ((void *)0)
# 12730 "/libmdbx/src/core.c"
                                                      ) != MDBX_SUCCESS) {
      int err = mdbx_override_meta(env, n, 0, 
# 12731 "/libmdbx/src/core.c" 3 4
                                             ((void *)0)
# 12731 "/libmdbx/src/core.c"
                                                    );
      if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
        return err;
    } else {
      txnid_t txnid = constmeta_txnid(env, &meta);
      if (new_txnid <= txnid)
        new_txnid = safe64_txnid_next(txnid);
    }
  }

  if (__builtin_expect(!!(new_txnid > (0xffffFFFF00000000UL - 1)), 0)) {
    do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 12742, "txnid overflow, raise %d" "\n", MDBX_TXN_FULL); } while (0);
    return MDBX_TXN_FULL;
  }
  return mdbx_override_meta(env, target, new_txnid, target_meta);
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_open_for_recovery(MDBX_env *env, const char *pathname,
                                      unsigned target_meta, _Bool writeable) {
  if (__builtin_expect(!!(target_meta >= 3), 0))
    return MDBX_EINVAL;
  int rc = check_env(env, (0));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;
  if (__builtin_expect(!!(env->me_dxb_mmap.dxb), 0))
    return MDBX_EPERM;

  env->me_stuck_meta = (int8_t)target_meta;
  return mdbx_env_open(
      env, pathname, writeable ? MDBX_EXCLUSIVE : MDBX_EXCLUSIVE | MDBX_RDONLY,
      0);
}

typedef struct {
  void *buffer_for_free;
  char *lck, *dxb;
  size_t ent_len;
} MDBX_handle_env_pathname;

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static int mdbx_handle_env_pathname(MDBX_handle_env_pathname *ctx,
                                           const char *pathname,
                                           MDBX_env_flags_t *flags,
                                           const mdbx_mode_t mode) {
  int rc;
  memset(ctx, 0, sizeof(*ctx));
  if (__builtin_expect(!!(!pathname), 0))
    return MDBX_EINVAL;
# 12810 "/libmdbx/src/core.c"
  struct stat st;
  if (stat(pathname, &st)) {
    rc = 
# 12812 "/libmdbx/src/core.c" 3 4
        (*__errno_location ())
# 12812 "/libmdbx/src/core.c"
             ;
    if (rc != MDBX_ENOFILE)
      return rc;
    if (mode == 0 || (*flags & MDBX_RDONLY) != 0)

      return rc;


    const mdbx_mode_t dir_mode =
        ( mode &
         (
# 12822 "/libmdbx/src/core.c" 3 4
         (0400 >> 3) 
# 12822 "/libmdbx/src/core.c"
                 | 
# 12822 "/libmdbx/src/core.c" 3 4
                   (0200 >> 3) 
# 12822 "/libmdbx/src/core.c"
                           | 
# 12822 "/libmdbx/src/core.c" 3 4
                             ((0400 >> 3) >> 3) 
# 12822 "/libmdbx/src/core.c"
                                     | 
# 12822 "/libmdbx/src/core.c" 3 4
                                       ((0200 >> 3) >> 3)
# 12822 "/libmdbx/src/core.c"
                                              )) |
                                                     
# 12823 "/libmdbx/src/core.c" 3 4
                                                    (0400|0200|0100) 
# 12823 "/libmdbx/src/core.c"
                                                            |
        ((mode & 
# 12824 "/libmdbx/src/core.c" 3 4
                (0400 >> 3)
# 12824 "/libmdbx/src/core.c"
                       ) ? 
# 12824 "/libmdbx/src/core.c" 3 4
                                                              (0100 >> 3) 
# 12824 "/libmdbx/src/core.c"
                                                                      : 0) |
        ((mode & 
# 12825 "/libmdbx/src/core.c" 3 4
                ((0400 >> 3) >> 3)
# 12825 "/libmdbx/src/core.c"
                       ) ? 
# 12825 "/libmdbx/src/core.c" 3 4
                                                               ((0100 >> 3) >> 3) 
# 12825 "/libmdbx/src/core.c"
                                                                       : 0);
    if ((*flags & MDBX_NOSUBDIR) == 0 && mkdir(pathname, dir_mode)) {
      rc = 
# 12827 "/libmdbx/src/core.c" 3 4
          (*__errno_location ())
# 12827 "/libmdbx/src/core.c"
               ;
      if (rc != 
# 12828 "/libmdbx/src/core.c" 3 4
               17
# 12828 "/libmdbx/src/core.c"
                     )
        return rc;
    }
  } else {

    *flags |= MDBX_NOSUBDIR;
    if (
# 12834 "/libmdbx/src/core.c" 3 4
       ((((
# 12834 "/libmdbx/src/core.c"
       st.st_mode
# 12834 "/libmdbx/src/core.c" 3 4
       )) & 0170000) == (0040000))
# 12834 "/libmdbx/src/core.c"
                          )
      *flags -= MDBX_NOSUBDIR;
  }


  static const char dxb_name[] = "/mdbx.dat";
  static const size_t dxb_name_len = sizeof(dxb_name) - 1;
  static const char lck_name[] = "/mdbx.lck";
  static const char lock_suffix[] = "-lck";

  ctx->ent_len = strlen(pathname);
  if ((*flags & MDBX_NOSUBDIR) && ctx->ent_len >= dxb_name_len &&
      !memcmp(dxb_name, pathname + ctx->ent_len - dxb_name_len, dxb_name_len)) {
    *flags -= MDBX_NOSUBDIR;
    ctx->ent_len -= dxb_name_len;
  }

  const size_t bytes_needed =
      ctx->ent_len * 2 + ((*flags & MDBX_NOSUBDIR)
                              ? sizeof(lock_suffix) + 1
                              : sizeof(lck_name) + sizeof(dxb_name));
  ctx->buffer_for_free = malloc(bytes_needed);
  if (!ctx->buffer_for_free)
    return MDBX_ENOMEM;

  ctx->lck = ctx->buffer_for_free;
  if (*flags & MDBX_NOSUBDIR) {
    ctx->dxb = ctx->lck + ctx->ent_len + sizeof(lock_suffix);
    sprintf(ctx->lck, "%s%s", pathname, lock_suffix);
    strcpy(ctx->dxb, pathname);
  } else {
    ctx->dxb = ctx->lck + ctx->ent_len + sizeof(lck_name);
    sprintf(ctx->lck, "%.*s%s", (int)ctx->ent_len, pathname, lck_name);
    sprintf(ctx->dxb, "%.*s%s", (int)ctx->ent_len, pathname, dxb_name);
  }

  return MDBX_SUCCESS;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_delete(const char *pathname, MDBX_env_delete_mode_t mode) {
  switch (mode) {
  default:
    return MDBX_EINVAL;
  case MDBX_ENV_JUST_DELETE:
  case MDBX_ENV_ENSURE_UNUSED:
  case MDBX_ENV_WAIT_FOR_UNUSED:
    break;
  }




  MDBX_env dummy_env_silo, *const dummy_env = &dummy_env_silo;

  memset(dummy_env, 0, sizeof(*dummy_env));
  dummy_env->me_flags =
      (mode == MDBX_ENV_ENSURE_UNUSED) ? MDBX_EXCLUSIVE : MDBX_ENV_DEFAULTS;
  dummy_env->me_os_psize = (unsigned)mdbx_syspagesize();
  dummy_env->me_psize = (unsigned)mdbx_default_pagesize();
  dummy_env->me_pathname = (char *)pathname;

  MDBX_handle_env_pathname env_pathname;
  _Static_assert(sizeof(dummy_env->me_flags) == sizeof(MDBX_env_flags_t), "sizeof(dummy_env->me_flags) == sizeof(MDBX_env_flags_t)");
  int rc = MDBX_RESULT_TRUE,
      err = mdbx_handle_env_pathname(
          &env_pathname, pathname, (MDBX_env_flags_t *)&dummy_env->me_flags, 0);
  if (__builtin_expect(!!(err == MDBX_SUCCESS), 1)) {
    mdbx_filehandle_t clk_handle = (-1),
                      dxb_handle = (-1);
    if (mode > MDBX_ENV_JUST_DELETE) {
      err = mdbx_openfile(MDBX_OPEN_DELETE, dummy_env, env_pathname.dxb,
                          &dxb_handle, 0);
      err = (err == MDBX_ENOFILE) ? MDBX_SUCCESS : err;
      if (err == MDBX_SUCCESS) {
        err = mdbx_openfile(MDBX_OPEN_DELETE, dummy_env, env_pathname.lck,
                            &clk_handle, 0);
        err = (err == MDBX_ENOFILE) ? MDBX_SUCCESS : err;
      }
      if (err == MDBX_SUCCESS && clk_handle != (-1))
        err = mdbx_lockfile(clk_handle, mode == MDBX_ENV_WAIT_FOR_UNUSED);
      if (err == MDBX_SUCCESS && dxb_handle != (-1))
        err = mdbx_lockfile(dxb_handle, mode == MDBX_ENV_WAIT_FOR_UNUSED);
    }

    if (err == MDBX_SUCCESS) {
      err = mdbx_removefile(env_pathname.dxb);
      if (err == MDBX_SUCCESS)
        rc = MDBX_SUCCESS;
      else if (err == MDBX_ENOFILE)
        err = MDBX_SUCCESS;
    }

    if (err == MDBX_SUCCESS) {
      err = mdbx_removefile(env_pathname.lck);
      if (err == MDBX_SUCCESS)
        rc = MDBX_SUCCESS;
      else if (err == MDBX_ENOFILE)
        err = MDBX_SUCCESS;
    }

    if (err == MDBX_SUCCESS && !(dummy_env->me_flags & MDBX_NOSUBDIR)) {
      err = mdbx_removedirectory(pathname);
      if (err == MDBX_SUCCESS)
        rc = MDBX_SUCCESS;
      else if (err == MDBX_ENOFILE)
        err = MDBX_SUCCESS;
    }

    if (dxb_handle != (-1))
      mdbx_closefile(dxb_handle);
    if (clk_handle != (-1))
      mdbx_closefile(clk_handle);
  } else if (err == MDBX_ENOFILE)
    err = MDBX_SUCCESS;

  free(env_pathname.buffer_for_free);
  return (err == MDBX_SUCCESS) ? rc : err;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_open(MDBX_env *env, const char *pathname,
                         MDBX_env_flags_t flags, mdbx_mode_t mode) {
  int rc = check_env(env, (0));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(flags & ~((MDBX_SAFE_NOSYNC | MDBX_NOMETASYNC | 0x100000U | MDBX_NOMEMINIT | MDBX_COALESCE | MDBX_PAGEPERTURB | MDBX_ACCEDE) | (MDBX_NOSUBDIR | MDBX_RDONLY | MDBX_WRITEMAP | MDBX_NOTLS | MDBX_NORDAHEAD | MDBX_LIFORECLAIM | MDBX_EXCLUSIVE))), 0))
    return MDBX_EINVAL;

  if (flags & MDBX_RDONLY)
    mode = 0;

  if (env->me_dxb_mmap.fd != (-1) ||
      (env->me_flags & 0x20000000U) != 0 || env->me_dxb_mmap.dxb)
    return MDBX_EPERM;



  const uint32_t saved_me_flags = env->me_flags;
  flags = merge_sync_flags(flags, env->me_flags);

  MDBX_handle_env_pathname env_pathname;
  rc = mdbx_handle_env_pathname(&env_pathname, pathname, &flags, mode);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    goto bailout;

  if (flags & MDBX_RDONLY) {


    flags &= ~(MDBX_WRITEMAP | 0x100000U | MDBX_SAFE_NOSYNC |
               MDBX_NOMETASYNC | MDBX_COALESCE | MDBX_LIFORECLAIM |
               MDBX_NOMEMINIT | MDBX_ACCEDE);
  } else {
# 13001 "/libmdbx/src/core.c"
  }

  env->me_flags = (flags & ~0x80000000U) | 0x20000000U;
  env->me_pathname = calloc(env_pathname.ent_len + 1, 1);
  env->me_dbxs = calloc(env->me_maxdbs, sizeof(MDBX_dbx));
  env->me_dbflags = calloc(env->me_maxdbs, sizeof(env->me_dbflags[0]));
  env->me_dbiseqs = calloc(env->me_maxdbs, sizeof(env->me_dbiseqs[0]));
  if (!(env->me_dbxs && env->me_pathname && env->me_dbflags &&
        env->me_dbiseqs)) {
    rc = MDBX_ENOMEM;
    goto bailout;
  }
  memcpy(env->me_pathname, env_pathname.dxb, env_pathname.ent_len);
  env->me_dbxs[0].md_cmp = cmp_int_align4;
  env->me_dbxs[0].md_dcmp = cmp_lenfast;

  rc = mdbx_openfile((((flags) & (MDBX_RDONLY)) == (MDBX_RDONLY)) ? MDBX_OPEN_DXB_READ
                                                 : MDBX_OPEN_DXB_LAZY,
                     env, env_pathname.dxb, &env->me_dxb_mmap.fd, mode);
  if (rc != MDBX_SUCCESS)
    goto bailout;

  do { if ((0)) do { if (__builtin_expect(!!(!(env->me_dsync_fd == (-1))), 0)) mdbx_assert_fail(env, "env->me_dsync_fd == (-1)", __func__, 13023); } while (0); } while (0);
  if ((flags & (MDBX_RDONLY | MDBX_SAFE_NOSYNC | MDBX_NOMETASYNC)) == 0) {
    rc = mdbx_openfile(MDBX_OPEN_DXB_DSYNC, env, env_pathname.dxb,
                       &env->me_dsync_fd, 0);
    do { if (__builtin_expect(!!(!((rc != MDBX_SUCCESS) == (env->me_dsync_fd == (-1)))), 0)) mdbx_assert_fail(env, "(rc != MDBX_SUCCESS) == (env->me_dsync_fd == INVALID_HANDLE_VALUE)", __func__, 13027); } while (0)
                                                                    ;
  }
# 13040 "/libmdbx/src/core.c"
  if (mode == 0) {

    struct stat st;
    if (fstat(env->me_dxb_mmap.fd, &st)) {
      rc = 
# 13044 "/libmdbx/src/core.c" 3 4
          (*__errno_location ())
# 13044 "/libmdbx/src/core.c"
               ;
      goto bailout;
    }
    mode = st.st_mode;
  }
  mode = ( mode &
          (
# 13050 "/libmdbx/src/core.c" 3 4
          (0400 >> 3) 
# 13050 "/libmdbx/src/core.c"
                  | 
# 13050 "/libmdbx/src/core.c" 3 4
                    (0200 >> 3) 
# 13050 "/libmdbx/src/core.c"
                            | 
# 13050 "/libmdbx/src/core.c" 3 4
                              ((0400 >> 3) >> 3) 
# 13050 "/libmdbx/src/core.c"
                                      | 
# 13050 "/libmdbx/src/core.c" 3 4
                                        ((0200 >> 3) >> 3)
# 13050 "/libmdbx/src/core.c"
                                               )) |
                                                      
# 13051 "/libmdbx/src/core.c" 3 4
                                                     0400 
# 13051 "/libmdbx/src/core.c"
                                                             | 
# 13051 "/libmdbx/src/core.c" 3 4
                                                               0200 
# 13051 "/libmdbx/src/core.c"
                                                                       |
         ((mode & 
# 13052 "/libmdbx/src/core.c" 3 4
                 (0400 >> 3)
# 13052 "/libmdbx/src/core.c"
                        ) ? 
# 13052 "/libmdbx/src/core.c" 3 4
                                                              (0200 >> 3) 
# 13052 "/libmdbx/src/core.c"
                                                                      : 0) |
         ((mode & 
# 13053 "/libmdbx/src/core.c" 3 4
                 ((0400 >> 3) >> 3)
# 13053 "/libmdbx/src/core.c"
                        ) ? 
# 13053 "/libmdbx/src/core.c" 3 4
                                                               ((0200 >> 3) >> 3) 
# 13053 "/libmdbx/src/core.c"
                                                                       : 0);

  const int lck_rc = mdbx_setup_lck(env, env_pathname.lck, mode);
  if (((lck_rc) != MDBX_RESULT_TRUE && (lck_rc) != MDBX_RESULT_FALSE)) {
    rc = lck_rc;
    goto bailout;
  }



  mdbx_fseek(env->me_lck_mmap.fd, 1UL << 63);
  mdbx_fseek(env->me_dxb_mmap.fd, 1UL << 63);
  if (env->me_dsync_fd != (-1))
    mdbx_fseek(env->me_dsync_fd, 1UL << 63);

  const MDBX_env_flags_t rigorous_flags =
      MDBX_SAFE_NOSYNC | 0x100000U;
  const MDBX_env_flags_t mode_flags = rigorous_flags | MDBX_NOMETASYNC |
                                      MDBX_LIFORECLAIM | MDBX_COALESCE |
                                      MDBX_NORDAHEAD;

  MDBX_lockinfo *const lck = env->me_lck_mmap.lck;
  if (lck && lck_rc != MDBX_RESULT_TRUE && (env->me_flags & MDBX_RDONLY) == 0) {
    while (atomic_load32(&lck->mti_envmode, mo_AcquireRelease) == MDBX_RDONLY) {
      if (atomic_cas32(&lck->mti_envmode, MDBX_RDONLY,
                       env->me_flags & mode_flags)) {
# 13090 "/libmdbx/src/core.c"
        break;
      }
      atomic_yield();
    }

    if (env->me_flags & MDBX_ACCEDE) {


      const unsigned diff =
          (lck->mti_envmode.weak ^ env->me_flags) & mode_flags;
      do { if ((MDBX_LOG_NOTICE < MDBX_LOG_VERBOSE && MDBX_LOG_NOTICE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_NOTICE, __func__, 13100, "accede mode-flags: 0x%X, 0x%X -> 0x%X" "\n", diff, env->me_flags, env->me_flags ^ diff); } while (0)
                                       ;
      env->me_flags ^= diff;
    }

    if ((lck->mti_envmode.weak ^ env->me_flags) & rigorous_flags) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 13106, "%s" "\n", "current mode/flags incompatible with requested"); } while (0);
      rc = MDBX_INCOMPATIBLE;
      goto bailout;
    }
  }

  const int dxb_rc = mdbx_setup_dxb(env, lck_rc, mode);
  if (((dxb_rc) != MDBX_RESULT_TRUE && (dxb_rc) != MDBX_RESULT_FALSE)) {
    rc = dxb_rc;
    goto bailout;
  }

  if (__builtin_expect(!!(env->me_stuck_meta >= 0), 0) &&
      (lck_rc != MDBX_RESULT_TRUE ||
       (flags & MDBX_EXCLUSIVE) == 0)) {
    do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 13121, "%s" "\n", "recovery requires exclusive mode"); } while (0);
    rc = MDBX_BUSY;
    goto bailout;
  }

  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 13126, "opened dbenv %p" "\n", (void *)env); } while (0);
  if (lck) {
    if (lck_rc == MDBX_RESULT_TRUE) {
      lck->mti_envmode.weak = env->me_flags & (mode_flags | MDBX_RDONLY);
      rc = mdbx_lck_downgrade(env);
      do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 13131, "lck-downgrade-%s: rc %i" "\n", (env->me_flags & MDBX_EXCLUSIVE) ? "partial" : "full", rc); } while (0)
                                                                           ;
      if (rc != MDBX_SUCCESS)
        goto bailout;
    } else {
      rc = mdbx_cleanup_dead_readers(env, (0), 
# 13136 "/libmdbx/src/core.c" 3 4
                                                ((void *)0)
# 13136 "/libmdbx/src/core.c"
                                                    );
      if (((rc) != MDBX_RESULT_TRUE && (rc) != MDBX_RESULT_FALSE))
        goto bailout;
    }

    if ((env->me_flags & MDBX_NOTLS) == 0) {
      rc = mdbx_rthc_alloc(&env->me_txkey, &lck->mti_readers[0],
                           &lck->mti_readers[env->me_maxreaders]);
      if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
        goto bailout;
      env->me_flags |= 0x10000000U;
    }
  }

  if ((flags & MDBX_RDONLY) == 0) {
    const size_t tsize = sizeof(MDBX_txn),
                 size = tsize + env->me_maxdbs *
                                    (sizeof(MDBX_db) + sizeof(MDBX_cursor *) +
                                     sizeof(unsigned) + 1);
    rc = alloc_page_buf(env);
    if (rc == MDBX_SUCCESS) {
      memset(env->me_pbuf, -1, env->me_psize * 2);
      MDBX_txn *txn = calloc(1, size);
      if (txn) {
        txn->mt_dbs = (MDBX_db *)((char *)txn + tsize);
        txn->mt_cursors = (MDBX_cursor **)(txn->mt_dbs + env->me_maxdbs);
        txn->mt_dbiseqs = (unsigned *)(txn->mt_cursors + env->me_maxdbs);
        txn->mt_dbistate = (uint8_t *)(txn->mt_dbiseqs + env->me_maxdbs);
        txn->mt_env = env;
        txn->mt_dbxs = env->me_dbxs;
        txn->mt_flags = 0x01;
        env->me_txn0 = txn;
        txn->tw.retired_pages = mdbx_pnl_alloc((1024 - 2 - (8 * 2u) / sizeof(pgno_t)));
        txn->tw.reclaimed_pglist = mdbx_pnl_alloc((1024 - 2 - (8 * 2u) / sizeof(pgno_t)));
        if (__builtin_expect(!!(!txn->tw.retired_pages || !txn->tw.reclaimed_pglist), 0))
          rc = MDBX_ENOMEM;
      } else
        rc = MDBX_ENOMEM;
    }
  }
# 13197 "/libmdbx/src/core.c"
bailout:
  if (rc != MDBX_SUCCESS) {
    rc = mdbx_env_close0(env) ? MDBX_PANIC : rc;
    env->me_flags =
        saved_me_flags | ((rc != MDBX_PANIC) ? 0 : 0x80000000U);
  } else {



  }
  free(env_pathname.buffer_for_free);
  return rc;
}


__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static int mdbx_env_close0(MDBX_env *env) {
  const unsigned flags = env->me_flags;
  if (!(flags & 0x20000000U)) {
    do { if (__builtin_expect(!!(!(env->me_lcklist_next == 
# 13215 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 13215 "/libmdbx/src/core.c"
   )), 0)) mdbx_assert_fail(env, "env->me_lcklist_next == nullptr", __func__, 13215); } while (0);
    return MDBX_SUCCESS;
  }

  env->me_flags &= ~(0x80000000U | 0x20000000U | 0x10000000U);
  env->me_lck = 
# 13220 "/libmdbx/src/core.c" 3 4
               ((void *)0)
# 13220 "/libmdbx/src/core.c"
                      ;
  if (flags & 0x10000000U) {
    mdbx_rthc_remove(env->me_txkey);
    env->me_txkey = (mdbx_thread_key_t)0;
  }

  lcklist_lock();
  const int rc = lcklist_detach_locked(env);
  lcklist_unlock();

  if (env->me_dxb_mmap.dxb) {
    mdbx_munmap(&env->me_dxb_mmap);




  }

  if (env->me_dsync_fd != (-1)) {
    (void)mdbx_closefile(env->me_dsync_fd);
    env->me_dsync_fd = (-1);
  }

  if (env->me_dxb_mmap.fd != (-1)) {
    (void)mdbx_closefile(env->me_dxb_mmap.fd);
    env->me_dxb_mmap.fd = (-1);
  }

  if (env->me_lck_mmap.lck)
    mdbx_munmap(&env->me_lck_mmap);

  if (env->me_lck_mmap.fd != (-1)) {
    (void)mdbx_closefile(env->me_lck_mmap.fd);
    env->me_lck_mmap.fd = (-1);
  }

  if (env->me_dbxs) {
    for (unsigned i = env->me_numdbs; --i >= 2;)
      free(env->me_dbxs[i].md_name.iov_base);
    free(env->me_dbxs);
    env->me_dbxs = 
# 13260 "/libmdbx/src/core.c" 3 4
                  ((void *)0)
# 13260 "/libmdbx/src/core.c"
                         ;
  }
  if (env->me_pbuf) {
    mdbx_memalign_free(env->me_pbuf);
    env->me_pbuf = 
# 13264 "/libmdbx/src/core.c" 3 4
                  ((void *)0)
# 13264 "/libmdbx/src/core.c"
                         ;
  }
  if (env->me_dbiseqs) {
    free(env->me_dbiseqs);
    env->me_dbiseqs = 
# 13268 "/libmdbx/src/core.c" 3 4
                     ((void *)0)
# 13268 "/libmdbx/src/core.c"
                            ;
  }
  if (env->me_dbflags) {
    free(env->me_dbflags);
    env->me_dbflags = 
# 13272 "/libmdbx/src/core.c" 3 4
                     ((void *)0)
# 13272 "/libmdbx/src/core.c"
                            ;
  }
  if (env->me_pathname) {
    free(env->me_pathname);
    env->me_pathname = 
# 13276 "/libmdbx/src/core.c" 3 4
                      ((void *)0)
# 13276 "/libmdbx/src/core.c"
                             ;
  }
  if (env->me_txn0) {
    mdbx_dpl_free(env->me_txn0);
    mdbx_txl_free(env->me_txn0->tw.lifo_reclaimed);
    mdbx_pnl_free(env->me_txn0->tw.retired_pages);
    mdbx_pnl_free(env->me_txn0->tw.spill_pages);
    mdbx_pnl_free(env->me_txn0->tw.reclaimed_pglist);
    free(env->me_txn0);
    env->me_txn0 = 
# 13285 "/libmdbx/src/core.c" 3 4
                  ((void *)0)
# 13285 "/libmdbx/src/core.c"
                         ;
  }
  env->me_stuck_meta = -1;
  return rc;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_close_ex(MDBX_env *env, _Bool dont_sync) {
  MDBX_page *dp;
  int rc = MDBX_SUCCESS;

  if (__builtin_expect(!!(!env), 0))
    return MDBX_EINVAL;

  if (__builtin_expect(!!(env->me_signature.weak != 0x9A899641U), 0))
    return MDBX_EBADSIGN;






  if (__builtin_expect(!!(env->me_pid != mdbx_getpid()), 0))
    env->me_flags |= 0x80000000U;


  if (env->me_dxb_mmap.dxb && (env->me_flags & (MDBX_RDONLY | 0x80000000U)) == 0 &&
      env->me_txn0) {
    if (env->me_txn0->mt_owner && env->me_txn0->mt_owner != mdbx_thread_self())
      return MDBX_BUSY;
  } else
    dont_sync = (1);

  if (!atomic_cas32(&env->me_signature, 0x9A899641U, 0))
    return MDBX_EBADSIGN;

  if (!dont_sync) {
# 13329 "/libmdbx/src/core.c"
    struct stat st;
    if (__builtin_expect(!!(fstat(env->me_dxb_mmap.fd, &st)), 0))
      rc = 
# 13331 "/libmdbx/src/core.c" 3 4
          (*__errno_location ())
# 13331 "/libmdbx/src/core.c"
               ;
    else if (st.st_nlink > 0 ) {
      rc = mdbx_env_sync_internal(env, (1), (1));
      rc = (rc == MDBX_BUSY || rc == 
# 13334 "/libmdbx/src/core.c" 3 4
                                    11 
# 13334 "/libmdbx/src/core.c"
                                           || rc == 
# 13334 "/libmdbx/src/core.c" 3 4
                                                    13 
# 13334 "/libmdbx/src/core.c"
                                                           || rc == 
# 13334 "/libmdbx/src/core.c" 3 4
                                                                    16 
# 13334 "/libmdbx/src/core.c"
                                                                          ||
            rc == 
# 13335 "/libmdbx/src/core.c" 3 4
                 11 
# 13335 "/libmdbx/src/core.c"
                             || rc == MDBX_RESULT_TRUE)
               ? MDBX_SUCCESS
               : rc;
    }

  }

  do { if ((0)) do { if (__builtin_expect(!!(!(env->me_signature.weak == 0)), 0)) mdbx_assert_fail(env, "env->me_signature.weak == 0", __func__, 13342); } while (0); } while (0);
  rc = mdbx_env_close0(env) ? MDBX_PANIC : rc;
  do { if (__builtin_expect(!!(!(mdbx_fastmutex_destroy(&env->me_dbi_lock) == MDBX_SUCCESS)), 0)) mdbx_assert_fail(env, "mdbx_fastmutex_destroy(&env->me_dbi_lock) == MDBX_SUCCESS", __func__, 13344); } while (0);




  do { if (__builtin_expect(!!(!(mdbx_fastmutex_destroy(&env->me_remap_guard) == MDBX_SUCCESS)), 0)) mdbx_assert_fail(env, "mdbx_fastmutex_destroy(&env->me_remap_guard) == MDBX_SUCCESS", __func__, 13349); } while (0)
                                                                           ;



  MDBX_lockinfo *const stub = lckless_stub(env);
  do { if (__builtin_expect(!!(!(mdbx_ipclock_destroy(&stub->mti_wlock) == 0)), 0)) mdbx_assert_fail(env, "mdbx_ipclock_destroy(&stub->mti_wlock) == 0", __func__, 13355); } while (0);


  while ((dp = env->me_dp_reserve) != 
# 13358 "/libmdbx/src/core.c" 3 4
                                     ((void *)0)
# 13358 "/libmdbx/src/core.c"
                                         ) {
    do { do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 13359, "UNPOISON_MEMORY_REGION(%p, %zu) at %u" "\n", (void *)(dp), (size_t)(env->me_psize), 13359); } while (0); ((void)(dp), (void)(env->me_psize)); } while (0);
    ;
    env->me_dp_reserve = dp->mp_next;
    free(dp);
  }
  ;
  do { if (__builtin_expect(!!(!(env->me_lcklist_next == 
# 13365 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 13365 "/libmdbx/src/core.c"
 )), 0)) mdbx_assert_fail(env, "env->me_lcklist_next == nullptr", __func__, 13365); } while (0);
  env->me_pid = 0;
  free(env);

  return rc;
}


__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_close(MDBX_env *env) {
  return __inline_mdbx_env_close(env);
}



static int __attribute__((__hot__)) __attribute__((__optimize__("O3"))) cmp_int_align4(const MDBX_val *a, const MDBX_val *b) {
  do { if ((0)) do { if (__builtin_expect(!!(!(a->iov_len == b->iov_len)), 0)) mdbx_assert_fail(
# 13380 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 13380 "/libmdbx/src/core.c"
 , "a->iov_len == b->iov_len", __func__, 13380); } while (0); } while (0);
  switch (a->iov_len) {
  case 4:
    return (((unaligned_peek_u32(4, b->iov_base)) > (unaligned_peek_u32(4, a->iov_base))) ? -1 : (unaligned_peek_u32(4, a->iov_base)) > (unaligned_peek_u32(4, b->iov_base)))
                                                      ;
  case 8:
    return (((unaligned_peek_u64(4, b->iov_base)) > (unaligned_peek_u64(4, a->iov_base))) ? -1 : (unaligned_peek_u64(4, a->iov_base)) > (unaligned_peek_u64(4, b->iov_base)))
                                                      ;
  default:
    mdbx_assert_fail(
# 13389 "/libmdbx/src/core.c" 3 4
                    ((void *)0)
# 13389 "/libmdbx/src/core.c"
                        , "invalid size for INTEGERKEY/INTEGERDUP", __func__,
                     13390);
    return 0;
  }
}


static int __attribute__((__hot__)) __attribute__((__optimize__("O3"))) cmp_int_align2(const MDBX_val *a, const MDBX_val *b) {
  do { if ((0)) do { if (__builtin_expect(!!(!(a->iov_len == b->iov_len)), 0)) mdbx_assert_fail(
# 13397 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 13397 "/libmdbx/src/core.c"
 , "a->iov_len == b->iov_len", __func__, 13397); } while (0); } while (0);
  switch (a->iov_len) {
  case 4:
    return (((unaligned_peek_u32(2, b->iov_base)) > (unaligned_peek_u32(2, a->iov_base))) ? -1 : (unaligned_peek_u32(2, a->iov_base)) > (unaligned_peek_u32(2, b->iov_base)))
                                                      ;
  case 8:
    return (((unaligned_peek_u64(2, b->iov_base)) > (unaligned_peek_u64(2, a->iov_base))) ? -1 : (unaligned_peek_u64(2, a->iov_base)) > (unaligned_peek_u64(2, b->iov_base)))
                                                      ;
  default:
    mdbx_assert_fail(
# 13406 "/libmdbx/src/core.c" 3 4
                    ((void *)0)
# 13406 "/libmdbx/src/core.c"
                        , "invalid size for INTEGERKEY/INTEGERDUP", __func__,
                     13407);
    return 0;
  }
}




static int __attribute__((__hot__)) __attribute__((__optimize__("O3"))) cmp_int_unaligned(const MDBX_val *a, const MDBX_val *b) {
  do { if ((0)) do { if (__builtin_expect(!!(!(a->iov_len == b->iov_len)), 0)) mdbx_assert_fail(
# 13416 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 13416 "/libmdbx/src/core.c"
 , "a->iov_len == b->iov_len", __func__, 13416); } while (0); } while (0);
  switch (a->iov_len) {
  case 4:
    return (((unaligned_peek_u32(1, b->iov_base)) > (unaligned_peek_u32(1, a->iov_base))) ? -1 : (unaligned_peek_u32(1, a->iov_base)) > (unaligned_peek_u32(1, b->iov_base)))
                                                      ;
  case 8:
    return (((unaligned_peek_u64(1, b->iov_base)) > (unaligned_peek_u64(1, a->iov_base))) ? -1 : (unaligned_peek_u64(1, a->iov_base)) > (unaligned_peek_u64(1, b->iov_base)))
                                                      ;
  default:
    mdbx_assert_fail(
# 13425 "/libmdbx/src/core.c" 3 4
                    ((void *)0)
# 13425 "/libmdbx/src/core.c"
                        , "invalid size for INTEGERKEY/INTEGERDUP", __func__,
                     13426);
    return 0;
  }
}


static int __attribute__((__hot__)) __attribute__((__optimize__("O3"))) cmp_lexical(const MDBX_val *a, const MDBX_val *b) {
  if (a->iov_len == b->iov_len)
    return a->iov_len ? memcmp(a->iov_base, b->iov_base, a->iov_len) : 0;

  const int diff_len = (a->iov_len < b->iov_len) ? -1 : 1;
  const size_t shortest = (a->iov_len < b->iov_len) ? a->iov_len : b->iov_len;
  int diff_data = shortest ? memcmp(a->iov_base, b->iov_base, shortest) : 0;
  return __builtin_expect(!!(diff_data), 1) ? diff_data : diff_len;
}


static int __attribute__((__hot__)) __attribute__((__optimize__("O3"))) cmp_reverse(const MDBX_val *a, const MDBX_val *b) {
  const size_t shortest = (a->iov_len < b->iov_len) ? a->iov_len : b->iov_len;
  if (__builtin_expect(!!(shortest), 1)) {
    const uint8_t *pa = (const uint8_t *)a->iov_base + a->iov_len;
    const uint8_t *pb = (const uint8_t *)b->iov_base + b->iov_len;
    const uint8_t *const end = pa - shortest;
    do {
      int diff = *--pa - *--pb;
      if (__builtin_expect(!!(diff), 1))
        return diff;
    } while (pa != end);
  }
  return (((b->iov_len) > (a->iov_len)) ? -1 : (a->iov_len) > (b->iov_len));
}


static int __attribute__((__hot__)) __attribute__((__optimize__("O3"))) cmp_lenfast(const MDBX_val *a, const MDBX_val *b) {
  int diff = (((b->iov_len) > (a->iov_len)) ? -1 : (a->iov_len) > (b->iov_len));
  return __builtin_expect(!!(diff || a->iov_len == 0), 1)
             ? diff
             : memcmp(a->iov_base, b->iov_base, a->iov_len);
}

static _Bool unsure_equal(MDBX_cmp_func cmp, const MDBX_val *a,
                         const MDBX_val *b) {


  return cmp == cmp_lenfast || cmp == cmp_lexical || cmp == cmp_reverse ||
         cmp == cmp_int_unaligned || cmp_lenfast(a, b) == 0;
}





static struct node_result __attribute__((__hot__)) __attribute__((__optimize__("O3"))) mdbx_node_search(MDBX_cursor *mc,
                                                 const MDBX_val *key) {
  MDBX_page *mp = mc->mc_pg[mc->mc_top];
  const int nkeys = page_numkeys(mp);
  ((void)(0));

  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 13484, "searching %u keys in %s %spage %" 
# 13484 "/libmdbx/src/core.c" 3 4
 "u" 
# 13484 "/libmdbx/src/core.c"
 "\n", nkeys, (((mp)->mp_flags & 0x02) != 0) ? "leaf" : "branch", (((mp)->mp_flags & 0x40) != 0) ? "sub-" : "", mp->mp_pgno); } while (0)

                         ;

  struct node_result ret;
  ret.exact = (0);
  _Static_assert(0x01 == 1, "P_BRANCH == 1");
  int low = mp->mp_flags & 0x01;
  int high = nkeys - 1;
  if (__builtin_expect(!!(high < low), 0)) {
    mc->mc_ki[mc->mc_top] = 0;
    ret.node = 
# 13495 "/libmdbx/src/core.c" 3 4
              ((void *)0)
# 13495 "/libmdbx/src/core.c"
                  ;
    return ret;
  }

  int cr = 0, i = 0;
  MDBX_cmp_func *cmp = mc->mc_dbx->md_cmp;
  MDBX_val nodekey;
  if (__builtin_expect(!!(__builtin_expect(!!(((mp)->mp_flags & 0x20) != 0), 0)), 0)) {
    do { if ((0)) do { if (__builtin_expect(!!(!(mp->mp_leaf2_ksize == mc->mc_db->md_xsize)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mp->mp_leaf2_ksize == mc->mc_db->md_xsize", __func__, 13503); } while (0); } while (0);
    nodekey.iov_len = mp->mp_leaf2_ksize;
    do {
      i = (low + high) >> 1;
      nodekey.iov_base = page_leaf2key(mp, i, nodekey.iov_len);
      do { if ((0)) do { if (__builtin_expect(!!(!((char *)mp + mc->mc_txn->mt_env->me_psize >= (char *)nodekey.iov_base + nodekey.iov_len)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "(char *)mp + mc->mc_txn->mt_env->me_psize >= (char *)nodekey.iov_base + nodekey.iov_len", __func__, 13508); } while (0); } while (0)
                                                                      ;
      cr = cmp(key, &nodekey);
      do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 13511, "found leaf index %u [%s], rc = %i" "\n", i, ("-"), cr); } while (0)
                    ;
      if (__builtin_expect(!!(cr == 0), 0)) {
        ret.exact = (1);
        break;
      }
      low = (cr < 0) ? low : i + 1;
      high = (cr < 0) ? i - 1 : high;
    } while (__builtin_expect(!!(low <= high), 1));



    i += cr > 0;


    mc->mc_ki[mc->mc_top] = (indx_t)i;
    ret.node = (i < nkeys)
                   ? (MDBX_node *)(intptr_t)-1
                   : 
# 13529 "/libmdbx/src/core.c" 3 4
                                                                        ((void *)0)
# 13529 "/libmdbx/src/core.c"
                                                                            ;
    return ret;
  }

  if ((((mp)->mp_flags & 0x01) != 0) && cmp == cmp_int_align2)


    cmp = cmp_int_align4;

  MDBX_node *node;
  do {
    i = (low + high) >> 1;

    node = page_node(mp, i);
    nodekey.iov_len = node_ks(node);
    nodekey.iov_base = node_key(node);
    do { if ((0)) do { if (__builtin_expect(!!(!((char *)mp + mc->mc_txn->mt_env->me_psize >= (char *)nodekey.iov_base + nodekey.iov_len)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "(char *)mp + mc->mc_txn->mt_env->me_psize >= (char *)nodekey.iov_base + nodekey.iov_len", __func__, 13545); } while (0); } while (0)
                                                                    ;

    cr = cmp(key, &nodekey);
    if ((((mp)->mp_flags & 0x02) != 0))
      do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 13550, "found leaf index %u [%s], rc = %i" "\n", i, ("-"), cr); } while (0)
                    ;
    else
      do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 13553, "found branch index %u [%s -> %" 
# 13553 "/libmdbx/src/core.c" 3 4
     "u" 
# 13553 "/libmdbx/src/core.c"
     "], rc = %i" "\n", i, ("-"), node_pgno(node), cr); } while (0)
                                                           ;
    if (__builtin_expect(!!(cr == 0), 0)) {
      ret.exact = (1);
      break;
    }
    low = (cr < 0) ? low : i + 1;
    high = (cr < 0) ? i - 1 : high;
  } while (__builtin_expect(!!(low <= high), 1));



  i += cr > 0;


  mc->mc_ki[mc->mc_top] = (indx_t)i;
  ret.node = (i < nkeys)
                 ? page_node(mp, i)
                 : 
# 13571 "/libmdbx/src/core.c" 3 4
                                                                      ((void *)0)
# 13571 "/libmdbx/src/core.c"
                                                                          ;
  return ret;
}


static __inline void mdbx_cursor_pop(MDBX_cursor *mc) {
  if (mc->mc_snum) {
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 13578, "popped page %" 
# 13578 "/libmdbx/src/core.c" 3 4
   "u" 
# 13578 "/libmdbx/src/core.c"
   " off db %d cursor %p" "\n", mc->mc_pg[mc->mc_top]->mp_pgno, (((mc)->mc_flags & 0x04) ? -(int)(mc)->mc_dbi : (int)(mc)->mc_dbi), (void *)mc); } while (0)
                                                                    ;
    if (--mc->mc_snum) {
      mc->mc_top--;
    } else {
      mc->mc_flags &= ~0x01;
    }
  }
}



static __inline int mdbx_cursor_push(MDBX_cursor *mc, MDBX_page *mp) {
  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 13591, "pushing page %" 
# 13591 "/libmdbx/src/core.c" 3 4
 "u" 
# 13591 "/libmdbx/src/core.c"
 " on db %d cursor %p" "\n", mp->mp_pgno, (((mc)->mc_flags & 0x04) ? -(int)(mc)->mc_dbi : (int)(mc)->mc_dbi), (void *)mc); } while (0)
                                  ;

  if (__builtin_expect(!!(mc->mc_snum >= 32), 0)) {
    mc->mc_txn->mt_flags |= 0x02;
    return MDBX_CURSOR_FULL;
  }

  do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_snum < 
# 13599 "/libmdbx/src/core.c" 3 4
 (65535)
# 13599 "/libmdbx/src/core.c"
 )), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mc->mc_snum < (65535)", __func__, 13599); } while (0); } while (0);
  mc->mc_top = mc->mc_snum++;
  mc->mc_pg[mc->mc_top] = mp;
  mc->mc_ki[mc->mc_top] = 0;

  return MDBX_SUCCESS;
}

__attribute__((__hot__)) __attribute__((__optimize__("O3"))) static struct page_result
mdbx_page_get_ex(MDBX_cursor *const mc, const pgno_t pgno,
                                                 txnid_t front) {
  struct page_result ret;
  MDBX_txn *const txn = mc->mc_txn;
  do { if ((0)) do { if (__builtin_expect(!!(!(front <= txn->mt_front)), 0)) mdbx_assert_fail((txn)->mt_env, "front <= txn->mt_front", __func__, 13612); } while (0); } while (0);
  if (__builtin_expect(!!(pgno >= txn->mt_geo.next), 0)) {
    do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 13614, "page #%" 
# 13614 "/libmdbx/src/core.c" 3 4
   "u" 
# 13614 "/libmdbx/src/core.c"
   " beyond next-pgno" "\n", pgno); } while (0);
  notfound:
    ret.page = 
# 13616 "/libmdbx/src/core.c" 3 4
              ((void *)0)
# 13616 "/libmdbx/src/core.c"
                     ;
    ret.err = MDBX_PAGE_NOTFOUND;
  bailout:
    mc->mc_txn->mt_flags |= 0x02;
    return ret;
  }

  MDBX_env *const env = txn->mt_env;
  do { if ((0)) do { if (__builtin_expect(!!(!(((txn->mt_flags ^ env->me_flags) & MDBX_WRITEMAP) == 0)), 0)) mdbx_assert_fail(env, "((txn->mt_flags ^ env->me_flags) & MDBX_WRITEMAP) == 0", __func__, 13624); } while (0); } while (0);
  if (__builtin_expect(!!((txn->mt_flags & (MDBX_TXN_RDONLY | MDBX_WRITEMAP)) == 0), 0)) {
    const MDBX_txn *spiller = txn;
    do {




      if (__builtin_expect(!!(spiller->mt_flags & 0x08), 0) &&
          mdbx_search_spilled(spiller, pgno)) {
        goto spilled;
      }

      const unsigned i = mdbx_dpl_search(spiller, pgno);
      do { if ((0)) do { if (__builtin_expect(!!(!((int)i > 0)), 0)) mdbx_assert_fail(
# 13638 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 13638 "/libmdbx/src/core.c"
     , "(int)i > 0", __func__, 13638); } while (0); } while (0);
      if (spiller->tw.dirtylist->items[i].pgno == pgno) {
        ret.page = spiller->tw.dirtylist->items[i].ptr;
        spiller->tw.dirtylist->items[i].lru = txn->tw.dirtylru++;
        goto dirty;
      }

      spiller = spiller->mt_parent;
    } while (spiller != 
# 13646 "/libmdbx/src/core.c" 3 4
                       ((void *)0)
# 13646 "/libmdbx/src/core.c"
                           );
  }

spilled:
  ret.page = pgno2page(env, pgno);

dirty:
  if (__builtin_expect(!!(ret.page->mp_pgno != pgno), 0)) {
    bad_page(ret.page,
             "mismatch actual pgno (%" 
# 13655 "/libmdbx/src/core.c" 3 4
                                      "u" 
# 13655 "/libmdbx/src/core.c"
                                               ") != expected (%" 
# 13655 "/libmdbx/src/core.c" 3 4
                                                                  "u"
             
# 13656 "/libmdbx/src/core.c"
            ")\n",
             ret.page->mp_pgno, pgno);
    goto notfound;
  }


  if (__builtin_expect(!!(ret.page->mp_flags & (~(0x01 | 0x02 | 0x20 | 0x04 | 0x2000))), 0)) {
    ret.err =
        bad_page(ret.page, "invalid page's flags (%u)\n", ret.page->mp_flags);
    goto bailout;
  }

  if (__builtin_expect(!!(ret.page->mp_txnid > front), 0) &&
      __builtin_expect(!!(ret.page->mp_txnid > txn->mt_front || front < txn->mt_txnid), 0)) {
    ret.err = bad_page(
        ret.page,
        "invalid page txnid (%" 
# 13672 "/libmdbx/src/core.c" 3 4
                               "l" "i" 
# 13672 "/libmdbx/src/core.c"
                                       ") for %s' txnid (%" 
# 13672 "/libmdbx/src/core.c" 3 4
                                                            "l" "i" 
# 13672 "/libmdbx/src/core.c"
                                                                    ")\n",
        ret.page->mp_txnid,
        (front == txn->mt_front && front != txn->mt_txnid) ? "front-txn"
                                                           : "parent-page",
        front);
    goto bailout;
  }

  if (__builtin_expect(!!((ret.page->mp_upper < ret.page->mp_lower || ((ret.page->mp_lower | ret.page->mp_upper) & 1) || ((unsigned)
# 13680 "/libmdbx/src/core.c" 3 4
     __builtin_offsetof (
# 13680 "/libmdbx/src/core.c"
     MDBX_page
# 13680 "/libmdbx/src/core.c" 3 4
     , 
# 13680 "/libmdbx/src/core.c"
     mp_ptrs
# 13680 "/libmdbx/src/core.c" 3 4
     )
# 13680 "/libmdbx/src/core.c"
     ) + ret.page->mp_upper > env->me_psize) && !__builtin_expect(!!(((ret.page)->mp_flags & 0x04) != 0), 0)), 0)


                                      ) {
    ret.err =
        bad_page(ret.page, "invalid page lower(%u)/upper(%u) with limit (%u)\n",
                 ret.page->mp_lower, ret.page->mp_upper, page_space(env));
    goto bailout;
  }


  ret.err = MDBX_SUCCESS;
  if ((0))
    ret.err = mdbx_page_check(mc, ret.page, 0x200);
  return ret;
}



__attribute__((__hot__)) __attribute__((__optimize__("O3"))) static int mdbx_page_search_root(MDBX_cursor *mc, const MDBX_val *key,
                                       int flags) {
  MDBX_page *mp = mc->mc_pg[mc->mc_top];
  int rc;
  ((void)(0));

  while ((((mp)->mp_flags & 0x01) != 0)) {
    MDBX_node *node;
    int i;

    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 13709, "branch page %" 
# 13709 "/libmdbx/src/core.c" 3 4
   "u" 
# 13709 "/libmdbx/src/core.c"
   " has %u keys" "\n", mp->mp_pgno, page_numkeys(mp)); } while (0)
                                ;



    do { if ((0)) do { if (__builtin_expect(!!(!(!mc->mc_dbi || page_numkeys(mp) > 1)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "!mc->mc_dbi || page_numkeys(mp) > 1", __func__, 13714); } while (0); } while (0);
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 13715, "found index 0 to page %" 
# 13715 "/libmdbx/src/core.c" 3 4
   "u" 
# 13715 "/libmdbx/src/core.c"
   "\n", node_pgno(page_node(mp, 0))); } while (0);

    if (flags & (4 | 8)) {
      i = 0;
      if (flags & 8) {
        i = page_numkeys(mp) - 1;

        if (mc->mc_flags & 0x01) {
          if (mc->mc_ki[mc->mc_top] == i) {
            mc->mc_top = mc->mc_snum++;
            mp = mc->mc_pg[mc->mc_top];
            goto ready;
          }
        }
      }
    } else {
      const struct node_result nsr = mdbx_node_search(mc, key);
      if (nsr.node)
        i = mc->mc_ki[mc->mc_top] + nsr.exact - 1;
      else
        i = page_numkeys(mp) - 1;
      do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 13736, "following index %u for key [%s]" "\n", i, ("-")); } while (0);
    }

    do { if ((0)) do { if (__builtin_expect(!!(!(i >= 0 && i < (int)page_numkeys(mp))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "i >= 0 && i < (int)page_numkeys(mp)", __func__, 13739); } while (0); } while (0);
    node = page_node(mp, i);

    if (__builtin_expect(!!((rc = mdbx_page_get(mc, node_pgno(node), &mp, pp_txnid4chk(mp, mc->mc_txn))) != 0), 0)
                                                                         )
      return rc;

    mc->mc_ki[mc->mc_top] = (indx_t)i;
    if (__builtin_expect(!!(rc = mdbx_cursor_push(mc, mp)), 0))
      return rc;

  ready:
    if (flags & 1) {
      if (__builtin_expect(!!((rc = mdbx_page_touch(mc)) != 0), 0))
        return rc;
      mp = mc->mc_pg[mc->mc_top];
    }
  }


  if (__builtin_expect(!!(!(((mp)->mp_flags & 0x02) != 0)), 0)) {
    mc->mc_txn->mt_flags |= 0x02;
    return bad_page(mp, "index points to a page with 0x%02x flags\n",
                    mp->mp_flags);
  }


  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 13766, "found leaf page %" 
# 13766 "/libmdbx/src/core.c" 3 4
 "u" 
# 13766 "/libmdbx/src/core.c"
 " for key [%s]" "\n", mp->mp_pgno, ("-")); } while (0)
                             ;
  mc->mc_flags |= 0x01;
  mc->mc_flags &= ~0x02;

  return MDBX_SUCCESS;
}

static int mdbx_setup_dbx(MDBX_dbx *const dbx, const MDBX_db *const db,
                          const unsigned pagesize) {
  if (__builtin_expect(!!(!dbx->md_cmp), 0)) {
    dbx->md_cmp = get_default_keycmp(db->md_flags);
    dbx->md_dcmp = get_default_datacmp(db->md_flags);
  }

  dbx->md_klen_min =
      (db->md_flags & MDBX_INTEGERKEY) ? 4 : 0;
  dbx->md_klen_max = keysize_max(pagesize, db->md_flags);
  do { if ((0)) do { if (__builtin_expect(!!(!(dbx->md_klen_max != (unsigned)-1)), 0)) mdbx_assert_fail(
# 13784 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 13784 "/libmdbx/src/core.c"
 , "dbx->md_klen_max != (unsigned)-1", __func__, 13784); } while (0); } while (0);

  dbx->md_vlen_min = (db->md_flags & MDBX_INTEGERDUP)
                         ? 4
                         : ((db->md_flags & MDBX_DUPFIXED) ? 1 : 0);
  dbx->md_vlen_max = valsize_max(pagesize, db->md_flags);
  do { if ((0)) do { if (__builtin_expect(!!(!(dbx->md_vlen_max != (unsigned)-1)), 0)) mdbx_assert_fail(
# 13790 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 13790 "/libmdbx/src/core.c"
 , "dbx->md_vlen_max != (unsigned)-1", __func__, 13790); } while (0); } while (0);

  if ((db->md_flags & (MDBX_DUPFIXED | MDBX_INTEGERDUP)) != 0 && db->md_xsize) {
    if (!0 && __builtin_expect(!!(db->md_xsize < dbx->md_vlen_min || db->md_xsize > dbx->md_vlen_max), 0)
                                                                             ) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 13795, "db.md_xsize (%u) <> min/max value-length (%zu/%zu)" "\n", db->md_xsize, dbx->md_vlen_min, dbx->md_vlen_max); } while (0)
                                                                  ;
      return MDBX_CORRUPTED;
    }
    dbx->md_vlen_min = dbx->md_vlen_max = db->md_xsize;
  }
  return MDBX_SUCCESS;
}

static int mdbx_fetch_sdb(MDBX_txn *txn, MDBX_dbi dbi) {
  MDBX_cursor_couple couple;
  if (__builtin_expect(!!(((txn)->mt_dbiseqs[dbi] != (txn)->mt_env->me_dbiseqs[dbi])), 0))
    return MDBX_BAD_DBI;
  int rc = mdbx_cursor_init(&couple.outer, txn, 1);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  MDBX_dbx *const dbx = &txn->mt_dbxs[dbi];
  rc = mdbx_page_search(&couple.outer, &dbx->md_name, 0);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return (rc == MDBX_NOTFOUND) ? MDBX_BAD_DBI : rc;

  MDBX_val data;
  struct node_result nsr = mdbx_node_search(&couple.outer, &dbx->md_name);
  if (__builtin_expect(!!(!nsr.exact), 0))
    return MDBX_BAD_DBI;
  if (__builtin_expect(!!((node_flags(nsr.node) & (0x04 | 0x02)) != 0x02), 0))
    return MDBX_INCOMPATIBLE;

  const txnid_t pp_txnid =
      pp_txnid4chk(couple.outer.mc_pg[couple.outer.mc_top], txn);
  rc = mdbx_node_read(&couple.outer, nsr.node, &data, pp_txnid);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(data.iov_len != sizeof(MDBX_db)), 0))
    return MDBX_INCOMPATIBLE;

  uint16_t md_flags = unaligned_peek_u16(1, (const char *)(data.iov_base) + 
# 13833 "/libmdbx/src/core.c" 3 4
                     __builtin_offsetof (
# 13833 "/libmdbx/src/core.c"
                     MDBX_db
# 13833 "/libmdbx/src/core.c" 3 4
                     , 
# 13833 "/libmdbx/src/core.c"
                     md_flags
# 13833 "/libmdbx/src/core.c" 3 4
                     )
# 13833 "/libmdbx/src/core.c"
                     );


  MDBX_db *const db = &txn->mt_dbs[dbi];
  if (__builtin_expect(!!((db->md_flags & (MDBX_REVERSEKEY | MDBX_DUPSORT | MDBX_INTEGERKEY | MDBX_DUPFIXED | MDBX_INTEGERDUP | MDBX_REVERSEDUP)) != md_flags), 0))
    return MDBX_INCOMPATIBLE;

  memcpy(db, data.iov_base, sizeof(MDBX_db));

  do { if ((0)) do { if (__builtin_expect(!!(!(txn->mt_front >= pp_txnid)), 0)) mdbx_assert_fail((txn)->mt_env, "txn->mt_front >= pp_txnid", __func__, 13842); } while (0); } while (0);
  if (__builtin_expect(!!(db->md_mod_txnid > pp_txnid), 0)) {
    do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 13844, "db.md_mod_txnid (%" 
# 13844 "/libmdbx/src/core.c" 3 4
   "l" "i" 
# 13844 "/libmdbx/src/core.c"
   ") > page-txnid (%" 
# 13844 "/libmdbx/src/core.c" 3 4
   "l" "i" 
# 13844 "/libmdbx/src/core.c"
   ")" "\n", db->md_mod_txnid, pp_txnid); } while (0)
                                          ;
    return MDBX_CORRUPTED;
  }

  rc = mdbx_setup_dbx(dbx, db, txn->mt_env->me_psize);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  txn->mt_dbistate[dbi] &= ~MDBX_DBI_STALE;
  return MDBX_SUCCESS;
}






__attribute__((__hot__)) __attribute__((__optimize__("O3"))) static int mdbx_page_search_lowest(MDBX_cursor *mc) {
  MDBX_page *mp = mc->mc_pg[mc->mc_top];
  do { if ((0)) do { if (__builtin_expect(!!(!((((mp)->mp_flags & 0x01) != 0))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "(((mp)->mp_flags & 0x01) != 0)", __func__, 13864); } while (0); } while (0);
  MDBX_node *node = page_node(mp, 0);
  int rc;

  if (__builtin_expect(!!((rc = mdbx_page_get(mc, node_pgno(node), &mp, pp_txnid4chk(mp, mc->mc_txn))) != 0), 0)
                                                                       )
    return rc;

  mc->mc_ki[mc->mc_top] = 0;
  if (__builtin_expect(!!(rc = mdbx_cursor_push(mc, mp)), 0))
    return rc;
  return mdbx_page_search_root(mc, 
# 13875 "/libmdbx/src/core.c" 3 4
                                  ((void *)0)
# 13875 "/libmdbx/src/core.c"
                                      , 4);
}
# 13892 "/libmdbx/src/core.c"
__attribute__((__hot__)) __attribute__((__optimize__("O3"))) static int mdbx_page_search(MDBX_cursor *mc, const MDBX_val *key,
                                  int flags) {
  int rc;
  pgno_t root;



  if (__builtin_expect(!!(mc->mc_txn->mt_flags & (0x01 | 0x02 | 0x10)), 0)) {
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 13900, "%s" "\n", "transaction has failed, must abort"); } while (0);
    return MDBX_BAD_TXN;
  }


  if (__builtin_expect(!!(*mc->mc_dbistate & MDBX_DBI_STALE), 0)) {
    rc = mdbx_fetch_sdb(mc->mc_txn, mc->mc_dbi);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      return rc;
  }
  root = mc->mc_db->md_root;

  if (__builtin_expect(!!(root == (~(pgno_t)0)), 0)) {
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 13913, "%s" "\n", "tree is empty"); } while (0);
    return MDBX_NOTFOUND;
  }

  do { if ((0)) do { if (__builtin_expect(!!(!(root >= 3)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "root >= 3", __func__, 13917); } while (0); } while (0);
  if (!mc->mc_pg[0] || mc->mc_pg[0]->mp_pgno != root) {
    txnid_t pp_txnid = mc->mc_db->md_mod_txnid;
    pp_txnid = pp_txnid
                   ? pp_txnid
                   : mc->mc_txn->mt_txnid;
    if ((mc->mc_txn->mt_flags & MDBX_TXN_RDONLY) == 0) {
      MDBX_txn *scan = mc->mc_txn;
      do
        if ((scan->mt_flags & 0x04) &&
            (mc->mc_dbi == 1 ||
             (scan->mt_dbistate[mc->mc_dbi] & MDBX_DBI_DIRTY))) {
          pp_txnid = scan->mt_front;
          break;
        }
      while (__builtin_expect(!!((scan = scan->mt_parent) != 
# 13932 "/libmdbx/src/core.c" 3 4
            ((void *)0)
# 13932 "/libmdbx/src/core.c"
            ), 0));
    }
    if (__builtin_expect(!!((rc = mdbx_page_get(mc, root, &mc->mc_pg[0], pp_txnid)) != 0), 0))
      return rc;
  }

  mc->mc_snum = 1;
  mc->mc_top = 0;

  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 13941, "db %d root page %" 
# 13941 "/libmdbx/src/core.c" 3 4
 "u" 
# 13941 "/libmdbx/src/core.c"
 " has flags 0x%X" "\n", (((mc)->mc_flags & 0x04) ? -(int)(mc)->mc_dbi : (int)(mc)->mc_dbi), root, mc->mc_pg[0]->mp_flags); } while (0)
                                    ;

  if (flags & 1) {
    if (!(*mc->mc_dbistate & MDBX_DBI_DIRTY) && __builtin_expect(!!(rc = mdbx_touch_dbi(mc)), 0))
      return rc;
    if (__builtin_expect(!!(rc = mdbx_page_touch(mc)), 0))
      return rc;
  }

  if (flags & 2)
    return MDBX_SUCCESS;

  return mdbx_page_search_root(mc, key, flags);
}
# 13964 "/libmdbx/src/core.c"
static 
# 13964 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 13964 "/libmdbx/src/core.c"
                      int mdbx_node_read(MDBX_cursor *mc,
                                          const MDBX_node *node, MDBX_val *data,
                                          const txnid_t front) {
  data->iov_len = node_ds(node);
  data->iov_base = node_data(node);
  if (__builtin_expect(!!((((node_flags(node)) & (0x01)) == (0x01))), 0)) {

    MDBX_page *omp;
    int rc = mdbx_page_get(mc, node_largedata_pgno(node), &omp, front);
    if (__builtin_expect(!!((rc != MDBX_SUCCESS)), 0)) {
      do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 13974, "read overflow page %" 
# 13974 "/libmdbx/src/core.c" 3 4
     "u" 
# 13974 "/libmdbx/src/core.c"
     " failed" "\n", node_largedata_pgno(node)); } while (0)
                                           ;
      return rc;
    }
    data->iov_base = page_data(omp);
  }
  return MDBX_SUCCESS;
}

int mdbx_get(MDBX_txn *txn, MDBX_dbi dbi, const MDBX_val *key, MDBX_val *data) {
  ((void)(0));
  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 13985, "===> get db %u key [%s]" "\n", dbi, ("-")); } while (0);

  int rc = check_txn(txn, (0x01 | 0x02 | 0x10));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(!key || !data), 0))
    return MDBX_EINVAL;

  if (__builtin_expect(!!(!check_dbi(txn, dbi, 0x20)), 0))
    return MDBX_BAD_DBI;

  MDBX_cursor_couple cx;
  rc = mdbx_cursor_init(&cx.outer, txn, dbi);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  return mdbx_cursor_set(&cx.outer, (MDBX_val *)key, data, MDBX_SET).err;
}

int mdbx_get_equal_or_great(MDBX_txn *txn, MDBX_dbi dbi, MDBX_val *key,
                            MDBX_val *data) {
  int rc = check_txn(txn, (0x01 | 0x02 | 0x10));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(!key || !data), 0))
    return MDBX_EINVAL;

  if (__builtin_expect(!!(!check_dbi(txn, dbi, 0x20)), 0))
    return MDBX_BAD_DBI;

  if (__builtin_expect(!!(txn->mt_flags & (0x01 | 0x02 | 0x10)), 0))
    return MDBX_BAD_TXN;

  MDBX_cursor_couple cx;
  rc = mdbx_cursor_init(&cx.outer, txn, dbi);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  return mdbx_cursor_get(&cx.outer, key, data, MDBX_SET_LOWERBOUND);
}

int mdbx_get_ex(MDBX_txn *txn, MDBX_dbi dbi, MDBX_val *key, MDBX_val *data,
                size_t *values_count) {
  ((void)(0));
  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 14031, "===> get db %u key [%s]" "\n", dbi, ("-")); } while (0);

  int rc = check_txn(txn, (0x01 | 0x02 | 0x10));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(!key || !data), 0))
    return MDBX_EINVAL;

  if (__builtin_expect(!!(!check_dbi(txn, dbi, 0x20)), 0))
    return MDBX_BAD_DBI;

  MDBX_cursor_couple cx;
  rc = mdbx_cursor_init(&cx.outer, txn, dbi);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  rc = mdbx_cursor_set(&cx.outer, key, data, MDBX_SET_KEY).err;
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0)) {
    if (rc == MDBX_NOTFOUND && values_count)
      *values_count = 0;
    return rc;
  }

  if (values_count) {
    *values_count = 1;
    if (cx.outer.mc_xcursor != 
# 14057 "/libmdbx/src/core.c" 3 4
                              ((void *)0)
# 14057 "/libmdbx/src/core.c"
                                  ) {
      MDBX_node *node = page_node(cx.outer.mc_pg[cx.outer.mc_top],
                                  cx.outer.mc_ki[cx.outer.mc_top]);
      if ((((node_flags(node)) & (0x04)) == (0x04))) {

        do { if ((0)) do { if (__builtin_expect(!!(!(cx.outer.mc_xcursor == &cx.inner && (cx.inner.mx_cursor.mc_flags & 0x01))), 0)) mdbx_assert_fail((txn)->mt_env, "cx.outer.mc_xcursor == &cx.inner && (cx.inner.mx_cursor.mc_flags & 0x01)", __func__, 14062); } while (0); } while (0)
                                                                            ;

        *values_count =
            (sizeof(*values_count) >= sizeof(cx.inner.mx_db.md_entries) ||
             cx.inner.mx_db.md_entries <= 
# 14067 "/libmdbx/src/core.c" 3 4
                                         (9223372036854775807L)
# 14067 "/libmdbx/src/core.c"
                                                    )
                ? (size_t)cx.inner.mx_db.md_entries
                : 
# 14069 "/libmdbx/src/core.c" 3 4
                 (9223372036854775807L)
# 14069 "/libmdbx/src/core.c"
                            ;
      }
    }
  }
  return MDBX_SUCCESS;
}
# 14084 "/libmdbx/src/core.c"
static int mdbx_cursor_sibling(MDBX_cursor *mc, int dir) {
  int rc;
  MDBX_node *node;
  MDBX_page *mp;
  do { if ((0)) do { if (__builtin_expect(!!(!(dir == 0 || dir == 2)), 0)) mdbx_assert_fail(
# 14088 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 14088 "/libmdbx/src/core.c"
 , "dir == 0 || dir == 2", __func__, 14088); } while (0); } while (0);

  if (__builtin_expect(!!(mc->mc_snum < 2), 0))
    return MDBX_NOTFOUND;

  mdbx_cursor_pop(mc);
  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 14094, "parent page is page %" 
# 14094 "/libmdbx/src/core.c" 3 4
 "u" 
# 14094 "/libmdbx/src/core.c"
 ", index %u" "\n", mc->mc_pg[mc->mc_top]->mp_pgno, mc->mc_ki[mc->mc_top]); } while (0)
                                                                   ;

  if ((dir == 2)
          ? (mc->mc_ki[mc->mc_top] + 1u >= page_numkeys(mc->mc_pg[mc->mc_top]))
          : (mc->mc_ki[mc->mc_top] == 0)) {
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 14100, "no more keys aside, moving to next %s sibling" "\n", dir ? "right" : "left"); } while (0)
                                      ;
    if (__builtin_expect(!!((rc = mdbx_cursor_sibling(mc, dir)) != MDBX_SUCCESS), 0)) {

      mc->mc_top++;
      mc->mc_snum++;
      return rc;
    }
  } else {
    do { if ((0)) do { if (__builtin_expect(!!(!((dir - 1) == -1 || (dir - 1) == 1)), 0)) mdbx_assert_fail(
# 14109 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 14109 "/libmdbx/src/core.c"
   , "(dir - 1) == -1 || (dir - 1) == 1", __func__, 14109); } while (0); } while (0);
    mc->mc_ki[mc->mc_top] += (indx_t)(dir - 1);
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 14111, "just moving to %s index key %u" "\n", (dir == 2) ? "right" : "left", mc->mc_ki[mc->mc_top]); } while (0)

                                     ;
  }
  do { if ((0)) do { if (__builtin_expect(!!(!((((mc->mc_pg[mc->mc_top])->mp_flags & 0x01) != 0))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "(((mc->mc_pg[mc->mc_top])->mp_flags & 0x01) != 0)", __func__, 14115); } while (0); } while (0);

  node = page_node(mp = mc->mc_pg[mc->mc_top], mc->mc_ki[mc->mc_top]);
  if (__builtin_expect(!!((rc = mdbx_page_get(mc, node_pgno(node), &mp, pp_txnid4chk(mp, mc->mc_txn))) != 0), 0)
                                                                       ) {

    mc->mc_flags &= ~(0x01 | 0x02);
    return rc;
  }

  rc = mdbx_cursor_push(mc, mp);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  mc->mc_ki[mc->mc_top] =
      (indx_t)((dir == 0) ? page_numkeys(mp) - 1 : 0);
  return MDBX_SUCCESS;
}


static int mdbx_cursor_next(MDBX_cursor *mc, MDBX_val *key, MDBX_val *data,
                            MDBX_cursor_op op) {
  MDBX_page *mp;
  MDBX_node *node;
  int rc;

  if (__builtin_expect(!!(mc->mc_flags & 0x08), 0) && op == MDBX_NEXT_DUP)
    return MDBX_NOTFOUND;

  if (__builtin_expect(!!(!(mc->mc_flags & 0x01)), 0))
    return mdbx_cursor_first(mc, key, data);

  mp = mc->mc_pg[mc->mc_top];
  if (__builtin_expect(!!(mc->mc_flags & 0x02), 0)) {
    if (mc->mc_ki[mc->mc_top] + 1u >= page_numkeys(mp))
      return MDBX_NOTFOUND;
    mc->mc_flags ^= 0x02;
  }

  if (mc->mc_db->md_flags & MDBX_DUPSORT) {
    node = page_node(mp, mc->mc_ki[mc->mc_top]);
    if ((((node_flags(node)) & (0x04)) == (0x04))) {
      if (op == MDBX_NEXT || op == MDBX_NEXT_DUP) {
        rc =
            mdbx_cursor_next(&mc->mc_xcursor->mx_cursor, data, 
# 14159 "/libmdbx/src/core.c" 3 4
                                                              ((void *)0)
# 14159 "/libmdbx/src/core.c"
                                                                  , MDBX_NEXT);
        if (op != MDBX_NEXT || rc != MDBX_NOTFOUND) {
          if (__builtin_expect(!!(rc == MDBX_SUCCESS), 1))
            get_key_optional(node, key);
          return rc;
        }
      }
    } else {
      mc->mc_xcursor->mx_cursor.mc_flags &= ~(0x01 | 0x02);
      if (op == MDBX_NEXT_DUP)
        return MDBX_NOTFOUND;
    }
  }

  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 14173, "cursor_next: top page is %" 
# 14173 "/libmdbx/src/core.c" 3 4
 "u" 
# 14173 "/libmdbx/src/core.c"
 " in cursor %p" "\n", mp->mp_pgno, (void *)mc); } while (0)
                        ;
  if (mc->mc_flags & 0x08) {
    mc->mc_flags ^= 0x08;
    goto skip;
  }

  int ki = mc->mc_ki[mc->mc_top];
  mc->mc_ki[mc->mc_top] = (indx_t)++ki;
  const int numkeys = page_numkeys(mp);
  if (__builtin_expect(!!(ki >= numkeys), 0)) {
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 14184, "%s" "\n", "=====> move to next sibling page"); } while (0);
    mc->mc_ki[mc->mc_top] = (indx_t)(numkeys - 1);
    if (__builtin_expect(!!((rc = mdbx_cursor_sibling(mc, 2)) != MDBX_SUCCESS), 0)
                              ) {
      mc->mc_flags |= 0x02;
      return rc;
    }
    mp = mc->mc_pg[mc->mc_top];
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 14192, "next page is %" 
# 14192 "/libmdbx/src/core.c" 3 4
   "u" 
# 14192 "/libmdbx/src/core.c"
   ", key index %u" "\n", mp->mp_pgno, mc->mc_ki[mc->mc_top]); } while (0)
                                     ;
  }

skip:
  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 14197, "==> cursor points to page %" 
# 14197 "/libmdbx/src/core.c" 3 4
 "u" 
# 14197 "/libmdbx/src/core.c"
 " with %u keys, key index %u" "\n", mp->mp_pgno, page_numkeys(mp), mc->mc_ki[mc->mc_top]); } while (0)

                                                                  ;

  if (!0 && __builtin_expect(!!(!(((mp)->mp_flags & 0x02) != 0)), 0))
    return MDBX_CORRUPTED;

  if (__builtin_expect(!!(((mp)->mp_flags & 0x20) != 0), 0)) {
    if (!0 && __builtin_expect(!!((mc->mc_flags & 0x04) == 0), 0)) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 14206, "unexpected LEAF2-page %" 
# 14206 "/libmdbx/src/core.c" 3 4
     "u" 
# 14206 "/libmdbx/src/core.c"
     "for non-dupsort cursor" "\n", mp->mp_pgno); } while (0)
                             ;
      return MDBX_CORRUPTED;
    } else if (__builtin_expect(!!(key), 1)) {
      key->iov_len = mc->mc_db->md_xsize;
      key->iov_base = page_leaf2key(mp, mc->mc_ki[mc->mc_top], key->iov_len);
    }
    return MDBX_SUCCESS;
  }

  node = page_node(mp, mc->mc_ki[mc->mc_top]);
  if ((((node_flags(node)) & (0x04)) == (0x04))) {
    rc = mdbx_xcursor_init1(mc, node, mp);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      return rc;
    rc = mdbx_cursor_first(&mc->mc_xcursor->mx_cursor, data, 
# 14221 "/libmdbx/src/core.c" 3 4
                                                            ((void *)0)
# 14221 "/libmdbx/src/core.c"
                                                                );
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      return rc;
  } else if (__builtin_expect(!!(data), 1)) {
    if (__builtin_expect(!!((rc = mdbx_node_read(mc, node, data, pp_txnid4chk(mp, mc->mc_txn))) != MDBX_SUCCESS), 0)

                              )
      return rc;
  }

  get_key_optional(node, key);
  return MDBX_SUCCESS;
}


static int mdbx_cursor_prev(MDBX_cursor *mc, MDBX_val *key, MDBX_val *data,
                            MDBX_cursor_op op) {
  MDBX_page *mp;
  MDBX_node *node;
  int rc;

  if (__builtin_expect(!!(mc->mc_flags & 0x08), 0) && op == MDBX_PREV_DUP)
    return MDBX_NOTFOUND;

  if (__builtin_expect(!!(!(mc->mc_flags & 0x01)), 0)) {
    rc = mdbx_cursor_last(mc, key, data);
    if (__builtin_expect(!!(rc), 0))
      return rc;
    mc->mc_ki[mc->mc_top]++;
  }

  mp = mc->mc_pg[mc->mc_top];
  if ((mc->mc_db->md_flags & MDBX_DUPSORT) &&
      mc->mc_ki[mc->mc_top] < page_numkeys(mp)) {
    node = page_node(mp, mc->mc_ki[mc->mc_top]);
    if ((((node_flags(node)) & (0x04)) == (0x04))) {
      if (op == MDBX_PREV || op == MDBX_PREV_DUP) {
        rc =
            mdbx_cursor_prev(&mc->mc_xcursor->mx_cursor, data, 
# 14259 "/libmdbx/src/core.c" 3 4
                                                              ((void *)0)
# 14259 "/libmdbx/src/core.c"
                                                                  , MDBX_PREV);
        if (op != MDBX_PREV || rc != MDBX_NOTFOUND) {
          if (__builtin_expect(!!(rc == MDBX_SUCCESS), 1)) {
            get_key_optional(node, key);
            mc->mc_flags &= ~0x02;
          }
          return rc;
        }
      }
    } else {
      mc->mc_xcursor->mx_cursor.mc_flags &= ~(0x01 | 0x02);
      if (op == MDBX_PREV_DUP)
        return MDBX_NOTFOUND;
    }
  }

  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 14275, "cursor_prev: top page is %" 
# 14275 "/libmdbx/src/core.c" 3 4
 "u" 
# 14275 "/libmdbx/src/core.c"
 " in cursor %p" "\n", mp->mp_pgno, (void *)mc); } while (0)
                        ;

  mc->mc_flags &= ~(0x02 | 0x08);

  int ki = mc->mc_ki[mc->mc_top];
  mc->mc_ki[mc->mc_top] = (indx_t)--ki;
  if (__builtin_expect(!!(ki < 0), 0)) {
    mc->mc_ki[mc->mc_top] = 0;
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 14284, "%s" "\n", "=====> move to prev sibling page"); } while (0);
    if ((rc = mdbx_cursor_sibling(mc, 0)) != MDBX_SUCCESS)
      return rc;
    mp = mc->mc_pg[mc->mc_top];
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 14288, "prev page is %" 
# 14288 "/libmdbx/src/core.c" 3 4
   "u" 
# 14288 "/libmdbx/src/core.c"
   ", key index %u" "\n", mp->mp_pgno, mc->mc_ki[mc->mc_top]); } while (0)
                                     ;
  }
  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 14291, "==> cursor points to page %" 
# 14291 "/libmdbx/src/core.c" 3 4
 "u" 
# 14291 "/libmdbx/src/core.c"
 " with %u keys, key index %u" "\n", mp->mp_pgno, page_numkeys(mp), mc->mc_ki[mc->mc_top]); } while (0)

                                                                  ;

  if (!0 && __builtin_expect(!!(!(((mp)->mp_flags & 0x02) != 0)), 0))
    return MDBX_CORRUPTED;

  if (__builtin_expect(!!(((mp)->mp_flags & 0x20) != 0), 0)) {
    if (!0 && __builtin_expect(!!((mc->mc_flags & 0x04) == 0), 0)) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 14300, "unexpected LEAF2-page %" 
# 14300 "/libmdbx/src/core.c" 3 4
     "u" 
# 14300 "/libmdbx/src/core.c"
     "for non-dupsort cursor" "\n", mp->mp_pgno); } while (0)
                             ;
      return MDBX_CORRUPTED;
    } else if (__builtin_expect(!!(key), 1)) {
      key->iov_len = mc->mc_db->md_xsize;
      key->iov_base = page_leaf2key(mp, mc->mc_ki[mc->mc_top], key->iov_len);
    }
    return MDBX_SUCCESS;
  }

  node = page_node(mp, mc->mc_ki[mc->mc_top]);

  if ((((node_flags(node)) & (0x04)) == (0x04))) {
    rc = mdbx_xcursor_init1(mc, node, mp);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      return rc;
    rc = mdbx_cursor_last(&mc->mc_xcursor->mx_cursor, data, 
# 14316 "/libmdbx/src/core.c" 3 4
                                                           ((void *)0)
# 14316 "/libmdbx/src/core.c"
                                                               );
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      return rc;
  } else if (__builtin_expect(!!(data), 1)) {
    if (__builtin_expect(!!((rc = mdbx_node_read(mc, node, data, pp_txnid4chk(mp, mc->mc_txn))) != MDBX_SUCCESS), 0)

                              )
      return rc;
  }

  get_key_optional(node, key);
  return MDBX_SUCCESS;
}


static struct cursor_set_result mdbx_cursor_set(MDBX_cursor *mc, MDBX_val *key,
                                                MDBX_val *data,
                                                MDBX_cursor_op op) {
  MDBX_page *mp;
  MDBX_node *node = 
# 14335 "/libmdbx/src/core.c" 3 4
                   ((void *)0)
# 14335 "/libmdbx/src/core.c"
                       ;
  ((void)(0));

  struct cursor_set_result ret;
  ret.exact = (0);
  if (__builtin_expect(!!(key->iov_len < mc->mc_dbx->md_klen_min || key->iov_len > mc->mc_dbx->md_klen_max), 0)
                                                      ) {
    do { if ((0)) do { if (__builtin_expect(!!(!(!"Invalid key-size")), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "!\"Invalid key-size\"", __func__, 14342); } while (0); } while (0);
    ret.err = MDBX_BAD_VALSIZE;
    return ret;
  }

  MDBX_val aligned_key = *key;
  uint64_t aligned_keybytes;
  if (mc->mc_db->md_flags & MDBX_INTEGERKEY) {
    switch (aligned_key.iov_len) {
    default:
      do { if ((0)) do { if (__builtin_expect(!!(!(!"key-size is invalid for MDBX_INTEGERKEY")), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "!\"key-size is invalid for MDBX_INTEGERKEY\"", __func__, 14352); } while (0); } while (0);
      ret.err = MDBX_BAD_VALSIZE;
      return ret;
    case 4:
      if (__builtin_expect(!!(3 & (uintptr_t)aligned_key.iov_base), 0))

        aligned_key.iov_base =
            memcpy(&aligned_keybytes, aligned_key.iov_base, 4);
      break;
    case 8:
      if (__builtin_expect(!!(7 & (uintptr_t)aligned_key.iov_base), 0))

        aligned_key.iov_base =
            memcpy(&aligned_keybytes, aligned_key.iov_base, 8);
      break;
    }
  }

  if (mc->mc_xcursor)
    mc->mc_xcursor->mx_cursor.mc_flags &= ~(0x01 | 0x02);


  if (mc->mc_flags & 0x01) {
    MDBX_val nodekey;

    do { if ((0)) do { if (__builtin_expect(!!(!((((mc->mc_pg[mc->mc_top])->mp_flags & 0x02) != 0))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "(((mc->mc_pg[mc->mc_top])->mp_flags & 0x02) != 0)", __func__, 14377); } while (0); } while (0);
    mp = mc->mc_pg[mc->mc_top];
    if (__builtin_expect(!!(!page_numkeys(mp)), 0)) {
      mc->mc_ki[mc->mc_top] = 0;
      mc->mc_flags |= 0x02;
      ret.err = MDBX_NOTFOUND;
      return ret;
    }
    if (__builtin_expect(!!(((mp)->mp_flags & 0x20) != 0), 0)) {
      nodekey.iov_len = mc->mc_db->md_xsize;
      nodekey.iov_base = page_leaf2key(mp, 0, nodekey.iov_len);
    } else {
      node = page_node(mp, 0);
      get_key(node, &nodekey);
    }
    int cmp = mc->mc_dbx->md_cmp(&aligned_key, &nodekey);
    if (__builtin_expect(!!(cmp == 0), 0)) {


      mc->mc_ki[mc->mc_top] = 0;
      ret.exact = (1);
      do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_ki[mc->mc_top] < page_numkeys(mc->mc_pg[mc->mc_top]) || (mc->mc_flags & 0x02))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mc->mc_ki[mc->mc_top] < page_numkeys(mc->mc_pg[mc->mc_top]) || (mc->mc_flags & 0x02)", __func__, 14398); } while (0); } while (0)

                                                  ;
      goto got_node;
    }
    if (cmp > 0) {
      const unsigned nkeys = page_numkeys(mp);
      if (nkeys > 1) {
        if (__builtin_expect(!!(((mp)->mp_flags & 0x20) != 0), 0)) {
          nodekey.iov_base = page_leaf2key(mp, nkeys - 1, nodekey.iov_len);
        } else {
          node = page_node(mp, nkeys - 1);
          get_key(node, &nodekey);
        }
        cmp = mc->mc_dbx->md_cmp(&aligned_key, &nodekey);
        if (cmp == 0) {

          do { if ((0)) do { if (__builtin_expect(!!(!(nkeys >= 1 && nkeys <= 
# 14415 "/libmdbx/src/core.c" 3 4
         (65535) 
# 14415 "/libmdbx/src/core.c"
         + 1)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "nkeys >= 1 && nkeys <= (65535) + 1", __func__, 14415); } while (0); } while (0);
          mc->mc_ki[mc->mc_top] = (indx_t)(nkeys - 1);
          ret.exact = (1);
          do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_ki[mc->mc_top] < page_numkeys(mc->mc_pg[mc->mc_top]) || (mc->mc_flags & 0x02))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mc->mc_ki[mc->mc_top] < page_numkeys(mc->mc_pg[mc->mc_top]) || (mc->mc_flags & 0x02)", __func__, 14418); } while (0); } while (0)

                                                      ;
          goto got_node;
        }
        if (cmp < 0) {
          if (mc->mc_ki[mc->mc_top] < page_numkeys(mp)) {

            if (__builtin_expect(!!(((mp)->mp_flags & 0x20) != 0), 0)) {
              nodekey.iov_base =
                  page_leaf2key(mp, mc->mc_ki[mc->mc_top], nodekey.iov_len);
            } else {
              node = page_node(mp, mc->mc_ki[mc->mc_top]);
              get_key(node, &nodekey);
            }
            cmp = mc->mc_dbx->md_cmp(&aligned_key, &nodekey);
            if (cmp == 0) {

              ret.exact = (1);
              do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_ki[mc->mc_top] < page_numkeys(mc->mc_pg[mc->mc_top]) || (mc->mc_flags & 0x02))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mc->mc_ki[mc->mc_top] < page_numkeys(mc->mc_pg[mc->mc_top]) || (mc->mc_flags & 0x02)", __func__, 14437); } while (0); } while (0)

                                                          ;
              goto got_node;
            }
          }
          mc->mc_flags &= ~0x02;
          goto search_node;
        }
      }


      unsigned i;
      for (i = 0; i < mc->mc_top; i++)
        if (mc->mc_ki[i] < page_numkeys(mc->mc_pg[i]) - 1)
          break;
      if (i == mc->mc_top) {

        do { if ((0)) do { if (__builtin_expect(!!(!(nkeys <= 
# 14455 "/libmdbx/src/core.c" 3 4
       (65535)
# 14455 "/libmdbx/src/core.c"
       )), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "nkeys <= (65535)", __func__, 14455); } while (0); } while (0);
        mc->mc_ki[mc->mc_top] = (uint16_t)nkeys;
        mc->mc_flags |= 0x02;
        ret.err = MDBX_NOTFOUND;
        return ret;
      }
    }
    if (!mc->mc_top) {

      mc->mc_ki[mc->mc_top] = 0;
      if (op == MDBX_SET_RANGE)
        goto got_node;

      do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_ki[mc->mc_top] < page_numkeys(mc->mc_pg[mc->mc_top]) || (mc->mc_flags & 0x02))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mc->mc_ki[mc->mc_top] < page_numkeys(mc->mc_pg[mc->mc_top]) || (mc->mc_flags & 0x02)", __func__, 14468); } while (0); } while (0)

                                                  ;
      ret.err = MDBX_NOTFOUND;
      return ret;
    }
  } else {
    mc->mc_pg[0] = 0;
  }

  ret.err = mdbx_page_search(mc, &aligned_key, 0);
  if (__builtin_expect(!!(ret.err != MDBX_SUCCESS), 0))
    return ret;

  mp = mc->mc_pg[mc->mc_top];
  do { if ((0)) do { if (__builtin_expect(!!(!((((mp)->mp_flags & 0x02) != 0))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "(((mp)->mp_flags & 0x02) != 0)", __func__, 14483); } while (0); } while (0);

search_node:;
  struct node_result nsr = mdbx_node_search(mc, &aligned_key);
  node = nsr.node;
  ret.exact = nsr.exact;
  if (!ret.exact) {
    if (op != MDBX_SET_RANGE) {

      if (__builtin_expect(!!(mc->mc_ki[mc->mc_top] >= page_numkeys(mc->mc_pg[mc->mc_top])), 0)
                                                       )
        mc->mc_flags |= 0x02;
      ret.err = MDBX_NOTFOUND;
      return ret;
    }

    if (node == 
# 14499 "/libmdbx/src/core.c" 3 4
               ((void *)0)
# 14499 "/libmdbx/src/core.c"
                   ) {
      do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 14500, "%s" "\n", "===> inexact leaf not found, goto sibling"); } while (0);
      ret.err = mdbx_cursor_sibling(mc, 2);
      if (__builtin_expect(!!(ret.err != MDBX_SUCCESS), 0)) {
        mc->mc_flags |= 0x02;
        return ret;
      }
      mp = mc->mc_pg[mc->mc_top];
      do { if ((0)) do { if (__builtin_expect(!!(!((((mp)->mp_flags & 0x02) != 0))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "(((mp)->mp_flags & 0x02) != 0)", __func__, 14507); } while (0); } while (0);
      if (!__builtin_expect(!!(((mp)->mp_flags & 0x20) != 0), 0))
        node = page_node(mp, 0);
    }
  }
  do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_ki[mc->mc_top] < page_numkeys(mc->mc_pg[mc->mc_top]) || (mc->mc_flags & 0x02))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mc->mc_ki[mc->mc_top] < page_numkeys(mc->mc_pg[mc->mc_top]) || (mc->mc_flags & 0x02)", __func__, 14512); } while (0); } while (0)

                                          ;

got_node:
  mc->mc_flags |= 0x01;
  mc->mc_flags &= ~0x02;

  if (__builtin_expect(!!(((mp)->mp_flags & 0x20) != 0), 0)) {
    if (!0 && __builtin_expect(!!((mc->mc_flags & 0x04) == 0), 0)) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 14522, "unexpected LEAF2-page %" 
# 14522 "/libmdbx/src/core.c" 3 4
     "u" 
# 14522 "/libmdbx/src/core.c"
     "for non-dupsort cursor" "\n", mp->mp_pgno); } while (0)
                             ;
      ret.err = MDBX_CORRUPTED;
    } else {
      if (op == MDBX_SET_RANGE || op == MDBX_SET_KEY) {
        key->iov_len = mc->mc_db->md_xsize;
        key->iov_base = page_leaf2key(mp, mc->mc_ki[mc->mc_top], key->iov_len);
      }
      ret.err = MDBX_SUCCESS;
    }
    return ret;
  }

  if ((((node_flags(node)) & (0x04)) == (0x04))) {
    ret.err = mdbx_xcursor_init1(mc, node, mp);
    if (__builtin_expect(!!(ret.err != MDBX_SUCCESS), 0))
      return ret;
    if (op == MDBX_SET || op == MDBX_SET_KEY || op == MDBX_SET_RANGE) {
      ret.err = mdbx_cursor_first(&mc->mc_xcursor->mx_cursor, data, 
# 14540 "/libmdbx/src/core.c" 3 4
                                                                   ((void *)0)
# 14540 "/libmdbx/src/core.c"
                                                                       );
      if (__builtin_expect(!!(ret.err != MDBX_SUCCESS), 0))
        return ret;
    } else {
      ret = mdbx_cursor_set(&mc->mc_xcursor->mx_cursor, data, 
# 14544 "/libmdbx/src/core.c" 3 4
                                                             ((void *)0)
# 14544 "/libmdbx/src/core.c"
                                                                 ,
                            MDBX_SET_RANGE);
      if (__builtin_expect(!!(ret.err != MDBX_SUCCESS), 0))
        return ret;
      if (op == MDBX_GET_BOTH && !ret.exact) {
        ret.err = MDBX_NOTFOUND;
        return ret;
      }
    }
  } else if (__builtin_expect(!!(data), 1)) {
    if (op == MDBX_GET_BOTH || op == MDBX_GET_BOTH_RANGE) {
      if (__builtin_expect(!!(data->iov_len < mc->mc_dbx->md_vlen_min || data->iov_len > mc->mc_dbx->md_vlen_max), 0)
                                                           ) {
        do { if ((0)) do { if (__builtin_expect(!!(!(!"Invalid data-size")), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "!\"Invalid data-size\"", __func__, 14557); } while (0); } while (0);
        ret.err = MDBX_BAD_VALSIZE;
        return ret;
      }
      MDBX_val aligned_data = *data;
      uint64_t aligned_databytes;
      if (mc->mc_db->md_flags & MDBX_INTEGERDUP) {
        switch (aligned_data.iov_len) {
        default:
          do { if ((0)) do { if (__builtin_expect(!!(!(!"data-size is invalid for MDBX_INTEGERDUP")), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "!\"data-size is invalid for MDBX_INTEGERDUP\"", __func__, 14566); } while (0); } while (0);
          ret.err = MDBX_BAD_VALSIZE;
          return ret;
        case 4:
          if (__builtin_expect(!!(3 & (uintptr_t)aligned_data.iov_base), 0))

            aligned_data.iov_base =
                memcpy(&aligned_databytes, aligned_data.iov_base, 4);
          break;
        case 8:
          if (__builtin_expect(!!(7 & (uintptr_t)aligned_data.iov_base), 0))

            aligned_data.iov_base =
                memcpy(&aligned_databytes, aligned_data.iov_base, 8);
          break;
        }
      }
      MDBX_val actual_data;
      ret.err = mdbx_node_read(mc, node, &actual_data,
                               pp_txnid4chk(mc->mc_pg[mc->mc_top], mc->mc_txn));
      if (__builtin_expect(!!(ret.err != MDBX_SUCCESS), 0))
        return ret;
      const int cmp = mc->mc_dbx->md_dcmp(&aligned_data, &actual_data);
      if (cmp) {
        do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_ki[mc->mc_top] < page_numkeys(mc->mc_pg[mc->mc_top]) || (mc->mc_flags & 0x02))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mc->mc_ki[mc->mc_top] < page_numkeys(mc->mc_pg[mc->mc_top]) || (mc->mc_flags & 0x02)", __func__, 14590); } while (0); } while (0)

                                                    ;
        if (op != MDBX_GET_BOTH_RANGE || cmp > 0) {
          ret.err = MDBX_NOTFOUND;
          return ret;
        }
      }
      *data = actual_data;
    } else {
      ret.err = mdbx_node_read(mc, node, data,
                               pp_txnid4chk(mc->mc_pg[mc->mc_top], mc->mc_txn));
      if (__builtin_expect(!!(ret.err != MDBX_SUCCESS), 0))
        return ret;
    }
  }


  if (op == MDBX_SET_RANGE || op == MDBX_SET_KEY)
    get_key_optional(node, key);

  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 14611, "==> cursor placed on key [%s], data [%s]" "\n", ("-"), ("-")); } while (0)
                              ;
  ret.err = MDBX_SUCCESS;
  return ret;
}


static int mdbx_cursor_first(MDBX_cursor *mc, MDBX_val *key, MDBX_val *data) {
  int rc;

  if (mc->mc_xcursor)
    mc->mc_xcursor->mx_cursor.mc_flags &= ~(0x01 | 0x02);

  if (!(mc->mc_flags & 0x01) || mc->mc_top) {
    rc = mdbx_page_search(mc, 
# 14625 "/libmdbx/src/core.c" 3 4
                             ((void *)0)
# 14625 "/libmdbx/src/core.c"
                                 , 4);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      return rc;
  }

  if (!0 && __builtin_expect(!!(!(((mc->mc_pg[mc->mc_top])->mp_flags & 0x02) != 0)), 0))
    return MDBX_CORRUPTED;

  mc->mc_flags |= 0x01;
  mc->mc_flags &= ~0x02;
  mc->mc_ki[mc->mc_top] = 0;

  if (__builtin_expect(!!(((mc->mc_pg[mc->mc_top])->mp_flags & 0x20) != 0), 0)) {
    if (!0 && __builtin_expect(!!((mc->mc_flags & 0x04) == 0), 0)) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 14639, "unexpected LEAF2-page %" 
# 14639 "/libmdbx/src/core.c" 3 4
     "u" 
# 14639 "/libmdbx/src/core.c"
     "for non-dupsort cursor" "\n", mc->mc_pg[mc->mc_top]->mp_pgno); } while (0)
                                                ;
      return MDBX_CORRUPTED;
    } else if (__builtin_expect(!!(key), 1)) {
      key->iov_len = mc->mc_db->md_xsize;
      key->iov_base = page_leaf2key(mc->mc_pg[mc->mc_top], 0, key->iov_len);
    }
    return MDBX_SUCCESS;
  }

  MDBX_node *node = page_node(mc->mc_pg[mc->mc_top], 0);
  if ((((node_flags(node)) & (0x04)) == (0x04))) {
    rc = mdbx_xcursor_init1(mc, node, mc->mc_pg[mc->mc_top]);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      return rc;
    rc = mdbx_cursor_first(&mc->mc_xcursor->mx_cursor, data, 
# 14654 "/libmdbx/src/core.c" 3 4
                                                            ((void *)0)
# 14654 "/libmdbx/src/core.c"
                                                                );
    if (__builtin_expect(!!(rc), 0))
      return rc;
  } else if (__builtin_expect(!!(data), 1)) {
    if (__builtin_expect(!!((rc = mdbx_node_read( mc, node, data, pp_txnid4chk(mc->mc_pg[mc->mc_top], mc->mc_txn))) != MDBX_SUCCESS), 0)


                              )
      return rc;
  }

  get_key_optional(node, key);
  return MDBX_SUCCESS;
}


static int mdbx_cursor_last(MDBX_cursor *mc, MDBX_val *key, MDBX_val *data) {
  int rc;

  if (mc->mc_xcursor)
    mc->mc_xcursor->mx_cursor.mc_flags &= ~(0x01 | 0x02);

  if (!(mc->mc_flags & 0x01) || mc->mc_top) {
    rc = mdbx_page_search(mc, 
# 14677 "/libmdbx/src/core.c" 3 4
                             ((void *)0)
# 14677 "/libmdbx/src/core.c"
                                 , 8);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      return rc;
  }

  if (!0 && __builtin_expect(!!(!(((mc->mc_pg[mc->mc_top])->mp_flags & 0x02) != 0)), 0))
    return MDBX_CORRUPTED;

  mc->mc_ki[mc->mc_top] = (indx_t)page_numkeys(mc->mc_pg[mc->mc_top]) - 1;
  mc->mc_flags |= 0x01 | 0x02;

  if (__builtin_expect(!!(((mc->mc_pg[mc->mc_top])->mp_flags & 0x20) != 0), 0)) {
    if (!0 && __builtin_expect(!!((mc->mc_flags & 0x04) == 0), 0)) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 14690, "unexpected LEAF2-page %" 
# 14690 "/libmdbx/src/core.c" 3 4
     "u" 
# 14690 "/libmdbx/src/core.c"
     "for non-dupsort cursor" "\n", mc->mc_pg[mc->mc_top]->mp_pgno); } while (0)
                                                ;
      return MDBX_CORRUPTED;
    } else if (__builtin_expect(!!(key), 1)) {
      key->iov_len = mc->mc_db->md_xsize;
      key->iov_base = page_leaf2key(mc->mc_pg[mc->mc_top],
                                    mc->mc_ki[mc->mc_top], key->iov_len);
    }
    return MDBX_SUCCESS;
  }

  MDBX_node *node = page_node(mc->mc_pg[mc->mc_top], mc->mc_ki[mc->mc_top]);
  if ((((node_flags(node)) & (0x04)) == (0x04))) {
    rc = mdbx_xcursor_init1(mc, node, mc->mc_pg[mc->mc_top]);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      return rc;
    rc = mdbx_cursor_last(&mc->mc_xcursor->mx_cursor, data, 
# 14706 "/libmdbx/src/core.c" 3 4
                                                           ((void *)0)
# 14706 "/libmdbx/src/core.c"
                                                               );
    if (__builtin_expect(!!(rc), 0))
      return rc;
  } else if (__builtin_expect(!!(data), 1)) {
    if (__builtin_expect(!!((rc = mdbx_node_read( mc, node, data, pp_txnid4chk(mc->mc_pg[mc->mc_top], mc->mc_txn))) != MDBX_SUCCESS), 0)


                              )
      return rc;
  }

  get_key_optional(node, key);
  return MDBX_SUCCESS;
}

int mdbx_cursor_get(MDBX_cursor *mc, MDBX_val *key, MDBX_val *data,
                    MDBX_cursor_op op) {
  if (__builtin_expect(!!(mc == 
# 14723 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 14723 "/libmdbx/src/core.c"
     ), 0))
    return MDBX_EINVAL;

  if (__builtin_expect(!!(mc->mc_signature != 0xFE05D5B1U), 0))
    return (mc->mc_signature == 0x2817A047U) ? MDBX_EINVAL
                                                     : MDBX_EBADSIGN;

  int rc = check_txn(mc->mc_txn, (0x01 | 0x02 | 0x10));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  int (*mfunc)(MDBX_cursor * mc, MDBX_val * key, MDBX_val * data);
  switch (op) {
  case MDBX_GET_CURRENT: {
    if (__builtin_expect(!!(!(mc->mc_flags & 0x01)), 0))
      return MDBX_ENODATA;
    MDBX_page *mp = mc->mc_pg[mc->mc_top];
    const unsigned nkeys = page_numkeys(mp);
    if (__builtin_expect(!!(mc->mc_ki[mc->mc_top] >= nkeys), 0)) {
      do { if ((0)) do { if (__builtin_expect(!!(!(nkeys <= 
# 14742 "/libmdbx/src/core.c" 3 4
     (65535)
# 14742 "/libmdbx/src/core.c"
     )), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "nkeys <= (65535)", __func__, 14742); } while (0); } while (0);
      if (mc->mc_flags & 0x02)
        return MDBX_ENODATA;
      mc->mc_ki[mc->mc_top] = (uint16_t)nkeys;
      mc->mc_flags |= 0x02;
      return MDBX_NOTFOUND;
    }
    do { if ((0)) do { if (__builtin_expect(!!(!(nkeys > 0)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "nkeys > 0", __func__, 14749); } while (0); } while (0);

    rc = MDBX_SUCCESS;
    if (__builtin_expect(!!(((mp)->mp_flags & 0x20) != 0), 0)) {
      if (!0 && __builtin_expect(!!((mc->mc_flags & 0x04) == 0), 0)) {
        do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 14754, "unexpected LEAF2-page %" 
# 14754 "/libmdbx/src/core.c" 3 4
       "u" 
# 14754 "/libmdbx/src/core.c"
       "for non-dupsort cursor" "\n", mp->mp_pgno); } while (0)
                               ;
        return MDBX_CORRUPTED;
      }
      key->iov_len = mc->mc_db->md_xsize;
      key->iov_base = page_leaf2key(mp, mc->mc_ki[mc->mc_top], key->iov_len);
    } else {
      MDBX_node *node = page_node(mp, mc->mc_ki[mc->mc_top]);
      get_key_optional(node, key);
      if (data) {
        if ((((node_flags(node)) & (0x04)) == (0x04))) {
          if (__builtin_expect(!!(!(mc->mc_xcursor->mx_cursor.mc_flags & 0x01)), 0)) {
            rc = mdbx_xcursor_init1(mc, node, mp);
            if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
              return rc;
            rc = mdbx_cursor_first(&mc->mc_xcursor->mx_cursor, data, 
# 14769 "/libmdbx/src/core.c" 3 4
                                                                    ((void *)0)
# 14769 "/libmdbx/src/core.c"
                                                                        );
            if (__builtin_expect(!!(rc), 0))
              return rc;
          } else {
            rc = mdbx_cursor_get(&mc->mc_xcursor->mx_cursor, data, 
# 14773 "/libmdbx/src/core.c" 3 4
                                                                  ((void *)0)
# 14773 "/libmdbx/src/core.c"
                                                                      ,
                                 MDBX_GET_CURRENT);
            if (__builtin_expect(!!(rc), 0))
              return rc;
          }
        } else {
          rc = mdbx_node_read(mc, node, data, pp_txnid4chk(mp, mc->mc_txn));
          if (__builtin_expect(!!(rc), 0))
            return rc;
        }
      }
    }
    break;
  }
  case MDBX_GET_BOTH:
  case MDBX_GET_BOTH_RANGE:
    if (__builtin_expect(!!(data == 
# 14789 "/libmdbx/src/core.c" 3 4
       ((void *)0)
# 14789 "/libmdbx/src/core.c"
       ), 0))
      return MDBX_EINVAL;
    if (__builtin_expect(!!(mc->mc_xcursor == 
# 14791 "/libmdbx/src/core.c" 3 4
       ((void *)0)
# 14791 "/libmdbx/src/core.c"
       ), 0))
      return MDBX_INCOMPATIBLE;

    __attribute__((__fallthrough__));
  case MDBX_SET:
  case MDBX_SET_KEY:
  case MDBX_SET_RANGE:
    if (__builtin_expect(!!(key == 
# 14798 "/libmdbx/src/core.c" 3 4
       ((void *)0)
# 14798 "/libmdbx/src/core.c"
       ), 0))
      return MDBX_EINVAL;
    rc = mdbx_cursor_set(mc, key, data, op).err;
    if (mc->mc_flags & 0x01) {
      do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_snum > 0 && mc->mc_top < mc->mc_snum)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mc->mc_snum > 0 && mc->mc_top < mc->mc_snum", __func__, 14802); } while (0); } while (0);
      do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_ki[mc->mc_top] < page_numkeys(mc->mc_pg[mc->mc_top]) || (mc->mc_flags & 0x02))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mc->mc_ki[mc->mc_top] < page_numkeys(mc->mc_pg[mc->mc_top]) || (mc->mc_flags & 0x02)", __func__, 14803); } while (0); } while (0)

                                                  ;
    }
    break;
  case MDBX_GET_MULTIPLE:
    if (__builtin_expect(!!(data == 
# 14809 "/libmdbx/src/core.c" 3 4
       ((void *)0) 
# 14809 "/libmdbx/src/core.c"
       || !(mc->mc_flags & 0x01)), 0))
      return MDBX_EINVAL;
    if (__builtin_expect(!!(!(mc->mc_db->md_flags & MDBX_DUPFIXED)), 0))
      return MDBX_INCOMPATIBLE;
    rc = MDBX_SUCCESS;
    if ((mc->mc_xcursor->mx_cursor.mc_flags & (0x01 | 0x02)) !=
        0x01)
      break;
    goto fetchm;
  case MDBX_NEXT_MULTIPLE:
    if (__builtin_expect(!!(data == 
# 14819 "/libmdbx/src/core.c" 3 4
       ((void *)0)
# 14819 "/libmdbx/src/core.c"
       ), 0))
      return MDBX_EINVAL;
    if (__builtin_expect(!!(!(mc->mc_db->md_flags & MDBX_DUPFIXED)), 0))
      return MDBX_INCOMPATIBLE;
    rc = mdbx_cursor_next(mc, key, data, MDBX_NEXT_DUP);
    if (rc == MDBX_SUCCESS) {
      if (mc->mc_xcursor->mx_cursor.mc_flags & 0x01) {
        MDBX_cursor *mx;
      fetchm:
        mx = &mc->mc_xcursor->mx_cursor;
        data->iov_len =
            page_numkeys(mx->mc_pg[mx->mc_top]) * mx->mc_db->md_xsize;
        data->iov_base = page_data(mx->mc_pg[mx->mc_top]);
        mx->mc_ki[mx->mc_top] = (indx_t)page_numkeys(mx->mc_pg[mx->mc_top]) - 1;
      } else {
        rc = MDBX_NOTFOUND;
      }
    }
    break;
  case MDBX_PREV_MULTIPLE:
    if (data == 
# 14839 "/libmdbx/src/core.c" 3 4
               ((void *)0)
# 14839 "/libmdbx/src/core.c"
                   )
      return MDBX_EINVAL;
    if (!(mc->mc_db->md_flags & MDBX_DUPFIXED))
      return MDBX_INCOMPATIBLE;
    rc = MDBX_SUCCESS;
    if (!(mc->mc_flags & 0x01))
      rc = mdbx_cursor_last(mc, key, data);
    if (rc == MDBX_SUCCESS) {
      MDBX_cursor *mx = &mc->mc_xcursor->mx_cursor;
      if (mx->mc_flags & 0x01) {
        rc = mdbx_cursor_sibling(mx, 0);
        if (rc == MDBX_SUCCESS)
          goto fetchm;
      } else {
        rc = MDBX_NOTFOUND;
      }
    }
    break;
  case MDBX_NEXT:
  case MDBX_NEXT_DUP:
  case MDBX_NEXT_NODUP:
    rc = mdbx_cursor_next(mc, key, data, op);
    break;
  case MDBX_PREV:
  case MDBX_PREV_DUP:
  case MDBX_PREV_NODUP:
    rc = mdbx_cursor_prev(mc, key, data, op);
    break;
  case MDBX_FIRST:
    rc = mdbx_cursor_first(mc, key, data);
    break;
  case MDBX_FIRST_DUP:
    mfunc = mdbx_cursor_first;
  move:
    if (__builtin_expect(!!(data == 
# 14873 "/libmdbx/src/core.c" 3 4
       ((void *)0) 
# 14873 "/libmdbx/src/core.c"
       || !(mc->mc_flags & 0x01)), 0))
      return MDBX_EINVAL;
    if (__builtin_expect(!!(mc->mc_xcursor == 
# 14875 "/libmdbx/src/core.c" 3 4
       ((void *)0)
# 14875 "/libmdbx/src/core.c"
       ), 0))
      return MDBX_INCOMPATIBLE;
    if (mc->mc_ki[mc->mc_top] >= page_numkeys(mc->mc_pg[mc->mc_top])) {
      mc->mc_ki[mc->mc_top] = (indx_t)page_numkeys(mc->mc_pg[mc->mc_top]);
      mc->mc_flags |= 0x02;
      return MDBX_NOTFOUND;
    }
    {
      MDBX_node *node = page_node(mc->mc_pg[mc->mc_top], mc->mc_ki[mc->mc_top]);
      if (!(((node_flags(node)) & (0x04)) == (0x04))) {
        get_key_optional(node, key);
        rc = mdbx_node_read(mc, node, data,
                            pp_txnid4chk(mc->mc_pg[mc->mc_top], mc->mc_txn));
        break;
      }
    }
    if (__builtin_expect(!!(!(mc->mc_xcursor->mx_cursor.mc_flags & 0x01)), 0))
      return MDBX_EINVAL;
    rc = mfunc(&mc->mc_xcursor->mx_cursor, data, 
# 14893 "/libmdbx/src/core.c" 3 4
                                                ((void *)0)
# 14893 "/libmdbx/src/core.c"
                                                    );
    break;
  case MDBX_LAST:
    rc = mdbx_cursor_last(mc, key, data);
    break;
  case MDBX_LAST_DUP:
    mfunc = mdbx_cursor_last;
    goto move;
  case MDBX_SET_UPPERBOUND:
  case MDBX_SET_LOWERBOUND: {
    if (__builtin_expect(!!(key == 
# 14903 "/libmdbx/src/core.c" 3 4
       ((void *)0) 
# 14903 "/libmdbx/src/core.c"
       || data == 
# 14903 "/libmdbx/src/core.c" 3 4
       ((void *)0)
# 14903 "/libmdbx/src/core.c"
       ), 0))
      return MDBX_EINVAL;
    MDBX_val save_data = *data;
    struct cursor_set_result csr =
        mdbx_cursor_set(mc, key, data, MDBX_SET_RANGE);
    rc = csr.err;
    if (rc == MDBX_SUCCESS && csr.exact && mc->mc_xcursor) {
      mc->mc_flags &= ~0x08;
      csr.exact = (0);
      if (!save_data.iov_base && (mc->mc_db->md_flags & MDBX_DUPFIXED)) {



      } else if (mc->mc_xcursor->mx_cursor.mc_flags & 0x01) {
        *data = save_data;
        csr = mdbx_cursor_set(&mc->mc_xcursor->mx_cursor, data, 
# 14918 "/libmdbx/src/core.c" 3 4
                                                               ((void *)0)
# 14918 "/libmdbx/src/core.c"
                                                                   ,
                              MDBX_SET_RANGE);
        rc = csr.err;
        if (rc == MDBX_NOTFOUND) {
          do { if ((0)) do { if (__builtin_expect(!!(!(!csr.exact)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "!csr.exact", __func__, 14922); } while (0); } while (0);
          rc = mdbx_cursor_next(mc, key, data, MDBX_NEXT_NODUP);
        }
      } else {
        int cmp = mc->mc_dbx->md_dcmp(&save_data, data);
        csr.exact = (cmp == 0);
        if (cmp > 0)
          rc = mdbx_cursor_next(mc, key, data, MDBX_NEXT_NODUP);
      }
    }
    if (rc == MDBX_SUCCESS && !csr.exact)
      rc = MDBX_RESULT_TRUE;
    if (__builtin_expect(!!(op == MDBX_SET_UPPERBOUND), 0)) {

      if (rc == MDBX_RESULT_TRUE)

        rc = MDBX_SUCCESS;
      else if (rc == MDBX_SUCCESS)

        rc = mdbx_cursor_next(mc, key, data, MDBX_NEXT);
    }
    break;
  }
  default:
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 14946, "unhandled/unimplemented cursor operation %u" "\n", op); } while (0);
    return MDBX_EINVAL;
  }

  mc->mc_flags &= ~0x08;
  return rc;
}

static int cursor_first_batch(MDBX_cursor *mc) {
  if (!(mc->mc_flags & 0x01) || mc->mc_top) {
    int err = mdbx_page_search(mc, 
# 14956 "/libmdbx/src/core.c" 3 4
                                  ((void *)0)
# 14956 "/libmdbx/src/core.c"
                                      , 4);
    if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
      return err;
  }
  do { if ((0)) do { if (__builtin_expect(!!(!((((mc->mc_pg[mc->mc_top])->mp_flags & 0x02) != 0))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "(((mc->mc_pg[mc->mc_top])->mp_flags & 0x02) != 0)", __func__, 14960); } while (0); } while (0);

  mc->mc_flags |= 0x01;
  mc->mc_flags &= ~0x02;
  mc->mc_ki[mc->mc_top] = 0;
  return MDBX_SUCCESS;
}

static int cursor_next_batch(MDBX_cursor *mc) {
  if (__builtin_expect(!!(!(mc->mc_flags & 0x01)), 0))
    return cursor_first_batch(mc);

  MDBX_page *mp = mc->mc_pg[mc->mc_top];
  if (__builtin_expect(!!(mc->mc_flags & 0x02), 0)) {
    if ((unsigned)mc->mc_ki[mc->mc_top] + 1 >= page_numkeys(mp))
      return MDBX_NOTFOUND;
    mc->mc_flags ^= 0x02;
  }

  int ki = mc->mc_ki[mc->mc_top];
  mc->mc_ki[mc->mc_top] = (indx_t)++ki;
  const int numkeys = page_numkeys(mp);
  if (__builtin_expect(!!(ki >= numkeys), 1)) {
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 14983, "%s" "\n", "=====> move to next sibling page"); } while (0);
    mc->mc_ki[mc->mc_top] = (indx_t)(numkeys - 1);
    int err = mdbx_cursor_sibling(mc, 2);
    if (__builtin_expect(!!(err != MDBX_SUCCESS), 0)) {
      mc->mc_flags |= 0x02;
      return err;
    }
    mp = mc->mc_pg[mc->mc_top];
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 14991, "next page is %" 
# 14991 "/libmdbx/src/core.c" 3 4
   "u" 
# 14991 "/libmdbx/src/core.c"
   ", key index %u" "\n", mp->mp_pgno, mc->mc_ki[mc->mc_top]); } while (0)
                                     ;
  }
  return MDBX_SUCCESS;
}

int mdbx_cursor_get_batch(MDBX_cursor *mc, size_t *count, MDBX_val *pairs,
                          size_t limit, MDBX_cursor_op op) {
  if (__builtin_expect(!!(mc == 
# 14999 "/libmdbx/src/core.c" 3 4
     ((void *)0) 
# 14999 "/libmdbx/src/core.c"
     || count == 
# 14999 "/libmdbx/src/core.c" 3 4
     ((void *)0) 
# 14999 "/libmdbx/src/core.c"
     || limit < 4), 0))
    return MDBX_EINVAL;

  if (__builtin_expect(!!(mc->mc_signature != 0xFE05D5B1U), 0))
    return (mc->mc_signature == 0x2817A047U) ? MDBX_EINVAL
                                                     : MDBX_EBADSIGN;

  int rc = check_txn(mc->mc_txn, (0x01 | 0x02 | 0x10));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(mc->mc_db->md_flags & MDBX_DUPSORT), 0))
    return MDBX_INCOMPATIBLE ;

  switch (op) {
  case MDBX_FIRST:
    rc = cursor_first_batch(mc);
    break;
  case MDBX_NEXT:
    rc = cursor_next_batch(mc);
    break;
  case MDBX_GET_CURRENT:
    rc = __builtin_expect(!!(mc->mc_flags & 0x01), 1) ? MDBX_SUCCESS : MDBX_ENODATA;
    break;
  default:
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 15024, "unhandled/unimplemented cursor operation %u" "\n", op); } while (0);
    rc = 
# 15025 "/libmdbx/src/core.c" 3 4
        22
# 15025 "/libmdbx/src/core.c"
              ;
    break;
  }

  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0)) {
    *count = 0;
    return rc;
  }

  const MDBX_page *const page = mc->mc_pg[mc->mc_top];
  const unsigned nkeys = page_numkeys(page);
  unsigned i = mc->mc_ki[mc->mc_top], n = 0;
  if (__builtin_expect(!!(i >= nkeys), 0)) {
    do { if ((0)) do { if (__builtin_expect(!!(!(op == MDBX_GET_CURRENT)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "op == MDBX_GET_CURRENT", __func__, 15038); } while (0); } while (0);
    do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_cursor_on_last(mc) == MDBX_RESULT_TRUE)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mdbx_cursor_on_last(mc) == MDBX_RESULT_TRUE", __func__, 15039); } while (0); } while (0);
    *count = 0;
    if (mc->mc_flags & 0x02) {
      do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_cursor_on_last(mc) == MDBX_RESULT_TRUE)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mdbx_cursor_on_last(mc) == MDBX_RESULT_TRUE", __func__, 15042); } while (0); } while (0);
      return MDBX_ENODATA;
    }
    if (mdbx_cursor_on_last(mc) != MDBX_RESULT_TRUE)
      return MDBX_EINVAL ;
    mc->mc_flags |= 0x02;
    return MDBX_NOTFOUND;
  }

  const txnid_t pp_txnid = pp_txnid4chk(page, mc->mc_txn);
  do {
    if (__builtin_expect(!!(n + 2 > limit), 0)) {
      rc = MDBX_RESULT_TRUE;
      break;
    }
    const MDBX_node *leaf = page_node(page, i);
    get_key(leaf, &pairs[n]);
    rc = mdbx_node_read(mc, leaf, &pairs[n + 1], pp_txnid);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      break;
    n += 2;
  } while (++i < nkeys);

  mc->mc_ki[mc->mc_top] = (indx_t)i;
  *count = n;
  return rc;
}

static int mdbx_touch_dbi(MDBX_cursor *mc) {
  do { if ((0)) do { if (__builtin_expect(!!(!((*mc->mc_dbistate & MDBX_DBI_DIRTY) == 0)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "(*mc->mc_dbistate & MDBX_DBI_DIRTY) == 0", __func__, 15071); } while (0); } while (0);
  *mc->mc_dbistate |= MDBX_DBI_DIRTY;
  mc->mc_txn->mt_flags |= 0x04;
  if (mc->mc_dbi >= 2) {
    do { if ((0)) do { if (__builtin_expect(!!(!((mc->mc_flags & 0x20) == 0)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "(mc->mc_flags & 0x20) == 0", __func__, 15075); } while (0); } while (0);

    MDBX_cursor_couple cx;
    int rc = mdbx_cursor_init(&cx.outer, mc->mc_txn, 1);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      return rc;
    mc->mc_txn->mt_dbistate[1] |= MDBX_DBI_DIRTY;
    rc = mdbx_page_search(&cx.outer, &mc->mc_dbx->md_name, 1);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      return rc;
  }
  return MDBX_SUCCESS;
}




static int mdbx_cursor_touch(MDBX_cursor *mc) {
  int rc = MDBX_SUCCESS;
  if (__builtin_expect(!!((*mc->mc_dbistate & MDBX_DBI_DIRTY) == 0), 0)) {
    rc = mdbx_touch_dbi(mc);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      return rc;
  }
  if (__builtin_expect(!!(mc->mc_snum), 1)) {
    mc->mc_top = 0;
    do {
      rc = mdbx_page_touch(mc);
    } while (!rc && ++(mc->mc_top) < mc->mc_snum);
    mc->mc_top = mc->mc_snum - 1;
  }
  return rc;
}

int mdbx_cursor_put(MDBX_cursor *mc, const MDBX_val *key, MDBX_val *data,
                    unsigned flags) {
  MDBX_env *env;
  MDBX_page *sub_root = 
# 15112 "/libmdbx/src/core.c" 3 4
                       ((void *)0)
# 15112 "/libmdbx/src/core.c"
                           ;
  MDBX_val xdata, *rdata, dkey, olddata;
  MDBX_db nested_dupdb;
  int err;
  ((void)(0));

  if (__builtin_expect(!!(mc == 
# 15118 "/libmdbx/src/core.c" 3 4
     ((void *)0) 
# 15118 "/libmdbx/src/core.c"
     || key == 
# 15118 "/libmdbx/src/core.c" 3 4
     ((void *)0) 
# 15118 "/libmdbx/src/core.c"
     || data == 
# 15118 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 15118 "/libmdbx/src/core.c"
     ), 0))
    return MDBX_EINVAL;

  if (__builtin_expect(!!(mc->mc_signature != 0xFE05D5B1U), 0))
    return (mc->mc_signature == 0x2817A047U) ? MDBX_EINVAL
                                                     : MDBX_EBADSIGN;

  int rc = check_txn_rw(mc->mc_txn, (0x01 | 0x02 | 0x10));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(((mc->mc_txn)->mt_dbiseqs[mc->mc_dbi] != (mc->mc_txn)->mt_env->me_dbiseqs[mc->mc_dbi])), 0))
    return MDBX_BAD_DBI;

  do { if ((0)) do { if (__builtin_expect(!!(!(cursor_is_tracked(mc))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "cursor_is_tracked(mc)", __func__, 15132); } while (0); } while (0);
  env = mc->mc_txn->mt_env;


  size_t mcount = 0, dcount = 0;
  if (__builtin_expect(!!(flags & MDBX_MULTIPLE), 0)) {
    if (__builtin_expect(!!(flags & MDBX_RESERVE), 0))
      return MDBX_EINVAL;
    if (__builtin_expect(!!(!(((mc->mc_db->md_flags) & (MDBX_DUPFIXED)) == (MDBX_DUPFIXED))), 0))
      return MDBX_INCOMPATIBLE;
    dcount = data[1].iov_len;
    if (__builtin_expect(!!(dcount < 2 || data->iov_len == 0), 0))
      return MDBX_BAD_VALSIZE;
    if (__builtin_expect(!!(mc->mc_db->md_xsize != data->iov_len), 0) && mc->mc_db->md_xsize)
      return MDBX_BAD_VALSIZE;
    if (__builtin_expect(!!(dcount > ((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE) / 2 / (((((((MDBX_MAX_PAGESIZE)-((unsigned)
# 15147 "/libmdbx/src/core.c" 3 4
       __builtin_offsetof (
# 15147 "/libmdbx/src/core.c"
       MDBX_page
# 15147 "/libmdbx/src/core.c" 3 4
       , 
# 15147 "/libmdbx/src/core.c"
       mp_ptrs
# 15147 "/libmdbx/src/core.c" 3 4
       )
# 15147 "/libmdbx/src/core.c"
       )) - sizeof(indx_t) - 
# 15147 "/libmdbx/src/core.c" 3 4
       __builtin_offsetof (
# 15147 "/libmdbx/src/core.c"
       MDBX_node
# 15147 "/libmdbx/src/core.c" 3 4
       , 
# 15147 "/libmdbx/src/core.c"
       mn_data
# 15147 "/libmdbx/src/core.c" 3 4
       )
# 15147 "/libmdbx/src/core.c"
       ) / (3 - 1) - sizeof(indx_t)) & ~(size_t)1)) - 
# 15147 "/libmdbx/src/core.c" 3 4
       __builtin_offsetof (
# 15147 "/libmdbx/src/core.c"
       MDBX_node
# 15147 "/libmdbx/src/core.c" 3 4
       , 
# 15147 "/libmdbx/src/core.c"
       mn_data
# 15147 "/libmdbx/src/core.c" 3 4
       )
# 15147 "/libmdbx/src/core.c"
       )), 0)
                                                                         ) {

      if (__builtin_expect(!!(dcount > ((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE) / 2 / data->iov_len), 0))
        return MDBX_TOO_LARGE;
    }
    data[1].iov_len = 0 ;
  }

  if (flags & MDBX_RESERVE) {
    if (__builtin_expect(!!(mc->mc_db->md_flags & (MDBX_DUPSORT | MDBX_REVERSEDUP | MDBX_INTEGERDUP | MDBX_DUPFIXED)), 0)
                                                                         )
      return MDBX_INCOMPATIBLE;
    data->iov_base = 
# 15160 "/libmdbx/src/core.c" 3 4
                    ((void *)0)
# 15160 "/libmdbx/src/core.c"
                           ;
  }

  const unsigned nospill = flags & 0x8000;
  flags -= nospill;

  if (__builtin_expect(!!(mc->mc_txn->mt_flags & (MDBX_TXN_RDONLY | (0x01 | 0x02 | 0x10))), 0))
    return (mc->mc_txn->mt_flags & MDBX_TXN_RDONLY) ? MDBX_EACCESS
                                                    : MDBX_BAD_TXN;

  uint64_t aligned_keybytes, aligned_databytes;
  MDBX_val aligned_key, aligned_data;
  if (__builtin_expect(!!((mc->mc_flags & 0x04) == 0), 1)) {
    if (__builtin_expect(!!(key->iov_len < mc->mc_dbx->md_klen_min || key->iov_len > mc->mc_dbx->md_klen_max), 0)
                                                        ) {
      do { if ((0)) do { if (__builtin_expect(!!(!(!"Invalid key-size")), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "!\"Invalid key-size\"", __func__, 15175); } while (0); } while (0);
      return MDBX_BAD_VALSIZE;
    }
    if (__builtin_expect(!!(data->iov_len < mc->mc_dbx->md_vlen_min || data->iov_len > mc->mc_dbx->md_vlen_max), 0)
                                                         ) {
      do { if ((0)) do { if (__builtin_expect(!!(!(!"Invalid data-size")), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "!\"Invalid data-size\"", __func__, 15180); } while (0); } while (0);
      return MDBX_BAD_VALSIZE;
    }

    if (mc->mc_db->md_flags & MDBX_INTEGERKEY) {
      switch (key->iov_len) {
      default:
        do { if ((0)) do { if (__builtin_expect(!!(!(!"key-size is invalid for MDBX_INTEGERKEY")), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "!\"key-size is invalid for MDBX_INTEGERKEY\"", __func__, 15187); } while (0); } while (0);
        return MDBX_BAD_VALSIZE;
      case 4:
        if (__builtin_expect(!!(3 & (uintptr_t)key->iov_base), 0)) {

          aligned_key.iov_base =
              memcpy(&aligned_keybytes, key->iov_base, aligned_key.iov_len = 4);
          key = &aligned_key;
        }
        break;
      case 8:
        if (__builtin_expect(!!(7 & (uintptr_t)key->iov_base), 0)) {

          aligned_key.iov_base =
              memcpy(&aligned_keybytes, key->iov_base, aligned_key.iov_len = 8);
          key = &aligned_key;
        }
        break;
      }
    }
    if (mc->mc_db->md_flags & MDBX_INTEGERDUP) {
      switch (data->iov_len) {
      default:
        do { if ((0)) do { if (__builtin_expect(!!(!(!"data-size is invalid for MDBX_INTEGERKEY")), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "!\"data-size is invalid for MDBX_INTEGERKEY\"", __func__, 15210); } while (0); } while (0);
        return MDBX_BAD_VALSIZE;
      case 4:
        if (__builtin_expect(!!(3 & (uintptr_t)data->iov_base), 0)) {
          if (__builtin_expect(!!(flags & MDBX_MULTIPLE), 0))
            return MDBX_BAD_VALSIZE;

          aligned_data.iov_base = memcpy(&aligned_databytes, data->iov_base,
                                         aligned_data.iov_len = 4);
          data = &aligned_data;
        }
        break;
      case 8:
        if (__builtin_expect(!!(7 & (uintptr_t)data->iov_base), 0)) {
          if (__builtin_expect(!!(flags & MDBX_MULTIPLE), 0))
            return MDBX_BAD_VALSIZE;

          aligned_data.iov_base = memcpy(&aligned_databytes, data->iov_base,
                                         aligned_data.iov_len = 8);
          data = &aligned_data;
        }
        break;
      }
    }
  }

  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 15236, "==> put db %d key [%s], size %" 
# 15236 "/libmdbx/src/core.c" 3 4
 "l" "u" 
# 15236 "/libmdbx/src/core.c"
 ", data [%s] size %" 
# 15236 "/libmdbx/src/core.c" 3 4
 "l" "u" 
# 15236 "/libmdbx/src/core.c"
 "\n", (((mc)->mc_flags & 0x04) ? -(int)(mc)->mc_dbi : (int)(mc)->mc_dbi), ("-"), key->iov_len, ("-"), data->iov_len); } while (0)


                                                                         ;

  int dupdata_flag = 0;
  if ((flags & MDBX_CURRENT) != 0 && (mc->mc_flags & 0x04) == 0) {
    if (__builtin_expect(!!(flags & (MDBX_APPEND | MDBX_NOOVERWRITE)), 0))
      return MDBX_EINVAL;





    MDBX_val current_key, current_data;
    rc = mdbx_cursor_get(mc, &current_key, &current_data, MDBX_GET_CURRENT);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      return rc;
    if (mc->mc_dbx->md_cmp(key, &current_key) != 0)
      return MDBX_EKEYMISMATCH;

    if (__builtin_expect(!!((flags & MDBX_MULTIPLE)), 0))
      goto drop_current;

    if ((((mc->mc_db->md_flags) & (MDBX_DUPSORT)) == (MDBX_DUPSORT))) {
      MDBX_node *node = page_node(mc->mc_pg[mc->mc_top], mc->mc_ki[mc->mc_top]);
      if ((((node_flags(node)) & (0x04)) == (0x04))) {
        do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_xcursor != 
# 15263 "/libmdbx/src/core.c" 3 4
       ((void *)0) 
# 15263 "/libmdbx/src/core.c"
       && (mc->mc_xcursor->mx_cursor.mc_flags & 0x01))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mc->mc_xcursor != ((void *)0) && (mc->mc_xcursor->mx_cursor.mc_flags & 0x01)", __func__, 15263); } while (0); } while (0)

                                                                              ;



        if (mc->mc_xcursor->mx_db.md_entries > 1 ||
            current_data.iov_len != data->iov_len) {
        drop_current:
          rc = mdbx_cursor_del(mc, flags & MDBX_ALLDUPS);
          if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
            return rc;
          flags -= MDBX_CURRENT;
          goto skip_check_samedata;
        }
      } else if (__builtin_expect(!!(node_size(key, data) > env->me_leaf_nodemax), 0)) {
        rc = mdbx_cursor_del(mc, 0);
        if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
          return rc;
        flags -= MDBX_CURRENT;
        goto skip_check_samedata;
      }
    }
    if (!(flags & MDBX_RESERVE) &&
        __builtin_expect(!!(cmp_lenfast(&current_data, data) == 0), 0))
      return MDBX_SUCCESS ;
  skip_check_samedata:;
  }

  if (mc->mc_db->md_root == (~(pgno_t)0)) {

    mc->mc_snum = 0;
    mc->mc_top = 0;
    mc->mc_flags &= ~0x01;
    rc = (MDBX_LAST_ADDED_ERRCODE + 10);
  } else if ((flags & MDBX_CURRENT) == 0) {
    _Bool exact = (0);
    if ((flags & MDBX_APPEND) && mc->mc_db->md_entries > 0) {
      rc = mdbx_cursor_last(mc, &dkey, &olddata);
      if (__builtin_expect(!!(rc == MDBX_SUCCESS), 1)) {
        rc = mc->mc_dbx->md_cmp(key, &dkey);
        if (__builtin_expect(!!(rc > 0), 1)) {
          mc->mc_ki[mc->mc_top]++;
          rc = MDBX_NOTFOUND;
        } else {
          if (__builtin_expect(!!(rc != MDBX_SUCCESS || !(flags & MDBX_APPENDDUP)), 0))


            return MDBX_EKEYMISMATCH;
          exact = (1);
        }
      }
    } else {
      struct cursor_set_result csr =

          mdbx_cursor_set(mc, (MDBX_val *)key, &olddata, MDBX_SET);
      rc = csr.err;
      exact = csr.exact;
    }
    if (__builtin_expect(!!(rc == MDBX_SUCCESS), 1)) {
      if (exact) {
        if (__builtin_expect(!!(flags & MDBX_NOOVERWRITE), 0)) {
          do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 15325, "duplicate key [%s]" "\n", ("-")); } while (0);
          *data = olddata;
          return MDBX_KEYEXIST;
        }
        if (__builtin_expect(!!(mc->mc_flags & 0x04), 0)) {


          do { if ((0)) do { if (__builtin_expect(!!(!(data->iov_len == 0 && (olddata.iov_len == 0 || (mc->mc_db->md_flags & MDBX_DUPFIXED)))), 0)) mdbx_assert_fail(env, "data->iov_len == 0 && (olddata.iov_len == 0 || (mc->mc_db->md_flags & MDBX_DUPFIXED))", __func__, 15332); } while (0); } while (0)



                                                                       ;
          return MDBX_SUCCESS;
        }
        if (__builtin_expect(!!(flags & MDBX_ALLDUPS), 0) && mc->mc_xcursor &&
            (mc->mc_xcursor->mx_cursor.mc_flags & 0x01)) {
          rc = mdbx_cursor_del(mc, MDBX_ALLDUPS);
          if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
            return rc;
          flags -= MDBX_ALLDUPS;
          rc = MDBX_NOTFOUND;
          exact = (0);
        } else
          if (!(flags & (MDBX_RESERVE | MDBX_MULTIPLE)) &&
              __builtin_expect(!!(mc->mc_dbx->md_dcmp(data, &olddata) == 0), 0)) {
            if (!mc->mc_xcursor)

              return MDBX_SUCCESS;
            if (flags & MDBX_NODUPDATA)
              return MDBX_KEYEXIST;
            if (flags & MDBX_APPENDDUP)
              return MDBX_EKEYMISMATCH;
            if (__builtin_expect(!!(unsure_equal(mc->mc_dbx->md_dcmp, data, &olddata)), 1))

              return MDBX_SUCCESS;
            else {



            }
          }
      }
    } else if (__builtin_expect(!!(rc != MDBX_NOTFOUND), 0))
      return rc;
  }

  mc->mc_flags &= ~0x08;


  if (!nospill) {
    rdata = data;
    if (__builtin_expect(!!(flags & MDBX_MULTIPLE), 0)) {
      rdata = &xdata;
      xdata.iov_len = data->iov_len * dcount;
    }
    if (__builtin_expect(!!(err = mdbx_cursor_spill(mc, key, rdata)), 0))
      return err;
  }

  if (__builtin_expect(!!(rc == (MDBX_LAST_ADDED_ERRCODE + 10)), 0)) {

    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 15386, "%s" "\n", "allocating new root leaf page"); } while (0);
    if (__builtin_expect(!!((*mc->mc_dbistate & MDBX_DBI_DIRTY) == 0), 0)) {
      err = mdbx_touch_dbi(mc);
      if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
        return err;
    }
    struct page_result npr = mdbx_page_new(mc, 0x02, 1);
    if (__builtin_expect(!!(npr.err != MDBX_SUCCESS), 0))
      return npr.err;
    npr.err = mdbx_cursor_push(mc, npr.page);
    if (__builtin_expect(!!(npr.err != MDBX_SUCCESS), 0))
      return npr.err;
    mc->mc_db->md_root = npr.page->mp_pgno;
    mc->mc_db->md_depth++;
    if (mc->mc_db->md_flags & MDBX_INTEGERKEY) {
      do { if ((0)) do { if (__builtin_expect(!!(!(key->iov_len >= mc->mc_dbx->md_klen_min && key->iov_len <= mc->mc_dbx->md_klen_max)), 0)) mdbx_assert_fail(
# 15401 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 15401 "/libmdbx/src/core.c"
     , "key->iov_len >= mc->mc_dbx->md_klen_min && key->iov_len <= mc->mc_dbx->md_klen_max", __func__, 15401); } while (0); } while (0)
                                                     ;
      mc->mc_dbx->md_klen_min = mc->mc_dbx->md_klen_max = key->iov_len;
    }
    if (mc->mc_db->md_flags & (MDBX_INTEGERDUP | MDBX_DUPFIXED)) {
      do { if ((0)) do { if (__builtin_expect(!!(!(data->iov_len >= mc->mc_dbx->md_vlen_min && data->iov_len <= mc->mc_dbx->md_vlen_max)), 0)) mdbx_assert_fail(
# 15406 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 15406 "/libmdbx/src/core.c"
     , "data->iov_len >= mc->mc_dbx->md_vlen_min && data->iov_len <= mc->mc_dbx->md_vlen_max", __func__, 15406); } while (0); } while (0)
                                                      ;
      do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_xcursor != 
# 15408 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 15408 "/libmdbx/src/core.c"
     )), 0)) mdbx_assert_fail(
# 15408 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 15408 "/libmdbx/src/core.c"
     , "mc->mc_xcursor != ((void *)0)", __func__, 15408); } while (0); } while (0);
      mc->mc_db->md_xsize = mc->mc_xcursor->mx_db.md_xsize =
          (unsigned)(mc->mc_dbx->md_vlen_min = mc->mc_dbx->md_vlen_max =
                         mc->mc_xcursor->mx_dbx.md_klen_min =
                             mc->mc_xcursor->mx_dbx.md_klen_max =
                                 data->iov_len);
    }
    if ((mc->mc_db->md_flags & (MDBX_DUPSORT | MDBX_DUPFIXED)) == MDBX_DUPFIXED)
      npr.page->mp_flags |= 0x20;
    mc->mc_flags |= 0x01;
  } else {

    err = mdbx_cursor_touch(mc);
    if (__builtin_expect(!!(err), 0))
      return err;
  }

  _Bool insert_key, insert_data, do_sub = (0);
  insert_key = insert_data = (rc != MDBX_SUCCESS);
  uint16_t fp_flags = 0x02;
  MDBX_page *fp = env->me_pbuf;
  fp->mp_txnid = mc->mc_txn->mt_front;
  if (insert_key) {

    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 15432, "inserting key at index %i" "\n", mc->mc_ki[mc->mc_top]); } while (0);
    if ((mc->mc_db->md_flags & MDBX_DUPSORT) &&
        node_size(key, data) > env->me_leaf_nodemax) {


      fp->mp_leaf2_ksize =
          (mc->mc_db->md_flags & MDBX_DUPFIXED) ? (uint16_t)data->iov_len : 0;
      fp->mp_lower = fp->mp_upper = 0;
      olddata.iov_len = ((unsigned)
# 15440 "/libmdbx/src/core.c" 3 4
                       __builtin_offsetof (
# 15440 "/libmdbx/src/core.c"
                       MDBX_page
# 15440 "/libmdbx/src/core.c" 3 4
                       , 
# 15440 "/libmdbx/src/core.c"
                       mp_ptrs
# 15440 "/libmdbx/src/core.c" 3 4
                       )
# 15440 "/libmdbx/src/core.c"
                       );
      goto prep_subDB;
    }
  } else {

    if (__builtin_expect(!!(((mc->mc_pg[mc->mc_top])->mp_flags & 0x20) != 0), 0)) {
      char *ptr;
      unsigned ksize = mc->mc_db->md_xsize;
      if (__builtin_expect(!!(key->iov_len != ksize), 0))
        return MDBX_BAD_VALSIZE;
      ptr = page_leaf2key(mc->mc_pg[mc->mc_top], mc->mc_ki[mc->mc_top], ksize);
      memcpy(ptr, key->iov_base, ksize);
    fix_parent:


      if (mc->mc_top && !mc->mc_ki[mc->mc_top]) {
        unsigned dtop = 1;
        mc->mc_top--;

        while (mc->mc_top && !mc->mc_ki[mc->mc_top]) {
          mc->mc_top--;
          dtop++;
        }
        err = MDBX_SUCCESS;
        if (mc->mc_ki[mc->mc_top])
          err = mdbx_update_key(mc, key);
        do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_top + dtop < 
# 15466 "/libmdbx/src/core.c" 3 4
       (65535)
# 15466 "/libmdbx/src/core.c"
       )), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mc->mc_top + dtop < (65535)", __func__, 15466); } while (0); } while (0);
        mc->mc_top += (uint16_t)dtop;
        if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
          return err;
      }

      if ((0)) {
        err = mdbx_cursor_check(mc, 0);
        if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
          return err;
      }
      return MDBX_SUCCESS;
    }

  more:;
    if ((0)) {
      err = mdbx_cursor_check(mc, 0);
      if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
        return err;
    }
    MDBX_node *node = page_node(mc->mc_pg[mc->mc_top], mc->mc_ki[mc->mc_top]);


    if (__builtin_expect(!!((((node_flags(node)) & (0x01)) == (0x01))), 0)) {
      int dpages = (node_size(key, data) > env->me_leaf_nodemax)
                       ? number_of_ovpages(env, data->iov_len)
                       : 0;

      const pgno_t pgno = node_largedata_pgno(node);
      struct page_result pgr = mdbx_page_get_ex(
          mc, pgno, pp_txnid4chk(mc->mc_pg[mc->mc_top], mc->mc_txn));
      if (__builtin_expect(!!(pgr.err != MDBX_SUCCESS), 0))
        return pgr.err;
      if (__builtin_expect(!!(!__builtin_expect(!!(((pgr.page)->mp_flags & 0x04) != 0), 0)), 0))
        return MDBX_CORRUPTED;


      int ovpages = pgr.page->mp_pages;
      if (!((pgr.page)->mp_txnid < (mc->mc_txn)->mt_txnid) &&
          (__builtin_expect(!!(mc->mc_flags & 0x40), 0)
               ? (ovpages >= dpages)
               : (ovpages ==

                  dpages))) {

        if (!((pgr.page)->mp_txnid == (mc->mc_txn)->mt_front)) {
          if (((pgr.page)->mp_txnid == (mc->mc_txn)->mt_txnid)) {
            pgr =

                mdbx_page_unspill(mc->mc_txn, pgr.page);
            if (__builtin_expect(!!(pgr.err), 0))
              return pgr.err;
          } else {
            if (__builtin_expect(!!(!mc->mc_txn->mt_parent), 0)) {
              do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 15520, "Unexpected not frozen/modifiable/spilled but shadowed %s " "page %" 
# 15520 "/libmdbx/src/core.c" 3 4
             "u" 
# 15520 "/libmdbx/src/core.c"
             " mod-txnid %" 
# 15520 "/libmdbx/src/core.c" 3 4
             "l" "i" 
# 15520 "/libmdbx/src/core.c"
             "," " without parent transaction, current txn %" 
# 15520 "/libmdbx/src/core.c" 3 4
             "l" "i" 
# 15520 "/libmdbx/src/core.c"
             " front %" 
# 15520 "/libmdbx/src/core.c" 3 4
             "l" "i" 
# 15520 "/libmdbx/src/core.c"
             "\n", "overflow/large", pgno, pgr.page->mp_txnid, mc->mc_txn->mt_txnid, mc->mc_txn->mt_front); } while (0)





                                                             ;
              return MDBX_PROBLEM;
            }


            MDBX_page *np = mdbx_page_malloc(mc->mc_txn, ovpages);
            if (__builtin_expect(!!(!np), 0))
              return MDBX_ENOMEM;

            memcpy(np, pgr.page, ((unsigned)
# 15535 "/libmdbx/src/core.c" 3 4
                                __builtin_offsetof (
# 15535 "/libmdbx/src/core.c"
                                MDBX_page
# 15535 "/libmdbx/src/core.c" 3 4
                                , 
# 15535 "/libmdbx/src/core.c"
                                mp_ptrs
# 15535 "/libmdbx/src/core.c" 3 4
                                )
# 15535 "/libmdbx/src/core.c"
                                ));
            err = mdbx_page_dirty(mc->mc_txn, pgr.page = np, ovpages);
            if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
              return err;


            mc->mc_txn->mt_env->me_lck->mti_pgop_stat.clone.weak += ovpages;

            do { if ((0)) do { if (__builtin_expect(!!(!(mdbx_dirtylist_check(mc->mc_txn))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mdbx_dirtylist_check(mc->mc_txn)", __func__, 15543); } while (0); } while (0);
          }
        }
        node_set_ds(node, data->iov_len);
        if ((((flags) & (MDBX_RESERVE)) == (MDBX_RESERVE)))
          data->iov_base = page_data(pgr.page);
        else
          memcpy(page_data(pgr.page), data->iov_base, data->iov_len);

        if ((0)) {
          err = mdbx_cursor_check(mc, 0);
          if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
            return err;
        }
        return MDBX_SUCCESS;
      }

      if ((err = mdbx_page_retire(mc, pgr.page)) != MDBX_SUCCESS)
        return err;
    } else {
      olddata.iov_len = node_ds(node);
      olddata.iov_base = node_data(node);
      do { if ((0)) do { if (__builtin_expect(!!(!((char *)olddata.iov_base + olddata.iov_len <= (char *)(mc->mc_pg[mc->mc_top]) + env->me_psize)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "(char *)olddata.iov_base + olddata.iov_len <= (char *)(mc->mc_pg[mc->mc_top]) + env->me_psize", __func__, 15565); } while (0); } while (0)
                                                                           ;


      if ((((mc->mc_db->md_flags) & (MDBX_DUPSORT)) == (MDBX_DUPSORT))) {




        unsigned i;
        size_t offset = 0;
        MDBX_page *mp = fp = xdata.iov_base = env->me_pbuf;
        mp->mp_pgno = mc->mc_pg[mc->mc_top]->mp_pgno;


        if (!(((node_flags(node)) & (0x04)) == (0x04))) {


          const int cmp = mc->mc_dbx->md_dcmp(data, &olddata);
          if ((flags & MDBX_APPENDDUP) && __builtin_expect(!!(cmp <= 0), 0))
            return MDBX_EKEYMISMATCH;
          if (cmp == 0) {
            if (flags & MDBX_NODUPDATA)
              return MDBX_KEYEXIST;
            if (__builtin_expect(!!(unsure_equal(mc->mc_dbx->md_dcmp, data, &olddata)), 1)) {

              if (__builtin_expect(!!(flags & MDBX_MULTIPLE), 0)) {
                rc = MDBX_SUCCESS;
                goto continue_multiple;
              }
              return MDBX_SUCCESS;
            } else {



            }
            do { if ((0)) do { if (__builtin_expect(!!(!(node_size(key, data) <= env->me_leaf_nodemax)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "node_size(key, data) <= env->me_leaf_nodemax", __func__, 15601); } while (0); } while (0);
            goto current;
          }


          if (flags & MDBX_CURRENT) {
            do { if ((0)) do { if (__builtin_expect(!!(!(node_size(key, data) <= env->me_leaf_nodemax)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "node_size(key, data) <= env->me_leaf_nodemax", __func__, 15607); } while (0); } while (0);
            goto current;
          }


          memcpy(dkey.iov_base = fp + 1, olddata.iov_base,
                 dkey.iov_len = olddata.iov_len);
          dupdata_flag = 1;


          fp->mp_flags = 0x02 | 0x40;
          fp->mp_lower = 0;
          xdata.iov_len = ((unsigned)
# 15619 "/libmdbx/src/core.c" 3 4
                         __builtin_offsetof (
# 15619 "/libmdbx/src/core.c"
                         MDBX_page
# 15619 "/libmdbx/src/core.c" 3 4
                         , 
# 15619 "/libmdbx/src/core.c"
                         mp_ptrs
# 15619 "/libmdbx/src/core.c" 3 4
                         )
# 15619 "/libmdbx/src/core.c"
                         ) + dkey.iov_len + data->iov_len;
          if (mc->mc_db->md_flags & MDBX_DUPFIXED) {
            fp->mp_flags |= 0x20;
            fp->mp_leaf2_ksize = (uint16_t)data->iov_len;
            xdata.iov_len += 2 * data->iov_len;
            do { if ((0)) do { if (__builtin_expect(!!(!(xdata.iov_len <= env->me_psize)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "xdata.iov_len <= env->me_psize", __func__, 15624); } while (0); } while (0);
          } else {
            xdata.iov_len += 2 * (sizeof(indx_t) + 
# 15626 "/libmdbx/src/core.c" 3 4
                                                  __builtin_offsetof (
# 15626 "/libmdbx/src/core.c"
                                                  MDBX_node
# 15626 "/libmdbx/src/core.c" 3 4
                                                  , 
# 15626 "/libmdbx/src/core.c"
                                                  mn_data
# 15626 "/libmdbx/src/core.c" 3 4
                                                  )
# 15626 "/libmdbx/src/core.c"
                                                          ) +
                             (dkey.iov_len & 1) + (data->iov_len & 1);
            do { if ((0)) do { if (__builtin_expect(!!(!(xdata.iov_len <= env->me_psize)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "xdata.iov_len <= env->me_psize", __func__, 15628); } while (0); } while (0);
          }
          fp->mp_upper = (uint16_t)(xdata.iov_len - ((unsigned)
# 15630 "/libmdbx/src/core.c" 3 4
                                                   __builtin_offsetof (
# 15630 "/libmdbx/src/core.c"
                                                   MDBX_page
# 15630 "/libmdbx/src/core.c" 3 4
                                                   , 
# 15630 "/libmdbx/src/core.c"
                                                   mp_ptrs
# 15630 "/libmdbx/src/core.c" 3 4
                                                   )
# 15630 "/libmdbx/src/core.c"
                                                   ));
          olddata.iov_len = xdata.iov_len;
        } else if (node_flags(node) & 0x02) {

          flags |= 0x04 | 0x02;
          goto put_sub;
        } else {

          fp = olddata.iov_base;
          switch (flags) {
          default:
            if (!(mc->mc_db->md_flags & MDBX_DUPFIXED)) {
              offset = node_size(data, 
# 15642 "/libmdbx/src/core.c" 3 4
                                      ((void *)0)
# 15642 "/libmdbx/src/core.c"
                                             ) + sizeof(indx_t);
              break;
            }
            offset = fp->mp_leaf2_ksize;
            if (page_room(fp) < offset) {
              offset *= 4;
              break;
            }

            __attribute__((__fallthrough__));
          case MDBX_CURRENT | MDBX_NODUPDATA:
          case MDBX_CURRENT:
            fp->mp_txnid = mc->mc_txn->mt_front;
            fp->mp_pgno = mp->mp_pgno;
            mc->mc_xcursor->mx_cursor.mc_pg[0] = fp;
            flags |= 0x04;
            goto put_sub;
          }
          xdata.iov_len = olddata.iov_len + offset;
        }

        fp_flags = fp->mp_flags;
        if (node_size_len(node_ks(node), xdata.iov_len) >
            env->me_leaf_nodemax) {

          fp_flags &= ~0x40;
        prep_subDB:
          nested_dupdb.md_xsize = 0;
          nested_dupdb.md_flags = flags_db2sub(mc->mc_db->md_flags);
          if (mc->mc_db->md_flags & MDBX_DUPFIXED) {
            fp_flags |= 0x20;
            nested_dupdb.md_xsize = fp->mp_leaf2_ksize;
          }
          nested_dupdb.md_depth = 1;
          nested_dupdb.md_branch_pages = 0;
          nested_dupdb.md_leaf_pages = 1;
          nested_dupdb.md_overflow_pages = 0;
          nested_dupdb.md_entries = page_numkeys(fp);
          xdata.iov_len = sizeof(nested_dupdb);
          xdata.iov_base = &nested_dupdb;
          const struct page_result par = mdbx_page_alloc(mc, 1, (1 | 2 | 4));
          mp = par.page;
          if (__builtin_expect(!!(par.err != MDBX_SUCCESS), 0))
            return par.err;
          mc->mc_db->md_leaf_pages += 1;
          do { if ((0)) do { if (__builtin_expect(!!(!(env->me_psize > olddata.iov_len)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "env->me_psize > olddata.iov_len", __func__, 15687); } while (0); } while (0);
          offset = env->me_psize - (unsigned)olddata.iov_len;
          flags |= 0x04 | 0x02;
          nested_dupdb.md_root = mp->mp_pgno;
          nested_dupdb.md_seq = 0;
          nested_dupdb.md_mod_txnid = mc->mc_txn->mt_txnid;
          sub_root = mp;
        }
        if (mp != fp) {
          mp->mp_flags = fp_flags;
          mp->mp_txnid = mc->mc_txn->mt_front;
          mp->mp_leaf2_ksize = fp->mp_leaf2_ksize;
          mp->mp_lower = fp->mp_lower;
          do { if ((0)) do { if (__builtin_expect(!!(!(fp->mp_upper + offset <= 
# 15700 "/libmdbx/src/core.c" 3 4
         (65535)
# 15700 "/libmdbx/src/core.c"
         )), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "fp->mp_upper + offset <= (65535)", __func__, 15700); } while (0); } while (0);
          mp->mp_upper = (indx_t)(fp->mp_upper + offset);
          if (__builtin_expect(!!(fp_flags & 0x20), 0)) {
            memcpy(page_data(mp), page_data(fp),
                   page_numkeys(fp) * fp->mp_leaf2_ksize);
          } else {
            memcpy((char *)mp + mp->mp_upper + ((unsigned)
# 15706 "/libmdbx/src/core.c" 3 4
                                              __builtin_offsetof (
# 15706 "/libmdbx/src/core.c"
                                              MDBX_page
# 15706 "/libmdbx/src/core.c" 3 4
                                              , 
# 15706 "/libmdbx/src/core.c"
                                              mp_ptrs
# 15706 "/libmdbx/src/core.c" 3 4
                                              )
# 15706 "/libmdbx/src/core.c"
                                              ),
                   (char *)fp + fp->mp_upper + ((unsigned)
# 15707 "/libmdbx/src/core.c" 3 4
                                              __builtin_offsetof (
# 15707 "/libmdbx/src/core.c"
                                              MDBX_page
# 15707 "/libmdbx/src/core.c" 3 4
                                              , 
# 15707 "/libmdbx/src/core.c"
                                              mp_ptrs
# 15707 "/libmdbx/src/core.c" 3 4
                                              )
# 15707 "/libmdbx/src/core.c"
                                              ),
                   olddata.iov_len - fp->mp_upper - ((unsigned)
# 15708 "/libmdbx/src/core.c" 3 4
                                                   __builtin_offsetof (
# 15708 "/libmdbx/src/core.c"
                                                   MDBX_page
# 15708 "/libmdbx/src/core.c" 3 4
                                                   , 
# 15708 "/libmdbx/src/core.c"
                                                   mp_ptrs
# 15708 "/libmdbx/src/core.c" 3 4
                                                   )
# 15708 "/libmdbx/src/core.c"
                                                   ));
            memcpy((char *)(&mp->mp_ptrs), (char *)(&fp->mp_ptrs),
                   page_numkeys(fp) * sizeof(mp->mp_ptrs[0]));
            for (i = 0; i < page_numkeys(fp); i++) {
              do { if ((0)) do { if (__builtin_expect(!!(!(mp->mp_ptrs[i] + offset <= 
# 15712 "/libmdbx/src/core.c" 3 4
             (65535)
# 15712 "/libmdbx/src/core.c"
             )), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mp->mp_ptrs[i] + offset <= (65535)", __func__, 15712); } while (0); } while (0);
              mp->mp_ptrs[i] += (indx_t)offset;
            }
          }
        }

        rdata = &xdata;
        flags |= 0x04;
        do_sub = (1);
        if (!insert_key)
          mdbx_node_del(mc, 0);
        goto new_sub;
      }


      if (__builtin_expect(!!((node_flags(node) ^ flags) & 0x02), 0))
        return MDBX_INCOMPATIBLE;

    current:
      if (data->iov_len == olddata.iov_len) {
        do { if ((0)) do { if (__builtin_expect(!!(!((((key->iov_len) + 1U) & -2) == (((node_ks(node)) + 1U) & -2))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "(((key->iov_len) + 1U) & -2) == (((node_ks(node)) + 1U) & -2)", __func__, 15732); } while (0); } while (0);



        if ((((flags) & (MDBX_RESERVE)) == (MDBX_RESERVE)))
          data->iov_base = olddata.iov_base;
        else if (!(mc->mc_flags & 0x04))
          memcpy(olddata.iov_base, data->iov_base, data->iov_len);
        else {
          do { if ((0)) do { if (__builtin_expect(!!(!(page_numkeys(mc->mc_pg[mc->mc_top]) == 1)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "page_numkeys(mc->mc_pg[mc->mc_top]) == 1", __func__, 15741); } while (0); } while (0);
          do { if ((0)) do { if (__builtin_expect(!!(!(((mc->mc_pg[mc->mc_top])->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) == 0x02)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "((mc->mc_pg[mc->mc_top])->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) == 0x02", __func__, 15742); } while (0); } while (0);
          do { if ((0)) do { if (__builtin_expect(!!(!(node_ds(node) == 0)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "node_ds(node) == 0", __func__, 15743); } while (0); } while (0);
          do { if ((0)) do { if (__builtin_expect(!!(!(node_flags(node) == 0)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "node_flags(node) == 0", __func__, 15744); } while (0); } while (0);
          do { if ((0)) do { if (__builtin_expect(!!(!(key->iov_len < 
# 15745 "/libmdbx/src/core.c" 3 4
         (65535)
# 15745 "/libmdbx/src/core.c"
         )), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "key->iov_len < (65535)", __func__, 15745); } while (0); } while (0);
          node_set_ks(node, key->iov_len);
          memcpy(node_key(node), key->iov_base, key->iov_len);
          do { if ((0)) do { if (__builtin_expect(!!(!((char *)node_key(node) + node_ds(node) < (char *)(mc->mc_pg[mc->mc_top]) + env->me_psize)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "(char *)node_key(node) + node_ds(node) < (char *)(mc->mc_pg[mc->mc_top]) + env->me_psize", __func__, 15748); } while (0); } while (0)
                                                                               ;
          goto fix_parent;
        }

        if ((0)) {
          err = mdbx_cursor_check(mc, 0);
          if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
            return err;
        }
        return MDBX_SUCCESS;
      }
    }
    mdbx_node_del(mc, 0);
  }

  rdata = data;

new_sub:;
  unsigned nflags = flags & (0x04 | 0x02 | MDBX_RESERVE | MDBX_APPEND);
  size_t nsize = __builtin_expect(!!(((mc->mc_pg[mc->mc_top])->mp_flags & 0x20) != 0), 0) ? key->iov_len
                                                 : leaf_size(env, key, rdata);
  if (page_room(mc->mc_pg[mc->mc_top]) < nsize) {
    if (!insert_key)
      nflags |= MDBX_APPENDDUP;
    rc = mdbx_page_split(mc, key, rdata, (~(pgno_t)0), nflags);
    if (rc == MDBX_SUCCESS && (0))
      rc = mdbx_cursor_check(mc, 0);
  } else {

    if (__builtin_expect(!!(((mc->mc_pg[mc->mc_top])->mp_flags & 0x20) != 0), 0)) {
      do { if ((0)) do { if (__builtin_expect(!!(!((nflags & (0x01 | 0x02 | 0x04)) == 0 && rdata->iov_len == 0)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "(nflags & (0x01 | 0x02 | 0x04)) == 0 && rdata->iov_len == 0", __func__, 15779); } while (0); } while (0)
                                               ;
      rc = mdbx_node_add_leaf2(mc, mc->mc_ki[mc->mc_top], key);
    } else
      rc = mdbx_node_add_leaf(mc, mc->mc_ki[mc->mc_top], key, rdata, nflags);
    if (__builtin_expect(!!(rc == 0), 1)) {

      const MDBX_dbi dbi = mc->mc_dbi;
      const unsigned i = mc->mc_top;
      MDBX_page *const mp = mc->mc_pg[i];
      for (MDBX_cursor *m2 = mc->mc_txn->mt_cursors[dbi]; m2;
           m2 = m2->mc_next) {
        MDBX_cursor *m3 =
            (mc->mc_flags & 0x04) ? &m2->mc_xcursor->mx_cursor : m2;
        if (m3 == mc || m3->mc_snum < mc->mc_snum || m3->mc_pg[i] != mp)
          continue;
        if (m3->mc_ki[i] >= mc->mc_ki[i])
          m3->mc_ki[i] += insert_key;
        if (((m3)->mc_xcursor && ((m3)->mc_xcursor->mx_cursor.mc_flags & 0x01)))
          do { MDBX_page *xr_pg = (mp); MDBX_node *xr_node = page_node(xr_pg, m3->mc_ki[i]); if ((node_flags(xr_node) & (0x04 | 0x02)) == 0x04) (m3)->mc_xcursor->mx_cursor.mc_pg[0] = node_data(xr_node); } while (0);
      }
    }
  }

  if (__builtin_expect(!!(rc == MDBX_SUCCESS), 1)) {




    if (do_sub) {
      int xflags;
      size_t ecount;
    put_sub:
      xdata.iov_len = 0;
      xdata.iov_base = 
# 15813 "/libmdbx/src/core.c" 3 4
                      ((void *)0)
# 15813 "/libmdbx/src/core.c"
                             ;
      MDBX_node *node = page_node(mc->mc_pg[mc->mc_top], mc->mc_ki[mc->mc_top]);

      _Static_assert((MDBX_NODUPDATA >> 1) == MDBX_NOOVERWRITE, "(MDBX_NODUPDATA >> SHIFT_MDBX_NODUPDATA_TO_MDBX_NOOVERWRITE) == MDBX_NOOVERWRITE")

                           ;
      xflags = MDBX_CURRENT | 0x8000 |
               ((flags & MDBX_NODUPDATA) >>
                1);
      if ((flags & MDBX_CURRENT) == 0) {
        xflags -= MDBX_CURRENT;
        err = mdbx_xcursor_init1(mc, node, mc->mc_pg[mc->mc_top]);
        if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
          return err;
      }
      if (sub_root)
        mc->mc_xcursor->mx_cursor.mc_pg[0] = sub_root;

      if (dupdata_flag) {
        rc = mdbx_cursor_put(&mc->mc_xcursor->mx_cursor, &dkey, &xdata, xflags);
        if (__builtin_expect(!!(rc), 0))
          goto bad_sub;

        dkey.iov_len = 0;
      }
      if (!(node_flags(node) & 0x02) || sub_root) {

        MDBX_cursor *m2;
        MDBX_xcursor *mx = mc->mc_xcursor;
        unsigned i = mc->mc_top;
        MDBX_page *mp = mc->mc_pg[i];
        const int nkeys = page_numkeys(mp);

        for (m2 = mc->mc_txn->mt_cursors[mc->mc_dbi]; m2; m2 = m2->mc_next) {
          if (m2 == mc || m2->mc_snum < mc->mc_snum)
            continue;
          if (!(m2->mc_flags & 0x01))
            continue;
          if (m2->mc_pg[i] == mp) {
            if (m2->mc_ki[i] == mc->mc_ki[i]) {
              err = mdbx_xcursor_init2(m2, mx, dupdata_flag);
              if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
                return err;
            } else if (!insert_key && m2->mc_ki[i] < nkeys) {
              do { MDBX_page *xr_pg = (mp); MDBX_node *xr_node = page_node(xr_pg, m2->mc_ki[i]); if ((node_flags(xr_node) & (0x04 | 0x02)) == 0x04) (m2)->mc_xcursor->mx_cursor.mc_pg[0] = node_data(xr_node); } while (0);
            }
          }
        }
      }
      do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_xcursor->mx_db.md_entries < 
# 15862 "/libmdbx/src/core.c" 3 4
     (9223372036854775807L)
# 15862 "/libmdbx/src/core.c"
     )), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mc->mc_xcursor->mx_db.md_entries < (9223372036854775807L)", __func__, 15862); } while (0); } while (0);
      ecount = (size_t)mc->mc_xcursor->mx_db.md_entries;

      _Static_assert((MDBX_APPENDDUP >> 1) == MDBX_APPEND, "(MDBX_APPENDDUP >> SHIFT_MDBX_APPENDDUP_TO_MDBX_APPEND) == MDBX_APPEND")
                                ;
      xflags |= (flags & MDBX_APPENDDUP) >> 1;
      rc = mdbx_cursor_put(&mc->mc_xcursor->mx_cursor, data, &xdata, xflags);
      if (flags & 0x02) {
        void *db = node_data(node);
        mc->mc_xcursor->mx_db.md_mod_txnid = mc->mc_txn->mt_txnid;
        memcpy(db, &mc->mc_xcursor->mx_db, sizeof(MDBX_db));
      }
      insert_data = (ecount != (size_t)mc->mc_xcursor->mx_db.md_entries);
    }

    if (insert_data)
      mc->mc_db->md_entries++;
    if (insert_key) {

      if (__builtin_expect(!!(rc), 0))
        goto bad_sub;


      mc->mc_flags |= 0x01;
    }
    if (__builtin_expect(!!(flags & MDBX_MULTIPLE), 0)) {
      if (__builtin_expect(!!(rc == MDBX_SUCCESS), 1)) {
      continue_multiple:
        mcount++;

        data[1].iov_len = mcount;
        if (mcount < dcount) {
          data[0].iov_base = (char *)data[0].iov_base + data[0].iov_len;
          insert_key = insert_data = (0);
          goto more;
        }
      }
    }
    if (rc == MDBX_SUCCESS && (0))
      rc = mdbx_cursor_check(mc, 0);
    return rc;
  bad_sub:
    if (__builtin_expect(!!(rc == MDBX_KEYEXIST), 0)) {

      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 15906, "Unexpected %i error while put to nested dupsort's hive" "\n", rc); } while (0);
      rc = MDBX_PROBLEM;
    }
  }
  mc->mc_txn->mt_flags |= 0x02;
  return rc;
}

int mdbx_cursor_del(MDBX_cursor *mc, MDBX_put_flags_t flags) {
  if (__builtin_expect(!!(!mc), 0))
    return MDBX_EINVAL;

  if (__builtin_expect(!!(mc->mc_signature != 0xFE05D5B1U), 0))
    return (mc->mc_signature == 0x2817A047U) ? MDBX_EINVAL
                                                     : MDBX_EBADSIGN;

  int rc = check_txn_rw(mc->mc_txn, (0x01 | 0x02 | 0x10));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(((mc->mc_txn)->mt_dbiseqs[mc->mc_dbi] != (mc->mc_txn)->mt_env->me_dbiseqs[mc->mc_dbi])), 0))
    return MDBX_BAD_DBI;

  if (__builtin_expect(!!(!(mc->mc_flags & 0x01)), 0))
    return MDBX_ENODATA;

  if (__builtin_expect(!!(mc->mc_ki[mc->mc_top] >= page_numkeys(mc->mc_pg[mc->mc_top])), 0))
    return MDBX_NOTFOUND;

  if (__builtin_expect(!!((flags & 0x8000) == 0), 1) &&
      __builtin_expect(!!(rc = mdbx_cursor_spill(mc, 
# 15936 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 15936 "/libmdbx/src/core.c"
     , 
# 15936 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 15936 "/libmdbx/src/core.c"
     )), 0))
    return rc;

  rc = mdbx_cursor_touch(mc);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  MDBX_page *mp = mc->mc_pg[mc->mc_top];
  if (!0 && __builtin_expect(!!(!(((mp)->mp_flags & 0x02) != 0)), 0))
    return MDBX_CORRUPTED;
  if (__builtin_expect(!!(((mp)->mp_flags & 0x20) != 0), 0)) {
    if (!0 && __builtin_expect(!!((mc->mc_flags & 0x04) == 0), 0)) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 15948, "unexpected LEAF2-page %" 
# 15948 "/libmdbx/src/core.c" 3 4
     "u" 
# 15948 "/libmdbx/src/core.c"
     "for non-dupsort cursor" "\n", mp->mp_pgno); } while (0)
                             ;
      return MDBX_CORRUPTED;
    }
    goto del_key;
  }

  MDBX_node *node = page_node(mp, mc->mc_ki[mc->mc_top]);
  if ((((node_flags(node)) & (0x04)) == (0x04))) {
    if (flags & (MDBX_ALLDUPS | MDBX_NODUPDATA)) {

      mc->mc_db->md_entries -= mc->mc_xcursor->mx_db.md_entries - 1;
      mc->mc_xcursor->mx_cursor.mc_flags &= ~0x01;
    } else {
      if (!(((node_flags(node)) & (0x02)) == (0x02)))
        mc->mc_xcursor->mx_cursor.mc_pg[0] = node_data(node);
      rc = mdbx_cursor_del(&mc->mc_xcursor->mx_cursor, 0x8000);
      if (__builtin_expect(!!(rc), 0))
        return rc;

      if (mc->mc_xcursor->mx_db.md_entries) {
        if (node_flags(node) & 0x02) {

          void *db = node_data(node);
          mc->mc_xcursor->mx_db.md_mod_txnid = mc->mc_txn->mt_txnid;
          memcpy(db, &mc->mc_xcursor->mx_db, sizeof(MDBX_db));
        } else {
          MDBX_cursor *m2;

          mdbx_node_shrink(mp, mc->mc_ki[mc->mc_top]);
          node = page_node(mp, mc->mc_ki[mc->mc_top]);
          mc->mc_xcursor->mx_cursor.mc_pg[0] = node_data(node);

          for (m2 = mc->mc_txn->mt_cursors[mc->mc_dbi]; m2; m2 = m2->mc_next) {
            if (m2 == mc || m2->mc_snum < mc->mc_snum)
              continue;
            if (!(m2->mc_flags & 0x01))
              continue;
            if (m2->mc_pg[mc->mc_top] == mp) {
              MDBX_node *inner = node;
              if (m2->mc_ki[mc->mc_top] >= page_numkeys(mp))
                continue;
              if (m2->mc_ki[mc->mc_top] != mc->mc_ki[mc->mc_top]) {
                inner = page_node(mp, m2->mc_ki[mc->mc_top]);
                if (node_flags(inner) & 0x02)
                  continue;
              }
              m2->mc_xcursor->mx_cursor.mc_pg[0] = node_data(inner);
            }
          }
        }
        mc->mc_db->md_entries--;
        do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_db->md_entries > 0 && mc->mc_db->md_depth > 0 && mc->mc_db->md_root != (~(pgno_t)0))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mc->mc_db->md_entries > 0 && mc->mc_db->md_depth > 0 && mc->mc_db->md_root != (~(pgno_t)0)", __func__, 16000); } while (0); } while (0)
                                                             ;
        return rc;
      } else {
        mc->mc_xcursor->mx_cursor.mc_flags &= ~0x01;
      }

    }

    if (node_flags(node) & 0x02) {

      rc = mdbx_drop_tree(&mc->mc_xcursor->mx_cursor, (0));
      if (__builtin_expect(!!(rc), 0))
        goto fail;
    }
  }

  else if (__builtin_expect(!!((node_flags(node) ^ flags) & 0x02), 0))
    return MDBX_INCOMPATIBLE;


  if ((((node_flags(node)) & (0x01)) == (0x01))) {
    MDBX_page *omp;
    if (__builtin_expect(!!((rc = mdbx_page_get(mc, node_largedata_pgno(node), &omp, pp_txnid4chk(mp, mc->mc_txn))) || (rc = mdbx_page_retire(mc, omp))), 0)

                                                  )
      goto fail;
  }

del_key:
  return mdbx_cursor_del0(mc);

fail:
  mc->mc_txn->mt_flags |= 0x02;
  return rc;
}
# 16047 "/libmdbx/src/core.c"
static struct page_result mdbx_page_new(MDBX_cursor *mc, const unsigned flags,
                                        const unsigned npages) {
  struct page_result ret = mdbx_page_alloc(mc, npages, (1 | 2 | 4));
  if (__builtin_expect(!!(ret.err != MDBX_SUCCESS), 0))
    return ret;

  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 16053, "db %u allocated new page %" 
# 16053 "/libmdbx/src/core.c" 3 4
 "u" 
# 16053 "/libmdbx/src/core.c"
 ", num %u" "\n", mc->mc_dbi, ret.page->mp_pgno, npages); } while (0)
                                       ;
  ret.page->mp_flags = (uint16_t)flags;
  ret.page->mp_txnid = mc->mc_txn->mt_front;
  do { if ((0)) do { if (__builtin_expect(!!(!(*mc->mc_dbistate & MDBX_DBI_DIRTY)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "*mc->mc_dbistate & MDBX_DBI_DIRTY", __func__, 16057); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_txn->mt_flags & 0x04)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mc->mc_txn->mt_flags & 0x04", __func__, 16058); } while (0); } while (0);

  mc->mc_txn->mt_env->me_lck->mti_pgop_stat.newly.weak += npages;


  if (__builtin_expect(!!((flags & 0x04) == 0), 1)) {
    _Static_assert(0x01 == 1, "P_BRANCH == 1");
    const _Bool is_branch = flags & 0x01;
    ret.page->mp_lower = 0;
    ret.page->mp_upper = (indx_t)(mc->mc_txn->mt_env->me_psize - ((unsigned)
# 16067 "/libmdbx/src/core.c" 3 4
                                                                __builtin_offsetof (
# 16067 "/libmdbx/src/core.c"
                                                                MDBX_page
# 16067 "/libmdbx/src/core.c" 3 4
                                                                , 
# 16067 "/libmdbx/src/core.c"
                                                                mp_ptrs
# 16067 "/libmdbx/src/core.c" 3 4
                                                                )
# 16067 "/libmdbx/src/core.c"
                                                                ));
    mc->mc_db->md_branch_pages += is_branch;
    mc->mc_db->md_leaf_pages += 1 - is_branch;
    if (__builtin_expect(!!(mc->mc_flags & 0x04), 0)) {
      MDBX_db *outer = mdbx_outer_db(mc);
      outer->md_branch_pages += is_branch;
      outer->md_leaf_pages += 1 - is_branch;
    }
  } else {
    mc->mc_db->md_overflow_pages += npages;
    ret.page->mp_pages = npages;
    do { if ((0)) do { if (__builtin_expect(!!(!(!(mc->mc_flags & 0x04))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "!(mc->mc_flags & 0x04)", __func__, 16078); } while (0); } while (0);
  }

  return ret;
}

static int __attribute__((__warn_unused_result__)) mdbx_node_add_leaf2(MDBX_cursor *mc,
                                                   unsigned indx,
                                                   const MDBX_val *key) {
  MDBX_page *mp = mc->mc_pg[mc->mc_top];
  ((void)(0));
  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 16089, "add to leaf2-%spage %" 
# 16089 "/libmdbx/src/core.c" 3 4
 "u" 
# 16089 "/libmdbx/src/core.c"
 " index %i, " " key size %" 
# 16089 "/libmdbx/src/core.c" 3 4
 "l" "u" 
# 16089 "/libmdbx/src/core.c"
 " [%s]" "\n", (((mp)->mp_flags & 0x40) != 0) ? "sub-" : "", mp->mp_pgno, indx, key ? key->iov_len : 0, ("-")); } while (0)


                                                     ;

  do { if ((0)) do { if (__builtin_expect(!!(!(key)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "key", __func__, 16094); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(((mp)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) == (0x02 | 0x20))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "((mp)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) == (0x02 | 0x20)", __func__, 16095); } while (0); } while (0);
  const unsigned ksize = mc->mc_db->md_xsize;
  do { if ((0)) do { if (__builtin_expect(!!(!(ksize == key->iov_len)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "ksize == key->iov_len", __func__, 16097); } while (0); } while (0);
  const unsigned nkeys = page_numkeys(mp);


  const intptr_t lower = mp->mp_lower + sizeof(indx_t);
  const intptr_t upper = mp->mp_upper - (ksize - sizeof(indx_t));
  if (__builtin_expect(!!(lower > upper), 0)) {
    mc->mc_txn->mt_flags |= 0x02;
    return MDBX_PAGE_FULL;
  }
  mp->mp_lower = (indx_t)lower;
  mp->mp_upper = (indx_t)upper;

  char *const ptr = page_leaf2key(mp, indx, ksize);
  do { if ((0)) do { if (__builtin_expect(!!(!(nkeys >= indx)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "nkeys >= indx", __func__, 16111); } while (0); } while (0);
  const unsigned diff = nkeys - indx;
  if (__builtin_expect(!!(diff > 0), 1))

    memmove(ptr + ksize, ptr, diff * ksize);

  memcpy(ptr, key->iov_base, ksize);
  return MDBX_SUCCESS;
}

static int __attribute__((__warn_unused_result__)) mdbx_node_add_branch(MDBX_cursor *mc,
                                                    unsigned indx,
                                                    const MDBX_val *key,
                                                    pgno_t pgno) {
  MDBX_page *mp = mc->mc_pg[mc->mc_top];
  ((void)(0));
  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 16127, "add to branch-%spage %" 
# 16127 "/libmdbx/src/core.c" 3 4
 "u" 
# 16127 "/libmdbx/src/core.c"
 " index %i, node-pgno %" 
# 16127 "/libmdbx/src/core.c" 3 4
 "u" 
# 16127 "/libmdbx/src/core.c"
 " key size %" 
# 16127 "/libmdbx/src/core.c" 3 4
 "l" "u" 
# 16127 "/libmdbx/src/core.c"
 " [%s]" "\n", (((mp)->mp_flags & 0x40) != 0) ? "sub-" : "", mp->mp_pgno, indx, pgno, key ? key->iov_len : 0, ("-")); } while (0)


                                                     ;

  do { if ((0)) do { if (__builtin_expect(!!(!(((mp)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) == 0x01)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "((mp)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) == 0x01", __func__, 16132); } while (0); } while (0);
  _Static_assert(
# 16133 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 16133 "/libmdbx/src/core.c"
 MDBX_node
# 16133 "/libmdbx/src/core.c" 3 4
 , 
# 16133 "/libmdbx/src/core.c"
 mn_data
# 16133 "/libmdbx/src/core.c" 3 4
 ) 
# 16133 "/libmdbx/src/core.c"
 % 2 == 0, "NODESIZE % 2 == 0");


  const unsigned nkeys = page_numkeys(mp);
  do { if ((0)) do { if (__builtin_expect(!!(!(nkeys >= indx)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "nkeys >= indx", __func__, 16137); } while (0); } while (0);
  for (unsigned i = nkeys; i > indx; --i)
    mp->mp_ptrs[i] = mp->mp_ptrs[i - 1];


  const size_t branch_bytes = branch_size(mc->mc_txn->mt_env, key);
  const intptr_t lower = mp->mp_lower + sizeof(indx_t);
  const intptr_t upper = mp->mp_upper - (branch_bytes - sizeof(indx_t));
  if (__builtin_expect(!!(lower > upper), 0)) {
    mc->mc_txn->mt_flags |= 0x02;
    return MDBX_PAGE_FULL;
  }
  mp->mp_lower = (indx_t)lower;
  mp->mp_ptrs[indx] = mp->mp_upper = (indx_t)upper;


  MDBX_node *node = page_node(mp, indx);
  node_set_pgno(node, pgno);
  node_set_flags(node, 0);
  poke_u8((uint8_t *)(node) + 
# 16156 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 16156 "/libmdbx/src/core.c"
 MDBX_node
# 16156 "/libmdbx/src/core.c" 3 4
 , 
# 16156 "/libmdbx/src/core.c"
 mn_extra
# 16156 "/libmdbx/src/core.c" 3 4
 )
# 16156 "/libmdbx/src/core.c"
 , 0);
  node_set_ks(node, 0);
  if (__builtin_expect(!!(key != 
# 16158 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 16158 "/libmdbx/src/core.c"
     ), 1)) {
    node_set_ks(node, key->iov_len);
    memcpy(node_key(node), key->iov_base, key->iov_len);
  }
  return MDBX_SUCCESS;
}

static int __attribute__((__warn_unused_result__)) mdbx_node_add_leaf(MDBX_cursor *mc,
                                                  unsigned indx,
                                                  const MDBX_val *key,
                                                  MDBX_val *data,
                                                  unsigned flags) {
  MDBX_page *mp = mc->mc_pg[mc->mc_top];
  ((void)(0));
  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 16172, "add to leaf-%spage %" 
# 16172 "/libmdbx/src/core.c" 3 4
 "u" 
# 16172 "/libmdbx/src/core.c"
 " index %i, data size %" 
# 16172 "/libmdbx/src/core.c" 3 4
 "l" "u" 
# 16172 "/libmdbx/src/core.c"
 " key size %" 
# 16172 "/libmdbx/src/core.c" 3 4
 "l" "u" 
# 16172 "/libmdbx/src/core.c"
 " [%s]" "\n", (((mp)->mp_flags & 0x40) != 0) ? "sub-" : "", mp->mp_pgno, indx, data ? data->iov_len : 0, key ? key->iov_len : 0, ("-")); } while (0)


                                                                               ;
  do { if ((0)) do { if (__builtin_expect(!!(!(key != 
# 16176 "/libmdbx/src/core.c" 3 4
 ((void *)0) 
# 16176 "/libmdbx/src/core.c"
 && data != 
# 16176 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 16176 "/libmdbx/src/core.c"
 )), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "key != ((void *)0) && data != ((void *)0)", __func__, 16176); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(((mp)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) == 0x02)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "((mp)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) == 0x02", __func__, 16177); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(page_room(mp) >= leaf_size(mc->mc_txn->mt_env, key, data))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "page_room(mp) >= leaf_size(mc->mc_txn->mt_env, key, data)", __func__, 16178); } while (0); } while (0);
  MDBX_page *largepage = 
# 16179 "/libmdbx/src/core.c" 3 4
                        ((void *)0)
# 16179 "/libmdbx/src/core.c"
                            ;

  size_t node_bytes;
  if (__builtin_expect(!!(flags & 0x01), 0)) {

    _Static_assert(sizeof(pgno_t) % 2 == 0, "sizeof(pgno_t) % 2 == 0");
    node_bytes =
        node_size_len(key->iov_len, 0) + sizeof(pgno_t) + sizeof(indx_t);
  } else if (__builtin_expect(!!(node_size(key, data) > mc->mc_txn->mt_env->me_leaf_nodemax), 0)
                                                          ) {

    if (__builtin_expect(!!(mc->mc_db->md_flags & MDBX_DUPSORT), 0)) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 16191, "Unexpected target %s flags 0x%x for large data-item" "\n", "dupsort-db", mc->mc_db->md_flags); } while (0)
                                                   ;
      return MDBX_PROBLEM;
    }
    if (__builtin_expect(!!(flags & (0x04 | 0x02)), 0)) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 16196, "Unexpected target %s flags 0x%x for large data-item" "\n", "node", flags); } while (0)
                       ;
      return MDBX_PROBLEM;
    }
    const pgno_t ovpages = number_of_ovpages(mc->mc_txn->mt_env, data->iov_len);
    const struct page_result npr = mdbx_page_new(mc, 0x04, ovpages);
    if (__builtin_expect(!!(npr.err != MDBX_SUCCESS), 0))
      return npr.err;
    largepage = npr.page;
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 16205, "allocated %u overflow page(s) %" 
# 16205 "/libmdbx/src/core.c" 3 4
   "u" 
# 16205 "/libmdbx/src/core.c"
   "for %" 
# 16205 "/libmdbx/src/core.c" 3 4
   "l" "u" 
# 16205 "/libmdbx/src/core.c"
   " data bytes" "\n", largepage->mp_pages, largepage->mp_pgno, data->iov_len); } while (0)

                                                                      ;
    flags |= 0x01;
    node_bytes =
        node_size_len(key->iov_len, 0) + sizeof(pgno_t) + sizeof(indx_t);
  } else {
    node_bytes = node_size(key, data) + sizeof(indx_t);
  }
  do { if ((0)) do { if (__builtin_expect(!!(!(node_bytes == leaf_size(mc->mc_txn->mt_env, key, data))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "node_bytes == leaf_size(mc->mc_txn->mt_env, key, data)", __func__, 16214); } while (0); } while (0);


  const unsigned nkeys = page_numkeys(mp);
  do { if ((0)) do { if (__builtin_expect(!!(!(nkeys >= indx)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "nkeys >= indx", __func__, 16218); } while (0); } while (0);
  for (unsigned i = nkeys; i > indx; --i)
    mp->mp_ptrs[i] = mp->mp_ptrs[i - 1];


  const intptr_t lower = mp->mp_lower + sizeof(indx_t);
  const intptr_t upper = mp->mp_upper - (node_bytes - sizeof(indx_t));
  if (__builtin_expect(!!(lower > upper), 0)) {
    mc->mc_txn->mt_flags |= 0x02;
    return MDBX_PAGE_FULL;
  }
  mp->mp_lower = (indx_t)lower;
  mp->mp_ptrs[indx] = mp->mp_upper = (indx_t)upper;


  MDBX_node *node = page_node(mp, indx);
  node_set_ks(node, key->iov_len);
  node_set_flags(node, (uint8_t)flags);
  poke_u8((uint8_t *)(node) + 
# 16236 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 16236 "/libmdbx/src/core.c"
 MDBX_node
# 16236 "/libmdbx/src/core.c" 3 4
 , 
# 16236 "/libmdbx/src/core.c"
 mn_extra
# 16236 "/libmdbx/src/core.c" 3 4
 )
# 16236 "/libmdbx/src/core.c"
 , 0);
  node_set_ds(node, data->iov_len);
  memcpy(node_key(node), key->iov_base, key->iov_len);

  void *nodedata = node_data(node);
  if (__builtin_expect(!!(largepage == 
# 16241 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 16241 "/libmdbx/src/core.c"
     ), 1)) {
    if (__builtin_expect(!!(flags & 0x01), 0))
      memcpy(nodedata, data->iov_base, sizeof(pgno_t));
    else if (__builtin_expect(!!(flags & MDBX_RESERVE), 0))
      data->iov_base = nodedata;
    else if (__builtin_expect(!!(nodedata != data->iov_base && data->iov_len != 0), 1)
                                                                 )
      memcpy(nodedata, data->iov_base, data->iov_len);
  } else {
    poke_pgno(nodedata, largepage->mp_pgno);
    nodedata = page_data(largepage);
    if (__builtin_expect(!!(flags & MDBX_RESERVE), 0))
      data->iov_base = nodedata;
    else if (__builtin_expect(!!(nodedata != data->iov_base && data->iov_len != 0), 1)
                                                                 )
      memcpy(nodedata, data->iov_base, data->iov_len);
  }
  return MDBX_SUCCESS;
}





static void mdbx_node_del(MDBX_cursor *mc, size_t ksize) {
  MDBX_page *mp = mc->mc_pg[mc->mc_top];
  int indx = mc->mc_ki[mc->mc_top];
  int i, j, nkeys, ptr;
  MDBX_node *node;
  char *base;

  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 16272, "delete node %u on %s page %" 
# 16272 "/libmdbx/src/core.c" 3 4
 "u" 
# 16272 "/libmdbx/src/core.c"
 "\n", indx, (((mp)->mp_flags & 0x02) != 0) ? "leaf" : "branch", mp->mp_pgno); } while (0)
                                                          ;
  nkeys = page_numkeys(mp);
  do { if ((0)) do { if (__builtin_expect(!!(!(indx < nkeys)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "indx < nkeys", __func__, 16275); } while (0); } while (0);

  if (__builtin_expect(!!(((mp)->mp_flags & 0x20) != 0), 0)) {
    do { if ((0)) do { if (__builtin_expect(!!(!(ksize >= sizeof(indx_t))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "ksize >= sizeof(indx_t)", __func__, 16278); } while (0); } while (0);
    unsigned diff = nkeys - 1 - indx;
    base = page_leaf2key(mp, indx, ksize);
    if (diff)
      memmove(base, base + ksize, diff * ksize);
    do { if ((0)) do { if (__builtin_expect(!!(!(mp->mp_lower >= sizeof(indx_t))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mp->mp_lower >= sizeof(indx_t)", __func__, 16283); } while (0); } while (0);
    mp->mp_lower -= sizeof(indx_t);
    do { if ((0)) do { if (__builtin_expect(!!(!((size_t)
# 16285 "/libmdbx/src/core.c" 3 4
   (65535) 
# 16285 "/libmdbx/src/core.c"
   - mp->mp_upper >= ksize - sizeof(indx_t))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "(size_t)(65535) - mp->mp_upper >= ksize - sizeof(indx_t)", __func__, 16285); } while (0); } while (0)
                                                                             ;
    mp->mp_upper += (indx_t)(ksize - sizeof(indx_t));
    return;
  }

  node = page_node(mp, indx);
  do { if ((0)) do { if (__builtin_expect(!!(!(!(((mp)->mp_flags & 0x01) != 0) || indx || node_ks(node) == 0)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "!(((mp)->mp_flags & 0x01) != 0) || indx || node_ks(node) == 0", __func__, 16292); } while (0); } while (0);
  size_t sz = 
# 16293 "/libmdbx/src/core.c" 3 4
             __builtin_offsetof (
# 16293 "/libmdbx/src/core.c"
             MDBX_node
# 16293 "/libmdbx/src/core.c" 3 4
             , 
# 16293 "/libmdbx/src/core.c"
             mn_data
# 16293 "/libmdbx/src/core.c" 3 4
             ) 
# 16293 "/libmdbx/src/core.c"
                      + node_ks(node);
  if ((((mp)->mp_flags & 0x02) != 0)) {
    if ((((node_flags(node)) & (0x01)) == (0x01)))
      sz += sizeof(pgno_t);
    else
      sz += node_ds(node);
  }
  sz = (((sz) + 1U) & -2);

  ptr = mp->mp_ptrs[indx];
  for (i = j = 0; i < nkeys; i++) {
    if (i != indx) {
      mp->mp_ptrs[j] = mp->mp_ptrs[i];
      if (mp->mp_ptrs[i] < ptr) {
        do { if ((0)) do { if (__builtin_expect(!!(!((size_t)
# 16307 "/libmdbx/src/core.c" 3 4
       (65535) 
# 16307 "/libmdbx/src/core.c"
       - mp->mp_ptrs[j] >= sz)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "(size_t)(65535) - mp->mp_ptrs[j] >= sz", __func__, 16307); } while (0); } while (0);
        mp->mp_ptrs[j] += (indx_t)sz;
      }
      j++;
    }
  }

  base = (char *)mp + mp->mp_upper + ((unsigned)
# 16314 "/libmdbx/src/core.c" 3 4
                                    __builtin_offsetof (
# 16314 "/libmdbx/src/core.c"
                                    MDBX_page
# 16314 "/libmdbx/src/core.c" 3 4
                                    , 
# 16314 "/libmdbx/src/core.c"
                                    mp_ptrs
# 16314 "/libmdbx/src/core.c" 3 4
                                    )
# 16314 "/libmdbx/src/core.c"
                                    );
  memmove(base + sz, base, ptr - mp->mp_upper);

  do { if ((0)) do { if (__builtin_expect(!!(!(mp->mp_lower >= sizeof(indx_t))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mp->mp_lower >= sizeof(indx_t)", __func__, 16317); } while (0); } while (0);
  mp->mp_lower -= sizeof(indx_t);
  do { if ((0)) do { if (__builtin_expect(!!(!((size_t)
# 16319 "/libmdbx/src/core.c" 3 4
 (65535) 
# 16319 "/libmdbx/src/core.c"
 - mp->mp_upper >= sz)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "(size_t)(65535) - mp->mp_upper >= sz", __func__, 16319); } while (0); } while (0);
  mp->mp_upper += (indx_t)sz;







}




static void mdbx_node_shrink(MDBX_page *mp, unsigned indx) {
  MDBX_node *node;
  MDBX_page *sp, *xp;
  char *base;
  size_t nsize, delta, len, ptr;
  int i;

  node = page_node(mp, indx);
  sp = (MDBX_page *)node_data(node);
  delta = page_room(sp);
  do { if ((0)) do { if (__builtin_expect(!!(!(delta > 0)), 0)) mdbx_assert_fail(
# 16343 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 16343 "/libmdbx/src/core.c"
 , "delta > 0", __func__, 16343); } while (0); } while (0);


  if (__builtin_expect(!!(((sp)->mp_flags & 0x20) != 0), 0)) {
    delta &= ~(size_t)1;
    if (__builtin_expect(!!(delta), 0) == 0)
      return;
    nsize = node_ds(node) - delta;
    do { if ((0)) do { if (__builtin_expect(!!(!(nsize % 1 == 0)), 0)) mdbx_assert_fail(
# 16351 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 16351 "/libmdbx/src/core.c"
   , "nsize % 1 == 0", __func__, 16351); } while (0); } while (0);
    len = nsize;
  } else {
    xp = (MDBX_page *)((char *)sp + delta);
    for (i = page_numkeys(sp); --i >= 0;) {
      do { if ((0)) do { if (__builtin_expect(!!(!(sp->mp_ptrs[i] >= delta)), 0)) mdbx_assert_fail(
# 16356 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 16356 "/libmdbx/src/core.c"
     , "sp->mp_ptrs[i] >= delta", __func__, 16356); } while (0); } while (0);
      xp->mp_ptrs[i] = (indx_t)(sp->mp_ptrs[i] - delta);
    }
    nsize = node_ds(node) - delta;
    len = ((unsigned)
# 16360 "/libmdbx/src/core.c" 3 4
         __builtin_offsetof (
# 16360 "/libmdbx/src/core.c"
         MDBX_page
# 16360 "/libmdbx/src/core.c" 3 4
         , 
# 16360 "/libmdbx/src/core.c"
         mp_ptrs
# 16360 "/libmdbx/src/core.c" 3 4
         )
# 16360 "/libmdbx/src/core.c"
         );
  }
  sp->mp_upper = sp->mp_lower;
  sp->mp_pgno = mp->mp_pgno;
  node_set_ds(node, nsize);


  base = (char *)mp + mp->mp_upper + ((unsigned)
# 16367 "/libmdbx/src/core.c" 3 4
                                    __builtin_offsetof (
# 16367 "/libmdbx/src/core.c"
                                    MDBX_page
# 16367 "/libmdbx/src/core.c" 3 4
                                    , 
# 16367 "/libmdbx/src/core.c"
                                    mp_ptrs
# 16367 "/libmdbx/src/core.c" 3 4
                                    )
# 16367 "/libmdbx/src/core.c"
                                    );
  memmove(base + delta, base, (char *)sp + len - base);

  ptr = mp->mp_ptrs[indx];
  for (i = page_numkeys(mp); --i >= 0;) {
    if (mp->mp_ptrs[i] <= ptr) {
      do { if ((0)) do { if (__builtin_expect(!!(!((size_t)
# 16373 "/libmdbx/src/core.c" 3 4
     (65535) 
# 16373 "/libmdbx/src/core.c"
     - mp->mp_ptrs[i] >= delta)), 0)) mdbx_assert_fail(
# 16373 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 16373 "/libmdbx/src/core.c"
     , "(size_t)(65535) - mp->mp_ptrs[i] >= delta", __func__, 16373); } while (0); } while (0);
      mp->mp_ptrs[i] += (indx_t)delta;
    }
  }
  do { if ((0)) do { if (__builtin_expect(!!(!((size_t)
# 16377 "/libmdbx/src/core.c" 3 4
 (65535) 
# 16377 "/libmdbx/src/core.c"
 - mp->mp_upper >= delta)), 0)) mdbx_assert_fail(
# 16377 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 16377 "/libmdbx/src/core.c"
 , "(size_t)(65535) - mp->mp_upper >= delta", __func__, 16377); } while (0); } while (0);
  mp->mp_upper += (indx_t)delta;
}
# 16391 "/libmdbx/src/core.c"
static int mdbx_xcursor_init0(MDBX_cursor *mc) {
  MDBX_xcursor *mx = mc->mc_xcursor;
  if (!0 && __builtin_expect(!!(mx == 
# 16393 "/libmdbx/src/core.c" 3 4
                                 ((void *)0)
# 16393 "/libmdbx/src/core.c"
                                 ), 0)) {
    do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 16394, "unexpected dupsort-page for non-dupsort db/cursor (dbi %u)" "\n", mc->mc_dbi); } while (0)
                          ;
    return MDBX_CORRUPTED;
  }

  mx->mx_cursor.mc_xcursor = 
# 16399 "/libmdbx/src/core.c" 3 4
                            ((void *)0)
# 16399 "/libmdbx/src/core.c"
                                ;
  mx->mx_cursor.mc_next = 
# 16400 "/libmdbx/src/core.c" 3 4
                         ((void *)0)
# 16400 "/libmdbx/src/core.c"
                             ;
  mx->mx_cursor.mc_txn = mc->mc_txn;
  mx->mx_cursor.mc_db = &mx->mx_db;
  mx->mx_cursor.mc_dbx = &mx->mx_dbx;
  mx->mx_cursor.mc_dbi = mc->mc_dbi;
  mx->mx_cursor.mc_dbistate = mc->mc_dbistate;
  mx->mx_cursor.mc_snum = 0;
  mx->mx_cursor.mc_top = 0;
  mx->mx_cursor.mc_flags = 0x04 | (mc->mc_flags & (0x100 | 0x800));
  mx->mx_dbx.md_name.iov_len = 0;
  mx->mx_dbx.md_name.iov_base = 
# 16410 "/libmdbx/src/core.c" 3 4
                               ((void *)0)
# 16410 "/libmdbx/src/core.c"
                                   ;
  mx->mx_dbx.md_cmp = mc->mc_dbx->md_dcmp;
  mx->mx_dbx.md_dcmp = 
# 16412 "/libmdbx/src/core.c" 3 4
                      ((void *)0)
# 16412 "/libmdbx/src/core.c"
                          ;
  mx->mx_dbx.md_klen_min = 0x7fffffff;
  mx->mx_dbx.md_vlen_min = mx->mx_dbx.md_klen_max = mx->mx_dbx.md_vlen_max = 0;
  return MDBX_SUCCESS;
}






static int mdbx_xcursor_init1(MDBX_cursor *mc, MDBX_node *node,
                              const MDBX_page *mp) {
  MDBX_xcursor *mx = mc->mc_xcursor;
  if (!0 && __builtin_expect(!!(mx == 
# 16426 "/libmdbx/src/core.c" 3 4
                                 ((void *)0)
# 16426 "/libmdbx/src/core.c"
                                 ), 0)) {
    do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 16427, "unexpected dupsort-page for non-dupsort db/cursor (dbi %u)" "\n", mc->mc_dbi); } while (0)
                          ;
    return MDBX_CORRUPTED;
  }

  const uint8_t flags = node_flags(node);
  switch (flags) {
  default:
    do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 16435, "invalid node flags %u" "\n", flags); } while (0);
    return MDBX_CORRUPTED;
  case 0x04 | 0x02:
    if (!0 &&
        __builtin_expect(!!(node_ds(node) != sizeof(MDBX_db)), 0)) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 16440, "invalid nested-db record size %zu" "\n", node_ds(node)); } while (0);
      return MDBX_CORRUPTED;
    }
    memcpy(&mx->mx_db, node_data(node), sizeof(MDBX_db));
    const txnid_t pp_txnid = mp->mp_txnid;
    if (!0 &&
        __builtin_expect(!!(mx->mx_db.md_mod_txnid > pp_txnid), 0)) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 16447, "nested-db.md_mod_txnid (%" 
# 16447 "/libmdbx/src/core.c" 3 4
     "l" "i" 
# 16447 "/libmdbx/src/core.c"
     ") > page-txnid (%" 
# 16447 "/libmdbx/src/core.c" 3 4
     "l" "i" 
# 16447 "/libmdbx/src/core.c"
     ")" "\n", mx->mx_db.md_mod_txnid, pp_txnid); } while (0)

                                                  ;
      return MDBX_CORRUPTED;
    }
    mx->mx_cursor.mc_pg[0] = 0;
    mx->mx_cursor.mc_snum = 0;
    mx->mx_cursor.mc_top = 0;
    mx->mx_cursor.mc_flags = 0x04 | (mc->mc_flags & (0x100 | 0x800));
    break;
  case 0x04:
    if (!0 && __builtin_expect(!!(node_ds(node) <= ((unsigned)
# 16458 "/libmdbx/src/core.c" 3 4
                                   __builtin_offsetof (
# 16458 "/libmdbx/src/core.c"
                                   MDBX_page
# 16458 "/libmdbx/src/core.c" 3 4
                                   , 
# 16458 "/libmdbx/src/core.c"
                                   mp_ptrs
# 16458 "/libmdbx/src/core.c" 3 4
                                   )
# 16458 "/libmdbx/src/core.c"
                                   )), 0)) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 16459, "invalid nested-page size %zu" "\n", node_ds(node)); } while (0);
      return MDBX_CORRUPTED;
    }
    MDBX_page *fp = node_data(node);
    mx->mx_db.md_depth = 1;
    mx->mx_db.md_branch_pages = 0;
    mx->mx_db.md_leaf_pages = 1;
    mx->mx_db.md_overflow_pages = 0;
    mx->mx_db.md_entries = page_numkeys(fp);
    mx->mx_db.md_root = fp->mp_pgno;
    mx->mx_db.md_mod_txnid = mp->mp_txnid;
    mx->mx_cursor.mc_snum = 1;
    mx->mx_cursor.mc_top = 0;
    mx->mx_cursor.mc_flags =
        0x01 | 0x04 | (mc->mc_flags & (0x100 | 0x800));
    mx->mx_cursor.mc_pg[0] = fp;
    mx->mx_cursor.mc_ki[0] = 0;
    mx->mx_db.md_flags = flags_db2sub(mc->mc_db->md_flags);
    mx->mx_db.md_xsize =
        (mc->mc_db->md_flags & MDBX_DUPFIXED) ? fp->mp_leaf2_ksize : 0;
    break;
  }

  if (__builtin_expect(!!(mx->mx_db.md_xsize != mc->mc_db->md_xsize), 0)) {
    if (!0 && __builtin_expect(!!(mc->mc_db->md_xsize != 0), 0)) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 16484, "cursor mismatched nested-db md_xsize %u" "\n", mc->mc_db->md_xsize); } while (0)
                                     ;
      return MDBX_CORRUPTED;
    }
    if (!0 &&
        __builtin_expect(!!((mc->mc_db->md_flags & MDBX_DUPFIXED) == 0), 0)) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 16490, "mismatched nested-db md_flags %u" "\n", mc->mc_db->md_flags); } while (0);
      return MDBX_CORRUPTED;
    }
    if (!0 &&
        __builtin_expect(!!(mx->mx_db.md_xsize < mc->mc_dbx->md_vlen_min || mx->mx_db.md_xsize > mc->mc_dbx->md_vlen_max), 0)
                                                              ) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 16496, "mismatched nested-db.md_xsize (%u) <> min/max value-length " "(%zu/%zu)" "\n", mx->mx_db.md_xsize, mc->mc_dbx->md_vlen_min, mc->mc_dbx->md_vlen_max); } while (0)


                                         ;
      return MDBX_CORRUPTED;
    }
    mc->mc_db->md_xsize = mx->mx_db.md_xsize;
    mc->mc_dbx->md_vlen_min = mc->mc_dbx->md_vlen_max = mx->mx_db.md_xsize;
  }
  mx->mx_dbx.md_klen_min = mc->mc_dbx->md_vlen_min;
  mx->mx_dbx.md_klen_max = mc->mc_dbx->md_vlen_max;

  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 16508, "Sub-db -%u root page %" 
# 16508 "/libmdbx/src/core.c" 3 4
 "u" 
# 16508 "/libmdbx/src/core.c"
 "\n", mx->mx_cursor.mc_dbi, mx->mx_db.md_root); } while (0)
                               ;
  return MDBX_SUCCESS;
}
# 16520 "/libmdbx/src/core.c"
static int mdbx_xcursor_init2(MDBX_cursor *mc, MDBX_xcursor *src_mx,
                              _Bool new_dupdata) {
  MDBX_xcursor *mx = mc->mc_xcursor;
  if (!0 && __builtin_expect(!!(mx == 
# 16523 "/libmdbx/src/core.c" 3 4
                                 ((void *)0)
# 16523 "/libmdbx/src/core.c"
                                 ), 0)) {
    do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 16524, "unexpected dupsort-page for non-dupsort db/cursor (dbi %u)" "\n", mc->mc_dbi); } while (0)
                          ;
    return MDBX_CORRUPTED;
  }

  if (new_dupdata) {
    mx->mx_cursor.mc_snum = 1;
    mx->mx_cursor.mc_top = 0;
    mx->mx_cursor.mc_flags |= 0x01;
    mx->mx_cursor.mc_ki[0] = 0;
  }

  mx->mx_dbx.md_klen_min = src_mx->mx_dbx.md_klen_min;
  mx->mx_dbx.md_klen_max = src_mx->mx_dbx.md_klen_max;
  mx->mx_dbx.md_cmp = src_mx->mx_dbx.md_cmp;
  mx->mx_db = src_mx->mx_db;
  mx->mx_cursor.mc_pg[0] = src_mx->mx_cursor.mc_pg[0];
  if (mx->mx_cursor.mc_flags & 0x01) {
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 16542, "Sub-db -%u root page %" 
# 16542 "/libmdbx/src/core.c" 3 4
   "u" 
# 16542 "/libmdbx/src/core.c"
   "\n", mx->mx_cursor.mc_dbi, mx->mx_db.md_root); } while (0)
                                 ;
  }
  return MDBX_SUCCESS;
}

static __inline int mdbx_couple_init(MDBX_cursor_couple *couple,
                                     const MDBX_dbi dbi, MDBX_txn *const txn,
                                     MDBX_db *const db, MDBX_dbx *const dbx,
                                     uint8_t *const dbstate) {
  couple->outer.mc_signature = 0xFE05D5B1U;
  couple->outer.mc_next = 
# 16553 "/libmdbx/src/core.c" 3 4
                         ((void *)0)
# 16553 "/libmdbx/src/core.c"
                             ;
  couple->outer.mc_backup = 
# 16554 "/libmdbx/src/core.c" 3 4
                           ((void *)0)
# 16554 "/libmdbx/src/core.c"
                               ;
  couple->outer.mc_dbi = dbi;
  couple->outer.mc_txn = txn;
  couple->outer.mc_db = db;
  couple->outer.mc_dbx = dbx;
  couple->outer.mc_dbistate = dbstate;
  couple->outer.mc_snum = 0;
  couple->outer.mc_top = 0;
  couple->outer.mc_pg[0] = 0;
  couple->outer.mc_flags = 0;
  couple->outer.mc_ki[0] = 0;
  couple->outer.mc_xcursor = 
# 16565 "/libmdbx/src/core.c" 3 4
                            ((void *)0)
# 16565 "/libmdbx/src/core.c"
                                ;

  int rc = MDBX_SUCCESS;
  if (__builtin_expect(!!(*couple->outer.mc_dbistate & MDBX_DBI_STALE), 0)) {
    rc = mdbx_page_search(&couple->outer, 
# 16569 "/libmdbx/src/core.c" 3 4
                                         ((void *)0)
# 16569 "/libmdbx/src/core.c"
                                             , 2);
    rc = (rc != MDBX_NOTFOUND) ? rc : MDBX_SUCCESS;
  } else if (__builtin_expect(!!(couple->outer.mc_dbx->md_klen_max == 0), 0)) {
    rc = mdbx_setup_dbx(couple->outer.mc_dbx, couple->outer.mc_db,
                        txn->mt_env->me_psize);
  }

  if (couple->outer.mc_db->md_flags & MDBX_DUPSORT) {
    couple->inner.mx_cursor.mc_signature = 0xFE05D5B1U;
    couple->outer.mc_xcursor = &couple->inner;
    rc = mdbx_xcursor_init0(&couple->outer);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      return rc;
    couple->inner.mx_dbx.md_klen_min = couple->outer.mc_dbx->md_vlen_min;
    couple->inner.mx_dbx.md_klen_max = couple->outer.mc_dbx->md_vlen_max;
  }
  return rc;
}


static int mdbx_cursor_init(MDBX_cursor *mc, MDBX_txn *txn, MDBX_dbi dbi) {
  _Static_assert(
# 16590 "/libmdbx/src/core.c" 3 4
 __builtin_offsetof (
# 16590 "/libmdbx/src/core.c"
 MDBX_cursor_couple
# 16590 "/libmdbx/src/core.c" 3 4
 , 
# 16590 "/libmdbx/src/core.c"
 outer
# 16590 "/libmdbx/src/core.c" 3 4
 ) 
# 16590 "/libmdbx/src/core.c"
 == 0, "offsetof(MDBX_cursor_couple, outer) == 0");
  if (__builtin_expect(!!(((txn)->mt_dbiseqs[dbi] != (txn)->mt_env->me_dbiseqs[dbi])), 0))
    return MDBX_BAD_DBI;

  return mdbx_couple_init(((MDBX_cursor_couple *)((char *)(mc) - 
# 16594 "/libmdbx/src/core.c" 3 4
                         __builtin_offsetof (
# 16594 "/libmdbx/src/core.c"
                         MDBX_cursor_couple
# 16594 "/libmdbx/src/core.c" 3 4
                         , 
# 16594 "/libmdbx/src/core.c"
                         outer
# 16594 "/libmdbx/src/core.c" 3 4
                         )
# 16594 "/libmdbx/src/core.c"
                         )), dbi, txn,
                          &txn->mt_dbs[dbi], &txn->mt_dbxs[dbi],
                          &txn->mt_dbistate[dbi]);
}

MDBX_cursor *mdbx_cursor_create(void *context) {
  MDBX_cursor_couple *couple = calloc(1, sizeof(MDBX_cursor_couple));
  if (__builtin_expect(!!(!couple), 0))
    return 
# 16602 "/libmdbx/src/core.c" 3 4
          ((void *)0)
# 16602 "/libmdbx/src/core.c"
                 ;

  couple->outer.mc_signature = 0x2817A047U;
  couple->outer.mc_dbi = 
# 16605 "/libmdbx/src/core.c" 3 4
                        (0x7fffffff * 2U + 1U)
# 16605 "/libmdbx/src/core.c"
                                ;
  couple->mc_userctx = context;
  return &couple->outer;
}

int mdbx_cursor_set_userctx(MDBX_cursor *mc, void *ctx) {
  if (__builtin_expect(!!(!mc), 0))
    return MDBX_EINVAL;

  if (__builtin_expect(!!(mc->mc_signature != 0x2817A047U && mc->mc_signature != 0xFE05D5B1U), 0)
                                                )
    return MDBX_EBADSIGN;

  MDBX_cursor_couple *couple = ((MDBX_cursor_couple *)((char *)(mc) - 
# 16618 "/libmdbx/src/core.c" 3 4
                              __builtin_offsetof (
# 16618 "/libmdbx/src/core.c"
                              MDBX_cursor_couple
# 16618 "/libmdbx/src/core.c" 3 4
                              , 
# 16618 "/libmdbx/src/core.c"
                              outer
# 16618 "/libmdbx/src/core.c" 3 4
                              )
# 16618 "/libmdbx/src/core.c"
                              ));
  couple->mc_userctx = ctx;
  return MDBX_SUCCESS;
}

void *mdbx_cursor_get_userctx(const MDBX_cursor *mc) {
  if (__builtin_expect(!!(!mc), 0))
    return 
# 16625 "/libmdbx/src/core.c" 3 4
          ((void *)0)
# 16625 "/libmdbx/src/core.c"
                 ;

  if (__builtin_expect(!!(mc->mc_signature != 0x2817A047U && mc->mc_signature != 0xFE05D5B1U), 0)
                                                )
    return 
# 16629 "/libmdbx/src/core.c" 3 4
          ((void *)0)
# 16629 "/libmdbx/src/core.c"
                 ;

  MDBX_cursor_couple *couple = ((MDBX_cursor_couple *)((char *)(mc) - 
# 16631 "/libmdbx/src/core.c" 3 4
                              __builtin_offsetof (
# 16631 "/libmdbx/src/core.c"
                              MDBX_cursor_couple
# 16631 "/libmdbx/src/core.c" 3 4
                              , 
# 16631 "/libmdbx/src/core.c"
                              outer
# 16631 "/libmdbx/src/core.c" 3 4
                              )
# 16631 "/libmdbx/src/core.c"
                              ));
  return couple->mc_userctx;
}

int mdbx_cursor_bind(MDBX_txn *txn, MDBX_cursor *mc, MDBX_dbi dbi) {
  if (__builtin_expect(!!(!mc), 0))
    return MDBX_EINVAL;

  if (__builtin_expect(!!(mc->mc_signature != 0x2817A047U && mc->mc_signature != 0xFE05D5B1U), 0)
                                                )
    return MDBX_EBADSIGN;

  int rc = check_txn(txn, (0x01 | 0x02 | 0x10));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(!check_dbi(txn, dbi, 0x10)), 0))
    return MDBX_BAD_DBI;

  if (__builtin_expect(!!(dbi == 0 && !(((txn->mt_flags) & (MDBX_TXN_RDONLY)) == (MDBX_TXN_RDONLY))), 0))
    return MDBX_EACCESS;

  if (__builtin_expect(!!(mc->mc_backup), 0)) {
    do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_signature == 0xFE05D5B1U)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mc->mc_signature == 0xFE05D5B1U", __func__, 16654); } while (0); } while (0);
    if (__builtin_expect(!!(mc->mc_dbi != dbi || mc->mc_signature != 0xFE05D5B1U || mc->mc_txn != txn), 0)

                                   )
      return MDBX_EINVAL;

    do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_db == &txn->mt_dbs[dbi])), 0)) mdbx_assert_fail(
# 16660 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 16660 "/libmdbx/src/core.c"
   , "mc->mc_db == &txn->mt_dbs[dbi]", __func__, 16660); } while (0); } while (0);
    do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_dbx == &txn->mt_dbxs[dbi])), 0)) mdbx_assert_fail(
# 16661 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 16661 "/libmdbx/src/core.c"
   , "mc->mc_dbx == &txn->mt_dbxs[dbi]", __func__, 16661); } while (0); } while (0);
    do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_dbi == dbi)), 0)) mdbx_assert_fail(
# 16662 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 16662 "/libmdbx/src/core.c"
   , "mc->mc_dbi == dbi", __func__, 16662); } while (0); } while (0);
    do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_dbistate == &txn->mt_dbistate[dbi])), 0)) mdbx_assert_fail(
# 16663 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 16663 "/libmdbx/src/core.c"
   , "mc->mc_dbistate == &txn->mt_dbistate[dbi]", __func__, 16663); } while (0); } while (0);
    return __builtin_expect(!!(mc->mc_dbi == dbi && mc->mc_signature == 0xFE05D5B1U && mc->mc_txn == txn), 1)


               ? MDBX_SUCCESS
               : MDBX_EINVAL ;
  }

  if (mc->mc_signature == 0xFE05D5B1U) {
    if (__builtin_expect(!!(!mc->mc_txn || mc->mc_txn->mt_signature != 0x93D53A31U), 0)
                                                               ) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 16674, "Wrong cursor's transaction %p 0x%x" "\n", __Wpedantic_format_voidptr(mc->mc_txn), mc->mc_txn ? mc->mc_txn->mt_signature : 0); } while (0)

                                                           ;
      return MDBX_PROBLEM;
    }
    if (mc->mc_flags & 0x10) {
      MDBX_cursor **prev = &mc->mc_txn->mt_cursors[mc->mc_dbi];
      while (*prev && *prev != mc)
        prev = &(*prev)->mc_next;
      do { if ((0)) do { if (__builtin_expect(!!(!(*prev == mc)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "*prev == mc", __func__, 16683); } while (0); } while (0);
      *prev = mc->mc_next;
    }
    mc->mc_signature = 0x2817A047U;
    mc->mc_flags = 0;
    mc->mc_dbi = 
# 16688 "/libmdbx/src/core.c" 3 4
                (0x7fffffff * 2U + 1U)
# 16688 "/libmdbx/src/core.c"
                        ;
    mc->mc_next = 
# 16689 "/libmdbx/src/core.c" 3 4
                 ((void *)0)
# 16689 "/libmdbx/src/core.c"
                     ;
    mc->mc_db = 
# 16690 "/libmdbx/src/core.c" 3 4
               ((void *)0)
# 16690 "/libmdbx/src/core.c"
                   ;
    mc->mc_dbx = 
# 16691 "/libmdbx/src/core.c" 3 4
                ((void *)0)
# 16691 "/libmdbx/src/core.c"
                    ;
    mc->mc_dbistate = 
# 16692 "/libmdbx/src/core.c" 3 4
                     ((void *)0)
# 16692 "/libmdbx/src/core.c"
                         ;
  }
  do { if ((0)) do { if (__builtin_expect(!!(!(!(mc->mc_flags & 0x10))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "!(mc->mc_flags & 0x10)", __func__, 16694); } while (0); } while (0);

  rc = mdbx_cursor_init(mc, txn, dbi);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  mc->mc_next = txn->mt_cursors[dbi];
  txn->mt_cursors[dbi] = mc;
  mc->mc_flags |= 0x10;

  return MDBX_SUCCESS;
}

int mdbx_cursor_open(MDBX_txn *txn, MDBX_dbi dbi, MDBX_cursor **ret) {
  if (__builtin_expect(!!(!ret), 0))
    return MDBX_EINVAL;
  *ret = 
# 16710 "/libmdbx/src/core.c" 3 4
        ((void *)0)
# 16710 "/libmdbx/src/core.c"
            ;

  MDBX_cursor *const mc = mdbx_cursor_create(
# 16712 "/libmdbx/src/core.c" 3 4
                                            ((void *)0)
# 16712 "/libmdbx/src/core.c"
                                                   );
  if (__builtin_expect(!!(!mc), 0))
    return MDBX_ENOMEM;

  int rc = mdbx_cursor_bind(txn, mc, dbi);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0)) {
    mdbx_cursor_close(mc);
    return rc;
  }

  *ret = mc;
  return MDBX_SUCCESS;
}

int mdbx_cursor_renew(MDBX_txn *txn, MDBX_cursor *mc) {
  return __builtin_expect(!!(mc), 1) ? mdbx_cursor_bind(txn, mc, mc->mc_dbi) : MDBX_EINVAL;
}

int mdbx_cursor_copy(const MDBX_cursor *src, MDBX_cursor *dest) {
  if (__builtin_expect(!!(!src), 0))
    return MDBX_EINVAL;
  if (__builtin_expect(!!(src->mc_signature != 0xFE05D5B1U), 0))
    return (src->mc_signature == 0x2817A047U) ? MDBX_EINVAL
                                                      : MDBX_EBADSIGN;

  int rc = mdbx_cursor_bind(src->mc_txn, dest, src->mc_dbi);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  do { if ((0)) do { if (__builtin_expect(!!(!(dest->mc_db == src->mc_db)), 0)) mdbx_assert_fail(
# 16741 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 16741 "/libmdbx/src/core.c"
 , "dest->mc_db == src->mc_db", __func__, 16741); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(dest->mc_dbi == src->mc_dbi)), 0)) mdbx_assert_fail(
# 16742 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 16742 "/libmdbx/src/core.c"
 , "dest->mc_dbi == src->mc_dbi", __func__, 16742); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(dest->mc_dbx == src->mc_dbx)), 0)) mdbx_assert_fail(
# 16743 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 16743 "/libmdbx/src/core.c"
 , "dest->mc_dbx == src->mc_dbx", __func__, 16743); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(dest->mc_dbistate == src->mc_dbistate)), 0)) mdbx_assert_fail(
# 16744 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 16744 "/libmdbx/src/core.c"
 , "dest->mc_dbistate == src->mc_dbistate", __func__, 16744); } while (0); } while (0);
again:
  do { if ((0)) do { if (__builtin_expect(!!(!(dest->mc_txn == src->mc_txn)), 0)) mdbx_assert_fail(
# 16746 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 16746 "/libmdbx/src/core.c"
 , "dest->mc_txn == src->mc_txn", __func__, 16746); } while (0); } while (0);
  dest->mc_flags ^= (dest->mc_flags ^ src->mc_flags) & ~0x10;
  dest->mc_top = src->mc_top;
  dest->mc_snum = src->mc_snum;
  for (unsigned i = 0; i < src->mc_snum; ++i) {
    dest->mc_ki[i] = src->mc_ki[i];
    dest->mc_pg[i] = src->mc_pg[i];
  }

  if (src->mc_xcursor) {
    dest->mc_xcursor->mx_db = src->mc_xcursor->mx_db;
    dest->mc_xcursor->mx_dbx = src->mc_xcursor->mx_dbx;
    src = &src->mc_xcursor->mx_cursor;
    dest = &dest->mc_xcursor->mx_cursor;
    goto again;
  }

  return MDBX_SUCCESS;
}

void mdbx_cursor_close(MDBX_cursor *mc) {
  if (__builtin_expect(!!(mc), 1)) {
    do { if (__builtin_expect(!!(!(mc->mc_signature == 0xFE05D5B1U || mc->mc_signature == 0x2817A047U)), 0)) mdbx_assert_fail(
# 16768 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 16768 "/libmdbx/src/core.c"
   , "mc->mc_signature == MDBX_MC_LIVE || mc->mc_signature == MDBX_MC_READY4CLOSE", __func__, 16768); } while (0)
                                                                  ;
    MDBX_txn *const txn = mc->mc_txn;
    if (!mc->mc_backup) {
      mc->mc_txn = 
# 16772 "/libmdbx/src/core.c" 3 4
                  ((void *)0)
# 16772 "/libmdbx/src/core.c"
                      ;

      if (mc->mc_flags & 0x10) {
        do { if (__builtin_expect(!!(!(check_txn(txn, 0) == MDBX_SUCCESS)), 0)) mdbx_assert_fail(txn->mt_env, "check_txn(txn, 0) == MDBX_SUCCESS", __func__, 16775); } while (0);
        MDBX_cursor **prev = &txn->mt_cursors[mc->mc_dbi];
        while (*prev && *prev != mc)
          prev = &(*prev)->mc_next;
        do { if ((0)) do { if (__builtin_expect(!!(!(*prev == mc)), 0)) mdbx_assert_fail((txn)->mt_env, "*prev == mc", __func__, 16779); } while (0); } while (0);
        *prev = mc->mc_next;
      }
      mc->mc_signature = 0;
      mc->mc_next = mc;
      free(mc);
    } else {

      do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_signature == 0xFE05D5B1U)), 0)) mdbx_assert_fail((txn)->mt_env, "mc->mc_signature == 0xFE05D5B1U", __func__, 16787); } while (0); } while (0);
      do { if (__builtin_expect(!!(!(check_txn_rw(txn, 0) == MDBX_SUCCESS)), 0)) mdbx_assert_fail(txn->mt_env, "check_txn_rw(txn, 0) == MDBX_SUCCESS", __func__, 16788); } while (0);
      mc->mc_signature = 0x90E297A7U;
    }
  }
}

MDBX_txn *mdbx_cursor_txn(const MDBX_cursor *mc) {
  if (__builtin_expect(!!(!mc || mc->mc_signature != 0xFE05D5B1U), 0))
    return 
# 16796 "/libmdbx/src/core.c" 3 4
          ((void *)0)
# 16796 "/libmdbx/src/core.c"
              ;
  MDBX_txn *txn = mc->mc_txn;
  if (__builtin_expect(!!(!txn || txn->mt_signature != 0x93D53A31U), 0))
    return 
# 16799 "/libmdbx/src/core.c" 3 4
          ((void *)0)
# 16799 "/libmdbx/src/core.c"
              ;
  if (__builtin_expect(!!(txn->mt_flags & 0x01), 0))
    return 
# 16801 "/libmdbx/src/core.c" 3 4
          ((void *)0)
# 16801 "/libmdbx/src/core.c"
              ;
  return txn;
}

MDBX_dbi mdbx_cursor_dbi(const MDBX_cursor *mc) {
  if (__builtin_expect(!!(!mc || mc->mc_signature != 0xFE05D5B1U), 0))
    return 
# 16807 "/libmdbx/src/core.c" 3 4
          (0x7fffffff * 2U + 1U)
# 16807 "/libmdbx/src/core.c"
                  ;
  return mc->mc_dbi;
}


int mdbx_cursor_count(const MDBX_cursor *mc, size_t *countp) {
  if (__builtin_expect(!!(mc == 
# 16813 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 16813 "/libmdbx/src/core.c"
     ), 0))
    return MDBX_EINVAL;

  if (__builtin_expect(!!(mc->mc_signature != 0xFE05D5B1U), 0))
    return (mc->mc_signature == 0x2817A047U) ? MDBX_EINVAL
                                                     : MDBX_EBADSIGN;

  int rc = check_txn(mc->mc_txn, (0x01 | 0x02 | 0x10));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(countp == 
# 16824 "/libmdbx/src/core.c" 3 4
     ((void *)0) 
# 16824 "/libmdbx/src/core.c"
     || !(mc->mc_flags & 0x01)), 0))
    return MDBX_EINVAL;

  if (!mc->mc_snum) {
    *countp = 0;
    return MDBX_NOTFOUND;
  }

  MDBX_page *mp = mc->mc_pg[mc->mc_top];
  if ((mc->mc_flags & 0x02) && mc->mc_ki[mc->mc_top] >= page_numkeys(mp)) {
    *countp = 0;
    return MDBX_NOTFOUND;
  }

  *countp = 1;
  if (mc->mc_xcursor != 
# 16839 "/libmdbx/src/core.c" 3 4
                       ((void *)0)
# 16839 "/libmdbx/src/core.c"
                           ) {
    MDBX_node *node = page_node(mp, mc->mc_ki[mc->mc_top]);
    if ((((node_flags(node)) & (0x04)) == (0x04))) {
      do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_xcursor && (mc->mc_xcursor->mx_cursor.mc_flags & 0x01))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mc->mc_xcursor && (mc->mc_xcursor->mx_cursor.mc_flags & 0x01)", __func__, 16842); } while (0); } while (0)
                                                         ;
      *countp = __builtin_expect(!!(mc->mc_xcursor->mx_db.md_entries > 
# 16844 "/libmdbx/src/core.c" 3 4
               (9223372036854775807L)
# 16844 "/libmdbx/src/core.c"
               ), 0)
                    ? 
# 16845 "/libmdbx/src/core.c" 3 4
                     (9223372036854775807L)
                    
# 16846 "/libmdbx/src/core.c"
                   : (size_t)mc->mc_xcursor->mx_db.md_entries;
    }
  }
  return MDBX_SUCCESS;
}






static int mdbx_update_key(MDBX_cursor *mc, const MDBX_val *key) {
  MDBX_page *mp;
  MDBX_node *node;
  char *base;
  size_t len;
  int delta, ksize, oksize;
  int ptr, i, nkeys, indx;
  ((void)(0));

  do { if ((0)) do { if (__builtin_expect(!!(!(cursor_is_tracked(mc))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "cursor_is_tracked(mc)", __func__, 16866); } while (0); } while (0);
  indx = mc->mc_ki[mc->mc_top];
  mp = mc->mc_pg[mc->mc_top];
  node = page_node(mp, indx);
  ptr = mp->mp_ptrs[indx];
# 16880 "/libmdbx/src/core.c"
  ksize = (((key->iov_len) + 1U) & -2);
  oksize = (((node_ks(node)) + 1U) & -2);
  delta = ksize - oksize;


  if (delta) {
    if (delta > (int)page_room(mp)) {

      do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 16888, "Not enough room, delta = %d, splitting..." "\n", delta); } while (0);
      pgno_t pgno = node_pgno(node);
      mdbx_node_del(mc, 0);
      int rc = mdbx_page_split(mc, key, 
# 16891 "/libmdbx/src/core.c" 3 4
                                       ((void *)0)
# 16891 "/libmdbx/src/core.c"
                                           , pgno, MDBX_APPENDDUP);
      if (rc == MDBX_SUCCESS && (0))
        rc = mdbx_cursor_check(mc, 0x200);
      return rc;
    }

    nkeys = page_numkeys(mp);
    for (i = 0; i < nkeys; i++) {
      if (mp->mp_ptrs[i] <= ptr) {
        do { if ((0)) do { if (__builtin_expect(!!(!(mp->mp_ptrs[i] >= delta)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mp->mp_ptrs[i] >= delta", __func__, 16900); } while (0); } while (0);
        mp->mp_ptrs[i] -= (indx_t)delta;
      }
    }

    base = (char *)mp + mp->mp_upper + ((unsigned)
# 16905 "/libmdbx/src/core.c" 3 4
                                      __builtin_offsetof (
# 16905 "/libmdbx/src/core.c"
                                      MDBX_page
# 16905 "/libmdbx/src/core.c" 3 4
                                      , 
# 16905 "/libmdbx/src/core.c"
                                      mp_ptrs
# 16905 "/libmdbx/src/core.c" 3 4
                                      )
# 16905 "/libmdbx/src/core.c"
                                      );
    len = ptr - mp->mp_upper + 
# 16906 "/libmdbx/src/core.c" 3 4
                              __builtin_offsetof (
# 16906 "/libmdbx/src/core.c"
                              MDBX_node
# 16906 "/libmdbx/src/core.c" 3 4
                              , 
# 16906 "/libmdbx/src/core.c"
                              mn_data
# 16906 "/libmdbx/src/core.c" 3 4
                              )
# 16906 "/libmdbx/src/core.c"
                                      ;
    memmove(base - delta, base, len);
    do { if ((0)) do { if (__builtin_expect(!!(!(mp->mp_upper >= delta)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mp->mp_upper >= delta", __func__, 16908); } while (0); } while (0);
    mp->mp_upper -= (indx_t)delta;

    node = page_node(mp, indx);
  }


  node_set_ks(node, key->iov_len);

  if (__builtin_expect(!!(key->iov_len != 0), 1))
    memcpy(node_key(node), key->iov_base, key->iov_len);
  return MDBX_SUCCESS;
}


static int mdbx_node_move(MDBX_cursor *csrc, MDBX_cursor *cdst, _Bool fromleft) {
  int rc;
  ((void)(0));

  MDBX_page *psrc = csrc->mc_pg[csrc->mc_top];
  MDBX_page *pdst = cdst->mc_pg[cdst->mc_top];
  do { if ((0)) do { if (__builtin_expect(!!(!(((psrc)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) == ((pdst)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)))), 0)) mdbx_assert_fail((csrc)->mc_txn->mt_env, "((psrc)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) == ((pdst)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04))", __func__, 16929); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(csrc->mc_dbi == cdst->mc_dbi)), 0)) mdbx_assert_fail((csrc)->mc_txn->mt_env, "csrc->mc_dbi == cdst->mc_dbi", __func__, 16930); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(csrc->mc_top == cdst->mc_top)), 0)) mdbx_assert_fail((csrc)->mc_txn->mt_env, "csrc->mc_top == cdst->mc_top", __func__, 16931); } while (0); } while (0);
  if (__builtin_expect(!!(((psrc)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) != ((pdst)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04))), 0)) {
  bailout:
    do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 16934, "Wrong or mismatch pages's types (src %d, dst %d) to move node" "\n", ((psrc)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)), ((pdst)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04))); } while (0)
                                              ;
    csrc->mc_txn->mt_flags |= 0x02;
    return MDBX_PROBLEM;
  }

  MDBX_val key4move;
  switch (((psrc)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04))) {
  case 0x01: {
    const MDBX_node *srcnode = page_node(psrc, csrc->mc_ki[csrc->mc_top]);
    do { if ((0)) do { if (__builtin_expect(!!(!(node_flags(srcnode) == 0)), 0)) mdbx_assert_fail((csrc)->mc_txn->mt_env, "node_flags(srcnode) == 0", __func__, 16944); } while (0); } while (0);
    const pgno_t srcpg = node_pgno(srcnode);
    key4move.iov_len = node_ks(srcnode);
    key4move.iov_base = node_key(srcnode);

    if (csrc->mc_ki[csrc->mc_top] == 0) {
      const unsigned snum = csrc->mc_snum;
      do { if ((0)) do { if (__builtin_expect(!!(!(snum > 0)), 0)) mdbx_assert_fail((csrc)->mc_txn->mt_env, "snum > 0", __func__, 16951); } while (0); } while (0);

      rc = mdbx_page_search_lowest(csrc);
      MDBX_page *lowest_page = csrc->mc_pg[csrc->mc_top];
      if (__builtin_expect(!!(rc), 0))
        return rc;
      do { if ((0)) do { if (__builtin_expect(!!(!((((lowest_page)->mp_flags & 0x02) != 0))), 0)) mdbx_assert_fail((csrc)->mc_txn->mt_env, "(((lowest_page)->mp_flags & 0x02) != 0)", __func__, 16957); } while (0); } while (0);
      if (__builtin_expect(!!(!(((lowest_page)->mp_flags & 0x02) != 0)), 0))
        goto bailout;
      if (__builtin_expect(!!(((lowest_page)->mp_flags & 0x20) != 0), 0)) {
        key4move.iov_len = csrc->mc_db->md_xsize;
        key4move.iov_base = page_leaf2key(lowest_page, 0, key4move.iov_len);
      } else {
        const MDBX_node *lowest_node = page_node(lowest_page, 0);
        key4move.iov_len = node_ks(lowest_node);
        key4move.iov_base = node_key(lowest_node);
      }


      csrc->mc_snum = snum;
      csrc->mc_top = snum - 1;
      csrc->mc_ki[csrc->mc_top] = 0;


      do { if ((0)) do { if (__builtin_expect(!!(!(psrc == csrc->mc_pg[csrc->mc_top])), 0)) mdbx_assert_fail((csrc)->mc_txn->mt_env, "psrc == csrc->mc_pg[csrc->mc_top]", __func__, 16975); } while (0); } while (0);
      do { if ((0)) do { if (__builtin_expect(!!(!((((psrc)->mp_flags & 0x01) != 0))), 0)) mdbx_assert_fail((csrc)->mc_txn->mt_env, "(((psrc)->mp_flags & 0x01) != 0)", __func__, 16976); } while (0); } while (0);
      if (__builtin_expect(!!(!(((psrc)->mp_flags & 0x01) != 0)), 0))
        goto bailout;
    }

    if (cdst->mc_ki[cdst->mc_top] == 0) {
      const unsigned snum = cdst->mc_snum;
      do { if ((0)) do { if (__builtin_expect(!!(!(snum > 0)), 0)) mdbx_assert_fail((csrc)->mc_txn->mt_env, "snum > 0", __func__, 16983); } while (0); } while (0);
      MDBX_cursor mn;
      cursor_copy(cdst, &mn);

      rc = mdbx_page_search_lowest(&mn);
      if (__builtin_expect(!!(rc), 0))
        return rc;
      MDBX_page *const lowest_page = mn.mc_pg[mn.mc_top];
      do { if ((0)) do { if (__builtin_expect(!!(!((((lowest_page)->mp_flags & 0x02) != 0))), 0)) mdbx_assert_fail((cdst)->mc_txn->mt_env, "(((lowest_page)->mp_flags & 0x02) != 0)", __func__, 16991); } while (0); } while (0);
      if (__builtin_expect(!!(!(((lowest_page)->mp_flags & 0x02) != 0)), 0))
        goto bailout;
      MDBX_val key;
      if (__builtin_expect(!!(((lowest_page)->mp_flags & 0x20) != 0), 0)) {
        key.iov_len = mn.mc_db->md_xsize;
        key.iov_base = page_leaf2key(lowest_page, 0, key.iov_len);
      } else {
        MDBX_node *lowest_node = page_node(lowest_page, 0);
        key.iov_len = node_ks(lowest_node);
        key.iov_base = node_key(lowest_node);
      }


      mn.mc_snum = snum;
      mn.mc_top = snum - 1;
      mn.mc_ki[mn.mc_top] = 0;

      const intptr_t delta =
          (((key.iov_len) + 1U) & -2) - (((node_ks(page_node(mn.mc_pg[mn.mc_top], 0))) + 1U) & -2);
      const intptr_t needed =
          branch_size(cdst->mc_txn->mt_env, &key4move) + delta;
      const intptr_t have = page_room(pdst);
      if (__builtin_expect(!!(needed > have), 0))
        return MDBX_RESULT_TRUE;

      if (__builtin_expect(!!((rc = mdbx_page_touch(csrc)) || (rc = mdbx_page_touch(cdst))), 0)
                                                )
        return rc;
      psrc = csrc->mc_pg[csrc->mc_top];
      pdst = cdst->mc_pg[cdst->mc_top];

      do { do { if ((0)) do { if (__builtin_expect(!!(!(mn.mc_txn->mt_cursors != 
# 17023 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 17023 "/libmdbx/src/core.c"
     )), 0)) mdbx_assert_fail((&(mn))->mc_txn->mt_env, "mn.mc_txn->mt_cursors != ((void *)0)", __func__, 17023); } while (0); } while (0); do { if ((0)) do { if (__builtin_expect(!!(!(!cursor_is_tracked(&(mn)))), 0)) mdbx_assert_fail((&(mn))->mc_txn->mt_env, "!cursor_is_tracked(&(mn))", __func__, 17023); } while (0); } while (0); MDBX_cursor mc_dummy; MDBX_cursor **tracking_head = &(mn).mc_txn->mt_cursors[mn.mc_dbi]; MDBX_cursor *tracked = &(mn); if ((mn).mc_flags & 0x04) { mc_dummy.mc_flags = 0x01; mc_dummy.mc_top = 0; mc_dummy.mc_snum = 0; mc_dummy.mc_xcursor = (MDBX_xcursor *)&(mn); tracked = &mc_dummy; } tracked->mc_next = *tracking_head; *tracking_head = tracked; { rc = mdbx_update_key(&mn, &key); } *tracking_head = tracked->mc_next; } while (0);
      if (__builtin_expect(!!(rc), 0))
        return rc;
    } else {
      const size_t needed = branch_size(cdst->mc_txn->mt_env, &key4move);
      const size_t have = page_room(pdst);
      if (__builtin_expect(!!(needed > have), 0))
        return MDBX_RESULT_TRUE;

      if (__builtin_expect(!!((rc = mdbx_page_touch(csrc)) || (rc = mdbx_page_touch(cdst))), 0)
                                                )
        return rc;
      psrc = csrc->mc_pg[csrc->mc_top];
      pdst = cdst->mc_pg[cdst->mc_top];
    }

    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 17039, "moving %s-node %u [%s] on page %" 
# 17039 "/libmdbx/src/core.c" 3 4
   "u" 
# 17039 "/libmdbx/src/core.c"
   " to node %u on page %" 
# 17039 "/libmdbx/src/core.c" 3 4
   "u" 
# 17039 "/libmdbx/src/core.c"
   "\n", "branch", csrc->mc_ki[csrc->mc_top], ("-"), psrc->mp_pgno, cdst->mc_ki[cdst->mc_top], pdst->mp_pgno); } while (0)


                                                                       ;

    rc =
        mdbx_node_add_branch(cdst, cdst->mc_ki[cdst->mc_top], &key4move, srcpg);
  } break;

  case 0x02: {

    if (__builtin_expect(!!((rc = mdbx_page_touch(csrc)) || (rc = mdbx_page_touch(cdst))), 0))
      return rc;
    psrc = csrc->mc_pg[csrc->mc_top];
    pdst = cdst->mc_pg[cdst->mc_top];
    const MDBX_node *srcnode = page_node(psrc, csrc->mc_ki[csrc->mc_top]);
    MDBX_val data;
    data.iov_len = node_ds(srcnode);
    data.iov_base = node_data(srcnode);
    key4move.iov_len = node_ks(srcnode);
    key4move.iov_base = node_key(srcnode);
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 17060, "moving %s-node %u [%s] on page %" 
# 17060 "/libmdbx/src/core.c" 3 4
   "u" 
# 17060 "/libmdbx/src/core.c"
   " to node %u on page %" 
# 17060 "/libmdbx/src/core.c" 3 4
   "u" 
# 17060 "/libmdbx/src/core.c"
   "\n", "leaf", csrc->mc_ki[csrc->mc_top], ("-"), psrc->mp_pgno, cdst->mc_ki[cdst->mc_top], pdst->mp_pgno); } while (0)


                                                                       ;

    rc = mdbx_node_add_leaf(cdst, cdst->mc_ki[cdst->mc_top], &key4move, &data,
                            node_flags(srcnode));
  } break;

  case 0x02 | 0x20: {

    if (__builtin_expect(!!((rc = mdbx_page_touch(csrc)) || (rc = mdbx_page_touch(cdst))), 0))
      return rc;
    psrc = csrc->mc_pg[csrc->mc_top];
    pdst = cdst->mc_pg[cdst->mc_top];
    key4move.iov_len = csrc->mc_db->md_xsize;
    key4move.iov_base =
        page_leaf2key(psrc, csrc->mc_ki[csrc->mc_top], key4move.iov_len);
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 17078, "moving %s-node %u [%s] on page %" 
# 17078 "/libmdbx/src/core.c" 3 4
   "u" 
# 17078 "/libmdbx/src/core.c"
   " to node %u on page %" 
# 17078 "/libmdbx/src/core.c" 3 4
   "u" 
# 17078 "/libmdbx/src/core.c"
   "\n", "leaf2", csrc->mc_ki[csrc->mc_top], ("-"), psrc->mp_pgno, cdst->mc_ki[cdst->mc_top], pdst->mp_pgno); } while (0)


                                                                       ;

    rc = mdbx_node_add_leaf2(cdst, cdst->mc_ki[cdst->mc_top], &key4move);
  } break;

  default:
    goto bailout;
  }

  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;


  mdbx_node_del(csrc, key4move.iov_len);

  do { if ((0)) do { if (__builtin_expect(!!(!(psrc == csrc->mc_pg[csrc->mc_top])), 0)) mdbx_assert_fail((csrc)->mc_txn->mt_env, "psrc == csrc->mc_pg[csrc->mc_top]", __func__, 17096); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(pdst == cdst->mc_pg[cdst->mc_top])), 0)) mdbx_assert_fail((cdst)->mc_txn->mt_env, "pdst == cdst->mc_pg[cdst->mc_top]", __func__, 17097); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(((psrc)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) == ((pdst)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)))), 0)) mdbx_assert_fail((csrc)->mc_txn->mt_env, "((psrc)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) == ((pdst)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04))", __func__, 17098); } while (0); } while (0);

  {

    MDBX_cursor *m2, *m3;
    const MDBX_dbi dbi = csrc->mc_dbi;
    do { if ((0)) do { if (__builtin_expect(!!(!(csrc->mc_top == cdst->mc_top)), 0)) mdbx_assert_fail((csrc)->mc_txn->mt_env, "csrc->mc_top == cdst->mc_top", __func__, 17104); } while (0); } while (0);
    if (fromleft) {

      for (m2 = csrc->mc_txn->mt_cursors[dbi]; m2; m2 = m2->mc_next) {
        m3 = (csrc->mc_flags & 0x04) ? &m2->mc_xcursor->mx_cursor : m2;
        if (!(m3->mc_flags & 0x01) || m3->mc_top < csrc->mc_top)
          continue;
        if (m3 != cdst && m3->mc_pg[csrc->mc_top] == pdst &&
            m3->mc_ki[csrc->mc_top] >= cdst->mc_ki[csrc->mc_top]) {
          m3->mc_ki[csrc->mc_top]++;
        }
        if (m3 != csrc && m3->mc_pg[csrc->mc_top] == psrc &&
            m3->mc_ki[csrc->mc_top] == csrc->mc_ki[csrc->mc_top]) {
          m3->mc_pg[csrc->mc_top] = pdst;
          m3->mc_ki[csrc->mc_top] = cdst->mc_ki[cdst->mc_top];
          do { if ((0)) do { if (__builtin_expect(!!(!(csrc->mc_top > 0)), 0)) mdbx_assert_fail((csrc)->mc_txn->mt_env, "csrc->mc_top > 0", __func__, 17119); } while (0); } while (0);
          m3->mc_ki[csrc->mc_top - 1]++;
        }
        if (((m3)->mc_xcursor && ((m3)->mc_xcursor->mx_cursor.mc_flags & 0x01)) && (((psrc)->mp_flags & 0x02) != 0))
          do { MDBX_page *xr_pg = (m3->mc_pg[csrc->mc_top]); MDBX_node *xr_node = page_node(xr_pg, m3->mc_ki[csrc->mc_top]); if ((node_flags(xr_node) & (0x04 | 0x02)) == 0x04) (m3)->mc_xcursor->mx_cursor.mc_pg[0] = node_data(xr_node); } while (0);
      }
    } else {

      for (m2 = csrc->mc_txn->mt_cursors[dbi]; m2; m2 = m2->mc_next) {
        m3 = (csrc->mc_flags & 0x04) ? &m2->mc_xcursor->mx_cursor : m2;
        if (m3 == csrc)
          continue;
        if (!(m3->mc_flags & 0x01) || m3->mc_top < csrc->mc_top)
          continue;
        if (m3->mc_pg[csrc->mc_top] == psrc) {
          if (!m3->mc_ki[csrc->mc_top]) {
            m3->mc_pg[csrc->mc_top] = pdst;
            m3->mc_ki[csrc->mc_top] = cdst->mc_ki[cdst->mc_top];
            do { if ((0)) do { if (__builtin_expect(!!(!(csrc->mc_top > 0)), 0)) mdbx_assert_fail((csrc)->mc_txn->mt_env, "csrc->mc_top > 0", __func__, 17137); } while (0); } while (0);
            m3->mc_ki[csrc->mc_top - 1]--;
          } else {
            m3->mc_ki[csrc->mc_top]--;
          }
          if (((m3)->mc_xcursor && ((m3)->mc_xcursor->mx_cursor.mc_flags & 0x01)) && (((psrc)->mp_flags & 0x02) != 0))
            do { MDBX_page *xr_pg = (m3->mc_pg[csrc->mc_top]); MDBX_node *xr_node = page_node(xr_pg, m3->mc_ki[csrc->mc_top]); if ((node_flags(xr_node) & (0x04 | 0x02)) == 0x04) (m3)->mc_xcursor->mx_cursor.mc_pg[0] = node_data(xr_node); } while (0)
                                                    ;
        }
      }
    }
  }


  if (csrc->mc_ki[csrc->mc_top] == 0) {
    do { if ((0)) do { if (__builtin_expect(!!(!(csrc->mc_top > 0)), 0)) mdbx_assert_fail((csrc)->mc_txn->mt_env, "csrc->mc_top > 0", __func__, 17152); } while (0); } while (0);
    if (csrc->mc_ki[csrc->mc_top - 1] != 0) {
      MDBX_val key;
      if (__builtin_expect(!!(((psrc)->mp_flags & 0x20) != 0), 0)) {
        key.iov_len = psrc->mp_leaf2_ksize;
        key.iov_base = page_leaf2key(psrc, 0, key.iov_len);
      } else {
        MDBX_node *srcnode = page_node(psrc, 0);
        key.iov_len = node_ks(srcnode);
        key.iov_base = node_key(srcnode);
      }
      do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 17163, "update separator for source page %" 
# 17163 "/libmdbx/src/core.c" 3 4
     "u" 
# 17163 "/libmdbx/src/core.c"
     " to [%s]" "\n", psrc->mp_pgno, ("-")); } while (0)
                                                 ;
      MDBX_cursor mn;
      cursor_copy(csrc, &mn);
      do { if ((0)) do { if (__builtin_expect(!!(!(mn.mc_snum > 0)), 0)) mdbx_assert_fail((csrc)->mc_txn->mt_env, "mn.mc_snum > 0", __func__, 17167); } while (0); } while (0);
      mn.mc_snum--;
      mn.mc_top--;

      do { do { if ((0)) do { if (__builtin_expect(!!(!(mn.mc_txn->mt_cursors != 
# 17171 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 17171 "/libmdbx/src/core.c"
     )), 0)) mdbx_assert_fail((&(mn))->mc_txn->mt_env, "mn.mc_txn->mt_cursors != ((void *)0)", __func__, 17171); } while (0); } while (0); do { if ((0)) do { if (__builtin_expect(!!(!(!cursor_is_tracked(&(mn)))), 0)) mdbx_assert_fail((&(mn))->mc_txn->mt_env, "!cursor_is_tracked(&(mn))", __func__, 17171); } while (0); } while (0); MDBX_cursor mc_dummy; MDBX_cursor **tracking_head = &(mn).mc_txn->mt_cursors[mn.mc_dbi]; MDBX_cursor *tracked = &(mn); if ((mn).mc_flags & 0x04) { mc_dummy.mc_flags = 0x01; mc_dummy.mc_top = 0; mc_dummy.mc_snum = 0; mc_dummy.mc_xcursor = (MDBX_xcursor *)&(mn); tracked = &mc_dummy; } tracked->mc_next = *tracking_head; *tracking_head = tracked; { rc = mdbx_update_key(&mn, &key); } *tracking_head = tracked->mc_next; } while (0);
      if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
        return rc;
    }
    if ((((psrc)->mp_flags & 0x01) != 0)) {
      const MDBX_val nullkey = {0, 0};
      const indx_t ix = csrc->mc_ki[csrc->mc_top];
      csrc->mc_ki[csrc->mc_top] = 0;
      rc = mdbx_update_key(csrc, &nullkey);
      csrc->mc_ki[csrc->mc_top] = ix;
      do { if ((0)) do { if (__builtin_expect(!!(!(rc == MDBX_SUCCESS)), 0)) mdbx_assert_fail((csrc)->mc_txn->mt_env, "rc == MDBX_SUCCESS", __func__, 17181); } while (0); } while (0);
    }
  }

  if (cdst->mc_ki[cdst->mc_top] == 0) {
    do { if ((0)) do { if (__builtin_expect(!!(!(cdst->mc_top > 0)), 0)) mdbx_assert_fail((cdst)->mc_txn->mt_env, "cdst->mc_top > 0", __func__, 17186); } while (0); } while (0);
    if (cdst->mc_ki[cdst->mc_top - 1] != 0) {
      MDBX_val key;
      if (__builtin_expect(!!(((pdst)->mp_flags & 0x20) != 0), 0)) {
        key.iov_len = pdst->mp_leaf2_ksize;
        key.iov_base = page_leaf2key(pdst, 0, key.iov_len);
      } else {
        MDBX_node *srcnode = page_node(pdst, 0);
        key.iov_len = node_ks(srcnode);
        key.iov_base = node_key(srcnode);
      }
      do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 17197, "update separator for destination page %" 
# 17197 "/libmdbx/src/core.c" 3 4
     "u" 
# 17197 "/libmdbx/src/core.c"
     " to [%s]" "\n", pdst->mp_pgno, ("-")); } while (0)
                                                 ;
      MDBX_cursor mn;
      cursor_copy(cdst, &mn);
      do { if ((0)) do { if (__builtin_expect(!!(!(mn.mc_snum > 0)), 0)) mdbx_assert_fail((cdst)->mc_txn->mt_env, "mn.mc_snum > 0", __func__, 17201); } while (0); } while (0);
      mn.mc_snum--;
      mn.mc_top--;

      do { do { if ((0)) do { if (__builtin_expect(!!(!(mn.mc_txn->mt_cursors != 
# 17205 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 17205 "/libmdbx/src/core.c"
     )), 0)) mdbx_assert_fail((&(mn))->mc_txn->mt_env, "mn.mc_txn->mt_cursors != ((void *)0)", __func__, 17205); } while (0); } while (0); do { if ((0)) do { if (__builtin_expect(!!(!(!cursor_is_tracked(&(mn)))), 0)) mdbx_assert_fail((&(mn))->mc_txn->mt_env, "!cursor_is_tracked(&(mn))", __func__, 17205); } while (0); } while (0); MDBX_cursor mc_dummy; MDBX_cursor **tracking_head = &(mn).mc_txn->mt_cursors[mn.mc_dbi]; MDBX_cursor *tracked = &(mn); if ((mn).mc_flags & 0x04) { mc_dummy.mc_flags = 0x01; mc_dummy.mc_top = 0; mc_dummy.mc_snum = 0; mc_dummy.mc_xcursor = (MDBX_xcursor *)&(mn); tracked = &mc_dummy; } tracked->mc_next = *tracking_head; *tracking_head = tracked; { rc = mdbx_update_key(&mn, &key); } *tracking_head = tracked->mc_next; } while (0);
      if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
        return rc;
    }
    if ((((pdst)->mp_flags & 0x01) != 0)) {
      const MDBX_val nullkey = {0, 0};
      const indx_t ix = cdst->mc_ki[cdst->mc_top];
      cdst->mc_ki[cdst->mc_top] = 0;
      rc = mdbx_update_key(cdst, &nullkey);
      cdst->mc_ki[cdst->mc_top] = ix;
      do { if ((0)) do { if (__builtin_expect(!!(!(rc == MDBX_SUCCESS)), 0)) mdbx_assert_fail((cdst)->mc_txn->mt_env, "rc == MDBX_SUCCESS", __func__, 17215); } while (0); } while (0);
    }
  }

  return MDBX_SUCCESS;
}
# 17231 "/libmdbx/src/core.c"
static int mdbx_page_merge(MDBX_cursor *csrc, MDBX_cursor *cdst) {
  MDBX_val key;
  int rc;

  do { if ((0)) do { if (__builtin_expect(!!(!(csrc != cdst)), 0)) mdbx_assert_fail((csrc)->mc_txn->mt_env, "csrc != cdst", __func__, 17235); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(cursor_is_tracked(csrc))), 0)) mdbx_assert_fail((csrc)->mc_txn->mt_env, "cursor_is_tracked(csrc)", __func__, 17236); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(cursor_is_tracked(cdst))), 0)) mdbx_assert_fail((cdst)->mc_txn->mt_env, "cursor_is_tracked(cdst)", __func__, 17237); } while (0); } while (0);
  const MDBX_page *const psrc = csrc->mc_pg[csrc->mc_top];
  MDBX_page *pdst = cdst->mc_pg[cdst->mc_top];
  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 17240, "merging page %" 
# 17240 "/libmdbx/src/core.c" 3 4
 "u" 
# 17240 "/libmdbx/src/core.c"
 " into %" 
# 17240 "/libmdbx/src/core.c" 3 4
 "u" 
# 17240 "/libmdbx/src/core.c"
 "\n", psrc->mp_pgno, pdst->mp_pgno); } while (0)
                           ;

  do { if ((0)) do { if (__builtin_expect(!!(!(((psrc)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) == ((pdst)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)))), 0)) mdbx_assert_fail((csrc)->mc_txn->mt_env, "((psrc)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) == ((pdst)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04))", __func__, 17243); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(csrc->mc_dbi == cdst->mc_dbi && csrc->mc_db == cdst->mc_db)), 0)) mdbx_assert_fail((csrc)->mc_txn->mt_env, "csrc->mc_dbi == cdst->mc_dbi && csrc->mc_db == cdst->mc_db", __func__, 17244); } while (0); } while (0)
                                                                          ;
  do { if ((0)) do { if (__builtin_expect(!!(!(csrc->mc_snum > 1)), 0)) mdbx_assert_fail((csrc)->mc_txn->mt_env, "csrc->mc_snum > 1", __func__, 17246); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(cdst->mc_snum > 1)), 0)) mdbx_assert_fail((cdst)->mc_txn->mt_env, "cdst->mc_snum > 1", __func__, 17247); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(cdst->mc_snum < cdst->mc_db->md_depth || (((cdst->mc_pg[cdst->mc_db->md_depth - 1])->mp_flags & 0x02) != 0))), 0)) mdbx_assert_fail((cdst)->mc_txn->mt_env, "cdst->mc_snum < cdst->mc_db->md_depth || (((cdst->mc_pg[cdst->mc_db->md_depth - 1])->mp_flags & 0x02) != 0)", __func__, 17248); } while (0); } while (0)
                                                                         ;
  do { if ((0)) do { if (__builtin_expect(!!(!(csrc->mc_snum < csrc->mc_db->md_depth || (((csrc->mc_pg[csrc->mc_db->md_depth - 1])->mp_flags & 0x02) != 0))), 0)) mdbx_assert_fail((csrc)->mc_txn->mt_env, "csrc->mc_snum < csrc->mc_db->md_depth || (((csrc->mc_pg[csrc->mc_db->md_depth - 1])->mp_flags & 0x02) != 0)", __func__, 17250); } while (0); } while (0)
                                                                         ;
  do { if ((0)) do { if (__builtin_expect(!!(!(page_room(pdst) >= page_used(cdst->mc_txn->mt_env, psrc))), 0)) mdbx_assert_fail((cdst)->mc_txn->mt_env, "page_room(pdst) >= page_used(cdst->mc_txn->mt_env, psrc)", __func__, 17252); } while (0); } while (0);
  const int pagetype = ((psrc)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04));


  const unsigned dst_nkeys = page_numkeys(pdst);
  const unsigned src_nkeys = page_numkeys(psrc);
  do { if ((0)) do { if (__builtin_expect(!!(!(dst_nkeys + src_nkeys >= ((((psrc)->mp_flags & 0x02) != 0) ? 1u : 2u))), 0)) mdbx_assert_fail((cdst)->mc_txn->mt_env, "dst_nkeys + src_nkeys >= ((((psrc)->mp_flags & 0x02) != 0) ? 1u : 2u)", __func__, 17258); } while (0); } while (0);
  if (__builtin_expect(!!(src_nkeys), 1)) {
    unsigned j = dst_nkeys;
    if (__builtin_expect(!!(pagetype & 0x20), 0)) {

      if (__builtin_expect(!!(rc = mdbx_page_touch(cdst)), 0))
        return rc;

      key.iov_len = csrc->mc_db->md_xsize;
      key.iov_base = page_data(psrc);
      unsigned i = 0;
      do {
        rc = mdbx_node_add_leaf2(cdst, j++, &key);
        if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
          return rc;
        key.iov_base = (char *)key.iov_base + key.iov_len;
      } while (++i != src_nkeys);
    } else {
      MDBX_node *srcnode = page_node(psrc, 0);
      key.iov_len = node_ks(srcnode);
      key.iov_base = node_key(srcnode);
      if (pagetype & 0x01) {
        MDBX_cursor mn;
        cursor_copy(csrc, &mn);

        rc = mdbx_page_search_lowest(&mn);
        if (__builtin_expect(!!(rc), 0))
          return rc;

        const MDBX_page *mp = mn.mc_pg[mn.mc_top];
        if (__builtin_expect(!!(!__builtin_expect(!!(((mp)->mp_flags & 0x20) != 0), 0)), 1)) {
          do { if ((0)) do { if (__builtin_expect(!!(!((((mp)->mp_flags & 0x02) != 0))), 0)) mdbx_assert_fail((&mn)->mc_txn->mt_env, "(((mp)->mp_flags & 0x02) != 0)", __func__, 17289); } while (0); } while (0);
          const MDBX_node *lowest = page_node(mp, 0);
          key.iov_len = node_ks(lowest);
          key.iov_base = node_key(lowest);
        } else {
          do { if ((0)) do { if (__builtin_expect(!!(!(mn.mc_top > csrc->mc_top)), 0)) mdbx_assert_fail((&mn)->mc_txn->mt_env, "mn.mc_top > csrc->mc_top", __func__, 17294); } while (0); } while (0);
          key.iov_len = mp->mp_leaf2_ksize;
          key.iov_base = page_leaf2key(mp, mn.mc_ki[mn.mc_top], key.iov_len);
        }
        do { if ((0)) do { if (__builtin_expect(!!(!(key.iov_len >= csrc->mc_dbx->md_klen_min)), 0)) mdbx_assert_fail((&mn)->mc_txn->mt_env, "key.iov_len >= csrc->mc_dbx->md_klen_min", __func__, 17298); } while (0); } while (0);
        do { if ((0)) do { if (__builtin_expect(!!(!(key.iov_len <= csrc->mc_dbx->md_klen_max)), 0)) mdbx_assert_fail((&mn)->mc_txn->mt_env, "key.iov_len <= csrc->mc_dbx->md_klen_max", __func__, 17299); } while (0); } while (0);

        const size_t dst_room = page_room(pdst);
        const size_t src_used = page_used(cdst->mc_txn->mt_env, psrc);
        const size_t space_needed = src_used - node_ks(srcnode) + key.iov_len;
        if (__builtin_expect(!!(space_needed > dst_room), 0))
          return MDBX_RESULT_TRUE;
      }


      if (__builtin_expect(!!(rc = mdbx_page_touch(cdst)), 0))
        return rc;

      unsigned i = 0;
      while ((1)) {
        if (pagetype & 0x02) {
          MDBX_val data;
          data.iov_len = node_ds(srcnode);
          data.iov_base = node_data(srcnode);
          rc = mdbx_node_add_leaf(cdst, j++, &key, &data, node_flags(srcnode));
        } else {
          do { if ((0)) do { if (__builtin_expect(!!(!(node_flags(srcnode) == 0)), 0)) mdbx_assert_fail((csrc)->mc_txn->mt_env, "node_flags(srcnode) == 0", __func__, 17320); } while (0); } while (0);
          rc = mdbx_node_add_branch(cdst, j++, &key, node_pgno(srcnode));
        }
        if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
          return rc;

        if (++i == src_nkeys)
          break;
        srcnode = page_node(psrc, i);
        key.iov_len = node_ks(srcnode);
        key.iov_base = node_key(srcnode);
      }
    }

    pdst = cdst->mc_pg[cdst->mc_top];
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 17335, "dst page %" 
# 17335 "/libmdbx/src/core.c" 3 4
   "u" 
# 17335 "/libmdbx/src/core.c"
   " now has %u keys (%.1f%% filled)" "\n", pdst->mp_pgno, page_numkeys(pdst), page_fill(cdst->mc_txn->mt_env, pdst)); } while (0)

                                                     ;

    do { if ((0)) do { if (__builtin_expect(!!(!(psrc == csrc->mc_pg[csrc->mc_top])), 0)) mdbx_assert_fail((csrc)->mc_txn->mt_env, "psrc == csrc->mc_pg[csrc->mc_top]", __func__, 17339); } while (0); } while (0);
    do { if ((0)) do { if (__builtin_expect(!!(!(pdst == cdst->mc_pg[cdst->mc_top])), 0)) mdbx_assert_fail((cdst)->mc_txn->mt_env, "pdst == cdst->mc_pg[cdst->mc_top]", __func__, 17340); } while (0); } while (0);
  }


  csrc->mc_top--;
  mdbx_node_del(csrc, 0);
  if (csrc->mc_ki[csrc->mc_top] == 0) {
    const MDBX_val nullkey = {0, 0};
    rc = mdbx_update_key(csrc, &nullkey);
    if (__builtin_expect(!!(rc), 0)) {
      csrc->mc_top++;
      return rc;
    }
  }
  csrc->mc_top++;

  do { if ((0)) do { if (__builtin_expect(!!(!(psrc == csrc->mc_pg[csrc->mc_top])), 0)) mdbx_assert_fail((csrc)->mc_txn->mt_env, "psrc == csrc->mc_pg[csrc->mc_top]", __func__, 17356); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(pdst == cdst->mc_pg[cdst->mc_top])), 0)) mdbx_assert_fail((cdst)->mc_txn->mt_env, "pdst == cdst->mc_pg[cdst->mc_top]", __func__, 17357); } while (0); } while (0);

  {

    MDBX_cursor *m2, *m3;
    const MDBX_dbi dbi = csrc->mc_dbi;
    const unsigned top = csrc->mc_top;

    for (m2 = csrc->mc_txn->mt_cursors[dbi]; m2; m2 = m2->mc_next) {
      m3 = (csrc->mc_flags & 0x04) ? &m2->mc_xcursor->mx_cursor : m2;
      if (m3 == csrc || top >= m3->mc_snum)
        continue;
      if (m3->mc_pg[top] == psrc) {
        m3->mc_pg[top] = pdst;
        do { if ((0)) do { if (__builtin_expect(!!(!(dst_nkeys + m3->mc_ki[top] <= 
# 17371 "/libmdbx/src/core.c" 3 4
       (65535)
# 17371 "/libmdbx/src/core.c"
       )), 0)) mdbx_assert_fail((m3)->mc_txn->mt_env, "dst_nkeys + m3->mc_ki[top] <= (65535)", __func__, 17371); } while (0); } while (0);
        m3->mc_ki[top] += (indx_t)dst_nkeys;
        m3->mc_ki[top - 1] = cdst->mc_ki[top - 1];
      } else if (m3->mc_pg[top - 1] == csrc->mc_pg[top - 1] &&
                 m3->mc_ki[top - 1] > csrc->mc_ki[top - 1]) {
        m3->mc_ki[top - 1]--;
      }
      if (((m3)->mc_xcursor && ((m3)->mc_xcursor->mx_cursor.mc_flags & 0x01)) && (((psrc)->mp_flags & 0x02) != 0))
        do { MDBX_page *xr_pg = (m3->mc_pg[top]); MDBX_node *xr_node = page_node(xr_pg, m3->mc_ki[top]); if ((node_flags(xr_node) & (0x04 | 0x02)) == 0x04) (m3)->mc_xcursor->mx_cursor.mc_pg[0] = node_data(xr_node); } while (0);
    }
  }



  rc = mdbx_page_retire(csrc, (MDBX_page *)psrc);
  if (__builtin_expect(!!(rc), 0))
    return rc;

  do { if ((0)) do { if (__builtin_expect(!!(!(cdst->mc_db->md_entries > 0)), 0)) mdbx_assert_fail((cdst)->mc_txn->mt_env, "cdst->mc_db->md_entries > 0", __func__, 17389); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(cdst->mc_snum <= cdst->mc_db->md_depth)), 0)) mdbx_assert_fail((cdst)->mc_txn->mt_env, "cdst->mc_snum <= cdst->mc_db->md_depth", __func__, 17390); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(cdst->mc_top > 0)), 0)) mdbx_assert_fail((cdst)->mc_txn->mt_env, "cdst->mc_top > 0", __func__, 17391); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(cdst->mc_snum == cdst->mc_top + 1)), 0)) mdbx_assert_fail((cdst)->mc_txn->mt_env, "cdst->mc_snum == cdst->mc_top + 1", __func__, 17392); } while (0); } while (0);
  MDBX_page *const top_page = cdst->mc_pg[cdst->mc_top];
  const indx_t top_indx = cdst->mc_ki[cdst->mc_top];
  const unsigned save_snum = cdst->mc_snum;
  const uint16_t save_depth = cdst->mc_db->md_depth;
  mdbx_cursor_pop(cdst);
  rc = mdbx_rebalance(cdst);
  if (__builtin_expect(!!(rc), 0))
    return rc;

  do { if ((0)) do { if (__builtin_expect(!!(!(cdst->mc_db->md_entries > 0)), 0)) mdbx_assert_fail((cdst)->mc_txn->mt_env, "cdst->mc_db->md_entries > 0", __func__, 17402); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(cdst->mc_snum <= cdst->mc_db->md_depth)), 0)) mdbx_assert_fail((cdst)->mc_txn->mt_env, "cdst->mc_snum <= cdst->mc_db->md_depth", __func__, 17403); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(cdst->mc_snum == cdst->mc_top + 1)), 0)) mdbx_assert_fail((cdst)->mc_txn->mt_env, "cdst->mc_snum == cdst->mc_top + 1", __func__, 17404); } while (0); } while (0);


  cdst->mc_txn->mt_env->me_lck->mti_pgop_stat.merge.weak += 1;


  if ((((cdst->mc_pg[cdst->mc_top])->mp_flags & 0x02) != 0)) {

    do { if ((0)) do { if (__builtin_expect(!!(!((((cdst->mc_pg[cdst->mc_top])->mp_flags & 0x02) != 0) || ((cdst->mc_pg[cdst->mc_top])->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) == pagetype)), 0)) mdbx_assert_fail((cdst)->mc_txn->mt_env, "(((cdst->mc_pg[cdst->mc_top])->mp_flags & 0x02) != 0) || ((cdst->mc_pg[cdst->mc_top])->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) == pagetype", __func__, 17412); } while (0); } while (0)
                                                                           ;
    return MDBX_SUCCESS;
  }

  do { if ((0)) do { if (__builtin_expect(!!(!(page_numkeys(top_page) == dst_nkeys + src_nkeys)), 0)) mdbx_assert_fail((cdst)->mc_txn->mt_env, "page_numkeys(top_page) == dst_nkeys + src_nkeys", __func__, 17417); } while (0); } while (0);

  if (__builtin_expect(!!(pagetype != ((top_page)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04))), 0)) {

    goto bailout;
  }

  if (top_page == cdst->mc_pg[cdst->mc_top]) {

    do { if ((0)) do { if (__builtin_expect(!!(!(cdst->mc_ki[cdst->mc_top] == top_indx)), 0)) mdbx_assert_fail((cdst)->mc_txn->mt_env, "cdst->mc_ki[cdst->mc_top] == top_indx", __func__, 17426); } while (0); } while (0);
    do { if ((0)) do { if (__builtin_expect(!!(!((((cdst->mc_pg[cdst->mc_top])->mp_flags & 0x02) != 0) || ((cdst->mc_pg[cdst->mc_top])->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) == pagetype)), 0)) mdbx_assert_fail((cdst)->mc_txn->mt_env, "(((cdst->mc_pg[cdst->mc_top])->mp_flags & 0x02) != 0) || ((cdst->mc_pg[cdst->mc_top])->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) == pagetype", __func__, 17427); } while (0); } while (0)
                                                                           ;
    return MDBX_SUCCESS;
  }

  const int new_snum = save_snum - save_depth + cdst->mc_db->md_depth;
  if (__builtin_expect(!!(new_snum < 1 || new_snum > cdst->mc_db->md_depth), 0)) {

    goto bailout;
  }

  if (top_page == cdst->mc_pg[new_snum - 1]) {
    do { if ((0)) do { if (__builtin_expect(!!(!(cdst->mc_ki[new_snum - 1] == top_indx)), 0)) mdbx_assert_fail((cdst)->mc_txn->mt_env, "cdst->mc_ki[new_snum - 1] == top_indx", __func__, 17439); } while (0); } while (0);

    cdst->mc_snum = (uint16_t)new_snum;
    cdst->mc_top = (uint16_t)new_snum - 1;
    do { if ((0)) do { if (__builtin_expect(!!(!(cdst->mc_snum < cdst->mc_db->md_depth || (((cdst->mc_pg[cdst->mc_db->md_depth - 1])->mp_flags & 0x02) != 0))), 0)) mdbx_assert_fail((cdst)->mc_txn->mt_env, "cdst->mc_snum < cdst->mc_db->md_depth || (((cdst->mc_pg[cdst->mc_db->md_depth - 1])->mp_flags & 0x02) != 0)", __func__, 17443); } while (0); } while (0)
                                                                           ;
    do { if ((0)) do { if (__builtin_expect(!!(!((((cdst->mc_pg[cdst->mc_top])->mp_flags & 0x02) != 0) || ((cdst->mc_pg[cdst->mc_top])->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) == pagetype)), 0)) mdbx_assert_fail((cdst)->mc_txn->mt_env, "(((cdst->mc_pg[cdst->mc_top])->mp_flags & 0x02) != 0) || ((cdst->mc_pg[cdst->mc_top])->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) == pagetype", __func__, 17445); } while (0); } while (0)
                                                                           ;
    return MDBX_SUCCESS;
  }

  MDBX_page *const stub_page = (MDBX_page *)(~(uintptr_t)top_page);
  const indx_t stub_indx = top_indx;
  if (save_depth > cdst->mc_db->md_depth &&
      ((cdst->mc_pg[save_snum - 1] == top_page &&
        cdst->mc_ki[save_snum - 1] == top_indx) ||
       (cdst->mc_pg[save_snum - 1] == stub_page &&
        cdst->mc_ki[save_snum - 1] == stub_indx))) {

    cdst->mc_pg[new_snum - 1] = top_page;
    cdst->mc_ki[new_snum - 1] = top_indx;
    cdst->mc_pg[new_snum] = (MDBX_page *)(~(uintptr_t)cdst->mc_pg[new_snum]);
    cdst->mc_ki[new_snum] = ~cdst->mc_ki[new_snum];
    cdst->mc_snum = (uint16_t)new_snum;
    cdst->mc_top = (uint16_t)new_snum - 1;
    do { if ((0)) do { if (__builtin_expect(!!(!(cdst->mc_snum < cdst->mc_db->md_depth || (((cdst->mc_pg[cdst->mc_db->md_depth - 1])->mp_flags & 0x02) != 0))), 0)) mdbx_assert_fail((cdst)->mc_txn->mt_env, "cdst->mc_snum < cdst->mc_db->md_depth || (((cdst->mc_pg[cdst->mc_db->md_depth - 1])->mp_flags & 0x02) != 0)", __func__, 17464); } while (0); } while (0)
                                                                           ;
    do { if ((0)) do { if (__builtin_expect(!!(!((((cdst->mc_pg[cdst->mc_top])->mp_flags & 0x02) != 0) || ((cdst->mc_pg[cdst->mc_top])->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) == pagetype)), 0)) mdbx_assert_fail((cdst)->mc_txn->mt_env, "(((cdst->mc_pg[cdst->mc_top])->mp_flags & 0x02) != 0) || ((cdst->mc_pg[cdst->mc_top])->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) == pagetype", __func__, 17466); } while (0); } while (0)
                                                                           ;
    return MDBX_SUCCESS;
  }

bailout:

  cdst->mc_flags &= ~0x01;
  return MDBX_CURSOR_FULL;
}

static void cursor_restore(const MDBX_cursor *csrc, MDBX_cursor *cdst) {
  do { if ((0)) do { if (__builtin_expect(!!(!(cdst->mc_dbi == csrc->mc_dbi)), 0)) mdbx_assert_fail((cdst)->mc_txn->mt_env, "cdst->mc_dbi == csrc->mc_dbi", __func__, 17478); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(cdst->mc_txn == csrc->mc_txn)), 0)) mdbx_assert_fail((cdst)->mc_txn->mt_env, "cdst->mc_txn == csrc->mc_txn", __func__, 17479); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(cdst->mc_db == csrc->mc_db)), 0)) mdbx_assert_fail((cdst)->mc_txn->mt_env, "cdst->mc_db == csrc->mc_db", __func__, 17480); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(cdst->mc_dbx == csrc->mc_dbx)), 0)) mdbx_assert_fail((cdst)->mc_txn->mt_env, "cdst->mc_dbx == csrc->mc_dbx", __func__, 17481); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(cdst->mc_dbistate == csrc->mc_dbistate)), 0)) mdbx_assert_fail((cdst)->mc_txn->mt_env, "cdst->mc_dbistate == csrc->mc_dbistate", __func__, 17482); } while (0); } while (0);
  cdst->mc_snum = csrc->mc_snum;
  cdst->mc_top = csrc->mc_top;
  cdst->mc_flags = csrc->mc_flags;

  for (unsigned i = 0; i < csrc->mc_snum; i++) {
    cdst->mc_pg[i] = csrc->mc_pg[i];
    cdst->mc_ki[i] = csrc->mc_ki[i];
  }
}




static void cursor_copy(const MDBX_cursor *csrc, MDBX_cursor *cdst) {
  do { if ((0)) do { if (__builtin_expect(!!(!(csrc->mc_txn->mt_txnid >= csrc->mc_txn->mt_env->me_lck->mti_oldest_reader.weak)), 0)) mdbx_assert_fail((csrc)->mc_txn->mt_env, "csrc->mc_txn->mt_txnid >= csrc->mc_txn->mt_env->me_lck->mti_oldest_reader.weak", __func__, 17497); } while (0); } while (0)
                                                                              ;
  cdst->mc_dbi = csrc->mc_dbi;
  cdst->mc_next = 
# 17500 "/libmdbx/src/core.c" 3 4
                 ((void *)0)
# 17500 "/libmdbx/src/core.c"
                     ;
  cdst->mc_backup = 
# 17501 "/libmdbx/src/core.c" 3 4
                   ((void *)0)
# 17501 "/libmdbx/src/core.c"
                       ;
  cdst->mc_xcursor = 
# 17502 "/libmdbx/src/core.c" 3 4
                    ((void *)0)
# 17502 "/libmdbx/src/core.c"
                        ;
  cdst->mc_txn = csrc->mc_txn;
  cdst->mc_db = csrc->mc_db;
  cdst->mc_dbx = csrc->mc_dbx;
  cdst->mc_dbistate = csrc->mc_dbistate;
  cursor_restore(csrc, cdst);
}




static int mdbx_rebalance(MDBX_cursor *mc) {
  do { if ((0)) do { if (__builtin_expect(!!(!(cursor_is_tracked(mc))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "cursor_is_tracked(mc)", __func__, 17514); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_snum > 0)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mc->mc_snum > 0", __func__, 17515); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_snum < mc->mc_db->md_depth || (((mc->mc_pg[mc->mc_db->md_depth - 1])->mp_flags & 0x02) != 0))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mc->mc_snum < mc->mc_db->md_depth || (((mc->mc_pg[mc->mc_db->md_depth - 1])->mp_flags & 0x02) != 0)", __func__, 17516); } while (0); } while (0)
                                                                   ;
  const int pagetype = ((mc->mc_pg[mc->mc_top])->mp_flags & (0x01 | 0x02 | 0x20 | 0x04));

  _Static_assert(0x01 == 1, "P_BRANCH == 1");
  const unsigned minkeys = (pagetype & 0x01) + 1;


  unsigned room_threshold = __builtin_expect(!!(mc->mc_dbi != 0), 1)
                                ? mc->mc_txn->mt_env->me_merge_threshold
                                : mc->mc_txn->mt_env->me_merge_threshold_gc;

  const MDBX_page *const tp = mc->mc_pg[mc->mc_top];
  const unsigned numkeys = page_numkeys(tp);
  const unsigned room = page_room(tp);
  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 17531, "rebalancing %s page %" 
# 17531 "/libmdbx/src/core.c" 3 4
 "u" 
# 17531 "/libmdbx/src/core.c"
 " (has %u keys, full %.1f%%, used %u, room %u bytes )" "\n", (pagetype & 0x02) ? "leaf" : "branch", tp->mp_pgno, numkeys, page_fill(mc->mc_txn->mt_env, tp), page_used(mc->mc_txn->mt_env, tp), room); } while (0)



                                                     ;

  if (__builtin_expect(!!(numkeys < minkeys), 0)) {
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 17538, "page %" 
# 17538 "/libmdbx/src/core.c" 3 4
   "u" 
# 17538 "/libmdbx/src/core.c"
   " must be merged due keys < %u threshold" "\n", tp->mp_pgno, minkeys); } while (0)
                                    ;
  } else if (__builtin_expect(!!(room > room_threshold), 0)) {
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 17541, "page %" 
# 17541 "/libmdbx/src/core.c" 3 4
   "u" 
# 17541 "/libmdbx/src/core.c"
   " should be merged due room %u > %u threshold" "\n", tp->mp_pgno, room, room_threshold); } while (0)
                                                 ;
  } else {
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 17544, "no need to rebalance page %" 
# 17544 "/libmdbx/src/core.c" 3 4
   "u" 
# 17544 "/libmdbx/src/core.c"
   ", room %u < %u threshold" "\n", tp->mp_pgno, room, room_threshold); } while (0)

                                                 ;
    do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_db->md_entries > 0)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mc->mc_db->md_entries > 0", __func__, 17547); } while (0); } while (0);
    return MDBX_SUCCESS;
  }

  int rc;
  if (mc->mc_snum < 2) {
    MDBX_page *const mp = mc->mc_pg[0];
    const unsigned nkeys = page_numkeys(mp);
    do { if ((0)) do { if (__builtin_expect(!!(!((mc->mc_db->md_entries == 0) == (nkeys == 0))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "(mc->mc_db->md_entries == 0) == (nkeys == 0)", __func__, 17555); } while (0); } while (0);
    if ((((mp)->mp_flags & 0x40) != 0)) {
      do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 17557, "%s" "\n", "Can't rebalance a subpage, ignoring"); } while (0);
      do { if ((0)) do { if (__builtin_expect(!!(!(pagetype & 0x02)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "pagetype & 0x02", __func__, 17558); } while (0); } while (0);
      return MDBX_SUCCESS;
    }
    if (nkeys == 0) {
      do { if ((0)) do { if (__builtin_expect(!!(!((((mp)->mp_flags & 0x02) != 0))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "(((mp)->mp_flags & 0x02) != 0)", __func__, 17562); } while (0); } while (0);
      do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 17563, "%s" "\n", "tree is completely empty"); } while (0);
      do { if ((0)) do { if (__builtin_expect(!!(!((*mc->mc_dbistate & MDBX_DBI_DIRTY) != 0)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "(*mc->mc_dbistate & MDBX_DBI_DIRTY) != 0", __func__, 17564); } while (0); } while (0);
      mc->mc_db->md_root = (~(pgno_t)0);
      mc->mc_db->md_depth = 0;
      do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_db->md_branch_pages == 0 && mc->mc_db->md_overflow_pages == 0 && mc->mc_db->md_leaf_pages == 1)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mc->mc_db->md_branch_pages == 0 && mc->mc_db->md_overflow_pages == 0 && mc->mc_db->md_leaf_pages == 1", __func__, 17567); } while (0); } while (0)

                                                         ;

      for (MDBX_cursor *m2 = mc->mc_txn->mt_cursors[mc->mc_dbi]; m2;
           m2 = m2->mc_next) {
        MDBX_cursor *m3 =
            (mc->mc_flags & 0x04) ? &m2->mc_xcursor->mx_cursor : m2;
        if (m3 == mc || !(m3->mc_flags & 0x01))
          continue;
        if (m3->mc_pg[0] == mp) {
          m3->mc_snum = 0;
          m3->mc_top = 0;
          m3->mc_flags &= ~0x01;
        }
      }
      mc->mc_snum = 0;
      mc->mc_top = 0;
      mc->mc_flags &= ~0x01;

      rc = mdbx_page_retire(mc, mp);
      if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
        return rc;
    } else if ((((mp)->mp_flags & 0x01) != 0) && nkeys == 1) {
      do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 17591, "%s" "\n", "collapsing root page!"); } while (0);
      mc->mc_db->md_root = node_pgno(page_node(mp, 0));
      rc = mdbx_page_get(mc, mc->mc_db->md_root, &mc->mc_pg[0],
                         pp_txnid4chk(mp, mc->mc_txn));
      if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
        return rc;
      mc->mc_db->md_depth--;
      mc->mc_ki[0] = mc->mc_ki[1];
      for (int i = 1; i < mc->mc_db->md_depth; i++) {
        mc->mc_pg[i] = mc->mc_pg[i + 1];
        mc->mc_ki[i] = mc->mc_ki[i + 1];
      }


      for (MDBX_cursor *m2 = mc->mc_txn->mt_cursors[mc->mc_dbi]; m2;
           m2 = m2->mc_next) {
        MDBX_cursor *m3 =
            (mc->mc_flags & 0x04) ? &m2->mc_xcursor->mx_cursor : m2;
        if (m3 == mc || !(m3->mc_flags & 0x01))
          continue;
        if (m3->mc_pg[0] == mp) {
          for (int i = 0; i < mc->mc_db->md_depth; i++) {
            m3->mc_pg[i] = m3->mc_pg[i + 1];
            m3->mc_ki[i] = m3->mc_ki[i + 1];
          }
          m3->mc_snum--;
          m3->mc_top--;
        }
      }
      do { if ((0)) do { if (__builtin_expect(!!(!((((mc->mc_pg[mc->mc_top])->mp_flags & 0x02) != 0) || ((mc->mc_pg[mc->mc_top])->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) == pagetype)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "(((mc->mc_pg[mc->mc_top])->mp_flags & 0x02) != 0) || ((mc->mc_pg[mc->mc_top])->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) == pagetype", __func__, 17620); } while (0); } while (0)
                                                                       ;
      do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_snum < mc->mc_db->md_depth || (((mc->mc_pg[mc->mc_db->md_depth - 1])->mp_flags & 0x02) != 0))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mc->mc_snum < mc->mc_db->md_depth || (((mc->mc_pg[mc->mc_db->md_depth - 1])->mp_flags & 0x02) != 0)", __func__, 17622); } while (0); } while (0)
                                                                       ;

      rc = mdbx_page_retire(mc, mp);
      if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
        return rc;
    } else {
      do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 17629, "root page %" 
# 17629 "/libmdbx/src/core.c" 3 4
     "u" 
# 17629 "/libmdbx/src/core.c"
     " doesn't need rebalancing (flags 0x%x)" "\n", mp->mp_pgno, mp->mp_flags); } while (0)

                                           ;
    }
    return MDBX_SUCCESS;
  }



  const unsigned pre_top = mc->mc_top - 1;
  do { if ((0)) do { if (__builtin_expect(!!(!((((mc->mc_pg[pre_top])->mp_flags & 0x01) != 0))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "(((mc->mc_pg[pre_top])->mp_flags & 0x01) != 0)", __func__, 17639); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(!(((mc->mc_pg[0])->mp_flags & 0x40) != 0))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "!(((mc->mc_pg[0])->mp_flags & 0x40) != 0)", __func__, 17640); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(page_numkeys(mc->mc_pg[pre_top]) > 1)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "page_numkeys(mc->mc_pg[pre_top]) > 1", __func__, 17641); } while (0); } while (0);






  MDBX_cursor mn;
  cursor_copy(mc, &mn);

  MDBX_page *left = 
# 17651 "/libmdbx/src/core.c" 3 4
                   ((void *)0)
# 17651 "/libmdbx/src/core.c"
                          , *right = 
# 17651 "/libmdbx/src/core.c" 3 4
                                     ((void *)0)
# 17651 "/libmdbx/src/core.c"
                                            ;
  if (mn.mc_ki[pre_top] > 0) {
    rc = mdbx_page_get(
        &mn, node_pgno(page_node(mn.mc_pg[pre_top], mn.mc_ki[pre_top] - 1)),
        &left, pp_txnid4chk(mn.mc_pg[pre_top], mc->mc_txn));
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      return rc;
    do { if ((0)) do { if (__builtin_expect(!!(!(((left)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) == ((mc->mc_pg[mc->mc_top])->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "((left)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) == ((mc->mc_pg[mc->mc_top])->mp_flags & (0x01 | 0x02 | 0x20 | 0x04))", __func__, 17658); } while (0); } while (0);
  }
  if (mn.mc_ki[pre_top] + 1u < page_numkeys(mn.mc_pg[pre_top])) {
    rc = mdbx_page_get(
        &mn, node_pgno(page_node(mn.mc_pg[pre_top], mn.mc_ki[pre_top] + 1)),
        &right, pp_txnid4chk(mn.mc_pg[pre_top], mc->mc_txn));
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      return rc;
    do { if ((0)) do { if (__builtin_expect(!!(!(((right)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) == ((mc->mc_pg[mc->mc_top])->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "((right)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)) == ((mc->mc_pg[mc->mc_top])->mp_flags & (0x01 | 0x02 | 0x20 | 0x04))", __func__, 17666); } while (0); } while (0);
  }
  do { if ((0)) do { if (__builtin_expect(!!(!(left || right)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "left || right", __func__, 17668); } while (0); } while (0);

  const unsigned ki_top = mc->mc_ki[mc->mc_top];
  const unsigned ki_pre_top = mn.mc_ki[pre_top];
  const unsigned nkeys = page_numkeys(mn.mc_pg[mn.mc_top]);

  const unsigned left_room = left ? page_room(left) : 0;
  const unsigned right_room = right ? page_room(right) : 0;
  const unsigned left_nkeys = left ? page_numkeys(left) : 0;
  const unsigned right_nkeys = right ? page_numkeys(right) : 0;
retry:
  if (left_room > room_threshold && left_room >= right_room) {

    do { if ((0)) do { if (__builtin_expect(!!(!(left_nkeys >= minkeys)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "left_nkeys >= minkeys", __func__, 17681); } while (0); } while (0);
    mn.mc_pg[mn.mc_top] = left;
    mn.mc_ki[mn.mc_top - 1] = (indx_t)(ki_pre_top - 1);
    mn.mc_ki[mn.mc_top] = (indx_t)(left_nkeys - 1);
    mc->mc_ki[mc->mc_top] = 0;
    const unsigned new_ki = ki_top + left_nkeys;
    mn.mc_ki[mn.mc_top] += mc->mc_ki[mn.mc_top] + 1;

    do { do { if ((0)) do { if (__builtin_expect(!!(!(mn.mc_txn->mt_cursors != 
# 17689 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 17689 "/libmdbx/src/core.c"
   )), 0)) mdbx_assert_fail((&(mn))->mc_txn->mt_env, "mn.mc_txn->mt_cursors != ((void *)0)", __func__, 17689); } while (0); } while (0); do { if ((0)) do { if (__builtin_expect(!!(!(!cursor_is_tracked(&(mn)))), 0)) mdbx_assert_fail((&(mn))->mc_txn->mt_env, "!cursor_is_tracked(&(mn))", __func__, 17689); } while (0); } while (0); MDBX_cursor mc_dummy; MDBX_cursor **tracking_head = &(mn).mc_txn->mt_cursors[mn.mc_dbi]; MDBX_cursor *tracked = &(mn); if ((mn).mc_flags & 0x04) { mc_dummy.mc_flags = 0x01; mc_dummy.mc_top = 0; mc_dummy.mc_snum = 0; mc_dummy.mc_xcursor = (MDBX_xcursor *)&(mn); tracked = &mc_dummy; } tracked->mc_next = *tracking_head; *tracking_head = tracked; { rc = mdbx_page_merge(mc, &mn); } *tracking_head = tracked->mc_next; } while (0);
    if (__builtin_expect(!!(rc != MDBX_RESULT_TRUE), 1)) {
      cursor_restore(&mn, mc);
      mc->mc_ki[mc->mc_top] = (indx_t)new_ki;
      do { if ((0)) do { if (__builtin_expect(!!(!(rc || page_numkeys(mc->mc_pg[mc->mc_top]) >= minkeys)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "rc || page_numkeys(mc->mc_pg[mc->mc_top]) >= minkeys", __func__, 17693); } while (0); } while (0);
      return rc;
    }
  }
  if (right_room > room_threshold) {

    do { if ((0)) do { if (__builtin_expect(!!(!(right_nkeys >= minkeys)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "right_nkeys >= minkeys", __func__, 17699); } while (0); } while (0);
    mn.mc_pg[mn.mc_top] = right;
    mn.mc_ki[mn.mc_top - 1] = (indx_t)(ki_pre_top + 1);
    mn.mc_ki[mn.mc_top] = 0;
    mc->mc_ki[mc->mc_top] = (indx_t)nkeys;
    do { do { if ((0)) do { if (__builtin_expect(!!(!(mn.mc_txn->mt_cursors != 
# 17704 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 17704 "/libmdbx/src/core.c"
   )), 0)) mdbx_assert_fail((&(mn))->mc_txn->mt_env, "mn.mc_txn->mt_cursors != ((void *)0)", __func__, 17704); } while (0); } while (0); do { if ((0)) do { if (__builtin_expect(!!(!(!cursor_is_tracked(&(mn)))), 0)) mdbx_assert_fail((&(mn))->mc_txn->mt_env, "!cursor_is_tracked(&(mn))", __func__, 17704); } while (0); } while (0); MDBX_cursor mc_dummy; MDBX_cursor **tracking_head = &(mn).mc_txn->mt_cursors[mn.mc_dbi]; MDBX_cursor *tracked = &(mn); if ((mn).mc_flags & 0x04) { mc_dummy.mc_flags = 0x01; mc_dummy.mc_top = 0; mc_dummy.mc_snum = 0; mc_dummy.mc_xcursor = (MDBX_xcursor *)&(mn); tracked = &mc_dummy; } tracked->mc_next = *tracking_head; *tracking_head = tracked; { rc = mdbx_page_merge(&mn, mc); } *tracking_head = tracked->mc_next; } while (0);
    if (__builtin_expect(!!(rc != MDBX_RESULT_TRUE), 1)) {
      mc->mc_ki[mc->mc_top] = (indx_t)ki_top;
      do { if ((0)) do { if (__builtin_expect(!!(!(rc || page_numkeys(mc->mc_pg[mc->mc_top]) >= minkeys)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "rc || page_numkeys(mc->mc_pg[mc->mc_top]) >= minkeys", __func__, 17707); } while (0); } while (0);
      return rc;
    }
  }

  if (left_nkeys > minkeys &&
      (right_nkeys <= left_nkeys || right_room >= left_room)) {

    mn.mc_pg[mn.mc_top] = left;
    mn.mc_ki[mn.mc_top - 1] = (indx_t)(ki_pre_top - 1);
    mn.mc_ki[mn.mc_top] = (indx_t)(left_nkeys - 1);
    mc->mc_ki[mc->mc_top] = 0;
    do { do { if ((0)) do { if (__builtin_expect(!!(!(mn.mc_txn->mt_cursors != 
# 17719 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 17719 "/libmdbx/src/core.c"
   )), 0)) mdbx_assert_fail((&(mn))->mc_txn->mt_env, "mn.mc_txn->mt_cursors != ((void *)0)", __func__, 17719); } while (0); } while (0); do { if ((0)) do { if (__builtin_expect(!!(!(!cursor_is_tracked(&(mn)))), 0)) mdbx_assert_fail((&(mn))->mc_txn->mt_env, "!cursor_is_tracked(&(mn))", __func__, 17719); } while (0); } while (0); MDBX_cursor mc_dummy; MDBX_cursor **tracking_head = &(mn).mc_txn->mt_cursors[mn.mc_dbi]; MDBX_cursor *tracked = &(mn); if ((mn).mc_flags & 0x04) { mc_dummy.mc_flags = 0x01; mc_dummy.mc_top = 0; mc_dummy.mc_snum = 0; mc_dummy.mc_xcursor = (MDBX_xcursor *)&(mn); tracked = &mc_dummy; } tracked->mc_next = *tracking_head; *tracking_head = tracked; { rc = mdbx_node_move(&mn, mc, (1)); } *tracking_head = tracked->mc_next; } while (0);
    if (__builtin_expect(!!(rc != MDBX_RESULT_TRUE), 1)) {
      mc->mc_ki[mc->mc_top] = (indx_t)(ki_top + 1);
      do { if ((0)) do { if (__builtin_expect(!!(!(rc || page_numkeys(mc->mc_pg[mc->mc_top]) >= minkeys)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "rc || page_numkeys(mc->mc_pg[mc->mc_top]) >= minkeys", __func__, 17722); } while (0); } while (0);
      return rc;
    }
  }
  if (right_nkeys > minkeys) {

    mn.mc_pg[mn.mc_top] = right;
    mn.mc_ki[mn.mc_top - 1] = (indx_t)(ki_pre_top + 1);
    mn.mc_ki[mn.mc_top] = 0;
    mc->mc_ki[mc->mc_top] = (indx_t)nkeys;
    do { do { if ((0)) do { if (__builtin_expect(!!(!(mn.mc_txn->mt_cursors != 
# 17732 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 17732 "/libmdbx/src/core.c"
   )), 0)) mdbx_assert_fail((&(mn))->mc_txn->mt_env, "mn.mc_txn->mt_cursors != ((void *)0)", __func__, 17732); } while (0); } while (0); do { if ((0)) do { if (__builtin_expect(!!(!(!cursor_is_tracked(&(mn)))), 0)) mdbx_assert_fail((&(mn))->mc_txn->mt_env, "!cursor_is_tracked(&(mn))", __func__, 17732); } while (0); } while (0); MDBX_cursor mc_dummy; MDBX_cursor **tracking_head = &(mn).mc_txn->mt_cursors[mn.mc_dbi]; MDBX_cursor *tracked = &(mn); if ((mn).mc_flags & 0x04) { mc_dummy.mc_flags = 0x01; mc_dummy.mc_top = 0; mc_dummy.mc_snum = 0; mc_dummy.mc_xcursor = (MDBX_xcursor *)&(mn); tracked = &mc_dummy; } tracked->mc_next = *tracking_head; *tracking_head = tracked; { rc = mdbx_node_move(&mn, mc, (0)); } *tracking_head = tracked->mc_next; } while (0);
    if (__builtin_expect(!!(rc != MDBX_RESULT_TRUE), 1)) {
      mc->mc_ki[mc->mc_top] = (indx_t)ki_top;
      do { if ((0)) do { if (__builtin_expect(!!(!(rc || page_numkeys(mc->mc_pg[mc->mc_top]) >= minkeys)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "rc || page_numkeys(mc->mc_pg[mc->mc_top]) >= minkeys", __func__, 17735); } while (0); } while (0);
      return rc;
    }
  }

  if (nkeys >= minkeys) {
    mc->mc_ki[mc->mc_top] = (indx_t)ki_top;
    if (!(0))
      return MDBX_SUCCESS;
    return mdbx_cursor_check(mc, 0x200);
  }

  if (__builtin_expect(!!(room_threshold > 0), 1)) {
    room_threshold = 0;
    goto retry;
  }
  do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 17751, "Unable to merge/rebalance %s page %" 
# 17751 "/libmdbx/src/core.c" 3 4
 "u" 
# 17751 "/libmdbx/src/core.c"
 " (has %u keys, full %.1f%%, used %u, room %u bytes )" "\n", (pagetype & 0x02) ? "leaf" : "branch", tp->mp_pgno, numkeys, page_fill(mc->mc_txn->mt_env, tp), page_used(mc->mc_txn->mt_env, tp), room); } while (0)



                                                     ;
  return MDBX_PROBLEM;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static int mdbx_page_check(MDBX_cursor *const mc,
                                  const MDBX_page *const mp, unsigned options) {
  char _kbuf[511 * 4 + 2];
  options |= mc->mc_flags;
  MDBX_env *const env = mc->mc_txn->mt_env;
  const unsigned nkeys = page_numkeys(mp);
  char *const end_of_page = (char *)mp + env->me_psize;
  if (__builtin_expect(!!(mp->mp_pgno < 3 || mp->mp_pgno > 0x7FFFffffU), 0))
    return bad_page(mp, "invalid pgno (%u)\n", mp->mp_pgno);
  if (__builtin_expect(!!(((mp)->mp_flags & 0x04) != 0), 0)) {
    if (__builtin_expect(!!(mp->mp_pages < 1 && mp->mp_pages >= 0x7FFFffffU / 2), 0))
      return bad_page(mp, "invalid overflow n-pages (%u)\n", mp->mp_pages);
    if (__builtin_expect(!!(mp->mp_pgno + mp->mp_pages > mc->mc_txn->mt_geo.next), 0))
      return bad_page(mp, "overflow page beyond (%u) next-pgno\n",
                      mp->mp_pgno + mp->mp_pages);
    if (__builtin_expect(!!((options & (0x04 | 0x100)) == 0x04), 0))
      return bad_page(mp,
                      "unexpected overflow-page for dupsort db (flags 0x%x)\n",
                      mc->mc_db->md_flags);
    return MDBX_SUCCESS;
  }

  int rc = MDBX_SUCCESS;
  if ((options & 0x200) == 0 || !((mp)->mp_txnid == (mc->mc_txn)->mt_front)) {
    if (__builtin_expect(!!(nkeys < 2 && (((mp)->mp_flags & 0x01) != 0)), 0))
      rc = bad_page(mp, "branch-page nkey (%u) < 2\n", nkeys);
  }
  if (__builtin_expect(!!(((mp)->mp_flags & 0x20) != 0), 0) && __builtin_expect(!!((options & (0x04 | 0x100)) == 0), 0))
    rc = bad_page(mp, "unexpected leaf2-page (db flags 0x%x)\n",
                  mc->mc_db->md_flags);

  MDBX_val here, prev = {0, 0};
  for (unsigned i = 0; i < nkeys; ++i) {
    if (__builtin_expect(!!(((mp)->mp_flags & 0x20) != 0), 0)) {
      const size_t ksize = mp->mp_leaf2_ksize;
      char *const key = page_leaf2key(mp, i, ksize);
      if (__builtin_expect(!!(end_of_page < key + ksize), 0)) {
        rc = bad_page(mp, "leaf2-key beyond (%zu) page-end\n",
                      key + ksize - end_of_page);
        continue;
      }

      if ((options & 0x100) == 0) {
        if (__builtin_expect(!!(ksize != mc->mc_dbx->md_klen_min), 0)) {
          if (__builtin_expect(!!(ksize < mc->mc_dbx->md_klen_min || ksize > mc->mc_dbx->md_klen_max), 0)
                                                       )
            rc = bad_page(
                mp, "leaf2-key size (%zu) <> min/max key-length (%zu/%zu)\n",
                ksize, mc->mc_dbx->md_klen_min, mc->mc_dbx->md_klen_max);
          else
            mc->mc_dbx->md_klen_min = mc->mc_dbx->md_klen_max = ksize;
        }
        if ((options & 0x800) == 0) {
          here.iov_len = ksize;
          here.iov_base = key;
          if (prev.iov_base && __builtin_expect(!!(mc->mc_dbx->md_cmp(&prev, &here) >= 0), 0))
            rc = bad_page(mp, "leaf2-key #%u wrong order (%s >= %s)\n", i,
                          mdbx_dump_val(&prev, _kbuf, 511 * 2 + 1), mdbx_dump_val(&here, _kbuf + 511 * 2 + 1, 511 * 2 + 1));
          prev = here;
        }
      }
    } else {
      const MDBX_node *const node = page_node(mp, i);
      const char *node_end = (char *)node + 
# 17822 "/libmdbx/src/core.c" 3 4
                                           __builtin_offsetof (
# 17822 "/libmdbx/src/core.c"
                                           MDBX_node
# 17822 "/libmdbx/src/core.c" 3 4
                                           , 
# 17822 "/libmdbx/src/core.c"
                                           mn_data
# 17822 "/libmdbx/src/core.c" 3 4
                                           )
# 17822 "/libmdbx/src/core.c"
                                                   ;
      if (__builtin_expect(!!(node_end > end_of_page), 0)) {
        rc = bad_page(mp, "node[%u] (%zu) beyond page-end\n", i,
                      node_end - end_of_page);
        continue;
      }
      size_t ksize = node_ks(node);
      char *key = node_key(node);
      if (__builtin_expect(!!(end_of_page < key + ksize), 0)) {
        rc = bad_page(mp, "node[%u] key (%zu) beyond page-end\n", i,
                      key + ksize - end_of_page);
        continue;
      }
      if (((((mp)->mp_flags & 0x02) != 0) || i > 0) && (options & 0x100) == 0) {
        if (__builtin_expect(!!(ksize < mc->mc_dbx->md_klen_min || ksize > mc->mc_dbx->md_klen_max), 0)
                                                     )
          rc = bad_page(
              mp, "node[%u] key size (%zu) <> min/max key-length (%zu/%zu)\n",
              i, ksize, mc->mc_dbx->md_klen_min, mc->mc_dbx->md_klen_max);
        if ((options & 0x800) == 0) {
          here.iov_base = key;
          here.iov_len = ksize;
          if (prev.iov_base && __builtin_expect(!!(mc->mc_dbx->md_cmp(&prev, &here) >= 0), 0))
            rc = bad_page(mp, "node[%u] key wrong order (%s >= %s)\n", i,
                          mdbx_dump_val(&prev, _kbuf, 511 * 2 + 1), mdbx_dump_val(&here, _kbuf + 511 * 2 + 1, 511 * 2 + 1));
          prev = here;
        }
      }
      if ((((mp)->mp_flags & 0x01) != 0)) {
        if ((options & 0x200) == 0 && i == 0 && __builtin_expect(!!(ksize != 0), 0))
          rc = bad_page(mp, "branch-node[%u] wrong 0-node key-length (%zu)\n",
                        i, ksize);
        if ((options & 0x400) == 0) {
          const pgno_t ref = node_pgno(node);
          if (__builtin_expect(!!(ref < 3 || ref >= mc->mc_txn->mt_geo.next), 0))
            rc = bad_page(mp, "branch-node[%u] wrong pgno (%u)\n", i, ref);
        }
        if (__builtin_expect(!!(node_flags(node)), 0))
          rc = bad_page(mp, "branch-node[%u] wrong flags (%u)\n", i,
                        node_flags(node));
        continue;
      }

      switch (node_flags(node)) {
      default:
        rc = bad_page(mp, "invalid node[%u] flags (%u)\n", i, node_flags(node));
        break;
      case 0x01 :
      case 0 :
      case 0x02 :
      case 0x02 | 0x04 :
      case 0x04 :
        break;
      }

      const size_t dsize = node_ds(node);
      const char *const data = node_data(node);
      if (node_flags(node) & 0x01) {
        if (__builtin_expect(!!(end_of_page < data + sizeof(pgno_t)), 0)) {
          rc = bad_page(
              mp, "node-%s(%u of %u, %zu bytes) beyond (%zu) page-end\n",
              "bigdata-pgno", i, nkeys, dsize, data + dsize - end_of_page);
          continue;
        }
        if ((options & 0x100) == 0) {
          if (__builtin_expect(!!(dsize <= mc->mc_dbx->md_vlen_min || dsize > mc->mc_dbx->md_vlen_max), 0)
                                                       )
            rc = bad_page(
                mp,
                "big-node data size (%zu) <> min/max value-length (%zu/%zu)\n",
                dsize, mc->mc_dbx->md_vlen_min, mc->mc_dbx->md_vlen_max);
        }
        if ((options & 0x400) == 0) {
          MDBX_page *lp;
          int err = mdbx_page_get(mc, node_largedata_pgno(node), &lp,
                                  pp_txnid4chk(mp, mc->mc_txn));
          if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
            return err;
          if (__builtin_expect(!!(!__builtin_expect(!!(((lp)->mp_flags & 0x04) != 0), 0)), 0)) {
            rc = bad_page(mp, "big-node refs to non-overflow page (%u)\n",
                          lp->mp_pgno);
            continue;
          }
          if (__builtin_expect(!!(number_of_ovpages(env, dsize) > lp->mp_pages), 0))
            rc =
                bad_page(mp, "big-node size (%zu) mismatch n-pages size (%u)\n",
                         dsize, lp->mp_pages);
        }
        continue;
      }

      if (__builtin_expect(!!(end_of_page < data + dsize), 0)) {
        rc =
            bad_page(mp, "node-%s(%u of %u, %zu bytes) beyond (%zu) page-end\n",
                     "data", i, nkeys, dsize, data + dsize - end_of_page);
        continue;
      }

      switch (node_flags(node)) {
      default:

        continue;
      case 0 :
        if ((options & 0x100) == 0) {
          if (__builtin_expect(!!(dsize < mc->mc_dbx->md_vlen_min || dsize > mc->mc_dbx->md_vlen_max), 0)
                                                       ) {
            rc = bad_page(
                mp, "node-data size (%zu) <> min/max value-length (%zu/%zu)\n",
                dsize, mc->mc_dbx->md_vlen_min, mc->mc_dbx->md_vlen_max);
            continue;
          }
        }
        break;
      case 0x02 :
        if (__builtin_expect(!!(dsize != sizeof(MDBX_db)), 0)) {
          rc = bad_page(mp, "invalid sub-db record size (%zu)\n", dsize);
          continue;
        }
        break;
      case 0x02 | 0x04 :
        if (__builtin_expect(!!(dsize != sizeof(MDBX_db)), 0)) {
          rc = bad_page(mp, "invalid nested-db record size (%zu)\n", dsize);
          continue;
        }
        break;
      case 0x04 :
        if (__builtin_expect(!!(dsize <= ((unsigned)
# 17948 "/libmdbx/src/core.c" 3 4
           __builtin_offsetof (
# 17948 "/libmdbx/src/core.c"
           MDBX_page
# 17948 "/libmdbx/src/core.c" 3 4
           , 
# 17948 "/libmdbx/src/core.c"
           mp_ptrs
# 17948 "/libmdbx/src/core.c" 3 4
           )
# 17948 "/libmdbx/src/core.c"
           )), 0)) {
          rc = bad_page(mp, "invalid nested/sub-page record size (%zu)\n",
                        dsize);
          continue;
        } else {
          const MDBX_page *const sp = (MDBX_page *)data;
          const char *const end_of_subpage = data + dsize;
          const int nsubkeys = page_numkeys(sp);
          switch (sp->mp_flags & ~0x10) {
          case 0x02 | 0x40:
          case 0x02 | 0x20 | 0x40:
            break;
          default:
            rc = bad_page(mp, "invalid nested/sub-page flags (0x%02x)\n",
                          sp->mp_flags);
            continue;
          }

          MDBX_val sub_here, sub_prev = {0, 0};
          for (int j = 0; j < nsubkeys; j++) {
            if (__builtin_expect(!!(((sp)->mp_flags & 0x20) != 0), 0)) {

              size_t sub_ksize = sp->mp_leaf2_ksize;
              char *sub_key = page_leaf2key(sp, j, sub_ksize);
              if (__builtin_expect(!!(end_of_subpage < sub_key + sub_ksize), 0)) {
                rc = bad_page(mp, "nested-leaf2-key beyond (%zu) nested-page\n",
                              sub_key + sub_ksize - end_of_subpage);
                continue;
              }

              if ((options & 0x100) == 0) {
                if (__builtin_expect(!!(sub_ksize != mc->mc_dbx->md_vlen_min), 0)) {
                  if (__builtin_expect(!!(sub_ksize < mc->mc_dbx->md_vlen_min || sub_ksize > mc->mc_dbx->md_vlen_max), 0)
                                                                   ) {
                    rc = bad_page(mp,
                                  "nested-leaf2-key size (%zu) <> min/max "
                                  "value-length (%zu/%zu)\n",
                                  sub_ksize, mc->mc_dbx->md_vlen_min,
                                  mc->mc_dbx->md_vlen_max);
                    continue;
                  }
                  mc->mc_dbx->md_vlen_min = mc->mc_dbx->md_vlen_max = sub_ksize;
                }
                if ((options & 0x800) == 0) {
                  sub_here.iov_len = sub_ksize;
                  sub_here.iov_base = sub_key;
                  if (sub_prev.iov_base &&
                      __builtin_expect(!!(mc->mc_dbx->md_dcmp(&sub_prev, &sub_here) >= 0), 0))
                    rc = bad_page(
                        mp, "nested-leaf2-key #%u wrong order (%s >= %s)\n", j,
                        mdbx_dump_val(&sub_prev, _kbuf, 511 * 2 + 1), mdbx_dump_val(&sub_here, _kbuf + 511 * 2 + 1, 511 * 2 + 1));
                  sub_prev = sub_here;
                }
              }
            } else {
              const MDBX_node *const sub_node = page_node(sp, j);
              const char *sub_node_end = (char *)sub_node + 
# 18004 "/libmdbx/src/core.c" 3 4
                                                           __builtin_offsetof (
# 18004 "/libmdbx/src/core.c"
                                                           MDBX_node
# 18004 "/libmdbx/src/core.c" 3 4
                                                           , 
# 18004 "/libmdbx/src/core.c"
                                                           mn_data
# 18004 "/libmdbx/src/core.c" 3 4
                                                           )
# 18004 "/libmdbx/src/core.c"
                                                                   ;
              if (__builtin_expect(!!(sub_node_end > end_of_subpage), 0)) {
                rc = bad_page(mp, "nested-node beyond (%zu) nested-page\n",
                              end_of_subpage - sub_node_end);
                continue;
              }
              if (__builtin_expect(!!(node_flags(sub_node) != 0), 0))
                rc = bad_page(mp, "nested-node invalid flags (%u)\n",
                              node_flags(sub_node));

              size_t sub_ksize = node_ks(sub_node);
              char *sub_key = node_key(sub_node);
              size_t sub_dsize = node_ds(sub_node);


              if ((options & 0x100) == 0) {
                if (__builtin_expect(!!(sub_ksize < mc->mc_dbx->md_vlen_min || sub_ksize > mc->mc_dbx->md_vlen_max), 0)
                                                                 )
                  rc = bad_page(mp,
                                "nested-node-key size (%zu) <> min/max "
                                "value-length (%zu/%zu)\n",
                                sub_ksize, mc->mc_dbx->md_vlen_min,
                                mc->mc_dbx->md_vlen_max);

                if ((options & 0x800) == 0) {
                  sub_here.iov_len = sub_ksize;
                  sub_here.iov_base = sub_key;
                  if (sub_prev.iov_base &&
                      __builtin_expect(!!(mc->mc_dbx->md_dcmp(&sub_prev, &sub_here) >= 0), 0))
                    rc = bad_page(
                        mp, "nested-node-key #%u wrong order (%s >= %s)\n", j,
                        mdbx_dump_val(&sub_prev, _kbuf, 511 * 2 + 1), mdbx_dump_val(&sub_here, _kbuf + 511 * 2 + 1, 511 * 2 + 1));
                  sub_prev = sub_here;
                }
              }
              if (__builtin_expect(!!(sub_dsize != 0), 0))
                rc = bad_page(mp, "nested-node non-empty data size (%zu)\n",
                              sub_dsize);
              if (__builtin_expect(!!(end_of_subpage < sub_key + sub_ksize), 0))
                rc = bad_page(mp, "nested-node-key beyond (%zu) nested-page\n",
                              sub_key + sub_ksize - end_of_subpage);
            }
          }
        }
        break;
      }
    }
  }
  return rc;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static int mdbx_cursor_check(MDBX_cursor *mc, unsigned options) {
  do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_txn->tw.dirtyroom + mc->mc_txn->tw.dirtylist->length == (mc->mc_txn->mt_parent ? mc->mc_txn->mt_parent->tw.dirtyroom : mc->mc_txn->mt_env->me_options.dp_limit))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mc->mc_txn->tw.dirtyroom + mc->mc_txn->tw.dirtylist->length == (mc->mc_txn->mt_parent ? mc->mc_txn->mt_parent->tw.dirtyroom : mc->mc_txn->mt_env->me_options.dp_limit)", __func__, 18056); } while (0); } while (0)



                                                                   ;
  do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_top == mc->mc_snum - 1 || (options & 0x200))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mc->mc_top == mc->mc_snum - 1 || (options & 0x200)", __func__, 18061); } while (0); } while (0);
  if (__builtin_expect(!!(mc->mc_top != mc->mc_snum - 1), 0) && (options & 0x200) == 0)
    return MDBX_CURSOR_FULL;
  do { if ((0)) do { if (__builtin_expect(!!(!((options & 0x200) ? mc->mc_snum <= mc->mc_db->md_depth : mc->mc_snum == mc->mc_db->md_depth)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "(options & 0x200) ? mc->mc_snum <= mc->mc_db->md_depth : mc->mc_snum == mc->mc_db->md_depth", __func__, 18064); } while (0); } while (0)
                                                                               ;
  if (__builtin_expect(!!((options & 0x200) ? mc->mc_snum > mc->mc_db->md_depth : mc->mc_snum != mc->mc_db->md_depth), 0)
                                                                           )
    return MDBX_CURSOR_FULL;

  for (int n = 0; n < (int)mc->mc_snum; ++n) {
    MDBX_page *mp = mc->mc_pg[n];
    const unsigned nkeys = page_numkeys(mp);
    const _Bool expect_branch = (n < mc->mc_db->md_depth - 1) ? (1) : (0);
    const _Bool expect_nested_leaf =
        (n + 1 == mc->mc_db->md_depth - 1) ? (1) : (0);
    const _Bool branch = (((mp)->mp_flags & 0x01) != 0) ? (1) : (0);
    do { if ((0)) do { if (__builtin_expect(!!(!(branch == expect_branch)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "branch == expect_branch", __func__, 18077); } while (0); } while (0);
    if (__builtin_expect(!!(branch != expect_branch), 0))
      return MDBX_CURSOR_FULL;
    if ((options & 0x200) == 0) {
      do { if ((0)) do { if (__builtin_expect(!!(!(nkeys > mc->mc_ki[n] || (!branch && nkeys == mc->mc_ki[n] && (mc->mc_flags & 0x02) != 0))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "nkeys > mc->mc_ki[n] || (!branch && nkeys == mc->mc_ki[n] && (mc->mc_flags & 0x02) != 0)", __func__, 18081); } while (0); } while (0)

                                                                         ;
      if (__builtin_expect(!!(nkeys <= mc->mc_ki[n] && !(!branch && nkeys == mc->mc_ki[n] && (mc->mc_flags & 0x02) != 0)), 0)

                                                  )
        return MDBX_CURSOR_FULL;
    } else {
      do { if ((0)) do { if (__builtin_expect(!!(!(nkeys + 1 >= mc->mc_ki[n])), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "nkeys + 1 >= mc->mc_ki[n]", __func__, 18089); } while (0); } while (0);
      if (__builtin_expect(!!(nkeys + 1 < mc->mc_ki[n]), 0))
        return MDBX_CURSOR_FULL;
    }

    int err = mdbx_page_check(mc, mp, options);
    if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
      return err;

    for (unsigned i = 0; i < nkeys; ++i) {
      if (branch) {
        MDBX_node *node = page_node(mp, i);
        do { if ((0)) do { if (__builtin_expect(!!(!(node_flags(node) == 0)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "node_flags(node) == 0", __func__, 18101); } while (0); } while (0);
        if (__builtin_expect(!!(node_flags(node) != 0), 0))
          return MDBX_CURSOR_FULL;
        pgno_t pgno = node_pgno(node);
        MDBX_page *np;
        int rc = mdbx_page_get(mc, pgno, &np, pp_txnid4chk(mp, mc->mc_txn));
        do { if ((0)) do { if (__builtin_expect(!!(!(rc == MDBX_SUCCESS)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "rc == MDBX_SUCCESS", __func__, 18107); } while (0); } while (0);
        if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
          return rc;
        const _Bool nested_leaf = (((np)->mp_flags & 0x02) != 0) ? (1) : (0);
        do { if ((0)) do { if (__builtin_expect(!!(!(nested_leaf == expect_nested_leaf)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "nested_leaf == expect_nested_leaf", __func__, 18111); } while (0); } while (0);
        if (__builtin_expect(!!(nested_leaf != expect_nested_leaf), 0))
          return MDBX_CURSOR_FULL;
        err = mdbx_page_check(mc, np, options);
        if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
          return err;
      }
    }
  }
  return MDBX_SUCCESS;
}


static int mdbx_cursor_del0(MDBX_cursor *mc) {
  int rc;
  MDBX_page *mp;
  indx_t ki;
  unsigned nkeys;
  MDBX_dbi dbi = mc->mc_dbi;

  do { if ((0)) do { if (__builtin_expect(!!(!(cursor_is_tracked(mc))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "cursor_is_tracked(mc)", __func__, 18131); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!((((mc->mc_pg[mc->mc_top])->mp_flags & 0x02) != 0))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "(((mc->mc_pg[mc->mc_top])->mp_flags & 0x02) != 0)", __func__, 18132); } while (0); } while (0);
  ki = mc->mc_ki[mc->mc_top];
  mp = mc->mc_pg[mc->mc_top];
  mdbx_node_del(mc, mc->mc_db->md_xsize);
  mc->mc_db->md_entries--;


  for (MDBX_cursor *m2 = mc->mc_txn->mt_cursors[dbi]; m2; m2 = m2->mc_next) {
    MDBX_cursor *m3 = (mc->mc_flags & 0x04) ? &m2->mc_xcursor->mx_cursor : m2;
    if (m3 == mc || !(m2->mc_flags & m3->mc_flags & 0x01))
      continue;
    if (m3->mc_snum < mc->mc_snum)
      continue;
    if (m3->mc_pg[mc->mc_top] == mp) {
      if (m3->mc_ki[mc->mc_top] == ki) {
        m3->mc_flags |= 0x08;
        if (mc->mc_db->md_flags & MDBX_DUPSORT) {

          m3->mc_xcursor->mx_cursor.mc_flags &= ~(0x01 | 0x02);
        }
        continue;
      } else if (m3->mc_ki[mc->mc_top] > ki) {
        m3->mc_ki[mc->mc_top]--;
      }
      if (((m3)->mc_xcursor && ((m3)->mc_xcursor->mx_cursor.mc_flags & 0x01)))
        do { MDBX_page *xr_pg = (m3->mc_pg[mc->mc_top]); MDBX_node *xr_node = page_node(xr_pg, m3->mc_ki[mc->mc_top]); if ((node_flags(xr_node) & (0x04 | 0x02)) == 0x04) (m3)->mc_xcursor->mx_cursor.mc_pg[0] = node_data(xr_node); } while (0);
    }
  }

  rc = mdbx_rebalance(mc);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    goto bailout;

  if (__builtin_expect(!!(!mc->mc_snum), 0)) {



    do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_db->md_entries == 0 && mc->mc_db->md_depth == 0 && mc->mc_db->md_root == (~(pgno_t)0))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mc->mc_db->md_entries == 0 && mc->mc_db->md_depth == 0 && mc->mc_db->md_root == (~(pgno_t)0)", __func__, 18169); } while (0); } while (0)
                                                         ;
    mc->mc_flags |= 0x02;
    return MDBX_SUCCESS;
  }

  ki = mc->mc_ki[mc->mc_top];
  mp = mc->mc_pg[mc->mc_top];
  do { if ((0)) do { if (__builtin_expect(!!(!((((mc->mc_pg[mc->mc_top])->mp_flags & 0x02) != 0))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "(((mc->mc_pg[mc->mc_top])->mp_flags & 0x02) != 0)", __func__, 18177); } while (0); } while (0);
  nkeys = page_numkeys(mp);
  do { if ((0)) do { if (__builtin_expect(!!(!((mc->mc_db->md_entries > 0 && nkeys > 0) || ((mc->mc_flags & 0x04) && mc->mc_db->md_entries == 0 && nkeys == 0))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "(mc->mc_db->md_entries > 0 && nkeys > 0) || ((mc->mc_flags & 0x04) && mc->mc_db->md_entries == 0 && nkeys == 0)", __func__, 18179); } while (0); } while (0)

                                    ;


  for (MDBX_cursor *m2 = mc->mc_txn->mt_cursors[dbi]; m2; m2 = m2->mc_next) {
    MDBX_cursor *m3 = (mc->mc_flags & 0x04) ? &m2->mc_xcursor->mx_cursor : m2;
    if (!(m2->mc_flags & m3->mc_flags & 0x01))
      continue;
    if (m3->mc_snum < mc->mc_snum)
      continue;
    if (m3->mc_pg[mc->mc_top] == mp) {

      if (m3->mc_ki[mc->mc_top] >= nkeys) {
        rc = mdbx_cursor_sibling(m3, 2);
        if (rc == MDBX_NOTFOUND) {
          m3->mc_flags |= 0x02;
          rc = MDBX_SUCCESS;
          continue;
        }
        if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
          goto bailout;
      }
      if (m3->mc_ki[mc->mc_top] >= ki ||
                                       m3->mc_pg[mc->mc_top] != mp) {
        if (m3->mc_xcursor && !(m3->mc_flags & 0x02)) {
          MDBX_node *node =
              page_node(m3->mc_pg[m3->mc_top], m3->mc_ki[m3->mc_top]);




          if (node_flags(node) & 0x04) {
            if (m3->mc_xcursor->mx_cursor.mc_flags & 0x01) {
              if (!(node_flags(node) & 0x02))
                m3->mc_xcursor->mx_cursor.mc_pg[0] = node_data(node);
            } else {
              rc = mdbx_xcursor_init1(m3, node, m3->mc_pg[m3->mc_top]);
              if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
                goto bailout;
              rc = mdbx_cursor_first(&m3->mc_xcursor->mx_cursor, 
# 18219 "/libmdbx/src/core.c" 3 4
                                                                ((void *)0)
# 18219 "/libmdbx/src/core.c"
                                                                    , 
# 18219 "/libmdbx/src/core.c" 3 4
                                                                      ((void *)0)
# 18219 "/libmdbx/src/core.c"
                                                                          );
              if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
                goto bailout;
            }
          }
          m3->mc_xcursor->mx_cursor.mc_flags |= 0x08;
        }
        m3->mc_flags |= 0x08;
      }
    }
  }

  do { if ((0)) do { if (__builtin_expect(!!(!(rc == MDBX_SUCCESS)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "rc == MDBX_SUCCESS", __func__, 18231); } while (0); } while (0);
  if ((0))
    rc = mdbx_cursor_check(mc, 0);
  return rc;

bailout:
  mc->mc_txn->mt_flags |= 0x02;
  return rc;
}

int mdbx_del(MDBX_txn *txn, MDBX_dbi dbi, const MDBX_val *key,
             const MDBX_val *data) {
  int rc = check_txn_rw(txn, (0x01 | 0x02 | 0x10));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(!key), 0))
    return MDBX_EINVAL;

  if (__builtin_expect(!!(!check_dbi(txn, dbi, 0x20)), 0))
    return MDBX_BAD_DBI;

  if (__builtin_expect(!!(txn->mt_flags & (MDBX_TXN_RDONLY | (0x01 | 0x02 | 0x10))), 0))
    return (txn->mt_flags & MDBX_TXN_RDONLY) ? MDBX_EACCESS : MDBX_BAD_TXN;

  return mdbx_del0(txn, dbi, key, data, 0);
}

static int mdbx_del0(MDBX_txn *txn, MDBX_dbi dbi, const MDBX_val *key,
                     const MDBX_val *data, unsigned flags) {
  MDBX_cursor_couple cx;
  MDBX_cursor_op op;
  MDBX_val rdata;
  int rc;
  ((void)(0));

  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 18267, "====> delete db %u key [%s], data [%s]" "\n", dbi, ("-"), ("-")); } while (0)
                              ;

  rc = mdbx_cursor_init(&cx.outer, txn, dbi);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (data) {
    op = MDBX_GET_BOTH;
    rdata = *data;
    data = &rdata;
  } else {
    op = MDBX_SET;
    flags |= MDBX_ALLDUPS;
  }
  rc = mdbx_cursor_set(&cx.outer, (MDBX_val *)key, (MDBX_val *)data, op).err;
  if (__builtin_expect(!!(rc == MDBX_SUCCESS), 1)) {







    cx.outer.mc_next = txn->mt_cursors[dbi];
    txn->mt_cursors[dbi] = &cx.outer;
    rc = mdbx_cursor_del(&cx.outer, flags);
    txn->mt_cursors[dbi] = cx.outer.mc_next;
  }
  return rc;
}
# 18309 "/libmdbx/src/core.c"
static int mdbx_page_split(MDBX_cursor *mc, const MDBX_val *const newkey,
                           MDBX_val *const newdata, pgno_t newpgno,
                           unsigned nflags) {
  unsigned flags;
  int rc = MDBX_SUCCESS, foliage = 0;
  unsigned i, ptop;
  MDBX_env *const env = mc->mc_txn->mt_env;
  MDBX_val sepkey, rkey, xdata;
  MDBX_page *tmp_ki_copy = 
# 18317 "/libmdbx/src/core.c" 3 4
                          ((void *)0)
# 18317 "/libmdbx/src/core.c"
                              ;
  char _kbuf[511 * 4 + 2];

  MDBX_page *const mp = mc->mc_pg[mc->mc_top];
  const unsigned newindx = mc->mc_ki[mc->mc_top];
  unsigned nkeys = page_numkeys(mp);
  if ((0)) {
    rc = mdbx_cursor_check(mc, 0x200);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      return rc;
  }
  _Static_assert(0x01 == 1, "P_BRANCH == 1");
  const unsigned minkeys = (mp->mp_flags & 0x01) + 1;

  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 18331, ">> splitting %s-page %" 
# 18331 "/libmdbx/src/core.c" 3 4
 "u" 
# 18331 "/libmdbx/src/core.c"
 " and adding %zu+%zu [%s] at %i, nkeys %i" "\n", (((mp)->mp_flags & 0x02) != 0) ? "leaf" : "branch", mp->mp_pgno, newkey->iov_len, newdata ? newdata->iov_len : 0, ("-"), mc->mc_ki[mc->mc_top], nkeys); } while (0)



                                          ;
  do { if ((0)) do { if (__builtin_expect(!!(!(nkeys + 1 >= minkeys * 2)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "nkeys + 1 >= minkeys * 2", __func__, 18336); } while (0); } while (0);


  struct page_result npr = mdbx_page_new(mc, mp->mp_flags, 1);
  if (__builtin_expect(!!(npr.err != MDBX_SUCCESS), 0))
    return npr.err;
  MDBX_page *const sister = npr.page;
  sister->mp_leaf2_ksize = mp->mp_leaf2_ksize;
  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 18344, "new sibling: page %" 
# 18344 "/libmdbx/src/core.c" 3 4
 "u" 
# 18344 "/libmdbx/src/core.c"
 "\n", sister->mp_pgno); } while (0);





  if (mc->mc_top < 1) {
    npr = mdbx_page_new(mc, 0x01, 1);
    rc = npr.err;
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      goto done;
    MDBX_page *const pp = npr.page;

    do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_snum < 2 && mc->mc_db->md_depth > 0)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mc->mc_snum < 2 && mc->mc_db->md_depth > 0", __func__, 18357); } while (0); } while (0);




    mc->mc_pg[2] = mc->mc_pg[1];
    mc->mc_ki[2] = mc->mc_ki[1];
    mc->mc_pg[1] = mc->mc_pg[0];
    mc->mc_ki[1] = mc->mc_ki[0];
    mc->mc_pg[0] = pp;
    mc->mc_ki[0] = 0;
    mc->mc_db->md_root = pp->mp_pgno;
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 18369, "root split! new root = %" 
# 18369 "/libmdbx/src/core.c" 3 4
   "u" 
# 18369 "/libmdbx/src/core.c"
   "\n", pp->mp_pgno); } while (0);
    foliage = mc->mc_db->md_depth++;


    rc = mdbx_node_add_branch(mc, 0, 
# 18373 "/libmdbx/src/core.c" 3 4
                                    ((void *)0)
# 18373 "/libmdbx/src/core.c"
                                        , mp->mp_pgno);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0)) {

      mc->mc_pg[0] = mc->mc_pg[1];
      mc->mc_ki[0] = mc->mc_ki[1];
      mc->mc_db->md_root = mp->mp_pgno;
      mc->mc_db->md_depth--;
      goto done;
    }
    mc->mc_snum++;
    mc->mc_top++;
    ptop = 0;
    if ((0)) {
      rc = mdbx_cursor_check(mc, 0x200);
      if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
        goto done;
    }
  } else {
    ptop = mc->mc_top - 1;
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 18392, "parent branch page is %" 
# 18392 "/libmdbx/src/core.c" 3 4
   "u" 
# 18392 "/libmdbx/src/core.c"
   "\n", mc->mc_pg[ptop]->mp_pgno); } while (0);
  }

  MDBX_cursor mn;
  cursor_copy(mc, &mn);
  mn.mc_pg[mn.mc_top] = sister;
  mn.mc_ki[mn.mc_top] = 0;
  mn.mc_ki[ptop] = mc->mc_ki[ptop] + 1;

  unsigned split_indx =
      (newindx < nkeys)
          ? (nkeys + 1) / 2
          : nkeys - minkeys + 1;

  do { if ((0)) do { if (__builtin_expect(!!(!(!(((mp)->mp_flags & 0x01) != 0) || newindx > 0)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "!(((mp)->mp_flags & 0x01) != 0) || newindx > 0", __func__, 18406); } while (0); } while (0);

  if (__builtin_expect(!!(newindx < minkeys), 0)) {
    split_indx = minkeys;
    if (newindx == 0 && foliage == 0 && !(nflags & MDBX_APPENDDUP)) {
      split_indx = 0;


      for (i = 0; i < mc->mc_top; ++i)
        if (mc->mc_ki[i]) {
          get_key(page_node(mc->mc_pg[i], mc->mc_ki[i]), &sepkey);
          if (mc->mc_dbx->md_cmp(newkey, &sepkey) >= 0)
            split_indx = minkeys;
          break;
        }
      if (split_indx == 0) {


        if (__builtin_expect(!!(((mp)->mp_flags & 0x20) != 0), 0)) {
          sepkey.iov_len = mp->mp_leaf2_ksize;
          sepkey.iov_base = page_leaf2key(mp, 0, sepkey.iov_len);
        } else
          get_key(page_node(mp, 0), &sepkey);
        do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_dbx->md_cmp(newkey, &sepkey) < 0)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mc->mc_dbx->md_cmp(newkey, &sepkey) < 0", __func__, 18429); } while (0); } while (0);

        if (page_room(mn.mc_pg[ptop]) < branch_size(env, &sepkey))
          split_indx = minkeys;
      }
    }
  }

  const _Bool pure_right = split_indx == nkeys;
  const _Bool pure_left = split_indx == 0;
  if (__builtin_expect(!!(pure_right), 0)) {

    do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 18441, "no-split, but add new pure page at the %s" "\n", "right/after"); } while (0);
    do { if ((0)) do { if (__builtin_expect(!!(!(newindx == nkeys && split_indx == nkeys && minkeys == 1)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "newindx == nkeys && split_indx == nkeys && minkeys == 1", __func__, 18442); } while (0); } while (0);
    sepkey = *newkey;
  } else if (__builtin_expect(!!(pure_left), 0)) {

    do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 18446, "no-split, but add new pure page at the %s" "\n", "left/before"); } while (0);
    do { if ((0)) do { if (__builtin_expect(!!(!(newindx == 0 && split_indx == 0 && minkeys == 1)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "newindx == 0 && split_indx == 0 && minkeys == 1", __func__, 18447); } while (0); } while (0);
    do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 18448, "old-first-key is %s" "\n", ("-")); } while (0);
  } else {
    if (__builtin_expect(!!(((sister)->mp_flags & 0x20) != 0), 0)) {
      char *split, *ins;
      unsigned lsize, rsize, ksize;

      const int x = mc->mc_ki[mc->mc_top] - split_indx;
      ksize = mc->mc_db->md_xsize;
      split = page_leaf2key(mp, split_indx, ksize);
      rsize = (nkeys - split_indx) * ksize;
      lsize = (nkeys - split_indx) * sizeof(indx_t);
      do { if ((0)) do { if (__builtin_expect(!!(!(mp->mp_lower >= lsize)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mp->mp_lower >= lsize", __func__, 18459); } while (0); } while (0);
      mp->mp_lower -= (indx_t)lsize;
      do { if ((0)) do { if (__builtin_expect(!!(!(sister->mp_lower + lsize <= 
# 18461 "/libmdbx/src/core.c" 3 4
     (65535)
# 18461 "/libmdbx/src/core.c"
     )), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "sister->mp_lower + lsize <= (65535)", __func__, 18461); } while (0); } while (0);
      sister->mp_lower += (indx_t)lsize;
      do { if ((0)) do { if (__builtin_expect(!!(!(mp->mp_upper + rsize - lsize <= 
# 18463 "/libmdbx/src/core.c" 3 4
     (65535)
# 18463 "/libmdbx/src/core.c"
     )), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mp->mp_upper + rsize - lsize <= (65535)", __func__, 18463); } while (0); } while (0);
      mp->mp_upper += (indx_t)(rsize - lsize);
      do { if ((0)) do { if (__builtin_expect(!!(!(sister->mp_upper >= rsize - lsize)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "sister->mp_upper >= rsize - lsize", __func__, 18465); } while (0); } while (0);
      sister->mp_upper -= (indx_t)(rsize - lsize);
      sepkey.iov_len = ksize;
      sepkey.iov_base = (newindx != split_indx) ? split : newkey->iov_base;
      if (x < 0) {
        do { if ((0)) do { if (__builtin_expect(!!(!(ksize >= sizeof(indx_t))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "ksize >= sizeof(indx_t)", __func__, 18470); } while (0); } while (0);
        ins = page_leaf2key(mp, mc->mc_ki[mc->mc_top], ksize);
        memcpy(sister->mp_ptrs, split, rsize);
        sepkey.iov_base = sister->mp_ptrs;
        memmove(ins + ksize, ins, (split_indx - mc->mc_ki[mc->mc_top]) * ksize);
        memcpy(ins, newkey->iov_base, ksize);
        do { if ((0)) do { if (__builtin_expect(!!(!(
# 18476 "/libmdbx/src/core.c" 3 4
       (65535) 
# 18476 "/libmdbx/src/core.c"
       - mp->mp_lower >= (int)sizeof(indx_t))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "(65535) - mp->mp_lower >= (int)sizeof(indx_t)", __func__, 18476); } while (0); } while (0);
        mp->mp_lower += sizeof(indx_t);
        do { if ((0)) do { if (__builtin_expect(!!(!(mp->mp_upper >= ksize - sizeof(indx_t))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mp->mp_upper >= ksize - sizeof(indx_t)", __func__, 18478); } while (0); } while (0);
        mp->mp_upper -= (indx_t)(ksize - sizeof(indx_t));
      } else {
        memcpy(sister->mp_ptrs, split, x * ksize);
        ins = page_leaf2key(sister, x, ksize);
        memcpy(ins, newkey->iov_base, ksize);
        memcpy(ins + ksize, split + x * ksize, rsize - x * ksize);
        do { if ((0)) do { if (__builtin_expect(!!(!(
# 18485 "/libmdbx/src/core.c" 3 4
       (65535) 
# 18485 "/libmdbx/src/core.c"
       - sister->mp_lower >= (int)sizeof(indx_t))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "(65535) - sister->mp_lower >= (int)sizeof(indx_t)", __func__, 18485); } while (0); } while (0);
        sister->mp_lower += sizeof(indx_t);
        do { if ((0)) do { if (__builtin_expect(!!(!(sister->mp_upper >= ksize - sizeof(indx_t))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "sister->mp_upper >= ksize - sizeof(indx_t)", __func__, 18487); } while (0); } while (0);
        sister->mp_upper -= (indx_t)(ksize - sizeof(indx_t));
        do { if ((0)) do { if (__builtin_expect(!!(!(x <= (int)
# 18489 "/libmdbx/src/core.c" 3 4
       (65535)
# 18489 "/libmdbx/src/core.c"
       )), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "x <= (int)(65535)", __func__, 18489); } while (0); } while (0);
        mc->mc_ki[mc->mc_top] = (indx_t)x;
      }

      if ((0)) {
        rc = mdbx_cursor_check(mc, 0x200);
        if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
          goto done;
        rc = mdbx_cursor_check(&mn, 0x200);
        if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
          goto done;
      }
    } else {

      const unsigned max_space = page_space(env);
      const size_t new_size = (((mp)->mp_flags & 0x02) != 0) ? leaf_size(env, newkey, newdata)
                                          : branch_size(env, newkey);


      tmp_ki_copy = mdbx_page_malloc(mc->mc_txn, 1);
      if (__builtin_expect(!!(tmp_ki_copy == 
# 18509 "/libmdbx/src/core.c" 3 4
         ((void *)0)
# 18509 "/libmdbx/src/core.c"
         ), 0)) {
        rc = MDBX_ENOMEM;
        goto done;
      }


      for (unsigned j = i = 0; i < nkeys; ++i, ++j) {
        tmp_ki_copy->mp_ptrs[j] = 0;
        j += (i == newindx);
        tmp_ki_copy->mp_ptrs[j] = mp->mp_ptrs[i];
      }
      tmp_ki_copy->mp_pgno = mp->mp_pgno;
      tmp_ki_copy->mp_flags = mp->mp_flags;
      tmp_ki_copy->mp_txnid = 
# 18522 "/libmdbx/src/core.c" 3 4
                             (18446744073709551615UL)
# 18522 "/libmdbx/src/core.c"
                                          ;
      tmp_ki_copy->mp_lower = 0;
      tmp_ki_copy->mp_upper = (indx_t)max_space;
# 18541 "/libmdbx/src/core.c"
      if (nkeys < 32 || new_size > max_space / 16) {

        int dir;
        if (newindx <= split_indx) {
          i = 0;
          dir = 1;
        } else {
          i = nkeys;
          dir = -1;
        }
        size_t before = 0, after = new_size + page_used(env, mp);
        int best = split_indx;
        int best_offset = nkeys + 1;

        do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 18555, "seek separator from %u, step %i, default %u, new-idx %u, " "new-size %zu" "\n", i, dir, split_indx, newindx, new_size); } while (0)

                                                         ;
        do {
          do { if ((0)) do { if (__builtin_expect(!!(!(i <= nkeys)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "i <= nkeys", __func__, 18559); } while (0); } while (0);
          size_t size = new_size;
          if (i != newindx) {
            MDBX_node *node =
                (MDBX_node *)((char *)mp + tmp_ki_copy->mp_ptrs[i] + ((unsigned)
# 18563 "/libmdbx/src/core.c" 3 4
                                                                    __builtin_offsetof (
# 18563 "/libmdbx/src/core.c"
                                                                    MDBX_page
# 18563 "/libmdbx/src/core.c" 3 4
                                                                    , 
# 18563 "/libmdbx/src/core.c"
                                                                    mp_ptrs
# 18563 "/libmdbx/src/core.c" 3 4
                                                                    )
# 18563 "/libmdbx/src/core.c"
                                                                    ));
            size = 
# 18564 "/libmdbx/src/core.c" 3 4
                  __builtin_offsetof (
# 18564 "/libmdbx/src/core.c"
                  MDBX_node
# 18564 "/libmdbx/src/core.c" 3 4
                  , 
# 18564 "/libmdbx/src/core.c"
                  mn_data
# 18564 "/libmdbx/src/core.c" 3 4
                  ) 
# 18564 "/libmdbx/src/core.c"
                           + node_ks(node) + sizeof(indx_t);
            if ((((mp)->mp_flags & 0x02) != 0))
              size += (((node_flags(node)) & (0x01)) == (0x01)) ? sizeof(pgno_t)
                                                           : node_ds(node);
            size = (((size) + 1U) & -2);
          }

          before += size;
          after -= size;
          do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 18573, "step %u, size %zu, before %zu, after %zu, max %u" "\n", i, size, before, after, max_space); } while (0)
                                                    ;

          if (before <= max_space && after <= max_space) {
            int offset = branchless_abs(split_indx - i);
            if (offset >= best_offset)
              break;
            best_offset = offset;
            best = i;
          }
          i += dir;
        } while (i < nkeys);

        split_indx = best + (dir > 0);
        split_indx = (split_indx <= nkeys - minkeys + 1) ? split_indx
                                                         : nkeys - minkeys + 1;
        split_indx = (split_indx >= minkeys) ? split_indx : minkeys;
        do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 18590, "chosen %u" "\n", split_indx); } while (0);
      }

      sepkey.iov_len = newkey->iov_len;
      sepkey.iov_base = newkey->iov_base;
      if (split_indx != newindx) {
        MDBX_node *node =
            (MDBX_node *)((char *)mp + tmp_ki_copy->mp_ptrs[split_indx] +
                          ((unsigned)
# 18598 "/libmdbx/src/core.c" 3 4
                         __builtin_offsetof (
# 18598 "/libmdbx/src/core.c"
                         MDBX_page
# 18598 "/libmdbx/src/core.c" 3 4
                         , 
# 18598 "/libmdbx/src/core.c"
                         mp_ptrs
# 18598 "/libmdbx/src/core.c" 3 4
                         )
# 18598 "/libmdbx/src/core.c"
                         ));
        sepkey.iov_len = node_ks(node);
        sepkey.iov_base = node_key(node);
      }
    }
  }
  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 18604, "separator is %d [%s]" "\n", split_indx, ("-")); } while (0);

  _Bool did_split_parent = (0);

  if (page_room(mn.mc_pg[ptop]) < branch_size(env, &sepkey)) {
    do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 18609, "need split parent branch-page for key %s" "\n", ("-")); } while (0);
    do { if ((0)) do { if (__builtin_expect(!!(!(page_numkeys(mn.mc_pg[ptop]) > 2)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "page_numkeys(mn.mc_pg[ptop]) > 2", __func__, 18610); } while (0); } while (0);
    do { if ((0)) do { if (__builtin_expect(!!(!(!pure_left)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "!pure_left", __func__, 18611); } while (0); } while (0);
    const int snum = mc->mc_snum;
    const int depth = mc->mc_db->md_depth;
    mn.mc_snum--;
    mn.mc_top--;
    did_split_parent = (1);

    do { do { if ((0)) do { if (__builtin_expect(!!(!(mn.mc_txn->mt_cursors != 
# 18618 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 18618 "/libmdbx/src/core.c"
   )), 0)) mdbx_assert_fail((&(mn))->mc_txn->mt_env, "mn.mc_txn->mt_cursors != ((void *)0)", __func__, 18618); } while (0); } while (0); do { if ((0)) do { if (__builtin_expect(!!(!(!cursor_is_tracked(&(mn)))), 0)) mdbx_assert_fail((&(mn))->mc_txn->mt_env, "!cursor_is_tracked(&(mn))", __func__, 18618); } while (0); } while (0); MDBX_cursor mc_dummy; MDBX_cursor **tracking_head = &(mn).mc_txn->mt_cursors[mn.mc_dbi]; MDBX_cursor *tracked = &(mn); if ((mn).mc_flags & 0x04) { mc_dummy.mc_flags = 0x01; mc_dummy.mc_top = 0; mc_dummy.mc_snum = 0; mc_dummy.mc_xcursor = (MDBX_xcursor *)&(mn); tracked = &mc_dummy; } tracked->mc_next = *tracking_head; *tracking_head = tracked; { rc = mdbx_page_split(&mn, &sepkey, 
# 18618 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 18618 "/libmdbx/src/core.c"
   , sister->mp_pgno, 0); } *tracking_head = tracked->mc_next; } while (0)
                                                                         ;
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      goto done;
    do { if ((0)) do { if (__builtin_expect(!!(!((int)mc->mc_snum - snum == mc->mc_db->md_depth - depth)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "(int)mc->mc_snum - snum == mc->mc_db->md_depth - depth", __func__, 18622); } while (0); } while (0);
    if ((0)) {
      rc = mdbx_cursor_check(mc, 0x200);
      if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
        goto done;
    }


    ptop += mc->mc_snum - snum;



    if (mn.mc_pg[ptop] != mc->mc_pg[ptop] &&
        mc->mc_ki[ptop] >= page_numkeys(mc->mc_pg[ptop])) {
      for (i = 0; i < ptop; i++) {
        mc->mc_pg[i] = mn.mc_pg[i];
        mc->mc_ki[i] = mn.mc_ki[i];
      }
      mc->mc_pg[ptop] = mn.mc_pg[ptop];
      if (mn.mc_ki[ptop]) {
        mc->mc_ki[ptop] = mn.mc_ki[ptop] - 1;
      } else {

        mc->mc_ki[ptop] = mn.mc_ki[ptop];
        rc = mdbx_cursor_sibling(mc, 0);
        if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0)) {
          if (rc == MDBX_NOTFOUND) {
            do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 18649, "unexpected %i error going left sibling" "\n", rc); } while (0);
            rc = MDBX_PROBLEM;
          }
          goto done;
        }
      }
    }
  } else if (__builtin_expect(!!(pure_left), 0)) {
    MDBX_page *ptop_page = mc->mc_pg[ptop];
    do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 18658, "adding to parent page %u node[%u] left-leaf page #%u key %s" "\n", ptop_page->mp_pgno, mc->mc_ki[ptop], sister->mp_pgno, mdbx_dump_val(mc->mc_ki[ptop] ? newkey : 
# 18658 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 18658 "/libmdbx/src/core.c"
   , _kbuf, 511 * 2 + 1)); } while (0)

                                                     ;
    mc->mc_top--;
    rc = mdbx_node_add_branch(mc, mc->mc_ki[ptop],
                              mc->mc_ki[ptop] ? newkey : 
# 18663 "/libmdbx/src/core.c" 3 4
                                                        ((void *)0)
# 18663 "/libmdbx/src/core.c"
                                                            , sister->mp_pgno);
    do { if ((0)) do { if (__builtin_expect(!!(!(mp == mc->mc_pg[ptop + 1] && newindx == mc->mc_ki[ptop + 1] && ptop == mc->mc_top)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mp == mc->mc_pg[ptop + 1] && newindx == mc->mc_ki[ptop + 1] && ptop == mc->mc_top", __func__, 18664); } while (0); } while (0)
                                                                              ;

    if (__builtin_expect(!!(rc == MDBX_SUCCESS), 1) && mc->mc_ki[ptop] == 0) {
      do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 18668, "update prev-first key on parent %s" "\n", mdbx_dump_val(&sepkey, _kbuf, 511 * 2 + 1)); } while (0);
      MDBX_node *node = page_node(mc->mc_pg[ptop], 1);
      do { if ((0)) do { if (__builtin_expect(!!(!(node_ks(node) == 0 && node_pgno(node) == mp->mp_pgno)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "node_ks(node) == 0 && node_pgno(node) == mp->mp_pgno", __func__, 18670); } while (0); } while (0);
      do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_top == ptop && mc->mc_ki[ptop] == 0)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mc->mc_top == ptop && mc->mc_ki[ptop] == 0", __func__, 18671); } while (0); } while (0);
      mc->mc_ki[ptop] = 1;
      rc = mdbx_update_key(mc, &sepkey);
      do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_top == ptop && mc->mc_ki[ptop] == 1)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mc->mc_top == ptop && mc->mc_ki[ptop] == 1", __func__, 18674); } while (0); } while (0);
      do { if ((0)) do { if (__builtin_expect(!!(!(mp == mc->mc_pg[ptop + 1] && newindx == mc->mc_ki[ptop + 1])), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mp == mc->mc_pg[ptop + 1] && newindx == mc->mc_ki[ptop + 1]", __func__, 18675); } while (0); } while (0)
                                                                               ;
      mc->mc_ki[ptop] = 0;
    }

    mc->mc_top++;
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      goto done;

    MDBX_node *node = page_node(mc->mc_pg[ptop], mc->mc_ki[ptop] + 1);
    do { if ((0)) do { if (__builtin_expect(!!(!(node_pgno(node) == mp->mp_pgno && mc->mc_pg[ptop] == ptop_page)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "node_pgno(node) == mp->mp_pgno && mc->mc_pg[ptop] == ptop_page", __func__, 18685); } while (0); } while (0)
                                                      ;
  } else {
    mn.mc_top--;
    do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 18689, "add-to-parent the right-entry[%u] for new sibling-page" "\n", mn.mc_ki[ptop]); } while (0)
                              ;
    rc = mdbx_node_add_branch(&mn, mn.mc_ki[ptop], &sepkey, sister->mp_pgno);
    mn.mc_top++;
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      goto done;
  }

  if (__builtin_expect(!!(pure_left | pure_right), 0)) {
    mc->mc_pg[mc->mc_top] = sister;
    mc->mc_ki[mc->mc_top] = 0;
    switch (((sister)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04))) {
    case 0x02: {
      do { if ((0)) do { if (__builtin_expect(!!(!(newpgno == 0 || newpgno == (~(pgno_t)0))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "newpgno == 0 || newpgno == (~(pgno_t)0)", __func__, 18702); } while (0); } while (0);
      rc = mdbx_node_add_leaf(mc, 0, newkey, newdata, nflags);
    } break;
    case 0x02 | 0x20: {
      do { if ((0)) do { if (__builtin_expect(!!(!((nflags & (0x01 | 0x02 | 0x04)) == 0)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "(nflags & (0x01 | 0x02 | 0x04)) == 0", __func__, 18706); } while (0); } while (0);
      do { if ((0)) do { if (__builtin_expect(!!(!(newpgno == 0 || newpgno == (~(pgno_t)0))), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "newpgno == 0 || newpgno == (~(pgno_t)0)", __func__, 18707); } while (0); } while (0);
      rc = mdbx_node_add_leaf2(mc, 0, newkey);
    } break;
    default:
      rc = bad_page(sister, "wrong page-type %u\n", ((sister)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)));
    }
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      goto done;

    if (pure_right) {
      for (i = 0; i < mc->mc_top; i++)
        mc->mc_ki[i] = mn.mc_ki[i];
    } else if (mc->mc_ki[mc->mc_top - 1] == 0) {
      for (i = 2; i <= mc->mc_top; ++i)
        if (mc->mc_ki[mc->mc_top - i]) {
          get_key(
              page_node(mc->mc_pg[mc->mc_top - i], mc->mc_ki[mc->mc_top - i]),
              &sepkey);
          if (mc->mc_dbx->md_cmp(newkey, &sepkey) < 0) {
            mc->mc_top -= i;
            do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 18727, "update new-first on parent [%i] page %u key %s" "\n", mc->mc_ki[mc->mc_top], mc->mc_pg[mc->mc_top]->mp_pgno, mdbx_dump_val(newkey, _kbuf, 511 * 2 + 1)); } while (0)

                                    ;
            rc = mdbx_update_key(mc, newkey);
            mc->mc_top += i;
            if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
              goto done;
          }
          break;
        }
    }
  } else if (!__builtin_expect(!!(((mp)->mp_flags & 0x20) != 0), 0)) {

    mc->mc_pg[mc->mc_top] = sister;
    i = split_indx;
    unsigned n = 0;
    pgno_t pgno = 0;
    do {
      do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 18745, "i %u, nkeys %u => n %u, rp #%u" "\n", i, nkeys, n, sister->mp_pgno); } while (0)
                                 ;
      MDBX_val *rdata = 
# 18747 "/libmdbx/src/core.c" 3 4
                       ((void *)0)
# 18747 "/libmdbx/src/core.c"
                           ;
      if (i == newindx) {
        rkey.iov_base = newkey->iov_base;
        rkey.iov_len = newkey->iov_len;
        if ((((mp)->mp_flags & 0x02) != 0))
          rdata = newdata;
        else
          pgno = newpgno;
        flags = nflags;

        mc->mc_ki[mc->mc_top] = (indx_t)n;
      } else {
        MDBX_node *node =
            (MDBX_node *)((char *)mp + tmp_ki_copy->mp_ptrs[i] + ((unsigned)
# 18760 "/libmdbx/src/core.c" 3 4
                                                                __builtin_offsetof (
# 18760 "/libmdbx/src/core.c"
                                                                MDBX_page
# 18760 "/libmdbx/src/core.c" 3 4
                                                                , 
# 18760 "/libmdbx/src/core.c"
                                                                mp_ptrs
# 18760 "/libmdbx/src/core.c" 3 4
                                                                )
# 18760 "/libmdbx/src/core.c"
                                                                ));
        rkey.iov_base = node_key(node);
        rkey.iov_len = node_ks(node);
        if ((((mp)->mp_flags & 0x02) != 0)) {
          xdata.iov_base = node_data(node);
          xdata.iov_len = node_ds(node);
          rdata = &xdata;
        } else
          pgno = node_pgno(node);
        flags = node_flags(node);
      }

      switch (((sister)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04))) {
      case 0x01: {
        do { if ((0)) do { if (__builtin_expect(!!(!(0 == (uint16_t)flags)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "0 == (uint16_t)flags", __func__, 18774); } while (0); } while (0);

        rc = mdbx_node_add_branch(mc, n, n ? &rkey : 
# 18776 "/libmdbx/src/core.c" 3 4
                                                    ((void *)0)
# 18776 "/libmdbx/src/core.c"
                                                        , pgno);
      } break;
      case 0x02: {
        do { if ((0)) do { if (__builtin_expect(!!(!(pgno == 0)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "pgno == 0", __func__, 18779); } while (0); } while (0);
        do { if ((0)) do { if (__builtin_expect(!!(!(rdata != 
# 18780 "/libmdbx/src/core.c" 3 4
       ((void *)0)
# 18780 "/libmdbx/src/core.c"
       )), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "rdata != ((void *)0)", __func__, 18780); } while (0); } while (0);
        rc = mdbx_node_add_leaf(mc, n, &rkey, rdata, flags);
      } break;





      default:
        rc = bad_page(sister, "wrong page-type %u\n", ((sister)->mp_flags & (0x01 | 0x02 | 0x20 | 0x04)));
      }
      if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
        goto done;

      ++n;
      if (++i > nkeys) {
        i = 0;
        n = 0;
        mc->mc_pg[mc->mc_top] = tmp_ki_copy;
        do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 18799, "switch to mp #%u" "\n", tmp_ki_copy->mp_pgno); } while (0);
      }
    } while (i != split_indx);

    do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 18803, "i %u, nkeys %u, n %u, pgno #%u" "\n", i, nkeys, n, mc->mc_pg[mc->mc_top]->mp_pgno); } while (0)
                                              ;

    nkeys = page_numkeys(tmp_ki_copy);
    for (i = 0; i < nkeys; i++)
      mp->mp_ptrs[i] = tmp_ki_copy->mp_ptrs[i];
    mp->mp_lower = tmp_ki_copy->mp_lower;
    mp->mp_upper = tmp_ki_copy->mp_upper;
    memcpy(page_node(mp, nkeys - 1), page_node(tmp_ki_copy, nkeys - 1),
           env->me_psize - tmp_ki_copy->mp_upper - ((unsigned)
# 18812 "/libmdbx/src/core.c" 3 4
                                                  __builtin_offsetof (
# 18812 "/libmdbx/src/core.c"
                                                  MDBX_page
# 18812 "/libmdbx/src/core.c" 3 4
                                                  , 
# 18812 "/libmdbx/src/core.c"
                                                  mp_ptrs
# 18812 "/libmdbx/src/core.c" 3 4
                                                  )
# 18812 "/libmdbx/src/core.c"
                                                  ));


    if (newindx < split_indx) {
      mc->mc_pg[mc->mc_top] = mp;
    } else {
      mc->mc_pg[mc->mc_top] = sister;
      mc->mc_ki[ptop]++;

      if (mn.mc_pg[ptop] != mc->mc_pg[ptop] &&
          mc->mc_ki[ptop] >= page_numkeys(mc->mc_pg[ptop])) {
        for (i = 0; i <= ptop; i++) {
          mc->mc_pg[i] = mn.mc_pg[i];
          mc->mc_ki[i] = mn.mc_ki[i];
        }
      }
    }
  } else if (newindx >= split_indx) {
    mc->mc_pg[mc->mc_top] = sister;
    mc->mc_ki[ptop]++;

    if (mn.mc_pg[ptop] != mc->mc_pg[ptop] &&
        mc->mc_ki[ptop] >= page_numkeys(mc->mc_pg[ptop])) {
      for (i = 0; i <= ptop; i++) {
        mc->mc_pg[i] = mn.mc_pg[i];
        mc->mc_ki[i] = mn.mc_ki[i];
      }
    }
  }


  nkeys = page_numkeys(mp);
  for (MDBX_cursor *m2 = mc->mc_txn->mt_cursors[mc->mc_dbi]; m2;
       m2 = m2->mc_next) {
    MDBX_cursor *m3 = (mc->mc_flags & 0x04) ? &m2->mc_xcursor->mx_cursor : m2;
    if (m3 == mc)
      continue;
    if (!(m2->mc_flags & m3->mc_flags & 0x01))
      continue;
    if (foliage) {

      if (m3->mc_pg[0] != mp)
        continue;

      for (int k = foliage; k >= 0; k--) {
        m3->mc_ki[k + 1] = m3->mc_ki[k];
        m3->mc_pg[k + 1] = m3->mc_pg[k];
      }
      m3->mc_ki[0] = (m3->mc_ki[0] >= nkeys) ? 1 : 0;
      m3->mc_pg[0] = mc->mc_pg[0];
      m3->mc_snum++;
      m3->mc_top++;
    }

    if (m3->mc_top >= mc->mc_top && m3->mc_pg[mc->mc_top] == mp && !pure_left) {
      if (m3->mc_ki[mc->mc_top] >= newindx && !(nflags & MDBX_APPENDDUP))
        m3->mc_ki[mc->mc_top]++;
      if (m3->mc_ki[mc->mc_top] >= nkeys) {
        m3->mc_pg[mc->mc_top] = sister;
        do { if ((0)) do { if (__builtin_expect(!!(!(m3->mc_ki[mc->mc_top] >= nkeys)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "m3->mc_ki[mc->mc_top] >= nkeys", __func__, 18871); } while (0); } while (0);
        m3->mc_ki[mc->mc_top] -= (indx_t)nkeys;
        for (i = 0; i < mc->mc_top; i++) {
          m3->mc_ki[i] = mn.mc_ki[i];
          m3->mc_pg[i] = mn.mc_pg[i];
        }
      }
    } else if (!did_split_parent && m3->mc_top >= ptop &&
               m3->mc_pg[ptop] == mc->mc_pg[ptop] &&
               m3->mc_ki[ptop] >= mc->mc_ki[ptop]) {
      m3->mc_ki[ptop]++;
    }
    if (((m3)->mc_xcursor && ((m3)->mc_xcursor->mx_cursor.mc_flags & 0x01)) && (((mp)->mp_flags & 0x02) != 0))
      do { MDBX_page *xr_pg = (m3->mc_pg[mc->mc_top]); MDBX_node *xr_node = page_node(xr_pg, m3->mc_ki[mc->mc_top]); if ((node_flags(xr_node) & (0x04 | 0x02)) == 0x04) (m3)->mc_xcursor->mx_cursor.mc_pg[0] = node_data(xr_node); } while (0);
  }
  do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 18886, "mp #%u left: %d, sister #%u left: %d" "\n", mp->mp_pgno, page_room(mp), sister->mp_pgno, page_room(sister)); } while (0)
                                                ;

done:
  if (tmp_ki_copy)
    mdbx_dpage_free(env, tmp_ki_copy, 1);

  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    mc->mc_txn->mt_flags |= 0x02;
  else {
    if ((0))
      rc = mdbx_cursor_check(mc, 0x200);
    if (__builtin_expect(!!(nflags & MDBX_RESERVE), 0)) {
      MDBX_node *node = page_node(mc->mc_pg[mc->mc_top], mc->mc_ki[mc->mc_top]);
      if (!(node_flags(node) & 0x01))
        newdata->iov_base = node_data(node);
    }

    env->me_lck->mti_pgop_stat.split.weak += 1;

  }

  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 18908, "<< mp #%u, rc %d" "\n", mp->mp_pgno, rc); } while (0);
  return rc;
}

int mdbx_put(MDBX_txn *txn, MDBX_dbi dbi, const MDBX_val *key, MDBX_val *data,
             unsigned flags) {
  int rc = check_txn_rw(txn, (0x01 | 0x02 | 0x10));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(!key || !data), 0))
    return MDBX_EINVAL;

  if (__builtin_expect(!!(!check_dbi(txn, dbi, 0x20)), 0))
    return MDBX_BAD_DBI;

  if (__builtin_expect(!!(flags & ~(MDBX_NOOVERWRITE | MDBX_NODUPDATA | MDBX_ALLDUPS | MDBX_ALLDUPS | MDBX_RESERVE | MDBX_APPEND | MDBX_APPENDDUP | MDBX_CURRENT | MDBX_MULTIPLE)), 0)

                                                                        )
    return MDBX_EINVAL;

  if (__builtin_expect(!!(txn->mt_flags & (MDBX_TXN_RDONLY | (0x01 | 0x02 | 0x10))), 0))
    return (txn->mt_flags & MDBX_TXN_RDONLY) ? MDBX_EACCESS : MDBX_BAD_TXN;

  MDBX_cursor_couple cx;
  rc = mdbx_cursor_init(&cx.outer, txn, dbi);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;
  cx.outer.mc_next = txn->mt_cursors[dbi];
  txn->mt_cursors[dbi] = &cx.outer;


  if (flags & MDBX_CURRENT) {
    rc = mdbx_cursor_get(&cx.outer, (MDBX_val *)key, 
# 18941 "/libmdbx/src/core.c" 3 4
                                                    ((void *)0)
# 18941 "/libmdbx/src/core.c"
                                                        , MDBX_SET);
    if (__builtin_expect(!!(rc == MDBX_SUCCESS), 1) &&
        (txn->mt_dbs[dbi].md_flags & MDBX_DUPSORT) &&
        (flags & MDBX_ALLDUPS) == 0) {

      MDBX_node *node = page_node(cx.outer.mc_pg[cx.outer.mc_top],
                                  cx.outer.mc_ki[cx.outer.mc_top]);
      if ((((node_flags(node)) & (0x04)) == (0x04))) {
        do { if ((0)) do { if (__builtin_expect(!!(!(((&cx.outer)->mc_xcursor && ((&cx.outer)->mc_xcursor->mx_cursor.mc_flags & 0x01)) && cx.outer.mc_xcursor->mx_db.md_entries > 1)), 0)) mdbx_assert_fail((txn)->mt_env, "((&cx.outer)->mc_xcursor && ((&cx.outer)->mc_xcursor->mx_cursor.mc_flags & 0x01)) && cx.outer.mc_xcursor->mx_db.md_entries > 1", __func__, 18949); } while (0); } while (0)
                                                                        ;
        rc = MDBX_EMULTIVAL;
      }
    }
  }

  if (__builtin_expect(!!(rc == MDBX_SUCCESS), 1))
    rc = mdbx_cursor_put(&cx.outer, key, data, flags);
  txn->mt_cursors[dbi] = cx.outer.mc_next;

  return rc;
}




typedef struct mdbx_copy {
  MDBX_env *mc_env;
  MDBX_txn *mc_txn;
  mdbx_condpair_t mc_condpair;
  uint8_t *mc_wbuf[2];
  uint8_t *mc_over[2];
  size_t mc_wlen[2];
  size_t mc_olen[2];
  mdbx_filehandle_t mc_fd;


  volatile int mc_error;
  pgno_t mc_next_pgno;
  volatile unsigned mc_head;
  volatile unsigned mc_tail;
} mdbx_copy;


__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static void * mdbx_env_copythr(void *arg) {
  mdbx_copy *my = arg;


  sigset_t sigset;
  sigemptyset(&sigset);
  sigaddset(&sigset, 
# 18990 "/libmdbx/src/core.c" 3 4
                    13
# 18990 "/libmdbx/src/core.c"
                           );
  my->mc_error = pthread_sigmask(
# 18991 "/libmdbx/src/core.c" 3 4
                                0
# 18991 "/libmdbx/src/core.c"
                                         , &sigset, 
# 18991 "/libmdbx/src/core.c" 3 4
                                                    ((void *)0)
# 18991 "/libmdbx/src/core.c"
                                                        );


  mdbx_condpair_lock(&my->mc_condpair);
  while (!my->mc_error) {
    while (my->mc_tail == my->mc_head && !my->mc_error) {
      int err = mdbx_condpair_wait(&my->mc_condpair, (1));
      if (err != MDBX_SUCCESS) {
        my->mc_error = err;
        goto bailout;
      }
    }
    const unsigned toggle = my->mc_tail & 1;
    size_t wsize = my->mc_wlen[toggle];
    if (wsize == 0) {
      my->mc_tail += 1;
      break ;
    }
    my->mc_wlen[toggle] = 0;
    uint8_t *ptr = my->mc_wbuf[toggle];
  again:
    if (!my->mc_error) {
      int err = mdbx_write(my->mc_fd, ptr, wsize);
      if (err != MDBX_SUCCESS) {

        if (err == 
# 19016 "/libmdbx/src/core.c" 3 4
                  32
# 19016 "/libmdbx/src/core.c"
                       ) {


          int unused;
          sigwait(&sigset, &unused);
        }

        my->mc_error = err;
        goto bailout;
      }
    }


    wsize = my->mc_olen[toggle];
    if (wsize) {
      my->mc_olen[toggle] = 0;
      ptr = my->mc_over[toggle];
      goto again;
    }
    my->mc_tail += 1;
    mdbx_condpair_signal(&my->mc_condpair, (0));
  }
bailout:
  mdbx_condpair_unlock(&my->mc_condpair);
  return (void *)0;
}


__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static int mdbx_env_cthr_toggle(mdbx_copy *my) {
  mdbx_condpair_lock(&my->mc_condpair);
  do { if ((0)) do { if (__builtin_expect(!!(!(my->mc_head - my->mc_tail < 2 || my->mc_error)), 0)) mdbx_assert_fail(my->mc_env, "my->mc_head - my->mc_tail < 2 || my->mc_error", __func__, 19046); } while (0); } while (0);
  my->mc_head += 1;
  mdbx_condpair_signal(&my->mc_condpair, (1));
  while (!my->mc_error &&
         my->mc_head - my->mc_tail == 2 ) {
    int err = mdbx_condpair_wait(&my->mc_condpair, (0));
    if (err != MDBX_SUCCESS)
      my->mc_error = err;
  }
  mdbx_condpair_unlock(&my->mc_condpair);
  return my->mc_error;
}





__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static int mdbx_env_cwalk(mdbx_copy *my, pgno_t *pg, int flags) {
  MDBX_cursor_couple couple;
  MDBX_page *mo, *mp, *leaf;
  char *buf, *ptr;
  int rc;
  unsigned i;


  if (*pg == (~(pgno_t)0))
    return MDBX_SUCCESS;

  memset(&couple, 0, sizeof(couple));
  couple.outer.mc_snum = 1;
  couple.outer.mc_txn = my->mc_txn;
  couple.outer.mc_flags = couple.inner.mx_cursor.mc_flags =
      0x100 | 0x800;

  rc = mdbx_page_get(&couple.outer, *pg, &couple.outer.mc_pg[0],
                     my->mc_txn->mt_txnid);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;
  rc = mdbx_page_search_root(&couple.outer, 
# 19084 "/libmdbx/src/core.c" 3 4
                                           ((void *)0)
# 19084 "/libmdbx/src/core.c"
                                               , 4);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;


  buf = ptr = malloc(pgno2bytes(my->mc_env, couple.outer.mc_snum));
  if (buf == 
# 19090 "/libmdbx/src/core.c" 3 4
            ((void *)0)
# 19090 "/libmdbx/src/core.c"
                )
    return MDBX_ENOMEM;

  for (i = 0; i < couple.outer.mc_top; i++) {
    mdbx_page_copy((MDBX_page *)ptr, couple.outer.mc_pg[i],
                   my->mc_env->me_psize);
    couple.outer.mc_pg[i] = (MDBX_page *)ptr;
    ptr += my->mc_env->me_psize;
  }


  leaf = (MDBX_page *)ptr;

  while (couple.outer.mc_snum > 0) {
    mp = couple.outer.mc_pg[couple.outer.mc_top];
    unsigned n = page_numkeys(mp);

    if ((((mp)->mp_flags & 0x02) != 0)) {
      if (!__builtin_expect(!!(((mp)->mp_flags & 0x20) != 0), 0) && !(flags & 0x04)) {
        for (i = 0; i < n; i++) {
          MDBX_node *node = page_node(mp, i);
          if (node_flags(node) & 0x01) {
            MDBX_page *omp;


            if (mp != leaf) {
              couple.outer.mc_pg[couple.outer.mc_top] = leaf;
              mdbx_page_copy(leaf, mp, my->mc_env->me_psize);
              mp = leaf;
              node = page_node(mp, i);
            }

            const pgno_t pgno = node_largedata_pgno(node);
            poke_pgno(node_data(node), my->mc_next_pgno);
            rc = mdbx_page_get(&couple.outer, pgno, &omp,
                               pp_txnid4chk(mp, my->mc_txn));
            if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
              goto done;
            unsigned toggle = my->mc_head & 1;
            if (my->mc_wlen[toggle] + my->mc_env->me_psize >
                ((size_t)(1048576u))) {
              rc = mdbx_env_cthr_toggle(my);
              if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
                goto done;
              toggle = my->mc_head & 1;
            }
            mo = (MDBX_page *)(my->mc_wbuf[toggle] + my->mc_wlen[toggle]);
            memcpy(mo, omp, my->mc_env->me_psize);
            mo->mp_pgno = my->mc_next_pgno;
            my->mc_next_pgno += omp->mp_pages;
            my->mc_wlen[toggle] += my->mc_env->me_psize;
            if (omp->mp_pages > 1) {
              my->mc_olen[toggle] = pgno2bytes(my->mc_env, omp->mp_pages - 1);
              my->mc_over[toggle] = (uint8_t *)omp + my->mc_env->me_psize;
              rc = mdbx_env_cthr_toggle(my);
              if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
                goto done;
              toggle = my->mc_head & 1;
            }
          } else if (node_flags(node) & 0x02) {
            if (!0 &&
                __builtin_expect(!!(node_ds(node) != sizeof(MDBX_db)), 0)) {
              rc = MDBX_CORRUPTED;
              goto done;
            }


            if (mp != leaf) {
              couple.outer.mc_pg[couple.outer.mc_top] = leaf;
              mdbx_page_copy(leaf, mp, my->mc_env->me_psize);
              mp = leaf;
              node = page_node(mp, i);
            }

            MDBX_db db;
            memcpy(&db, node_data(node), sizeof(MDBX_db));
            rc = mdbx_env_cwalk(my, &db.md_root, node_flags(node) & 0x04);
            if (rc)
              goto done;
            memcpy(node_data(node), &db, sizeof(MDBX_db));
          }
        }
      }
    } else {
      couple.outer.mc_ki[couple.outer.mc_top]++;
      if (couple.outer.mc_ki[couple.outer.mc_top] < n) {
      again:
        rc = mdbx_page_get(
            &couple.outer,
            node_pgno(page_node(mp, couple.outer.mc_ki[couple.outer.mc_top])),
            &mp, pp_txnid4chk(mp, my->mc_txn));
        if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
          goto done;
        couple.outer.mc_top++;
        couple.outer.mc_snum++;
        couple.outer.mc_ki[couple.outer.mc_top] = 0;
        if ((((mp)->mp_flags & 0x01) != 0)) {


          mdbx_page_copy(couple.outer.mc_pg[couple.outer.mc_top], mp,
                         my->mc_env->me_psize);
          goto again;
        } else
          couple.outer.mc_pg[couple.outer.mc_top] = mp;
        continue;
      }
    }
    unsigned toggle = my->mc_head & 1;
    if (my->mc_wlen[toggle] + my->mc_wlen[toggle] >
        ((size_t)(1048576u))) {
      rc = mdbx_env_cthr_toggle(my);
      if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
        goto done;
      toggle = my->mc_head & 1;
    }
    mo = (MDBX_page *)(my->mc_wbuf[toggle] + my->mc_wlen[toggle]);
    mdbx_page_copy(mo, mp, my->mc_env->me_psize);
    mo->mp_pgno = my->mc_next_pgno++;
    my->mc_wlen[toggle] += my->mc_env->me_psize;
    if (couple.outer.mc_top) {

      node_set_pgno(page_node(couple.outer.mc_pg[couple.outer.mc_top - 1],
                              couple.outer.mc_ki[couple.outer.mc_top - 1]),
                    mo->mp_pgno);
      mdbx_cursor_pop(&couple.outer);
    } else {

      *pg = mo->mp_pgno;
      break;
    }
  }
done:
  free(buf);
  return rc;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static void compact_fixup_meta(MDBX_env *env, MDBX_meta *meta) {

  if (meta->mm_geo.next != meta->mm_geo.now) {
    meta->mm_geo.now = meta->mm_geo.next;
    const pgno_t aligner = pv2pages(
        meta->mm_geo.grow_pv ? meta->mm_geo.grow_pv : meta->mm_geo.shrink_pv);
    if (aligner) {
      const pgno_t aligned = pgno_align2os_pgno(
          env, meta->mm_geo.next + aligner - meta->mm_geo.next % aligner);
      meta->mm_geo.now = aligned;
    }
  }

  if (meta->mm_geo.now < meta->mm_geo.lower)
    meta->mm_geo.now = meta->mm_geo.lower;
  if (meta->mm_geo.now > meta->mm_geo.upper)
    meta->mm_geo.now = meta->mm_geo.upper;


  do { if ((0)) do { if (__builtin_expect(!!(!(meta->mm_geo.now >= meta->mm_geo.next)), 0)) mdbx_assert_fail(
# 19245 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 19245 "/libmdbx/src/core.c"
 , "meta->mm_geo.now >= meta->mm_geo.next", __func__, 19245); } while (0); } while (0);
  unaligned_poke_u64(4, meta->mm_datasync_sign, meta_sign(meta));
}


__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static void make_sizeable(MDBX_meta *meta) {
  meta->mm_geo.lower = 3;
  if (meta->mm_geo.grow_pv == 0) {
    const pgno_t step = 1 + (meta->mm_geo.upper - meta->mm_geo.lower) / 42;
    meta->mm_geo.grow_pv = pages2pv(step);
  }
  if (meta->mm_geo.shrink_pv == 0) {
    const pgno_t step = pv2pages(meta->mm_geo.grow_pv) << 1;
    meta->mm_geo.shrink_pv = pages2pv(step);
  }
}


__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static int mdbx_env_compact(MDBX_env *env, MDBX_txn *read_txn,
                                   mdbx_filehandle_t fd, uint8_t *buffer,
                                   const _Bool dest_is_pipe, const int flags) {
  const size_t meta_bytes = pgno2bytes(env, 3);
  uint8_t *const data_buffer =
      buffer + ceil_powerof2(meta_bytes, env->me_os_psize);
  MDBX_meta *const meta = mdbx_init_metas(env, buffer);
  meta_set_txnid(env, meta, read_txn->mt_txnid);

  if (flags & MDBX_CP_FORCE_DYNAMIC_SIZE)
    make_sizeable(meta);


  if (read_txn->mt_canary.v) {
    meta->mm_canary = read_txn->mt_canary;
    meta->mm_canary.v = constmeta_txnid(env, meta);
  }


  pgno_t new_root, root = read_txn->mt_dbs[1].md_root;
  if ((new_root = root) == (~(pgno_t)0)) {


    meta->mm_dbs[1].md_flags = read_txn->mt_dbs[1].md_flags;
    compact_fixup_meta(env, meta);
    if (dest_is_pipe) {
      int rc = mdbx_write(fd, buffer, meta_bytes);
      if (rc != MDBX_SUCCESS)
        return rc;
    }
  } else {


    pgno_t freecount = 0;
    MDBX_cursor_couple couple;
    MDBX_val key, data;

    int rc = mdbx_cursor_init(&couple.outer, read_txn, 0);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      return rc;
    while ((rc = mdbx_cursor_get(&couple.outer, &key, &data, MDBX_NEXT)) == 0)
      freecount += *(pgno_t *)data.iov_base;
    if (__builtin_expect(!!(rc != MDBX_NOTFOUND), 0))
      return rc;

    freecount += read_txn->mt_dbs[0].md_branch_pages +
                 read_txn->mt_dbs[0].md_leaf_pages +
                 read_txn->mt_dbs[0].md_overflow_pages;

    new_root = read_txn->mt_geo.next - 1 - freecount;
    meta->mm_geo.next = new_root + 1;
    meta->mm_dbs[1] = read_txn->mt_dbs[1];
    meta->mm_dbs[1].md_root = new_root;

    mdbx_copy ctx;
    memset(&ctx, 0, sizeof(ctx));
    rc = mdbx_condpair_init(&ctx.mc_condpair);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      return rc;

    memset(data_buffer, 0, ((size_t)(1048576u)) * 2);
    ctx.mc_wbuf[0] = data_buffer;
    ctx.mc_wbuf[1] = data_buffer + ((size_t)(1048576u));
    ctx.mc_next_pgno = 3;
    ctx.mc_env = env;
    ctx.mc_fd = fd;
    ctx.mc_txn = read_txn;

    mdbx_thread_t thread;
    int thread_err = mdbx_thread_create(&thread, mdbx_env_copythr, &ctx);
    if (__builtin_expect(!!(thread_err == MDBX_SUCCESS), 1)) {
      if (dest_is_pipe) {
        compact_fixup_meta(env, meta);
        rc = mdbx_write(fd, buffer, meta_bytes);
      }
      if (rc == MDBX_SUCCESS)
        rc = mdbx_env_cwalk(&ctx, &root, 0);
      mdbx_env_cthr_toggle(&ctx);
      mdbx_env_cthr_toggle(&ctx);
      thread_err = mdbx_thread_join(thread);
      do { if ((0)) do { if (__builtin_expect(!!(!((ctx.mc_tail == ctx.mc_head && ctx.mc_wlen[ctx.mc_head & 1] == 0) || ctx.mc_error)), 0)) mdbx_assert_fail(env, "(ctx.mc_tail == ctx.mc_head && ctx.mc_wlen[ctx.mc_head & 1] == 0) || ctx.mc_error", __func__, 19343); } while (0); } while (0)

                                        ;
      mdbx_condpair_destroy(&ctx.mc_condpair);
    }
    if (__builtin_expect(!!(thread_err != MDBX_SUCCESS), 0))
      return thread_err;
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      return rc;
    if (__builtin_expect(!!(ctx.mc_error != MDBX_SUCCESS), 0))
      return ctx.mc_error;

    if (dest_is_pipe) {
      if (__builtin_expect(!!(root != new_root), 0)) {
        do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 19357, "post-compactification root %" 
# 19357 "/libmdbx/src/core.c" 3 4
       "u" 
# 19357 "/libmdbx/src/core.c"
       " NE expected %" 
# 19357 "/libmdbx/src/core.c" 3 4
       "u" 
# 19357 "/libmdbx/src/core.c"
       " (source DB corrupted or has a page leak(s))" "\n", root, new_root); } while (0)


                                  ;
        return MDBX_CORRUPTED;
      }
    } else {
      if (__builtin_expect(!!(root > new_root), 0)) {
        do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 19365, "post-compactification root %" 
# 19365 "/libmdbx/src/core.c" 3 4
       "u" 
# 19365 "/libmdbx/src/core.c"
       " GT expected %" 
# 19365 "/libmdbx/src/core.c" 3 4
       "u" 
# 19365 "/libmdbx/src/core.c"
       " (source DB corrupted)" "\n", root, new_root); } while (0)

                                  ;
        return MDBX_CORRUPTED;
      }
      if (__builtin_expect(!!(root < new_root), 0)) {
        do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 19371, "post-compactification root %" 
# 19371 "/libmdbx/src/core.c" 3 4
       "u" 
# 19371 "/libmdbx/src/core.c"
       " LT expected %" 
# 19371 "/libmdbx/src/core.c" 3 4
       "u" 
# 19371 "/libmdbx/src/core.c"
       " (page leak(s) in source DB)" "\n", root, new_root); } while (0)

                                    ;

        meta->mm_dbs[1].md_root = root;
        meta->mm_geo.next = root + 1;
      }
      compact_fixup_meta(env, meta);
    }
  }


  if (meta->mm_geo.now != meta->mm_geo.next) {
    const size_t whole_size = pgno2bytes(env, meta->mm_geo.now);
    if (!dest_is_pipe)
      return mdbx_ftruncate(fd, whole_size);

    const size_t used_size = pgno2bytes(env, meta->mm_geo.next);
    memset(data_buffer, 0, ((size_t)(1048576u)));
    for (size_t offset = used_size; offset < whole_size;) {
      const size_t chunk =
          (((size_t)(1048576u)) < whole_size - offset)
              ? ((size_t)(1048576u))
              : whole_size - offset;

      int rc = mdbx_write(fd, data_buffer, chunk);
      if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
        return rc;
      offset += chunk;
    }
  }
  return MDBX_SUCCESS;
}


__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static int mdbx_env_copy_asis(MDBX_env *env, MDBX_txn *read_txn,
                                     mdbx_filehandle_t fd, uint8_t *buffer,
                                     const _Bool dest_is_pipe, const int flags) {

  int rc = mdbx_txn_end(read_txn, MDBX_END_RESET_TMP);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;


  rc = mdbx_txn_lock(env, (0));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  rc = mdbx_txn_renew0(read_txn, MDBX_TXN_RDONLY);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0)) {
    mdbx_txn_unlock(env);
    return rc;
  }

  mdbx_jitter4testing((0));
  const size_t meta_bytes = pgno2bytes(env, 3);


  memcpy(buffer, env->me_dxb_mmap.dxb, meta_bytes);
  MDBX_meta *const headcopy =
      (MDBX_meta *)(buffer + ((uint8_t *)meta_prefer_last(env) - env->me_dxb_mmap.dxb));
  mdbx_txn_unlock(env);

  if (flags & MDBX_CP_FORCE_DYNAMIC_SIZE)
    make_sizeable(headcopy);

  unaligned_poke_u64(4, headcopy->mm_datasync_sign, meta_sign(headcopy));


  const size_t whole_size = pgno_align2os_bytes(env, read_txn->mt_geo.now);
  const size_t used_size = pgno2bytes(env, read_txn->mt_geo.next);
  mdbx_jitter4testing((0));

  if (dest_is_pipe)
    rc = mdbx_write(fd, buffer, meta_bytes);

  uint8_t *const data_buffer =
      buffer + ceil_powerof2(meta_bytes, env->me_os_psize);

  static _Bool copyfilerange_unavailable;
  _Bool not_the_same_filesystem = (0);

  for (size_t offset = meta_bytes; rc == MDBX_SUCCESS && offset < used_size;) {

    static _Bool sendfile_unavailable;
    if (dest_is_pipe && __builtin_expect(!!(!sendfile_unavailable), 1)) {
      off_t in_offset = offset;
      const ssize_t written =
          sendfile(fd, env->me_dxb_mmap.fd, &in_offset, used_size - offset);
      if (__builtin_expect(!!(written > 0), 1)) {
        offset = in_offset;
        continue;
      }
      rc = MDBX_ENODATA;
      if (written == 0 || ignore_enosys(rc = 
# 19465 "/libmdbx/src/core.c" 3 4
                                            (*__errno_location ())
# 19465 "/libmdbx/src/core.c"
                                                 ) != MDBX_RESULT_TRUE)
        break;
      sendfile_unavailable = (1);
    }



    if (!dest_is_pipe && !not_the_same_filesystem &&
        __builtin_expect(!!(!copyfilerange_unavailable), 1)) {
      off_t in_offset = offset, out_offset = offset;
      ssize_t bytes_copied = copy_file_range(
          env->me_dxb_mmap.fd, &in_offset, fd, &out_offset, used_size - offset, 0);
      if (__builtin_expect(!!(bytes_copied > 0), 1)) {
        offset = in_offset;
        continue;
      }
      rc = MDBX_ENODATA;
      if (bytes_copied == 0)
        break;
      rc = 
# 19484 "/libmdbx/src/core.c" 3 4
          (*__errno_location ())
# 19484 "/libmdbx/src/core.c"
               ;
      if (rc == 
# 19485 "/libmdbx/src/core.c" 3 4
               18
# 19485 "/libmdbx/src/core.c"
                    )
        not_the_same_filesystem = (1);
      else if (ignore_enosys(rc) == MDBX_RESULT_TRUE)
        copyfilerange_unavailable = (1);
      else
        break;
    }



    const size_t chunk =
        (((size_t)(1048576u)) < used_size - offset)
            ? ((size_t)(1048576u))
            : used_size - offset;

    memcpy(data_buffer, env->me_dxb_mmap.dxb + offset, chunk);
    rc = mdbx_write(fd, data_buffer, chunk);
    offset += chunk;
  }


  if (__builtin_expect(!!(rc == MDBX_SUCCESS), 1) && whole_size != used_size) {
    if (!dest_is_pipe)
      rc = mdbx_ftruncate(fd, whole_size);
    else {
      memset(data_buffer, 0, ((size_t)(1048576u)));
      for (size_t offset = used_size;
           rc == MDBX_SUCCESS && offset < whole_size;) {
        const size_t chunk =
            (((size_t)(1048576u)) < whole_size - offset)
                ? ((size_t)(1048576u))
                : whole_size - offset;

        rc = mdbx_write(fd, data_buffer, chunk);
        offset += chunk;
      }
    }
  }

  return rc;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_copy2fd(MDBX_env *env, mdbx_filehandle_t fd,
                            unsigned flags) {
  int rc = check_env(env, (1));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  const int dest_is_pipe = mdbx_is_pipe(fd);
  if (((dest_is_pipe) != MDBX_RESULT_TRUE && (dest_is_pipe) != MDBX_RESULT_FALSE))
    return dest_is_pipe;

  if (!dest_is_pipe) {
    rc = mdbx_fseek(fd, 0);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      return rc;
  }

  const size_t buffer_size =
      pgno_align2os_bytes(env, 3) +
      ceil_powerof2(((flags & MDBX_CP_COMPACT)
                         ? ((size_t)(1048576u)) * 2
                         : ((size_t)(1048576u))),
                    env->me_os_psize);

  uint8_t *buffer = 
# 19550 "/libmdbx/src/core.c" 3 4
                   ((void *)0)
# 19550 "/libmdbx/src/core.c"
                       ;
  rc = mdbx_memalign_alloc(env->me_os_psize, buffer_size, (void **)&buffer);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  MDBX_txn *read_txn = 
# 19555 "/libmdbx/src/core.c" 3 4
                      ((void *)0)
# 19555 "/libmdbx/src/core.c"
                          ;


  rc = mdbx_txn_begin(env, 
# 19558 "/libmdbx/src/core.c" 3 4
                          ((void *)0)
# 19558 "/libmdbx/src/core.c"
                              , MDBX_TXN_RDONLY, &read_txn);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0)) {
    mdbx_memalign_free(buffer);
    return rc;
  }

  if (!dest_is_pipe) {


    memset(buffer, -1, pgno2bytes(env, 3));
    rc = mdbx_write(fd, buffer, pgno2bytes(env, 3));
  }

  if (__builtin_expect(!!(rc == MDBX_SUCCESS), 1)) {
    memset(buffer, 0, pgno2bytes(env, 3));
    rc = ((flags & MDBX_CP_COMPACT) ? mdbx_env_compact : mdbx_env_copy_asis)(
        env, read_txn, fd, buffer, dest_is_pipe, flags);
  }
  mdbx_txn_abort(read_txn);

  if (!dest_is_pipe) {
    if (__builtin_expect(!!(rc == MDBX_SUCCESS), 1))
      rc = mdbx_fsync(fd, MDBX_SYNC_DATA | MDBX_SYNC_SIZE);


    if (__builtin_expect(!!(rc == MDBX_SUCCESS), 1))
      rc = mdbx_pwrite(fd, buffer, pgno2bytes(env, 3), 0);

    if (__builtin_expect(!!(rc == MDBX_SUCCESS), 1))
      rc = mdbx_fsync(fd, MDBX_SYNC_DATA | MDBX_SYNC_IODQ);
  }

  mdbx_memalign_free(buffer);
  return rc;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_copy(MDBX_env *env, const char *dest_path,
                         MDBX_copy_flags_t flags) {
  int rc = check_env(env, (1));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(!dest_path), 0))
    return MDBX_EINVAL;




  mdbx_filehandle_t newfd;
  rc = mdbx_openfile(MDBX_OPEN_COPY, env, dest_path, &newfd,



                     
# 19611 "/libmdbx/src/core.c" 3 4
                    0400 
# 19611 "/libmdbx/src/core.c"
                            | 
# 19611 "/libmdbx/src/core.c" 3 4
                              0200 
# 19611 "/libmdbx/src/core.c"
                                      | 
# 19611 "/libmdbx/src/core.c" 3 4
                                        (0400 >> 3) 
# 19611 "/libmdbx/src/core.c"
                                                | 
# 19611 "/libmdbx/src/core.c" 3 4
                                                  (0200 >> 3)

  
# 19613 "/libmdbx/src/core.c"
 );

  if (rc == MDBX_SUCCESS) {







    struct flock lock_op;
    memset(&lock_op, 0, sizeof(lock_op));
    lock_op.l_type = 
# 19625 "/libmdbx/src/core.c" 3 4
                    1
# 19625 "/libmdbx/src/core.c"
                           ;
    lock_op.l_whence = 
# 19626 "/libmdbx/src/core.c" 3 4
                      0
# 19626 "/libmdbx/src/core.c"
                              ;
    lock_op.l_start = 0;
    lock_op.l_len =
        (sizeof(lock_op.l_len) > 4 ? 
# 19629 "/libmdbx/src/core.c" 3 4
                                    (9223372036854775807L) 
# 19629 "/libmdbx/src/core.c"
                                              : 
# 19629 "/libmdbx/src/core.c" 3 4
                                                (2147483647)
# 19629 "/libmdbx/src/core.c"
                                                         ) & ~(size_t)0xffff;
    if (fcntl(newfd, 
# 19630 "/libmdbx/src/core.c" 3 4
                    6
# 19630 "/libmdbx/src/core.c"
                           , &lock_op)


        || flock(newfd, 
# 19633 "/libmdbx/src/core.c" 3 4
                       2 
# 19633 "/libmdbx/src/core.c"
                               | 
# 19633 "/libmdbx/src/core.c" 3 4
                                 4
# 19633 "/libmdbx/src/core.c"
                                        )

    )
      rc = 
# 19636 "/libmdbx/src/core.c" 3 4
          (*__errno_location ())
# 19636 "/libmdbx/src/core.c"
               ;

  }

  if (rc == MDBX_SUCCESS)
    rc = mdbx_env_copy2fd(env, newfd, flags);

  if (newfd != (-1)) {
    int err = mdbx_closefile(newfd);
    if (rc == MDBX_SUCCESS && err != rc)
      rc = err;
    if (rc != MDBX_SUCCESS)
      (void)mdbx_removefile(dest_path);
  }

  return rc;
}



__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_set_flags(MDBX_env *env, MDBX_env_flags_t flags,
                              _Bool onoff) {
  int rc = check_env(env, (0));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(flags & ((env->me_flags & 0x20000000U) ? ~(MDBX_SAFE_NOSYNC | MDBX_NOMETASYNC | 0x100000U | MDBX_NOMEMINIT | MDBX_COALESCE | MDBX_PAGEPERTURB | MDBX_ACCEDE) : ~((MDBX_SAFE_NOSYNC | MDBX_NOMETASYNC | 0x100000U | MDBX_NOMEMINIT | MDBX_COALESCE | MDBX_PAGEPERTURB | MDBX_ACCEDE) | (MDBX_NOSUBDIR | MDBX_RDONLY | MDBX_WRITEMAP | MDBX_NOTLS | MDBX_NORDAHEAD | MDBX_LIFORECLAIM | MDBX_EXCLUSIVE)))), 0)

                                                                       )
    return MDBX_EPERM;

  if (__builtin_expect(!!(env->me_flags & MDBX_RDONLY), 0))
    return MDBX_EACCESS;

  if ((env->me_flags & 0x20000000U) &&
      __builtin_expect(!!(env->me_txn0->mt_owner == mdbx_thread_self()), 0))
    return MDBX_BUSY;

  const _Bool lock_needed = (env->me_flags & 0x20000000U) &&
                           env->me_txn0->mt_owner != mdbx_thread_self();
  _Bool should_unlock = (0);
  if (lock_needed) {
    rc = mdbx_txn_lock(env, (0));
    if (__builtin_expect(!!(rc), 0))
      return rc;
    should_unlock = (1);
  }

  if (onoff)
    env->me_flags = merge_sync_flags(env->me_flags, flags);
  else
    env->me_flags &= ~flags;

  if (should_unlock)
    mdbx_txn_unlock(env);
  return MDBX_SUCCESS;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_get_flags(const MDBX_env *env, unsigned *arg) {
  int rc = check_env(env, (0));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(!arg), 0))
    return MDBX_EINVAL;

  *arg = env->me_flags & ((MDBX_SAFE_NOSYNC | MDBX_NOMETASYNC | 0x100000U | MDBX_NOMEMINIT | MDBX_COALESCE | MDBX_PAGEPERTURB | MDBX_ACCEDE) | (MDBX_NOSUBDIR | MDBX_RDONLY | MDBX_WRITEMAP | MDBX_NOTLS | MDBX_NORDAHEAD | MDBX_LIFORECLAIM | MDBX_EXCLUSIVE));
  return MDBX_SUCCESS;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_set_userctx(MDBX_env *env, void *ctx) {
  int rc = check_env(env, (0));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  env->me_userctx = ctx;
  return MDBX_SUCCESS;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) void *mdbx_env_get_userctx(const MDBX_env *env) {
  return env ? env->me_userctx : 
# 19716 "/libmdbx/src/core.c" 3 4
                                ((void *)0)
# 19716 "/libmdbx/src/core.c"
                                    ;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_set_assert(MDBX_env *env, MDBX_assert_func *func) {
  int rc = check_env(env, (0));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;





  (void)func;
  return MDBX_ENOSYS;

}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_get_path(const MDBX_env *env, const char **arg) {
  int rc = check_env(env, (1));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(!arg), 0))
    return MDBX_EINVAL;

  *arg = env->me_pathname;
  return MDBX_SUCCESS;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_get_fd(const MDBX_env *env, mdbx_filehandle_t *arg) {
  int rc = check_env(env, (1));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(!arg), 0))
    return MDBX_EINVAL;

  *arg = env->me_dxb_mmap.fd;
  return MDBX_SUCCESS;
}


__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_stat(const MDBX_env *env, MDBX_stat *stat, size_t bytes) {
  return __inline_mdbx_env_stat(env, stat, bytes);
}


static void stat_get(const MDBX_db *db, MDBX_stat *st, size_t bytes) {
  st->ms_depth = db->md_depth;
  st->ms_branch_pages = db->md_branch_pages;
  st->ms_leaf_pages = db->md_leaf_pages;
  st->ms_overflow_pages = db->md_overflow_pages;
  st->ms_entries = db->md_entries;
  if (__builtin_expect(!!(bytes >= 
# 19769 "/libmdbx/src/core.c" 3 4
     __builtin_offsetof (
# 19769 "/libmdbx/src/core.c"
     MDBX_stat
# 19769 "/libmdbx/src/core.c" 3 4
     , 
# 19769 "/libmdbx/src/core.c"
     ms_mod_txnid
# 19769 "/libmdbx/src/core.c" 3 4
     ) 
# 19769 "/libmdbx/src/core.c"
     + sizeof(st->ms_mod_txnid)), 1)
                                                                          )
    st->ms_mod_txnid = db->md_mod_txnid;
}

static void stat_add(const MDBX_db *db, MDBX_stat *const st,
                     const size_t bytes) {
  st->ms_depth += db->md_depth;
  st->ms_branch_pages += db->md_branch_pages;
  st->ms_leaf_pages += db->md_leaf_pages;
  st->ms_overflow_pages += db->md_overflow_pages;
  st->ms_entries += db->md_entries;
  if (__builtin_expect(!!(bytes >= 
# 19781 "/libmdbx/src/core.c" 3 4
     __builtin_offsetof (
# 19781 "/libmdbx/src/core.c"
     MDBX_stat
# 19781 "/libmdbx/src/core.c" 3 4
     , 
# 19781 "/libmdbx/src/core.c"
     ms_mod_txnid
# 19781 "/libmdbx/src/core.c" 3 4
     ) 
# 19781 "/libmdbx/src/core.c"
     + sizeof(st->ms_mod_txnid)), 1)
                                                                          )
    st->ms_mod_txnid = (st->ms_mod_txnid > db->md_mod_txnid) ? st->ms_mod_txnid
                                                             : db->md_mod_txnid;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static int stat_acc(const MDBX_txn *txn, MDBX_stat *st, size_t bytes) {
  int err = check_txn(txn, (0x01 | 0x02 | 0x10));
  if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
    return err;

  st->ms_psize = txn->mt_env->me_psize;


  stat_get(&txn->mt_dbs[1], st, bytes);






  for (MDBX_dbi dbi = 2; dbi < txn->mt_numdbs; dbi++)
    if ((txn->mt_dbistate[dbi] & (0x10 | MDBX_DBI_STALE)) == 0x10)
      stat_add(txn->mt_dbs + dbi, st, bytes);

  if (!(txn->mt_dbs[1].md_flags & (MDBX_DUPSORT | MDBX_INTEGERKEY)) &&
      txn->mt_dbs[1].md_entries ) {
    MDBX_cursor_couple cx;
    err = mdbx_cursor_init(&cx.outer, (MDBX_txn *)txn, 1);
    if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
      return err;


    err = mdbx_page_search(&cx.outer, 
# 19814 "/libmdbx/src/core.c" 3 4
                                     ((void *)0)
# 19814 "/libmdbx/src/core.c"
                                         , 4);
    while (err == MDBX_SUCCESS) {
      const MDBX_page *mp = cx.outer.mc_pg[cx.outer.mc_top];
      for (unsigned i = 0; i < page_numkeys(mp); i++) {
        const MDBX_node *node = page_node(mp, i);
        if (node_flags(node) != 0x02)
          continue;
        if (__builtin_expect(!!(node_ds(node) != sizeof(MDBX_db)), 0))
          return MDBX_CORRUPTED;


        for (MDBX_dbi dbi = 2; dbi < txn->mt_numdbs; dbi++)
          if ((txn->mt_dbistate[dbi] & (0x10 | MDBX_DBI_STALE)) == 0x10 &&
              node_ks(node) == txn->mt_dbxs[dbi].md_name.iov_len &&
              memcmp(node_key(node), txn->mt_dbxs[dbi].md_name.iov_base,
                     node_ks(node)) == 0) {
            node = 
# 19830 "/libmdbx/src/core.c" 3 4
                  ((void *)0)
# 19830 "/libmdbx/src/core.c"
                      ;
            break;
          }

        if (node) {
          MDBX_db db;
          memcpy(&db, node_data(node), sizeof(db));
          stat_add(&db, st, bytes);
        }
      }
      err = mdbx_cursor_sibling(&cx.outer, 2);
    }
    if (__builtin_expect(!!(err != MDBX_NOTFOUND), 0))
      return err;
  }

  return MDBX_SUCCESS;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_stat_ex(const MDBX_env *env, const MDBX_txn *txn,
                            MDBX_stat *dest, size_t bytes) {
  if (__builtin_expect(!!(!dest), 0))
    return MDBX_EINVAL;
  const size_t size_before_modtxnid = 
# 19853 "/libmdbx/src/core.c" 3 4
                                     __builtin_offsetof (
# 19853 "/libmdbx/src/core.c"
                                     MDBX_stat
# 19853 "/libmdbx/src/core.c" 3 4
                                     , 
# 19853 "/libmdbx/src/core.c"
                                     ms_mod_txnid
# 19853 "/libmdbx/src/core.c" 3 4
                                     )
# 19853 "/libmdbx/src/core.c"
                                                                      ;
  if (__builtin_expect(!!(bytes != sizeof(MDBX_stat)), 0) && bytes != size_before_modtxnid)
    return MDBX_EINVAL;

  if (__builtin_expect(!!(txn), 1)) {
    if (env && __builtin_expect(!!(txn->mt_env != env), 0))
      return MDBX_EINVAL;
    return stat_acc(txn, dest, bytes);
  }

  int err = check_env(env, (1));
  if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
    return err;

  if (env->me_txn0 && env->me_txn0->mt_owner == mdbx_thread_self())

    return stat_acc(env->me_txn, dest, bytes);

  MDBX_txn *tmp_txn;
  err = mdbx_txn_begin((MDBX_env *)env, 
# 19872 "/libmdbx/src/core.c" 3 4
                                       ((void *)0)
# 19872 "/libmdbx/src/core.c"
                                           , MDBX_TXN_RDONLY, &tmp_txn);
  if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
    return err;

  const int rc = stat_acc(tmp_txn, dest, bytes);
  err = mdbx_txn_abort(tmp_txn);
  if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
    return err;
  return rc;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_dbi_dupsort_depthmask(MDBX_txn *txn, MDBX_dbi dbi,
                                      uint32_t *mask) {
  int rc = check_txn(txn, (0x01 | 0x02 | 0x10));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(!mask), 0))
    return MDBX_EINVAL;

  if (__builtin_expect(!!(!check_dbi(txn, dbi, 0x10)), 0))
    return MDBX_BAD_DBI;

  MDBX_cursor_couple cx;
  rc = mdbx_cursor_init(&cx.outer, txn, dbi);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;
  if ((cx.outer.mc_db->md_flags & MDBX_DUPSORT) == 0)
    return MDBX_RESULT_TRUE;

  MDBX_val key, data;
  rc = mdbx_cursor_first(&cx.outer, &key, &data);
  *mask = 0;
  while (rc == MDBX_SUCCESS) {
    const MDBX_node *node = page_node(cx.outer.mc_pg[cx.outer.mc_top],
                                      cx.outer.mc_ki[cx.outer.mc_top]);
    const MDBX_db *db = node_data(node);
    const unsigned flags = node_flags(node);
    switch (flags) {
    case 0x01:
    case 0:

      *mask |= 1 << 0;
      break;
    case 0x04:

      *mask |= 1 << 1;
      break;
    case 0x04 | 0x02:

      *mask |= 1 << unaligned_peek_u16(1, (const char *)(db) + 
# 19922 "/libmdbx/src/core.c" 3 4
                   __builtin_offsetof (
# 19922 "/libmdbx/src/core.c"
                   MDBX_db
# 19922 "/libmdbx/src/core.c" 3 4
                   , 
# 19922 "/libmdbx/src/core.c"
                   md_depth
# 19922 "/libmdbx/src/core.c" 3 4
                   )
# 19922 "/libmdbx/src/core.c"
                   );
      break;
    default:
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 19925, "wrong node-flags %u" "\n", flags); } while (0);
      return MDBX_CORRUPTED;
    }
    rc = mdbx_cursor_next(&cx.outer, &key, &data, MDBX_NEXT_NODUP);
  }

  return (rc == MDBX_NOTFOUND) ? MDBX_SUCCESS : rc;
}


__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_info(const MDBX_env *env, MDBX_envinfo *info,
                         size_t bytes) {
  return __inline_mdbx_env_info(env, info, bytes);
}


__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static int fetch_envinfo_ex(const MDBX_env *env, const MDBX_txn *txn,
                                   MDBX_envinfo *arg, const size_t bytes) {

  const size_t size_before_bootid = 
# 19944 "/libmdbx/src/core.c" 3 4
                                   __builtin_offsetof (
# 19944 "/libmdbx/src/core.c"
                                   MDBX_envinfo
# 19944 "/libmdbx/src/core.c" 3 4
                                   , 
# 19944 "/libmdbx/src/core.c"
                                   mi_bootid
# 19944 "/libmdbx/src/core.c" 3 4
                                   )
# 19944 "/libmdbx/src/core.c"
                                                                    ;
  const size_t size_before_pgop_stat = 
# 19945 "/libmdbx/src/core.c" 3 4
                                      __builtin_offsetof (
# 19945 "/libmdbx/src/core.c"
                                      MDBX_envinfo
# 19945 "/libmdbx/src/core.c" 3 4
                                      , 
# 19945 "/libmdbx/src/core.c"
                                      mi_pgop_stat
# 19945 "/libmdbx/src/core.c" 3 4
                                      )
# 19945 "/libmdbx/src/core.c"
                                                                          ;


  if (__builtin_expect(!!(!env->me_dxb_mmap.dxb), 0)) {



    memset(arg, 0, bytes);
    arg->mi_geo.lower = env->me_dbgeo.lower;
    arg->mi_geo.upper = env->me_dbgeo.upper;
    arg->mi_geo.shrink = env->me_dbgeo.shrink;
    arg->mi_geo.grow = env->me_dbgeo.grow;
    arg->mi_geo.current = env->me_dbgeo.now;
    arg->mi_maxreaders = env->me_maxreaders;
    arg->mi_dxb_pagesize = env->me_psize;
    arg->mi_sys_pagesize = env->me_os_psize;
    if (__builtin_expect(!!(bytes > size_before_bootid), 1)) {
      arg->mi_bootid.current.x = bootid.x;
      arg->mi_bootid.current.y = bootid.y;
    }
    return MDBX_SUCCESS;




  }

  const MDBX_meta *const meta0 = page_meta(pgno2page(env, 0));
  const MDBX_meta *const meta1 = page_meta(pgno2page(env, 1));
  const MDBX_meta *const meta2 = page_meta(pgno2page(env, 2));
  if (__builtin_expect(!!(env->me_flags & 0x80000000U), 0))
    return MDBX_PANIC;

  volatile const MDBX_meta *const recent_meta = meta_prefer_last(env);
  arg->mi_recent_txnid = meta_txnid(env, recent_meta);
  arg->mi_meta0_txnid = meta_txnid(env, meta0);
  arg->mi_meta0_sign = unaligned_peek_u64(4, meta0->mm_datasync_sign);
  arg->mi_meta1_txnid = meta_txnid(env, meta1);
  arg->mi_meta1_sign = unaligned_peek_u64(4, meta1->mm_datasync_sign);
  arg->mi_meta2_txnid = meta_txnid(env, meta2);
  arg->mi_meta2_sign = unaligned_peek_u64(4, meta2->mm_datasync_sign);
  if (__builtin_expect(!!(bytes > size_before_bootid), 1)) {
    memcpy(&arg->mi_bootid.meta0, &meta0->mm_bootid, 16);
    memcpy(&arg->mi_bootid.meta1, &meta1->mm_bootid, 16);
    memcpy(&arg->mi_bootid.meta2, &meta2->mm_bootid, 16);
  }

  volatile const MDBX_meta *txn_meta = recent_meta;
  arg->mi_last_pgno = txn_meta->mm_geo.next - 1;
  arg->mi_geo.current = pgno2bytes(env, txn_meta->mm_geo.now);
  if (txn) {
    arg->mi_last_pgno = txn->mt_geo.next - 1;
    arg->mi_geo.current = pgno2bytes(env, txn->mt_geo.now);

    const txnid_t wanna_meta_txnid = (txn->mt_flags & MDBX_TXN_RDONLY)
                                         ? txn->mt_txnid
                                         : txn->mt_txnid - 1u;
    txn_meta = (arg->mi_meta0_txnid == wanna_meta_txnid) ? meta0 : txn_meta;
    txn_meta = (arg->mi_meta1_txnid == wanna_meta_txnid) ? meta1 : txn_meta;
    txn_meta = (arg->mi_meta2_txnid == wanna_meta_txnid) ? meta2 : txn_meta;
  }
  arg->mi_geo.lower = pgno2bytes(env, txn_meta->mm_geo.lower);
  arg->mi_geo.upper = pgno2bytes(env, txn_meta->mm_geo.upper);
  arg->mi_geo.shrink = pgno2bytes(env, pv2pages(txn_meta->mm_geo.shrink_pv));
  arg->mi_geo.grow = pgno2bytes(env, pv2pages(txn_meta->mm_geo.grow_pv));
  const pgno_t unsynced_pages =
      atomic_load32(&env->me_lck->mti_unsynced_pages, mo_Relaxed) +
      (atomic_load32(&env->me_lck->mti_meta_sync_txnid, mo_Relaxed) !=
       (uint32_t)arg->mi_recent_txnid);

  arg->mi_mapsize = env->me_dxb_mmap.limit;

  const MDBX_lockinfo *const lck = env->me_lck;
  arg->mi_maxreaders = env->me_maxreaders;
  arg->mi_numreaders = env->me_lck_mmap.lck
                           ? atomic_load32(&lck->mti_numreaders, mo_Relaxed)
                           : 
# 20021 "/libmdbx/src/core.c" 3 4
                            (2147483647)
# 20021 "/libmdbx/src/core.c"
                                     ;
  arg->mi_dxb_pagesize = env->me_psize;
  arg->mi_sys_pagesize = env->me_os_psize;

  if (__builtin_expect(!!(bytes > size_before_bootid), 1)) {
    arg->mi_unsync_volume = pgno2bytes(env, unsynced_pages);
    const uint64_t monotime_now = mdbx_osal_monotime();
    uint64_t ts = atomic_load64(&lck->mti_sync_timestamp, mo_Relaxed);
    arg->mi_since_sync_seconds16dot16 =
        ts ? mdbx_osal_monotime_to_16dot16(monotime_now - ts) : 0;
    ts = atomic_load64(&lck->mti_reader_check_timestamp, mo_Relaxed);
    arg->mi_since_reader_check_seconds16dot16 =
        ts ? mdbx_osal_monotime_to_16dot16(monotime_now - ts) : 0;
    arg->mi_autosync_threshold = pgno2bytes(
        env, atomic_load32(&lck->mti_autosync_threshold, mo_Relaxed));
    arg->mi_autosync_period_seconds16dot16 = mdbx_osal_monotime_to_16dot16(
        atomic_load64(&lck->mti_autosync_period, mo_Relaxed));
    arg->mi_bootid.current.x = bootid.x;
    arg->mi_bootid.current.y = bootid.y;
    arg->mi_mode = env->me_lck_mmap.lck ? lck->mti_envmode.weak : env->me_flags;
  }

  if (__builtin_expect(!!(bytes > size_before_pgop_stat), 1)) {

    arg->mi_pgop_stat.newly =
        atomic_load64(&lck->mti_pgop_stat.newly, mo_Relaxed);
    arg->mi_pgop_stat.cow = atomic_load64(&lck->mti_pgop_stat.cow, mo_Relaxed);
    arg->mi_pgop_stat.clone =
        atomic_load64(&lck->mti_pgop_stat.clone, mo_Relaxed);
    arg->mi_pgop_stat.split =
        atomic_load64(&lck->mti_pgop_stat.split, mo_Relaxed);
    arg->mi_pgop_stat.merge =
        atomic_load64(&lck->mti_pgop_stat.merge, mo_Relaxed);
    arg->mi_pgop_stat.spill =
        atomic_load64(&lck->mti_pgop_stat.spill, mo_Relaxed);
    arg->mi_pgop_stat.unspill =
        atomic_load64(&lck->mti_pgop_stat.unspill, mo_Relaxed);
    arg->mi_pgop_stat.wops =
        atomic_load64(&lck->mti_pgop_stat.wops, mo_Relaxed);



  }

  arg->mi_self_latter_reader_txnid = arg->mi_latter_reader_txnid =
      arg->mi_recent_txnid;
  for (unsigned i = 0; i < arg->mi_numreaders; ++i) {
    const uint32_t pid =
        atomic_load32(&lck->mti_readers[i].mr_pid, mo_AcquireRelease);
    if (pid) {
      const txnid_t txnid = safe64_read(&lck->mti_readers[i].mr_txnid);
      if (arg->mi_latter_reader_txnid > txnid)
        arg->mi_latter_reader_txnid = txnid;
      if (pid == env->me_pid && arg->mi_self_latter_reader_txnid > txnid)
        arg->mi_self_latter_reader_txnid = txnid;
    }
  }

  mdbx_compiler_barrier();
  return MDBX_SUCCESS;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_info_ex(const MDBX_env *env, const MDBX_txn *txn,
                            MDBX_envinfo *arg, size_t bytes) {
  if (__builtin_expect(!!((env == 
# 20085 "/libmdbx/src/core.c" 3 4
     ((void *)0) 
# 20085 "/libmdbx/src/core.c"
     && txn == 
# 20085 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 20085 "/libmdbx/src/core.c"
     ) || arg == 
# 20085 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 20085 "/libmdbx/src/core.c"
     ), 0))
    return MDBX_EINVAL;

  if (txn) {
    int err = check_txn(txn, (0x01 | 0x02 | 0x10) - 0x02);
    if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
      return err;
  }
  if (env) {
    int err = check_env(env, (0));
    if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
      return err;
    if (txn && __builtin_expect(!!(txn->mt_env != env), 0))
      return MDBX_EINVAL;
  } else {
    env = txn->mt_env;
  }

  const size_t size_before_bootid = 
# 20103 "/libmdbx/src/core.c" 3 4
                                   __builtin_offsetof (
# 20103 "/libmdbx/src/core.c"
                                   MDBX_envinfo
# 20103 "/libmdbx/src/core.c" 3 4
                                   , 
# 20103 "/libmdbx/src/core.c"
                                   mi_bootid
# 20103 "/libmdbx/src/core.c" 3 4
                                   )
# 20103 "/libmdbx/src/core.c"
                                                                    ;
  const size_t size_before_pgop_stat = 
# 20104 "/libmdbx/src/core.c" 3 4
                                      __builtin_offsetof (
# 20104 "/libmdbx/src/core.c"
                                      MDBX_envinfo
# 20104 "/libmdbx/src/core.c" 3 4
                                      , 
# 20104 "/libmdbx/src/core.c"
                                      mi_pgop_stat
# 20104 "/libmdbx/src/core.c" 3 4
                                      )
# 20104 "/libmdbx/src/core.c"
                                                                          ;
  if (__builtin_expect(!!(bytes != sizeof(MDBX_envinfo)), 0) && bytes != size_before_bootid &&
      bytes != size_before_pgop_stat)
    return MDBX_EINVAL;

  MDBX_envinfo snap;
  int rc = fetch_envinfo_ex(env, txn, &snap, sizeof(snap));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  while (1) {
    rc = fetch_envinfo_ex(env, txn, arg, bytes);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      return rc;
    snap.mi_since_sync_seconds16dot16 = arg->mi_since_sync_seconds16dot16;
    snap.mi_since_reader_check_seconds16dot16 =
        arg->mi_since_reader_check_seconds16dot16;
    if (__builtin_expect(!!(memcmp(&snap, arg, bytes) == 0), 1))
      return MDBX_SUCCESS;
    memcpy(&snap, arg, bytes);
  }
}

static __inline MDBX_cmp_func *get_default_keycmp(unsigned flags) {
  return (flags & MDBX_REVERSEKEY) ? cmp_reverse
         : (flags & MDBX_INTEGERKEY) ? cmp_int_align2
                                     : cmp_lexical;
}

static __inline MDBX_cmp_func *get_default_datacmp(unsigned flags) {
  return !(flags & MDBX_DUPSORT)
             ? cmp_lenfast
             : ((flags & MDBX_INTEGERDUP)
                    ? cmp_int_unaligned
                    : ((flags & MDBX_REVERSEDUP) ? cmp_reverse : cmp_lexical));
}

static int mdbx_dbi_bind(MDBX_txn *txn, const MDBX_dbi dbi, unsigned user_flags,
                         MDBX_cmp_func *keycmp, MDBX_cmp_func *datacmp) {
# 20151 "/libmdbx/src/core.c"
  if ((user_flags ^ txn->mt_dbs[dbi].md_flags) & (MDBX_REVERSEKEY | MDBX_DUPSORT | MDBX_INTEGERKEY | MDBX_DUPFIXED | MDBX_INTEGERDUP | MDBX_REVERSEDUP)) {

    if ((!user_flags && (!keycmp || keycmp == txn->mt_dbxs[dbi].md_cmp) &&
         (!datacmp || datacmp == txn->mt_dbxs[dbi].md_dcmp)) ||
        user_flags == MDBX_ACCEDE) {


      user_flags = txn->mt_dbs[dbi].md_flags;
    } else if ((user_flags & MDBX_CREATE) && txn->mt_dbs[dbi].md_entries == 0) {
      if (txn->mt_flags & MDBX_TXN_RDONLY)
        return MDBX_EACCESS;

      txn->mt_dbs[dbi].md_flags = user_flags & (MDBX_REVERSEKEY | MDBX_DUPSORT | MDBX_INTEGERKEY | MDBX_DUPFIXED | MDBX_INTEGERDUP | MDBX_REVERSEDUP);
      txn->mt_flags |= 0x04;
    } else {
      return MDBX_INCOMPATIBLE;
    }
  }

  if (!keycmp)
    keycmp = txn->mt_dbxs[dbi].md_cmp ? txn->mt_dbxs[dbi].md_cmp
                                      : get_default_keycmp(user_flags);
  if (txn->mt_dbxs[dbi].md_cmp != keycmp) {
    if (txn->mt_dbxs[dbi].md_cmp)
      return MDBX_EINVAL;
    txn->mt_dbxs[dbi].md_cmp = keycmp;
  }

  if (!datacmp)
    datacmp = txn->mt_dbxs[dbi].md_dcmp ? txn->mt_dbxs[dbi].md_dcmp
                                        : get_default_datacmp(user_flags);
  if (txn->mt_dbxs[dbi].md_dcmp != datacmp) {
    if (txn->mt_dbxs[dbi].md_dcmp)
      return MDBX_EINVAL;
    txn->mt_dbxs[dbi].md_dcmp = datacmp;
  }

  return MDBX_SUCCESS;
}

static int dbi_open(MDBX_txn *txn, const char *table_name, unsigned user_flags,
                    MDBX_dbi *dbi, MDBX_cmp_func *keycmp,
                    MDBX_cmp_func *datacmp) {
  int rc = MDBX_EINVAL;
  if (__builtin_expect(!!(!dbi), 0))
    return rc;

  if (__builtin_expect(!!((user_flags & ~((MDBX_REVERSEKEY | MDBX_DUPSORT | MDBX_INTEGERKEY | MDBX_DUPFIXED | MDBX_INTEGERDUP | MDBX_REVERSEDUP) | MDBX_CREATE | MDBX_DB_ACCEDE)) != 0), 0)) {
  early_bailout:
    *dbi = 0;
    return rc;
  }

  rc = check_txn(txn, (0x01 | 0x02 | 0x10));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    goto early_bailout;

  switch (user_flags & (MDBX_INTEGERDUP | MDBX_DUPFIXED | MDBX_DUPSORT |
                        MDBX_REVERSEDUP | MDBX_ACCEDE)) {
  case MDBX_ACCEDE:
    if ((user_flags & MDBX_CREATE) == 0)
      break;
    __attribute__((__fallthrough__)) ;
  default:
    rc = MDBX_EINVAL;
    goto early_bailout;

  case MDBX_DUPSORT:
  case MDBX_DUPSORT | MDBX_REVERSEDUP:
  case MDBX_DUPSORT | MDBX_DUPFIXED:
  case MDBX_DUPSORT | MDBX_DUPFIXED | MDBX_REVERSEDUP:
  case MDBX_DUPSORT | MDBX_DUPFIXED | MDBX_INTEGERDUP:
  case MDBX_DUPSORT | MDBX_DUPFIXED | MDBX_INTEGERDUP | MDBX_REVERSEDUP:
  case 0:
    break;
  }


  if (!table_name) {
    rc = mdbx_dbi_bind(txn, 1, user_flags, keycmp, datacmp);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      goto early_bailout;
    *dbi = 1;
    return rc;
  }

  MDBX_env *env = txn->mt_env;
  size_t len = strlen(table_name);
  if (len > env->me_leaf_nodemax - 
# 20239 "/libmdbx/src/core.c" 3 4
                                  __builtin_offsetof (
# 20239 "/libmdbx/src/core.c"
                                  MDBX_node
# 20239 "/libmdbx/src/core.c" 3 4
                                  , 
# 20239 "/libmdbx/src/core.c"
                                  mn_data
# 20239 "/libmdbx/src/core.c" 3 4
                                  ) 
# 20239 "/libmdbx/src/core.c"
                                           - sizeof(MDBX_db))
    return MDBX_EINVAL;

  if (txn->mt_dbxs[1].md_cmp == 
# 20242 "/libmdbx/src/core.c" 3 4
                                      ((void *)0)
# 20242 "/libmdbx/src/core.c"
                                          ) {
    txn->mt_dbxs[1].md_cmp =
        get_default_keycmp(txn->mt_dbs[1].md_flags);
    txn->mt_dbxs[1].md_dcmp =
        get_default_datacmp(txn->mt_dbs[1].md_flags);
  }


  MDBX_dbi scan, slot;
  for (slot = scan = txn->mt_numdbs; --scan >= 2;) {
    if (!txn->mt_dbxs[scan].md_name.iov_len) {

      slot = scan;
      continue;
    }
    if (len == txn->mt_dbxs[scan].md_name.iov_len &&
        !strncmp(table_name, txn->mt_dbxs[scan].md_name.iov_base, len)) {
      rc = mdbx_dbi_bind(txn, scan, user_flags, keycmp, datacmp);
      if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
        goto early_bailout;
      *dbi = scan;
      return rc;
    }
  }


  if (__builtin_expect(!!(slot >= env->me_maxdbs), 0)) {
    rc = MDBX_DBS_FULL;
    goto early_bailout;
  }


  if (__builtin_expect(!!(txn->mt_dbs[1].md_flags & (MDBX_DUPSORT | MDBX_INTEGERKEY)), 0)
                                                ) {
    rc = (user_flags & MDBX_CREATE) ? MDBX_INCOMPATIBLE : MDBX_NOTFOUND;
    goto early_bailout;
  }


  MDBX_val key, data;
  key.iov_len = len;
  key.iov_base = (void *)table_name;
  MDBX_cursor_couple couple;
  rc = mdbx_cursor_init(&couple.outer, txn, 1);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    goto early_bailout;
  rc = mdbx_cursor_set(&couple.outer, &key, &data, MDBX_SET).err;
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0)) {
    if (rc != MDBX_NOTFOUND || !(user_flags & MDBX_CREATE))
      goto early_bailout;
  } else {

    MDBX_node *node = page_node(couple.outer.mc_pg[couple.outer.mc_top],
                                couple.outer.mc_ki[couple.outer.mc_top]);
    if (__builtin_expect(!!((node_flags(node) & (0x04 | 0x02)) != 0x02), 0)) {
      rc = MDBX_INCOMPATIBLE;
      goto early_bailout;
    }
    if (!0 && __builtin_expect(!!(data.iov_len != sizeof(MDBX_db)), 0)) {
      rc = MDBX_CORRUPTED;
      goto early_bailout;
    }
  }

  if (rc != MDBX_SUCCESS && __builtin_expect(!!(txn->mt_flags & MDBX_TXN_RDONLY), 0)) {
    rc = MDBX_EACCESS;
    goto early_bailout;
  }


  char *namedup = strdup(table_name);
  if (__builtin_expect(!!(!namedup), 0)) {
    rc = MDBX_ENOMEM;
    goto early_bailout;
  }

  int err = mdbx_fastmutex_acquire(&env->me_dbi_lock);
  if (__builtin_expect(!!(err != MDBX_SUCCESS), 0)) {
    rc = err;
    free(namedup);
    goto early_bailout;
  }


  dbi_import_locked(txn);


  for (slot = scan = txn->mt_numdbs; --scan >= 2;) {
    if (!txn->mt_dbxs[scan].md_name.iov_len) {

      slot = scan;
      continue;
    }
    if (len == txn->mt_dbxs[scan].md_name.iov_len &&
        !strncmp(table_name, txn->mt_dbxs[scan].md_name.iov_base, len)) {
      rc = mdbx_dbi_bind(txn, scan, user_flags, keycmp, datacmp);
      if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
        goto later_bailout;
      *dbi = scan;
      goto later_exit;
    }
  }

  if (__builtin_expect(!!(slot >= env->me_maxdbs), 0)) {
    rc = MDBX_DBS_FULL;
    goto later_bailout;
  }

  unsigned dbiflags = MDBX_DBI_FRESH | 0x10 | 0x20;
  MDBX_db db_dummy;
  if (__builtin_expect(!!(rc), 0)) {

    do { if ((0)) do { if (__builtin_expect(!!(!(rc == MDBX_NOTFOUND)), 0)) mdbx_assert_fail((txn)->mt_env, "rc == MDBX_NOTFOUND", __func__, 20354); } while (0); } while (0);
    memset(&db_dummy, 0, sizeof(db_dummy));
    db_dummy.md_root = (~(pgno_t)0);
    db_dummy.md_mod_txnid = txn->mt_txnid;
    db_dummy.md_flags = user_flags & (MDBX_REVERSEKEY | MDBX_DUPSORT | MDBX_INTEGERKEY | MDBX_DUPFIXED | MDBX_INTEGERDUP | MDBX_REVERSEDUP);
    data.iov_len = sizeof(db_dummy);
    data.iov_base = &db_dummy;
    do { do { if ((0)) do { if (__builtin_expect(!!(!(couple.outer.mc_txn->mt_cursors != 
# 20361 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 20361 "/libmdbx/src/core.c"
   )), 0)) mdbx_assert_fail((&(couple.outer))->mc_txn->mt_env, "couple.outer.mc_txn->mt_cursors != ((void *)0)", __func__, 20361); } while (0); } while (0); do { if ((0)) do { if (__builtin_expect(!!(!(!cursor_is_tracked(&(couple.outer)))), 0)) mdbx_assert_fail((&(couple.outer))->mc_txn->mt_env, "!cursor_is_tracked(&(couple.outer))", __func__, 20361); } while (0); } while (0); MDBX_cursor mc_dummy; MDBX_cursor **tracking_head = &(couple.outer).mc_txn->mt_cursors[couple.outer.mc_dbi]; MDBX_cursor *tracked = &(couple.outer); if ((couple.outer).mc_flags & 0x04) { mc_dummy.mc_flags = 0x01; mc_dummy.mc_top = 0; mc_dummy.mc_snum = 0; mc_dummy.mc_xcursor = (MDBX_xcursor *)&(couple.outer); tracked = &mc_dummy; } tracked->mc_next = *tracking_head; *tracking_head = tracked; { rc = mdbx_cursor_put(&couple.outer, &key, &data, 0x02 | MDBX_NOOVERWRITE); } *tracking_head = tracked->mc_next; } while (0)

                                                                            ;

    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      goto later_bailout;

    dbiflags |= MDBX_DBI_DIRTY | MDBX_DBI_CREAT;
    txn->mt_flags |= 0x04;
    do { if ((0)) do { if (__builtin_expect(!!(!((txn->mt_dbistate[1] & MDBX_DBI_DIRTY) != 0)), 0)) mdbx_assert_fail((txn)->mt_env, "(txn->mt_dbistate[1] & MDBX_DBI_DIRTY) != 0", __func__, 20370); } while (0); } while (0);
  }


  memset(txn->mt_dbxs + slot, 0, sizeof(MDBX_dbx));
  memcpy(&txn->mt_dbs[slot], data.iov_base, sizeof(MDBX_db));
  env->me_dbflags[slot] = 0;
  rc = mdbx_dbi_bind(txn, slot, user_flags, keycmp, datacmp);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0)) {
    do { if ((0)) do { if (__builtin_expect(!!(!((dbiflags & MDBX_DBI_CREAT) == 0)), 0)) mdbx_assert_fail((txn)->mt_env, "(dbiflags & MDBX_DBI_CREAT) == 0", __func__, 20379); } while (0); } while (0);
  later_bailout:
    *dbi = 0;
  later_exit:
    free(namedup);
  } else {
    txn->mt_dbistate[slot] = (uint8_t)dbiflags;
    txn->mt_dbxs[slot].md_name.iov_base = namedup;
    txn->mt_dbxs[slot].md_name.iov_len = len;
    txn->mt_dbiseqs[slot] = ++env->me_dbiseqs[slot];
    if (!(dbiflags & MDBX_DBI_CREAT))
      env->me_dbflags[slot] = txn->mt_dbs[slot].md_flags | 0x8000;
    if (txn->mt_numdbs == slot) {
      mdbx_compiler_barrier();
      txn->mt_numdbs = env->me_numdbs = slot + 1;
      txn->mt_cursors[slot] = 
# 20394 "/libmdbx/src/core.c" 3 4
                             ((void *)0)
# 20394 "/libmdbx/src/core.c"
                                 ;
    }
    do { if ((0)) do { if (__builtin_expect(!!(!(env->me_numdbs > slot)), 0)) mdbx_assert_fail(env, "env->me_numdbs > slot", __func__, 20396); } while (0); } while (0);
    *dbi = slot;
  }

  do { if (__builtin_expect(!!(!(mdbx_fastmutex_release(&env->me_dbi_lock) == MDBX_SUCCESS)), 0)) mdbx_assert_fail(env, "mdbx_fastmutex_release(&env->me_dbi_lock) == MDBX_SUCCESS", __func__, 20400); } while (0);
  return rc;
}

int mdbx_dbi_open(MDBX_txn *txn, const char *table_name,
                  MDBX_db_flags_t table_flags, MDBX_dbi *dbi) {
  return dbi_open(txn, table_name, table_flags, dbi, 
# 20406 "/libmdbx/src/core.c" 3 4
                                                    ((void *)0)
# 20406 "/libmdbx/src/core.c"
                                                           , 
# 20406 "/libmdbx/src/core.c" 3 4
                                                             ((void *)0)
# 20406 "/libmdbx/src/core.c"
                                                                    );
}

int mdbx_dbi_open_ex(MDBX_txn *txn, const char *table_name,
                     MDBX_db_flags_t table_flags, MDBX_dbi *dbi,
                     MDBX_cmp_func *keycmp, MDBX_cmp_func *datacmp) {
  return dbi_open(txn, table_name, table_flags, dbi, keycmp, datacmp);
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_dbi_stat(MDBX_txn *txn, MDBX_dbi dbi, MDBX_stat *dest,
                         size_t bytes) {
  int rc = check_txn(txn, (0x01 | 0x02 | 0x10));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(!dest), 0))
    return MDBX_EINVAL;

  if (__builtin_expect(!!(!check_dbi(txn, dbi, 0x10)), 0))
    return MDBX_BAD_DBI;

  const size_t size_before_modtxnid = 
# 20427 "/libmdbx/src/core.c" 3 4
                                     __builtin_offsetof (
# 20427 "/libmdbx/src/core.c"
                                     MDBX_stat
# 20427 "/libmdbx/src/core.c" 3 4
                                     , 
# 20427 "/libmdbx/src/core.c"
                                     ms_mod_txnid
# 20427 "/libmdbx/src/core.c" 3 4
                                     )
# 20427 "/libmdbx/src/core.c"
                                                                      ;
  if (__builtin_expect(!!(bytes != sizeof(MDBX_stat)), 0) && bytes != size_before_modtxnid)
    return MDBX_EINVAL;

  if (__builtin_expect(!!(txn->mt_flags & (0x01 | 0x02 | 0x10)), 0))
    return MDBX_BAD_TXN;

  if (__builtin_expect(!!(txn->mt_dbistate[dbi] & MDBX_DBI_STALE), 0)) {
    rc = mdbx_fetch_sdb(txn, dbi);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      return rc;
  }

  dest->ms_psize = txn->mt_env->me_psize;
  stat_get(&txn->mt_dbs[dbi], dest, bytes);
  return MDBX_SUCCESS;
}

static int mdbx_dbi_close_locked(MDBX_env *env, MDBX_dbi dbi) {
  do { if ((0)) do { if (__builtin_expect(!!(!(dbi >= 2)), 0)) mdbx_assert_fail(env, "dbi >= 2", __func__, 20446); } while (0); } while (0);
  if (__builtin_expect(!!(dbi >= env->me_numdbs), 0))
    return MDBX_BAD_DBI;

  char *ptr = env->me_dbxs[dbi].md_name.iov_base;

  if (__builtin_expect(!!(!ptr), 0))
    return MDBX_BAD_DBI;

  env->me_dbflags[dbi] = 0;
  env->me_dbiseqs[dbi]++;
  env->me_dbxs[dbi].md_name.iov_len = 0;
  mdbx_memory_fence(mo_AcquireRelease, (1));
  env->me_dbxs[dbi].md_name.iov_base = 
# 20459 "/libmdbx/src/core.c" 3 4
                                      ((void *)0)
# 20459 "/libmdbx/src/core.c"
                                          ;
  free(ptr);

  if (env->me_numdbs == dbi + 1) {
    unsigned i = env->me_numdbs;
    do
      --i;
    while (i > 2 && !env->me_dbxs[i - 1].md_name.iov_base);
    env->me_numdbs = i;
  }

  return MDBX_SUCCESS;
}

int mdbx_dbi_close(MDBX_env *env, MDBX_dbi dbi) {
  int rc = check_env(env, (1));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(dbi < 2 || dbi >= env->me_maxdbs), 0))
    return MDBX_BAD_DBI;

  rc = mdbx_fastmutex_acquire(&env->me_dbi_lock);
  if (__builtin_expect(!!(rc == MDBX_SUCCESS), 1)) {
    rc = (dbi < env->me_maxdbs && (env->me_dbflags[dbi] & 0x8000))
             ? mdbx_dbi_close_locked(env, dbi)
             : MDBX_BAD_DBI;
    do { if (__builtin_expect(!!(!(mdbx_fastmutex_release(&env->me_dbi_lock) == MDBX_SUCCESS)), 0)) mdbx_assert_fail(env, "mdbx_fastmutex_release(&env->me_dbi_lock) == MDBX_SUCCESS", __func__, 20486); } while (0);
  }
  return rc;
}

int mdbx_dbi_flags_ex(MDBX_txn *txn, MDBX_dbi dbi, unsigned *flags,
                      unsigned *state) {
  int rc = check_txn(txn, (0x01 | 0x02 | 0x10) - 0x02);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(!flags || !state), 0))
    return MDBX_EINVAL;

  if (__builtin_expect(!!(!check_dbi(txn, dbi, 0x10)), 0))
    return MDBX_BAD_DBI;

  *flags = txn->mt_dbs[dbi].md_flags & (MDBX_REVERSEKEY | MDBX_DUPSORT | MDBX_INTEGERKEY | MDBX_DUPFIXED | MDBX_INTEGERDUP | MDBX_REVERSEDUP);
  *state =
      txn->mt_dbistate[dbi] & (MDBX_DBI_FRESH | MDBX_DBI_CREAT | MDBX_DBI_DIRTY | MDBX_DBI_STALE);

  return MDBX_SUCCESS;
}


int mdbx_dbi_flags(MDBX_txn *txn, MDBX_dbi dbi, unsigned *flags) {
  return __inline_mdbx_dbi_flags(txn, dbi, flags);
}


static int mdbx_drop_tree(MDBX_cursor *mc, const _Bool may_have_subDBs) {
  int rc = mdbx_page_search(mc, 
# 20517 "/libmdbx/src/core.c" 3 4
                               ((void *)0)
# 20517 "/libmdbx/src/core.c"
                                   , 4);
  if (__builtin_expect(!!(rc == MDBX_SUCCESS), 1)) {
    MDBX_txn *txn = mc->mc_txn;





    if (!(may_have_subDBs | mc->mc_db->md_overflow_pages))
      mdbx_cursor_pop(mc);

    rc = mdbx_pnl_need(&txn->tw.retired_pages,
                       mc->mc_db->md_branch_pages + mc->mc_db->md_leaf_pages +
                           mc->mc_db->md_overflow_pages);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      goto bailout;

    MDBX_cursor mx;
    cursor_copy(mc, &mx);
    while (mc->mc_snum > 0) {
      MDBX_page *const mp = mc->mc_pg[mc->mc_top];
      const unsigned nkeys = page_numkeys(mp);
      if ((((mp)->mp_flags & 0x02) != 0)) {
        do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_snum == mc->mc_db->md_depth)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mc->mc_snum == mc->mc_db->md_depth", __func__, 20540); } while (0); } while (0);
        for (unsigned i = 0; i < nkeys; i++) {
          MDBX_node *node = page_node(mp, i);
          if (node_flags(node) & 0x01) {
            rc = mdbx_page_retire_ex(mc, node_largedata_pgno(node), 
# 20544 "/libmdbx/src/core.c" 3 4
                                                                   ((void *)0)
# 20544 "/libmdbx/src/core.c"
                                                                       , 0);
            if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
              goto bailout;
            if (!(may_have_subDBs | mc->mc_db->md_overflow_pages))
              goto pop;
          } else if (node_flags(node) & 0x02) {
            if (__builtin_expect(!!((node_flags(node) & 0x04) == 0), 0)) {
              rc = MDBX_INCOMPATIBLE;
              goto bailout;
            }
            rc = mdbx_xcursor_init1(mc, node, mp);
            if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
              goto bailout;
            rc = mdbx_drop_tree(&mc->mc_xcursor->mx_cursor, (0));
            if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
              goto bailout;
          }
        }
      } else {
        do { if ((0)) do { if (__builtin_expect(!!(!(mc->mc_snum < mc->mc_db->md_depth)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "mc->mc_snum < mc->mc_db->md_depth", __func__, 20563); } while (0); } while (0);
        if ((0))
          mc->mc_flags |= 0x400;
        const int pagetype =
            (((mp)->mp_txnid < (txn)->mt_txnid) ? 0x8000 : 0) +
            ((mc->mc_snum + 1 == mc->mc_db->md_depth) ? 0x02 : 0x01);
        for (unsigned i = 0; i < nkeys; i++) {
          MDBX_node *node = page_node(mp, i);
          do { if ((0)) do { if (__builtin_expect(!!(!((node_flags(node) & (0x01 | 0x02 | 0x04)) == 0)), 0)) mdbx_assert_fail((txn)->mt_env, "(node_flags(node) & (0x01 | 0x02 | 0x04)) == 0", __func__, 20571); } while (0); } while (0)
                                                                       ;
          const pgno_t pgno = node_pgno(node);
          rc = mdbx_page_retire_ex(mc, pgno, 
# 20574 "/libmdbx/src/core.c" 3 4
                                            ((void *)0)
# 20574 "/libmdbx/src/core.c"
                                                , pagetype);
          if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
            goto bailout;
        }
        if ((0))
          mc->mc_flags -= 0x400;
      }
      if (!mc->mc_top)
        break;
      do { if ((0)) do { if (__builtin_expect(!!(!(nkeys > 0)), 0)) mdbx_assert_fail((mc)->mc_txn->mt_env, "nkeys > 0", __func__, 20583); } while (0); } while (0);
      mc->mc_ki[mc->mc_top] = (indx_t)nkeys;
      rc = mdbx_cursor_sibling(mc, 2);
      if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0)) {
        if (__builtin_expect(!!(rc != MDBX_NOTFOUND), 0))
          goto bailout;


      pop:
        mdbx_cursor_pop(mc);
        mc->mc_ki[0] = 0;
        for (unsigned i = 1; i < mc->mc_snum; i++) {
          mc->mc_ki[i] = 0;
          mc->mc_pg[i] = mx.mc_pg[i];
        }
      }
    }
    rc = mdbx_page_retire(mc, mc->mc_pg[0]);
  bailout:
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      txn->mt_flags |= 0x02;
  } else if (rc == MDBX_NOTFOUND) {
    rc = MDBX_SUCCESS;
  }
  mc->mc_flags &= ~0x01;
  return rc;
}

int mdbx_drop(MDBX_txn *txn, MDBX_dbi dbi, _Bool del) {
  int rc = check_txn_rw(txn, (0x01 | 0x02 | 0x10));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  MDBX_cursor *mc;
  rc = mdbx_cursor_open(txn, dbi, &mc);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  rc = mdbx_drop_tree(mc, dbi == 1 ||
                              (mc->mc_db->md_flags & MDBX_DUPSORT) != 0);

  for (MDBX_cursor *m2 = txn->mt_cursors[dbi]; m2; m2 = m2->mc_next)
    m2->mc_flags &= ~(0x01 | 0x02);
  if (__builtin_expect(!!(rc), 0))
    goto bailout;


  if (del && dbi >= 2) {
    rc = mdbx_del0(txn, 1, &mc->mc_dbx->md_name, 
# 20631 "/libmdbx/src/core.c" 3 4
                                                       ((void *)0)
# 20631 "/libmdbx/src/core.c"
                                                           , 0x02);
    if (__builtin_expect(!!(rc == MDBX_SUCCESS), 1)) {
      do { if ((0)) do { if (__builtin_expect(!!(!(txn->mt_dbistate[1] & MDBX_DBI_DIRTY)), 0)) mdbx_assert_fail((txn)->mt_env, "txn->mt_dbistate[1] & MDBX_DBI_DIRTY", __func__, 20633); } while (0); } while (0);
      do { if ((0)) do { if (__builtin_expect(!!(!(txn->mt_flags & 0x04)), 0)) mdbx_assert_fail((txn)->mt_env, "txn->mt_flags & 0x04", __func__, 20634); } while (0); } while (0);
      txn->mt_dbistate[dbi] = MDBX_DBI_STALE;
      MDBX_env *env = txn->mt_env;
      rc = mdbx_fastmutex_acquire(&env->me_dbi_lock);
      if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0)) {
        txn->mt_flags |= 0x02;
        goto bailout;
      }
      mdbx_dbi_close_locked(env, dbi);
      do { if (__builtin_expect(!!(!(mdbx_fastmutex_release(&env->me_dbi_lock) == MDBX_SUCCESS)), 0)) mdbx_assert_fail(env, "mdbx_fastmutex_release(&env->me_dbi_lock) == MDBX_SUCCESS", __func__, 20643); } while (0)
                                                                            ;
    } else {
      txn->mt_flags |= 0x02;
    }
  } else {

    txn->mt_dbistate[dbi] |= MDBX_DBI_DIRTY;
    txn->mt_dbs[dbi].md_depth = 0;
    txn->mt_dbs[dbi].md_branch_pages = 0;
    txn->mt_dbs[dbi].md_leaf_pages = 0;
    txn->mt_dbs[dbi].md_overflow_pages = 0;
    txn->mt_dbs[dbi].md_entries = 0;
    txn->mt_dbs[dbi].md_root = (~(pgno_t)0);
    txn->mt_dbs[dbi].md_seq = 0;

    txn->mt_flags |= 0x04;
  }

bailout:
  mdbx_cursor_close(mc);
  return rc;
}

int mdbx_set_compare(MDBX_txn *txn, MDBX_dbi dbi, MDBX_cmp_func *cmp) {
  int rc = check_txn(txn, (0x01 | 0x02 | 0x10) - 0x02);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(!check_dbi(txn, dbi, 0x20)), 0))
    return MDBX_BAD_DBI;

  txn->mt_dbxs[dbi].md_cmp = cmp;
  return MDBX_SUCCESS;
}

int mdbx_set_dupsort(MDBX_txn *txn, MDBX_dbi dbi, MDBX_cmp_func *cmp) {
  int rc = check_txn(txn, (0x01 | 0x02 | 0x10) - 0x02);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(!check_dbi(txn, dbi, 0x20)), 0))
    return MDBX_BAD_DBI;

  txn->mt_dbxs[dbi].md_dcmp = cmp;
  return MDBX_SUCCESS;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_reader_list(const MDBX_env *env, MDBX_reader_list_func *func,
                            void *ctx) {
  int rc = check_env(env, (1));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(!func), 0))
    return MDBX_EINVAL;

  rc = MDBX_RESULT_TRUE;
  int serial = 0;
  MDBX_lockinfo *const lck = env->me_lck_mmap.lck;
  if (__builtin_expect(!!(lck), 1)) {
    const unsigned snap_nreaders =
        atomic_load32(&lck->mti_numreaders, mo_AcquireRelease);
    for (unsigned i = 0; i < snap_nreaders; i++) {
      const MDBX_reader *r = lck->mti_readers + i;
    retry_reader:;
      const uint32_t pid = atomic_load32(&r->mr_pid, mo_AcquireRelease);
      if (!pid)
        continue;
      txnid_t txnid = safe64_read(&r->mr_txnid);
      const uint64_t tid = atomic_load64(&r->mr_tid, mo_Relaxed);
      const pgno_t pages_used =
          atomic_load32(&r->mr_snapshot_pages_used, mo_Relaxed);
      const uint64_t reader_pages_retired =
          atomic_load64(&r->mr_snapshot_pages_retired, mo_Relaxed);
      if (__builtin_expect(!!(txnid != safe64_read(&r->mr_txnid) || pid != atomic_load32(&r->mr_pid, mo_AcquireRelease) || tid != atomic_load64(&r->mr_tid, mo_Relaxed) || pages_used != atomic_load32(&r->mr_snapshot_pages_used, mo_Relaxed) || reader_pages_retired != atomic_load64(&r->mr_snapshot_pages_retired, mo_Relaxed)), 0)






                                                                           )
        goto retry_reader;

      do { if ((0)) do { if (__builtin_expect(!!(!(txnid > 0)), 0)) mdbx_assert_fail(env, "txnid > 0", __func__, 20728); } while (0); } while (0);
      if (txnid >= 0xffffFFFF00000000UL)
        txnid = 0;

      size_t bytes_used = 0;
      size_t bytes_retained = 0;
      uint64_t lag = 0;
      if (txnid) {
      retry_header:;
        volatile const MDBX_meta *const recent_meta = meta_prefer_last(env);
        const uint64_t head_pages_retired =
            unaligned_peek_u64_volatile(4, recent_meta->mm_pages_retired);
        const txnid_t head_txnid = meta_txnid(env, recent_meta);
        mdbx_compiler_barrier();
        if (__builtin_expect(!!(recent_meta != meta_prefer_last(env) || head_pages_retired != unaligned_peek_u64_volatile( 4, recent_meta->mm_pages_retired)), 0)


                                                                ||
            head_txnid != meta_txnid(env, recent_meta))
          goto retry_header;

        lag = (head_txnid - txnid) / 1u;
        bytes_used = pgno2bytes(env, pages_used);
        bytes_retained = (head_pages_retired > reader_pages_retired)
                             ? pgno2bytes(env, (pgno_t)(head_pages_retired -
                                                        reader_pages_retired))
                             : 0;
      }
      rc = func(ctx, ++serial, i, pid, (mdbx_tid_t)tid, txnid, lag, bytes_used,
                bytes_retained);
      if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
        break;
    }
  }

  return rc;
}



__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static _Bool mdbx_pid_insert(uint32_t *ids, uint32_t pid) {

  unsigned base = 0;
  unsigned cursor = 1;
  int val = 0;
  unsigned n = ids[0];

  while (n > 0) {
    unsigned pivot = n >> 1;
    cursor = base + pivot + 1;
    val = pid - ids[cursor];

    if (val < 0) {
      n = pivot;
    } else if (val > 0) {
      base = cursor;
      n -= pivot + 1;
    } else {

      return (0);
    }
  }

  if (val > 0)
    ++cursor;

  ids[0]++;
  for (n = ids[0]; n > cursor; n--)
    ids[n] = ids[n - 1];
  ids[n] = pid;
  return (1);
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_reader_check(MDBX_env *env, int *dead) {
  if (dead)
    *dead = 0;
  return mdbx_cleanup_dead_readers(env, (0), dead);
}





__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static int
mdbx_cleanup_dead_readers(MDBX_env *env, int rdt_locked, int *dead) {
  int rc = check_env(env, (1));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  do { if ((0)) do { if (__builtin_expect(!!(!(rdt_locked >= 0)), 0)) mdbx_assert_fail(env, "rdt_locked >= 0", __func__, 20817); } while (0); } while (0);
  MDBX_lockinfo *const lck = env->me_lck_mmap.lck;
  if (__builtin_expect(!!(lck == 
# 20819 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 20819 "/libmdbx/src/core.c"
     ), 0)) {

    if (dead)
      *dead = 0;
    return MDBX_SUCCESS;
  }

  const unsigned snap_nreaders =
      atomic_load32(&lck->mti_numreaders, mo_AcquireRelease);
  uint32_t pidsbuf_onstask[142];
  uint32_t *const pids =
      (snap_nreaders < (sizeof(pidsbuf_onstask) / sizeof(pidsbuf_onstask[0])))
          ? pidsbuf_onstask
          : malloc((snap_nreaders + 1) * sizeof(uint32_t));
  if (__builtin_expect(!!(!pids), 0))
    return MDBX_ENOMEM;

  pids[0] = 0;
  int count = 0;
  for (unsigned i = 0; i < snap_nreaders; i++) {
    const uint32_t pid =
        atomic_load32(&lck->mti_readers[i].mr_pid, mo_AcquireRelease);
    if (pid == 0)
      continue ;
    if (pid == env->me_pid)
      continue ;
    if (!mdbx_pid_insert(pids, pid))
      continue ;

    int err = mdbx_rpid_check(env, pid);
    if (err == MDBX_RESULT_TRUE)
      continue ;

    if (err != MDBX_SUCCESS) {
      rc = err;
      break ;
    }


    if (!rdt_locked) {
      err = mdbx_rdt_lock(env);
      if (((err) != MDBX_RESULT_TRUE && (err) != MDBX_RESULT_FALSE)) {
        rc = err;
        break;
      }

      rdt_locked = -1;
      if (err == MDBX_RESULT_TRUE) {

        rc = MDBX_RESULT_TRUE;
        break;
      }


      if (lck->mti_readers[i].mr_pid.weak != pid)
        continue;

      err = mdbx_rpid_check(env, pid);
      if (((err) != MDBX_RESULT_TRUE && (err) != MDBX_RESULT_FALSE)) {
        rc = err;
        break;
      }

      if (err != MDBX_SUCCESS)
        continue ;
    }


    for (unsigned j = i; j < snap_nreaders; j++) {
      if (lck->mti_readers[j].mr_pid.weak == pid) {
        do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 20889, "clear stale reader pid %" 
# 20889 "/libmdbx/src/core.c" 3 4
       "l" "u" 
# 20889 "/libmdbx/src/core.c"
       " txn %" 
# 20889 "/libmdbx/src/core.c" 3 4
       "l" "i" 
# 20889 "/libmdbx/src/core.c"
       "\n", (size_t)pid, lck->mti_readers[j].mr_txnid.weak); } while (0)
                                                                  ;
        atomic_store32(&lck->mti_readers[j].mr_pid, 0, mo_Relaxed);
        atomic_store32(&lck->mti_readers_refresh_flag, (1), mo_AcquireRelease);
        count++;
      }
    }
  }

  if (__builtin_expect(!!(!((rc) != MDBX_RESULT_TRUE && (rc) != MDBX_RESULT_FALSE)), 1))
    atomic_store64(&lck->mti_reader_check_timestamp, mdbx_osal_monotime(),
                   mo_Relaxed);

  if (rdt_locked < 0)
    mdbx_rdt_unlock(env);

  if (pids != pidsbuf_onstask)
    free(pids);

  if (dead)
    *dead = count;
  return rc;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_setup_debug(int loglevel, int flags, MDBX_debug_func *logger) {
  const int rc = mdbx_runtime_flags | (mdbx_loglevel << 16);

  if (loglevel != MDBX_LOG_DONTCHANGE)
    mdbx_loglevel = (uint8_t)loglevel;

  if (flags != MDBX_DBG_DONTCHANGE) {
    flags &=



        MDBX_DBG_DUMP | MDBX_DBG_LEGACY_MULTIOPEN | MDBX_DBG_LEGACY_OVERLAP |
        MDBX_DBG_DONT_UPGRADE;
    mdbx_runtime_flags = (uint8_t)flags;
  }

  if (logger != ((MDBX_debug_func *)(intptr_t)-1))
    mdbx_debug_logger = logger;
  return rc;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static txnid_t mdbx_kick_longlived_readers(MDBX_env *env,
                                                  const txnid_t laggard) {
  do { if ((MDBX_LOG_DEBUG < MDBX_LOG_VERBOSE && MDBX_LOG_DEBUG <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_DEBUG, __func__, 20936, "DB size maxed out by reading #%" 
# 20936 "/libmdbx/src/core.c" 3 4
 "l" "i" 
# 20936 "/libmdbx/src/core.c"
 "\n", laggard); } while (0);

  int retry;
  for (retry = 0; retry < 0x7fffffff; ++retry) {
    txnid_t oldest = mdbx_recent_steady_txnid(env);
    do { if ((0)) do { if (__builtin_expect(!!(!(oldest < env->me_txn0->mt_txnid)), 0)) mdbx_assert_fail(env, "oldest < env->me_txn0->mt_txnid", __func__, 20941); } while (0); } while (0);
    do { if ((0)) do { if (__builtin_expect(!!(!(oldest >= laggard)), 0)) mdbx_assert_fail(env, "oldest >= laggard", __func__, 20942); } while (0); } while (0);
    do { if ((0)) do { if (__builtin_expect(!!(!(oldest >= env->me_lck->mti_oldest_reader.weak)), 0)) mdbx_assert_fail(env, "oldest >= env->me_lck->mti_oldest_reader.weak", __func__, 20943); } while (0); } while (0);
    MDBX_lockinfo *const lck = env->me_lck_mmap.lck;
    if (oldest == laggard || __builtin_expect(!!(!lck), 0))
      return oldest;

    if (((mdbx_cleanup_dead_readers(env, (0), 
# 20948 "/libmdbx/src/core.c" 3 4
       ((void *)0)
# 20948 "/libmdbx/src/core.c"
       )) != MDBX_RESULT_TRUE && (mdbx_cleanup_dead_readers(env, (0), 
# 20948 "/libmdbx/src/core.c" 3 4
       ((void *)0)
# 20948 "/libmdbx/src/core.c"
       )) != MDBX_RESULT_FALSE))
      break;

    MDBX_reader *asleep = 
# 20951 "/libmdbx/src/core.c" 3 4
                         ((void *)0)
# 20951 "/libmdbx/src/core.c"
                                ;
    uint64_t oldest_retired = 
# 20952 "/libmdbx/src/core.c" 3 4
                             (18446744073709551615UL)
# 20952 "/libmdbx/src/core.c"
                                       ;
    const unsigned snap_nreaders =
        atomic_load32(&lck->mti_numreaders, mo_AcquireRelease);
    for (unsigned i = 0; i < snap_nreaders; ++i) {
    retry:
      if (atomic_load32(&lck->mti_readers[i].mr_pid, mo_AcquireRelease)) {

        const uint64_t snap_retired = atomic_load64(
            &lck->mti_readers[i].mr_snapshot_pages_retired, mo_Relaxed);
        const txnid_t snap_txnid = safe64_read(&lck->mti_readers[i].mr_txnid);
        if (__builtin_expect(!!(snap_retired != atomic_load64( &lck->mti_readers[i].mr_snapshot_pages_retired, mo_AcquireRelease) || snap_txnid != safe64_read(&lck->mti_readers[i].mr_txnid)), 0)



                                                                              )
          goto retry;
        if (oldest > snap_txnid &&
            laggard <= snap_txnid) {
          oldest = snap_txnid;
          oldest_retired = snap_retired;
          asleep = &lck->mti_readers[i];
        }
      }
    }

    if (laggard < oldest || !asleep) {
      if (retry && env->me_hsr_callback) {

        const txnid_t gap = oldest - laggard;
        env->me_hsr_callback(env, env->me_txn, 0, 0, laggard,
                             (gap < 
# 20982 "/libmdbx/src/core.c" 3 4
                                   (0x7fffffff * 2U + 1U)
# 20982 "/libmdbx/src/core.c"
                                           ) ? (unsigned)gap : 
# 20982 "/libmdbx/src/core.c" 3 4
                                                               (0x7fffffff * 2U + 1U)
# 20982 "/libmdbx/src/core.c"
                                                                       , 0,
                             -retry);
      }
      do { if ((MDBX_LOG_NOTICE < MDBX_LOG_VERBOSE && MDBX_LOG_NOTICE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_NOTICE, __func__, 20985, "hsr-kick: update oldest %" 
# 20985 "/libmdbx/src/core.c" 3 4
     "l" "i" 
# 20985 "/libmdbx/src/core.c"
     " -> %" 
# 20985 "/libmdbx/src/core.c" 3 4
     "l" "i" 
# 20985 "/libmdbx/src/core.c"
     "\n", lck->mti_oldest_reader.weak, oldest); } while (0)
                                                      ;
      do { if ((0)) do { if (__builtin_expect(!!(!(lck->mti_oldest_reader.weak <= oldest)), 0)) mdbx_assert_fail(env, "lck->mti_oldest_reader.weak <= oldest", __func__, 20987); } while (0); } while (0);
      return atomic_store64(&lck->mti_oldest_reader, oldest, mo_Relaxed);
    }

    if (!env->me_hsr_callback)
      break;

    uint32_t pid = atomic_load32(&asleep->mr_pid, mo_AcquireRelease);
    uint64_t tid = asleep->mr_tid.weak;
    if (safe64_read(&asleep->mr_txnid) != laggard || pid <= 0)
      continue;

    const MDBX_meta *head_meta = constmeta_prefer_last(env);
    const txnid_t gap =
        (constmeta_txnid(env, head_meta) - laggard) / 1u;
    const uint64_t head_retired =
        unaligned_peek_u64(4, head_meta->mm_pages_retired);
    const size_t space =
        (head_retired > oldest_retired)
            ? pgno2bytes(env, (pgno_t)(head_retired - oldest_retired))
            : 0;
    int rc = env->me_hsr_callback(
        env, env->me_txn, pid, (mdbx_tid_t)tid, laggard,
        (gap < 
# 21010 "/libmdbx/src/core.c" 3 4
              (0x7fffffff * 2U + 1U)
# 21010 "/libmdbx/src/core.c"
                      ) ? (unsigned)gap : 
# 21010 "/libmdbx/src/core.c" 3 4
                                          (0x7fffffff * 2U + 1U)
# 21010 "/libmdbx/src/core.c"
                                                  , space, retry);
    if (rc < 0)
      break;

    if (rc > 0) {
      if (rc == 1) {
        safe64_reset_compare(&asleep->mr_txnid, laggard);
      } else {
        safe64_reset(&asleep->mr_txnid, (1));
        atomic_store64(&asleep->mr_tid, 0, mo_Relaxed);
        atomic_store32(&asleep->mr_pid, 0, mo_Relaxed);
      }
      atomic_store32(&lck->mti_readers_refresh_flag, (1), mo_Relaxed);
    }
  }

  if (retry && env->me_hsr_callback) {

    env->me_hsr_callback(env, env->me_txn, 0, 0, laggard, 0, 0, -retry);
  }
  return mdbx_find_oldest(env->me_txn);
}


__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_set_syncbytes(MDBX_env *env, size_t threshold) {
  return __inline_mdbx_env_set_syncbytes(env, threshold);
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_set_syncperiod(MDBX_env *env, unsigned seconds_16dot16) {
  return __inline_mdbx_env_set_syncperiod(env, seconds_16dot16);
}


__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_set_hsr(MDBX_env *env, MDBX_hsr_func *hsr) {
  int rc = check_env(env, (0));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  env->me_hsr_callback = hsr;
  return MDBX_SUCCESS;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) MDBX_hsr_func *mdbx_env_get_hsr(const MDBX_env *env) {
  return __builtin_expect(!!(env && env->me_signature.weak == 0x9A899641U), 1)
             ? env->me_hsr_callback
             : 
# 21055 "/libmdbx/src/core.c" 3 4
              ((void *)0)
# 21055 "/libmdbx/src/core.c"
                  ;
}





int mdbx_txn_straggler(const MDBX_txn *txn, int *percent)
{
  int rc = check_txn(txn, (0x01 | 0x02 | 0x10));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return (rc > 0) ? -rc : rc;

  MDBX_env *env = txn->mt_env;
  if (__builtin_expect(!!((txn->mt_flags & MDBX_TXN_RDONLY) == 0), 0)) {
    if (percent)
      *percent =
          (int)((txn->mt_geo.next * 100UL + txn->mt_geo.now / 2) /
                txn->mt_geo.now);
    return 0;
  }

  txnid_t recent = 0;
  volatile const MDBX_meta *meta = 
# 21078 "/libmdbx/src/core.c" 3 4
                                  ((void *)0)
# 21078 "/libmdbx/src/core.c"
                                         ;
  do {
    meta = meta_prefer_last(env);
    recent = meta_txnid(env, meta);
    if (percent) {
      const pgno_t maxpg = meta->mm_geo.now;
      *percent = (int)((meta->mm_geo.next * 100UL + maxpg / 2) / maxpg);
    }
  } while (__builtin_expect(!!(recent != meta_txnid(env, meta)), 0));

  txnid_t lag = (recent - txn->mt_txnid) / 1u;
  return (lag > 0x7fffffff) ? 0x7fffffff : (int)lag;
}

typedef struct mdbx_walk_ctx {
  void *mw_user;
  MDBX_pgvisitor_func *mw_visitor;
  MDBX_txn *mw_txn;
  MDBX_cursor *mw_cursor;
  _Bool mw_dont_check_keys_ordering;
} mdbx_walk_ctx_t;

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static int mdbx_walk_sdb(mdbx_walk_ctx_t *ctx, MDBX_db *const db,
                                const char *name, int deep);

static MDBX_page_type_t walk_page_type(const MDBX_page *mp) {
  if (mp)
    switch (mp->mp_flags) {
    case 0x01:
      return MDBX_page_branch;
    case 0x02:
      return MDBX_page_leaf;
    case 0x02 | 0x20:
      return MDBX_page_dupfixed_leaf;
    case 0x04:
      return MDBX_page_large;
    case 0x08:
      return MDBX_page_meta;
    }
  return MDBX_page_broken;
}


__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static int mdbx_walk_tree(mdbx_walk_ctx_t *ctx, const pgno_t pgno,
                                 const char *name, int deep,
                                 txnid_t parent_txnid) {
  do { if ((0)) do { if (__builtin_expect(!!(!(pgno != (~(pgno_t)0))), 0)) mdbx_assert_fail(
# 21124 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 21124 "/libmdbx/src/core.c"
 , "pgno != (~(pgno_t)0)", __func__, 21124); } while (0); } while (0);
  MDBX_page *mp = 
# 21125 "/libmdbx/src/core.c" 3 4
                 ((void *)0)
# 21125 "/libmdbx/src/core.c"
                        ;
  int rc, err = mdbx_page_get(ctx->mw_cursor, pgno, &mp, parent_txnid);
  if (err == MDBX_SUCCESS)
    err = mdbx_page_check(ctx->mw_cursor, mp, 0);

  MDBX_page_type_t type = walk_page_type(mp);
  const int nentries = (mp && !__builtin_expect(!!(((mp)->mp_flags & 0x04) != 0), 0)) ? page_numkeys(mp) : 1;
  unsigned npages = (mp && __builtin_expect(!!(((mp)->mp_flags & 0x04) != 0), 0)) ? mp->mp_pages : 1;
  size_t pagesize = pgno2bytes(ctx->mw_txn->mt_env, npages);
  size_t header_size = (mp && !__builtin_expect(!!(((mp)->mp_flags & 0x20) != 0), 0) && !__builtin_expect(!!(((mp)->mp_flags & 0x04) != 0), 0))
                           ? ((unsigned)
# 21135 "/libmdbx/src/core.c" 3 4
                            __builtin_offsetof (
# 21135 "/libmdbx/src/core.c"
                            MDBX_page
# 21135 "/libmdbx/src/core.c" 3 4
                            , 
# 21135 "/libmdbx/src/core.c"
                            mp_ptrs
# 21135 "/libmdbx/src/core.c" 3 4
                            )
# 21135 "/libmdbx/src/core.c"
                            ) + mp->mp_lower
                           : ((unsigned)
# 21136 "/libmdbx/src/core.c" 3 4
                            __builtin_offsetof (
# 21136 "/libmdbx/src/core.c"
                            MDBX_page
# 21136 "/libmdbx/src/core.c" 3 4
                            , 
# 21136 "/libmdbx/src/core.c"
                            mp_ptrs
# 21136 "/libmdbx/src/core.c" 3 4
                            )
# 21136 "/libmdbx/src/core.c"
                            );
  size_t payload_size = 0;
  size_t unused_size =
      (mp && !__builtin_expect(!!(((mp)->mp_flags & 0x04) != 0), 0) ? page_room(mp) : pagesize - header_size) -
      payload_size;
  size_t align_bytes = 0;

  if (err == MDBX_SUCCESS) {



    switch (mp->mp_flags) {
    default:
      err = MDBX_CORRUPTED;
      break;
    case 0x01:
      if (__builtin_expect(!!(nentries < 2), 0))
        err = MDBX_CORRUPTED;
    case 0x02:
    case 0x02 | 0x20:
      break;
    }
  }

  for (int i = 0; err == MDBX_SUCCESS && i < nentries;
       align_bytes += ((payload_size + align_bytes) & 1), i++) {
    if (type == MDBX_page_dupfixed_leaf) {

      payload_size += mp->mp_leaf2_ksize;
      continue;
    }

    MDBX_node *node = page_node(mp, i);
    payload_size += 
# 21169 "/libmdbx/src/core.c" 3 4
                   __builtin_offsetof (
# 21169 "/libmdbx/src/core.c"
                   MDBX_node
# 21169 "/libmdbx/src/core.c" 3 4
                   , 
# 21169 "/libmdbx/src/core.c"
                   mn_data
# 21169 "/libmdbx/src/core.c" 3 4
                   ) 
# 21169 "/libmdbx/src/core.c"
                            + node_ks(node);

    if (type == MDBX_page_branch) {
      do { if ((0)) do { if (__builtin_expect(!!(!(i > 0 || node_ks(node) == 0)), 0)) mdbx_assert_fail(
# 21172 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 21172 "/libmdbx/src/core.c"
     , "i > 0 || node_ks(node) == 0", __func__, 21172); } while (0); } while (0);
      continue;
    }

    do { if ((0)) do { if (__builtin_expect(!!(!(type == MDBX_page_leaf)), 0)) mdbx_assert_fail(
# 21176 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 21176 "/libmdbx/src/core.c"
   , "type == MDBX_page_leaf", __func__, 21176); } while (0); } while (0);
    switch (node_flags(node)) {
    case 0 :
      payload_size += node_ds(node);
      break;

    case 0x01 : {
      payload_size += sizeof(pgno_t);
      const pgno_t large_pgno = node_largedata_pgno(node);
      const size_t over_payload = node_ds(node);
      const size_t over_header = ((unsigned)
# 21186 "/libmdbx/src/core.c" 3 4
                                __builtin_offsetof (
# 21186 "/libmdbx/src/core.c"
                                MDBX_page
# 21186 "/libmdbx/src/core.c" 3 4
                                , 
# 21186 "/libmdbx/src/core.c"
                                mp_ptrs
# 21186 "/libmdbx/src/core.c" 3 4
                                )
# 21186 "/libmdbx/src/core.c"
                                );
      npages = 1;

      MDBX_page *op;
      err = mdbx_page_get(ctx->mw_cursor, large_pgno, &op,
                          pp_txnid4chk(mp, ctx->mw_txn));
      if (err == MDBX_SUCCESS)
        err = mdbx_page_check(ctx->mw_cursor, op, 0);
      if (err == MDBX_SUCCESS) {



        if (__builtin_expect(!!(0x04 != op->mp_flags), 0))
          err = bad_page(mp, "wrong page type %d for large data", op->mp_flags);
        else
          npages = op->mp_pages;
      }

      pagesize = pgno2bytes(ctx->mw_txn->mt_env, npages);
      const size_t over_unused = pagesize - over_payload - over_header;
      rc = ctx->mw_visitor(large_pgno, npages, ctx->mw_user, deep, name,
                           pagesize, MDBX_page_large, err, 1, over_payload,
                           over_header, over_unused);
      if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
        return (rc == MDBX_RESULT_TRUE) ? MDBX_SUCCESS : rc;
    } break;

    case 0x02 : {
      const size_t namelen = node_ks(node);
      payload_size += node_ds(node);
      if (__builtin_expect(!!(namelen == 0 || node_ds(node) != sizeof(MDBX_db)), 0))
        err = MDBX_CORRUPTED;
    } break;

    case 0x02 | 0x04 :
      payload_size += sizeof(MDBX_db);
      if (__builtin_expect(!!(node_ds(node) != sizeof(MDBX_db)), 0))
        err = MDBX_CORRUPTED;
      break;

    case 0x04 : {
      if (__builtin_expect(!!(node_ds(node) <= ((unsigned)
# 21227 "/libmdbx/src/core.c" 3 4
         __builtin_offsetof (
# 21227 "/libmdbx/src/core.c"
         MDBX_page
# 21227 "/libmdbx/src/core.c" 3 4
         , 
# 21227 "/libmdbx/src/core.c"
         mp_ptrs
# 21227 "/libmdbx/src/core.c" 3 4
         )
# 21227 "/libmdbx/src/core.c"
         )), 0)) {
        err = MDBX_CORRUPTED;
        break;
      }

      MDBX_page *sp = node_data(node);
      const int nsubkeys = page_numkeys(sp);
      size_t subheader_size =
          __builtin_expect(!!(((sp)->mp_flags & 0x20) != 0), 0) ? ((unsigned)
# 21235 "/libmdbx/src/core.c" 3 4
                        __builtin_offsetof (
# 21235 "/libmdbx/src/core.c"
                        MDBX_page
# 21235 "/libmdbx/src/core.c" 3 4
                        , 
# 21235 "/libmdbx/src/core.c"
                        mp_ptrs
# 21235 "/libmdbx/src/core.c" 3 4
                        )
# 21235 "/libmdbx/src/core.c"
                        ) : ((unsigned)
# 21235 "/libmdbx/src/core.c" 3 4
                                    __builtin_offsetof (
# 21235 "/libmdbx/src/core.c"
                                    MDBX_page
# 21235 "/libmdbx/src/core.c" 3 4
                                    , 
# 21235 "/libmdbx/src/core.c"
                                    mp_ptrs
# 21235 "/libmdbx/src/core.c" 3 4
                                    )
# 21235 "/libmdbx/src/core.c"
                                    ) + sp->mp_lower;
      size_t subunused_size = page_room(sp);
      size_t subpayload_size = 0;
      size_t subalign_bytes = 0;
      MDBX_page_type_t subtype;

      switch (sp->mp_flags & ~0x10) {
      case 0x02 | 0x40:
        subtype = MDBX_subpage_leaf;
        break;
      case 0x02 | 0x20 | 0x40:
        subtype = MDBX_subpage_dupfixed_leaf;
        break;
      default:
        subtype = MDBX_subpage_broken;
        err = MDBX_CORRUPTED;
      }

      for (int j = 0; err == MDBX_SUCCESS && j < nsubkeys;
           subalign_bytes += ((subpayload_size + subalign_bytes) & 1), j++) {

        if (subtype == MDBX_subpage_dupfixed_leaf) {

          subpayload_size += sp->mp_leaf2_ksize;
        } else {
          do { if ((0)) do { if (__builtin_expect(!!(!(subtype == MDBX_subpage_leaf)), 0)) mdbx_assert_fail(
# 21260 "/libmdbx/src/core.c" 3 4
         ((void *)0)
# 21260 "/libmdbx/src/core.c"
         , "subtype == MDBX_subpage_leaf", __func__, 21260); } while (0); } while (0);
          MDBX_node *subnode = page_node(sp, j);
          subpayload_size += 
# 21262 "/libmdbx/src/core.c" 3 4
                            __builtin_offsetof (
# 21262 "/libmdbx/src/core.c"
                            MDBX_node
# 21262 "/libmdbx/src/core.c" 3 4
                            , 
# 21262 "/libmdbx/src/core.c"
                            mn_data
# 21262 "/libmdbx/src/core.c" 3 4
                            ) 
# 21262 "/libmdbx/src/core.c"
                                     + node_ks(subnode) + node_ds(subnode);
          if (__builtin_expect(!!(node_flags(subnode) != 0), 0))
            err = MDBX_CORRUPTED;
        }
      }

      rc = ctx->mw_visitor(pgno, 0, ctx->mw_user, deep + 1, name, node_ds(node),
                           subtype, err, nsubkeys, subpayload_size,
                           subheader_size, subunused_size + subalign_bytes);
      if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
        return (rc == MDBX_RESULT_TRUE) ? MDBX_SUCCESS : rc;
      header_size += subheader_size;
      unused_size += subunused_size;
      payload_size += subpayload_size;
      align_bytes += subalign_bytes;
    } break;

    default:
      err = MDBX_CORRUPTED;
    }
  }

  rc = ctx->mw_visitor(pgno, 1, ctx->mw_user, deep, name,
                       ctx->mw_txn->mt_env->me_psize, type, err, nentries,
                       payload_size, header_size, unused_size + align_bytes);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return (rc == MDBX_RESULT_TRUE) ? MDBX_SUCCESS : rc;

  for (int i = 0; err == MDBX_SUCCESS && i < nentries; i++) {
    if (type == MDBX_page_dupfixed_leaf)
      continue;

    MDBX_node *node = page_node(mp, i);
    if (type == MDBX_page_branch) {
      err = mdbx_walk_tree(ctx, node_pgno(node), name, deep + 1,
                           pp_txnid4chk(mp, ctx->mw_txn));
      if (__builtin_expect(!!(err != MDBX_SUCCESS), 0)) {
        if (err == MDBX_RESULT_TRUE)
          break;
        return err;
      }
      continue;
    }

    do { if ((0)) do { if (__builtin_expect(!!(!(type == MDBX_page_leaf)), 0)) mdbx_assert_fail(
# 21306 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 21306 "/libmdbx/src/core.c"
   , "type == MDBX_page_leaf", __func__, 21306); } while (0); } while (0);
    MDBX_db db;
    switch (node_flags(node)) {
    default:
      continue;

    case 0x02 : {
      const size_t namelen = node_ks(node);
      if (__builtin_expect(!!(namelen == 0 || node_ds(node) != sizeof(MDBX_db)), 0)) {
        err = MDBX_CORRUPTED;
        break;
      }

      char namebuf_onstask[64];
      char *const sub_name = (namelen < sizeof(namebuf_onstask))
                                 ? namebuf_onstask
                                 : malloc(namelen + 1);
      if (sub_name) {
        memcpy(sub_name, node_key(node), namelen);
        sub_name[namelen] = 0;
        memcpy(&db, node_data(node), sizeof(db));
        err = mdbx_walk_sdb(ctx, &db, sub_name, deep + 1);
        if (sub_name != namebuf_onstask)
          free(sub_name);
      } else {
        err = MDBX_ENOMEM;
      }
    } break;

    case 0x02 | 0x04 :
      if (__builtin_expect(!!(node_ds(node) != sizeof(MDBX_db) || ctx->mw_cursor->mc_xcursor == 
# 21336 "/libmdbx/src/core.c" 3 4
         ((void *)0)
# 21336 "/libmdbx/src/core.c"
         ), 0)
                                                      )
        err = MDBX_CORRUPTED;
      else {
        memcpy(&db, node_data(node), sizeof(db));
        do { if ((0)) do { if (__builtin_expect(!!(!(ctx->mw_cursor->mc_xcursor == &((MDBX_cursor_couple *)((char *)(ctx->mw_cursor) - 
# 21341 "/libmdbx/src/core.c" 3 4
       __builtin_offsetof (
# 21341 "/libmdbx/src/core.c"
       MDBX_cursor_couple
# 21341 "/libmdbx/src/core.c" 3 4
       , 
# 21341 "/libmdbx/src/core.c"
       outer
# 21341 "/libmdbx/src/core.c" 3 4
       )
# 21341 "/libmdbx/src/core.c"
       ))->inner)), 0)) mdbx_assert_fail(
# 21341 "/libmdbx/src/core.c" 3 4
       ((void *)0)
# 21341 "/libmdbx/src/core.c"
       , "ctx->mw_cursor->mc_xcursor == &((MDBX_cursor_couple *)((char *)(ctx->mw_cursor) - __builtin_offsetof (MDBX_cursor_couple, outer)))->inner", __func__, 21341); } while (0); } while (0)
                                                                               ;
        ctx->mw_cursor = &ctx->mw_cursor->mc_xcursor->mx_cursor;
        err = mdbx_walk_tree(ctx, db.md_root, name, deep + 1,
                             pp_txnid4chk(mp, ctx->mw_txn));
        MDBX_xcursor *inner_xcursor =
            ((MDBX_xcursor *)((char *)(ctx->mw_cursor) - 
# 21347 "/libmdbx/src/core.c" 3 4
           __builtin_offsetof (
# 21347 "/libmdbx/src/core.c"
           MDBX_xcursor
# 21347 "/libmdbx/src/core.c" 3 4
           , 
# 21347 "/libmdbx/src/core.c"
           mx_cursor
# 21347 "/libmdbx/src/core.c" 3 4
           )
# 21347 "/libmdbx/src/core.c"
           ));
        MDBX_cursor_couple *couple =
            ((MDBX_cursor_couple *)((char *)(inner_xcursor) - 
# 21349 "/libmdbx/src/core.c" 3 4
           __builtin_offsetof (
# 21349 "/libmdbx/src/core.c"
           MDBX_cursor_couple
# 21349 "/libmdbx/src/core.c" 3 4
           , 
# 21349 "/libmdbx/src/core.c"
           inner
# 21349 "/libmdbx/src/core.c" 3 4
           )
# 21349 "/libmdbx/src/core.c"
           ));
        ctx->mw_cursor = &couple->outer;
      }
      break;
    }
  }

  return MDBX_SUCCESS;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static int mdbx_walk_sdb(mdbx_walk_ctx_t *ctx, MDBX_db *const db,
                                const char *name, int deep) {
  if (__builtin_expect(!!(db->md_root == (~(pgno_t)0)), 0))
    return MDBX_SUCCESS;

  MDBX_cursor_couple couple;
  MDBX_dbx dbx = {.md_klen_min = 0x7fffffff};
  uint8_t dbistate = 0x10 | 0x40;
  int rc = mdbx_couple_init(&couple, ~0u, ctx->mw_txn, db, &dbx, &dbistate);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (ctx->mw_dont_check_keys_ordering) {
    couple.outer.mc_flags |= 0x800;
    couple.inner.mx_cursor.mc_flags |= 0x800;
  }
  couple.outer.mc_next = ctx->mw_cursor;
  ctx->mw_cursor = &couple.outer;
  rc = mdbx_walk_tree(ctx, db->md_root, name, deep, ctx->mw_txn->mt_txnid);
  ctx->mw_cursor = couple.outer.mc_next;
  return rc;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_pgwalk(MDBX_txn *txn, MDBX_pgvisitor_func *visitor,
                           void *user, _Bool dont_check_keys_ordering) {
  int rc = check_txn(txn, (0x01 | 0x02 | 0x10));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  mdbx_walk_ctx_t ctx;
  memset(&ctx, 0, sizeof(ctx));
  ctx.mw_txn = txn;
  ctx.mw_user = user;
  ctx.mw_visitor = visitor;
  ctx.mw_dont_check_keys_ordering = dont_check_keys_ordering;

  rc = visitor(0, 3, user, 0, ((const char *)((ptrdiff_t)-2)),
               pgno2bytes(txn->mt_env, 3), MDBX_page_meta, MDBX_SUCCESS,
               3, sizeof(MDBX_meta) * 3, ((unsigned)
# 21397 "/libmdbx/src/core.c" 3 4
                                                        __builtin_offsetof (
# 21397 "/libmdbx/src/core.c"
                                                        MDBX_page
# 21397 "/libmdbx/src/core.c" 3 4
                                                        , 
# 21397 "/libmdbx/src/core.c"
                                                        mp_ptrs
# 21397 "/libmdbx/src/core.c" 3 4
                                                        )
# 21397 "/libmdbx/src/core.c"
                                                        ) * 3,
               (txn->mt_env->me_psize - sizeof(MDBX_meta) - ((unsigned)
# 21398 "/libmdbx/src/core.c" 3 4
                                                           __builtin_offsetof (
# 21398 "/libmdbx/src/core.c"
                                                           MDBX_page
# 21398 "/libmdbx/src/core.c" 3 4
                                                           , 
# 21398 "/libmdbx/src/core.c"
                                                           mp_ptrs
# 21398 "/libmdbx/src/core.c" 3 4
                                                           )
# 21398 "/libmdbx/src/core.c"
                                                           )) *
                   3);
  if (!((rc) != MDBX_RESULT_TRUE && (rc) != MDBX_RESULT_FALSE))
    rc = mdbx_walk_sdb(&ctx, &txn->mt_dbs[0], ((const char *)((ptrdiff_t)-1)), 0);
  if (!((rc) != MDBX_RESULT_TRUE && (rc) != MDBX_RESULT_FALSE))
    rc = mdbx_walk_sdb(&ctx, &txn->mt_dbs[1], ((const char *)((ptrdiff_t)0)), 0);
  return rc;
}

int mdbx_canary_put(MDBX_txn *txn, const MDBX_canary *canary) {
  int rc = check_txn_rw(txn, (0x01 | 0x02 | 0x10));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(canary), 1)) {
    if (txn->mt_canary.x == canary->x && txn->mt_canary.y == canary->y &&
        txn->mt_canary.z == canary->z)
      return MDBX_SUCCESS;
    txn->mt_canary.x = canary->x;
    txn->mt_canary.y = canary->y;
    txn->mt_canary.z = canary->z;
  }
  txn->mt_canary.v = txn->mt_txnid;
  txn->mt_flags |= 0x04;

  return MDBX_SUCCESS;
}

int mdbx_canary_get(const MDBX_txn *txn, MDBX_canary *canary) {
  int rc = check_txn(txn, (0x01 | 0x02 | 0x10));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(canary == 
# 21431 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 21431 "/libmdbx/src/core.c"
     ), 0))
    return MDBX_EINVAL;

  *canary = txn->mt_canary;
  return MDBX_SUCCESS;
}

int mdbx_cursor_on_first(const MDBX_cursor *mc) {
  if (__builtin_expect(!!(mc == 
# 21439 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 21439 "/libmdbx/src/core.c"
     ), 0))
    return MDBX_EINVAL;

  if (__builtin_expect(!!(mc->mc_signature != 0xFE05D5B1U), 0))
    return (mc->mc_signature == 0x2817A047U) ? MDBX_EINVAL
                                                     : MDBX_EBADSIGN;

  if (!(mc->mc_flags & 0x01))
    return mc->mc_db->md_entries ? MDBX_RESULT_FALSE : MDBX_RESULT_TRUE;

  for (unsigned i = 0; i < mc->mc_snum; ++i) {
    if (mc->mc_ki[i])
      return MDBX_RESULT_FALSE;
  }

  return MDBX_RESULT_TRUE;
}

int mdbx_cursor_on_last(const MDBX_cursor *mc) {
  if (__builtin_expect(!!(mc == 
# 21458 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 21458 "/libmdbx/src/core.c"
     ), 0))
    return MDBX_EINVAL;

  if (__builtin_expect(!!(mc->mc_signature != 0xFE05D5B1U), 0))
    return (mc->mc_signature == 0x2817A047U) ? MDBX_EINVAL
                                                     : MDBX_EBADSIGN;

  if (!(mc->mc_flags & 0x01))
    return mc->mc_db->md_entries ? MDBX_RESULT_FALSE : MDBX_RESULT_TRUE;

  for (unsigned i = 0; i < mc->mc_snum; ++i) {
    unsigned nkeys = page_numkeys(mc->mc_pg[i]);
    if (mc->mc_ki[i] < nkeys - 1)
      return MDBX_RESULT_FALSE;
  }

  return MDBX_RESULT_TRUE;
}

int mdbx_cursor_eof(const MDBX_cursor *mc) {
  if (__builtin_expect(!!(mc == 
# 21478 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 21478 "/libmdbx/src/core.c"
     ), 0))
    return MDBX_EINVAL;

  if (__builtin_expect(!!(mc->mc_signature != 0xFE05D5B1U), 0))
    return (mc->mc_signature == 0x2817A047U) ? MDBX_EINVAL
                                                     : MDBX_EBADSIGN;

  return ((mc->mc_flags & (0x01 | 0x02)) == 0x01 &&
          mc->mc_snum &&
          mc->mc_ki[mc->mc_top] < page_numkeys(mc->mc_pg[mc->mc_top]))
             ? MDBX_RESULT_FALSE
             : MDBX_RESULT_TRUE;
}



struct diff_result {
  ptrdiff_t diff;
  unsigned level;
  int root_nkeys;
};


__attribute__((__hot__)) __attribute__((__optimize__("O3"))) static int cursor_diff(const MDBX_cursor *const __restrict x,
                             const MDBX_cursor *const __restrict y,
                             struct diff_result *const __restrict r) {
  r->diff = 0;
  r->level = 0;
  r->root_nkeys = 0;

  if (__builtin_expect(!!(x->mc_signature != 0xFE05D5B1U), 0))
    return (x->mc_signature == 0x2817A047U) ? MDBX_EINVAL
                                                    : MDBX_EBADSIGN;

  if (__builtin_expect(!!(y->mc_signature != 0xFE05D5B1U), 0))
    return (y->mc_signature == 0x2817A047U) ? MDBX_EINVAL
                                                    : MDBX_EBADSIGN;

  int rc = check_txn(x->mc_txn, (0x01 | 0x02 | 0x10));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(x->mc_txn != y->mc_txn), 0))
    return MDBX_BAD_TXN;

  if (__builtin_expect(!!(y->mc_dbi != x->mc_dbi), 0))
    return MDBX_EINVAL;

  if (__builtin_expect(!!(!(y->mc_flags & x->mc_flags & 0x01)), 0))
    return MDBX_ENODATA;

  while (__builtin_expect(!!(r->level < y->mc_snum && r->level < x->mc_snum), 1)) {
    if (__builtin_expect(!!(y->mc_pg[r->level] != x->mc_pg[r->level]), 0)) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 21531, "Mismatch cursors's pages at %u level" "\n", r->level); } while (0);
      return MDBX_PROBLEM;
    }

    int nkeys = page_numkeys(y->mc_pg[r->level]);
    do { if ((0)) do { if (__builtin_expect(!!(!(nkeys > 0)), 0)) mdbx_assert_fail(
# 21536 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 21536 "/libmdbx/src/core.c"
   , "nkeys > 0", __func__, 21536); } while (0); } while (0);
    if (r->level == 0)
      r->root_nkeys = nkeys;

    const int limit_ki = nkeys - 1;
    const int x_ki = x->mc_ki[r->level];
    const int y_ki = y->mc_ki[r->level];
    r->diff = ((x_ki < limit_ki) ? x_ki : limit_ki) -
              ((y_ki < limit_ki) ? y_ki : limit_ki);
    if (r->diff == 0) {
      r->level += 1;
      continue;
    }

    while (__builtin_expect(!!(r->diff == 1), 0) &&
           __builtin_expect(!!(r->level + 1 < y->mc_snum && r->level + 1 < x->mc_snum), 1)) {
      r->level += 1;






      nkeys = page_numkeys(y->mc_pg[r->level]);
      r->diff = (nkeys - y->mc_ki[r->level]) + x->mc_ki[r->level];
      do { if ((0)) do { if (__builtin_expect(!!(!(r->diff > 0)), 0)) mdbx_assert_fail(
# 21561 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 21561 "/libmdbx/src/core.c"
     , "r->diff > 0", __func__, 21561); } while (0); } while (0);
    }

    while (__builtin_expect(!!(r->diff == -1), 0) &&
           __builtin_expect(!!(r->level + 1 < y->mc_snum && r->level + 1 < x->mc_snum), 1)) {
      r->level += 1;






      nkeys = page_numkeys(x->mc_pg[r->level]);
      r->diff = -(nkeys - x->mc_ki[r->level]) - y->mc_ki[r->level];
      do { if ((0)) do { if (__builtin_expect(!!(!(r->diff < 0)), 0)) mdbx_assert_fail(
# 21575 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 21575 "/libmdbx/src/core.c"
     , "r->diff < 0", __func__, 21575); } while (0); } while (0);
    }

    return MDBX_SUCCESS;
  }

  r->diff = (((y->mc_flags & 0x02) > (x->mc_flags & 0x02)) ? -1 : (x->mc_flags & 0x02) > (y->mc_flags & 0x02));
  return MDBX_SUCCESS;
}

__attribute__((__hot__)) __attribute__((__optimize__("O3"))) static ptrdiff_t estimate(const MDBX_db *db,
                                struct diff_result *const __restrict dr) {






  ptrdiff_t btree_power = (ptrdiff_t)db->md_depth - 2 - (ptrdiff_t)dr->level;
  if (btree_power < 0)
    return dr->diff;

  ptrdiff_t estimated =
      (ptrdiff_t)db->md_entries * dr->diff / (ptrdiff_t)db->md_leaf_pages;
  if (btree_power == 0)
    return estimated;

  if (db->md_depth < 4) {
    do { if ((0)) do { if (__builtin_expect(!!(!(dr->level == 0 && btree_power == 1)), 0)) mdbx_assert_fail(
# 21603 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 21603 "/libmdbx/src/core.c"
   , "dr->level == 0 && btree_power == 1", __func__, 21603); } while (0); } while (0);
    return (ptrdiff_t)db->md_entries * dr->diff / (ptrdiff_t)dr->root_nkeys;
  }



  const size_t log2_fixedpoint = sizeof(size_t) - 1;
  const size_t half = 1UL << (log2_fixedpoint - 1);
  const size_t factor =
      ((db->md_leaf_pages + db->md_branch_pages - 1) << log2_fixedpoint) /
      db->md_branch_pages;
  while (1) {
    switch ((size_t)btree_power) {
    default: {
      const size_t square = (factor * factor + half) >> log2_fixedpoint;
      const size_t quad = (square * square + half) >> log2_fixedpoint;
      do {
        estimated = estimated * quad + half;
        estimated >>= log2_fixedpoint;
        btree_power -= 4;
      } while (btree_power >= 4);
      continue;
    }
    case 3:
      estimated = estimated * factor + half;
      estimated >>= log2_fixedpoint;
      __attribute__((__fallthrough__)) ;
    case 2:
      estimated = estimated * factor + half;
      estimated >>= log2_fixedpoint;
      __attribute__((__fallthrough__)) ;
    case 1:
      estimated = estimated * factor + half;
      estimated >>= log2_fixedpoint;
      __attribute__((__fallthrough__)) ;
    case 0:
      if (__builtin_expect(!!(estimated > (ptrdiff_t)db->md_entries), 0))
        return (ptrdiff_t)db->md_entries;
      if (__builtin_expect(!!(estimated < -(ptrdiff_t)db->md_entries), 0))
        return -(ptrdiff_t)db->md_entries;
      return estimated;
    }
  }
}

int mdbx_estimate_distance(const MDBX_cursor *first, const MDBX_cursor *last,
                           ptrdiff_t *distance_items) {
  if (__builtin_expect(!!(first == 
# 21650 "/libmdbx/src/core.c" 3 4
     ((void *)0) 
# 21650 "/libmdbx/src/core.c"
     || last == 
# 21650 "/libmdbx/src/core.c" 3 4
     ((void *)0) 
# 21650 "/libmdbx/src/core.c"
     || distance_items == 
# 21650 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 21650 "/libmdbx/src/core.c"
     ), 0))
    return MDBX_EINVAL;

  *distance_items = 0;
  struct diff_result dr;
  int rc = cursor_diff(last, first, &dr);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(dr.diff == 0), 0) &&
      (((first->mc_db->md_flags & last->mc_db->md_flags) & (MDBX_DUPSORT | 0x01)) == (MDBX_DUPSORT | 0x01))
                                           ) {
    first = &first->mc_xcursor->mx_cursor;
    last = &last->mc_xcursor->mx_cursor;
    rc = cursor_diff(first, last, &dr);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      return rc;
  }

  if (__builtin_expect(!!(dr.diff != 0), 1))
    *distance_items = estimate(first->mc_db, &dr);

  return MDBX_SUCCESS;
}

int mdbx_estimate_move(const MDBX_cursor *cursor, MDBX_val *key, MDBX_val *data,
                       MDBX_cursor_op move_op, ptrdiff_t *distance_items) {
  if (__builtin_expect(!!(cursor == 
# 21677 "/libmdbx/src/core.c" 3 4
     ((void *)0) 
# 21677 "/libmdbx/src/core.c"
     || distance_items == 
# 21677 "/libmdbx/src/core.c" 3 4
     ((void *)0) 
# 21677 "/libmdbx/src/core.c"
     || move_op == MDBX_GET_CURRENT || move_op == MDBX_GET_MULTIPLE), 0)
                                                                           )
    return MDBX_EINVAL;

  if (__builtin_expect(!!(cursor->mc_signature != 0xFE05D5B1U), 0))
    return (cursor->mc_signature == 0x2817A047U) ? MDBX_EINVAL
                                                         : MDBX_EBADSIGN;

  int rc = check_txn(cursor->mc_txn, (0x01 | 0x02 | 0x10));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (!(cursor->mc_flags & 0x01))
    return MDBX_ENODATA;

  MDBX_cursor_couple next;
  cursor_copy(cursor, &next.outer);
  if (cursor->mc_db->md_flags & MDBX_DUPSORT) {
    next.outer.mc_xcursor = &next.inner;
    rc = mdbx_xcursor_init0(&next.outer);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      return rc;
    MDBX_xcursor *mx = &((MDBX_cursor_couple *)((char *)(cursor) - 
# 21699 "/libmdbx/src/core.c" 3 4
                       __builtin_offsetof (
# 21699 "/libmdbx/src/core.c"
                       MDBX_cursor_couple
# 21699 "/libmdbx/src/core.c" 3 4
                       , 
# 21699 "/libmdbx/src/core.c"
                       outer
# 21699 "/libmdbx/src/core.c" 3 4
                       )
# 21699 "/libmdbx/src/core.c"
                       ))->inner;
    cursor_copy(&mx->mx_cursor, &next.inner.mx_cursor);
  }

  MDBX_val stub = {0, 0};
  if (data == 
# 21704 "/libmdbx/src/core.c" 3 4
             ((void *)0)
# 21704 "/libmdbx/src/core.c"
                 ) {
    const unsigned mask =
        1 << MDBX_GET_BOTH | 1 << MDBX_GET_BOTH_RANGE | 1 << MDBX_SET_KEY;
    if (__builtin_expect(!!(mask & (1 << move_op)), 0))
      return MDBX_EINVAL;
    data = &stub;
  }

  if (key == 
# 21712 "/libmdbx/src/core.c" 3 4
            ((void *)0)
# 21712 "/libmdbx/src/core.c"
                ) {
    const unsigned mask = 1 << MDBX_GET_BOTH | 1 << MDBX_GET_BOTH_RANGE |
                          1 << MDBX_SET_KEY | 1 << MDBX_SET |
                          1 << MDBX_SET_RANGE;
    if (__builtin_expect(!!(mask & (1 << move_op)), 0))
      return MDBX_EINVAL;
    key = &stub;
  }

  next.outer.mc_signature = 0xFE05D5B1U;
  rc = mdbx_cursor_get(&next.outer, key, data, move_op);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS && (rc != MDBX_NOTFOUND || !(next.outer.mc_flags & 0x01))), 0)
                                                                               )
    return rc;

  return mdbx_estimate_distance(cursor, &next.outer, distance_items);
}

int mdbx_estimate_range(MDBX_txn *txn, MDBX_dbi dbi, MDBX_val *begin_key,
                        MDBX_val *begin_data, MDBX_val *end_key,
                        MDBX_val *end_data, ptrdiff_t *size_items) {
  int rc = check_txn(txn, (0x01 | 0x02 | 0x10));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(!size_items), 0))
    return MDBX_EINVAL;

  if (__builtin_expect(!!(begin_data && (begin_key == 
# 21740 "/libmdbx/src/core.c" 3 4
     ((void *)0) 
# 21740 "/libmdbx/src/core.c"
     || begin_key == ((MDBX_val *)((ptrdiff_t)-1)))), 0))
    return MDBX_EINVAL;

  if (__builtin_expect(!!(end_data && (end_key == 
# 21743 "/libmdbx/src/core.c" 3 4
     ((void *)0) 
# 21743 "/libmdbx/src/core.c"
     || end_key == ((MDBX_val *)((ptrdiff_t)-1)))), 0))
    return MDBX_EINVAL;

  if (__builtin_expect(!!(begin_key == ((MDBX_val *)((ptrdiff_t)-1)) && end_key == ((MDBX_val *)((ptrdiff_t)-1))), 0))
    return MDBX_EINVAL;

  if (__builtin_expect(!!(!check_dbi(txn, dbi, 0x20)), 0))
    return MDBX_BAD_DBI;

  MDBX_cursor_couple begin;

  rc = mdbx_cursor_init(&begin.outer, txn, dbi);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(begin.outer.mc_db->md_entries == 0), 0)) {
    *size_items = 0;
    return MDBX_SUCCESS;
  }

  if (!begin_key) {
    if (__builtin_expect(!!(!end_key), 0)) {

      *size_items = (ptrdiff_t)begin.outer.mc_db->md_entries;
      return MDBX_SUCCESS;
    }
    MDBX_val stub = {0, 0};
    rc = mdbx_cursor_first(&begin.outer, &stub, &stub);
    if (__builtin_expect(!!(end_key == ((MDBX_val *)((ptrdiff_t)-1))), 0)) {

      return (rc == MDBX_SUCCESS)
                 ? mdbx_cursor_count(&begin.outer, (size_t *)size_items)
                 : rc;
    }
  } else {
    if (__builtin_expect(!!(begin_key == ((MDBX_val *)((ptrdiff_t)-1))), 0)) {
      if (end_key == 
# 21779 "/libmdbx/src/core.c" 3 4
                    ((void *)0)
# 21779 "/libmdbx/src/core.c"
                        ) {

        MDBX_val stub = {0, 0};
        rc = mdbx_cursor_last(&begin.outer, &stub, &stub);
        return (rc == MDBX_SUCCESS)
                   ? mdbx_cursor_count(&begin.outer, (size_t *)size_items)
                   : rc;
      }

      do { if ((0)) do { if (__builtin_expect(!!(!(end_key != ((MDBX_val *)((ptrdiff_t)-1)))), 0)) mdbx_assert_fail(
# 21788 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 21788 "/libmdbx/src/core.c"
     , "end_key != ((MDBX_val *)((ptrdiff_t)-1))", __func__, 21788); } while (0); } while (0);
      begin_key = end_key;
    } else if (__builtin_expect(!!(end_key == ((MDBX_val *)((ptrdiff_t)-1))), 0)) {

      do { if ((0)) do { if (__builtin_expect(!!(!(begin_key != ((MDBX_val *)((ptrdiff_t)-1)))), 0)) mdbx_assert_fail(
# 21792 "/libmdbx/src/core.c" 3 4
     ((void *)0)
# 21792 "/libmdbx/src/core.c"
     , "begin_key != ((MDBX_val *)((ptrdiff_t)-1))", __func__, 21792); } while (0); } while (0);
      end_key = begin_key;
    }
    if (end_key && !begin_data && !end_data &&
        (begin_key == end_key ||
         begin.outer.mc_dbx->md_cmp(begin_key, end_key) == 0)) {

      rc = mdbx_cursor_set(&begin.outer, begin_key, 
# 21799 "/libmdbx/src/core.c" 3 4
                                                   ((void *)0)
# 21799 "/libmdbx/src/core.c"
                                                       , MDBX_SET).err;
      if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0)) {
        *size_items = 0;
        return (rc == MDBX_NOTFOUND) ? MDBX_SUCCESS : rc;
      }
      *size_items = 1;
      if (begin.outer.mc_xcursor != 
# 21805 "/libmdbx/src/core.c" 3 4
                                   ((void *)0)
# 21805 "/libmdbx/src/core.c"
                                       ) {
        MDBX_node *node = page_node(begin.outer.mc_pg[begin.outer.mc_top],
                                    begin.outer.mc_ki[begin.outer.mc_top]);
        if ((((node_flags(node)) & (0x04)) == (0x04))) {

          do { if ((0)) do { if (__builtin_expect(!!(!(begin.outer.mc_xcursor == &begin.inner && (begin.inner.mx_cursor.mc_flags & 0x01))), 0)) mdbx_assert_fail((txn)->mt_env, "begin.outer.mc_xcursor == &begin.inner && (begin.inner.mx_cursor.mc_flags & 0x01)", __func__, 21810); } while (0); } while (0)

                                                                            ;
          *size_items =
              (sizeof(*size_items) >= sizeof(begin.inner.mx_db.md_entries) ||
               begin.inner.mx_db.md_entries <= 
# 21815 "/libmdbx/src/core.c" 3 4
                                              (9223372036854775807L)
# 21815 "/libmdbx/src/core.c"
                                                         )
                  ? (size_t)begin.inner.mx_db.md_entries
                  : 
# 21817 "/libmdbx/src/core.c" 3 4
                   (9223372036854775807L)
# 21817 "/libmdbx/src/core.c"
                              ;
        }
      }
      return MDBX_SUCCESS;
    } else {
      rc = mdbx_cursor_set(&begin.outer, begin_key, begin_data,
                           begin_data ? MDBX_GET_BOTH_RANGE : MDBX_SET_RANGE)
               .err;
    }
  }

  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0)) {
    if (rc != MDBX_NOTFOUND || !(begin.outer.mc_flags & 0x01))
      return rc;
  }

  MDBX_cursor_couple end;
  rc = mdbx_cursor_init(&end.outer, txn, dbi);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;
  if (!end_key) {
    MDBX_val stub = {0, 0};
    rc = mdbx_cursor_last(&end.outer, &stub, &stub);
  } else {
    rc = mdbx_cursor_set(&end.outer, end_key, end_data,
                         end_data ? MDBX_GET_BOTH_RANGE : MDBX_SET_RANGE)
             .err;
  }
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0)) {
    if (rc != MDBX_NOTFOUND || !(end.outer.mc_flags & 0x01))
      return rc;
  }

  rc = mdbx_estimate_distance(&begin.outer, &end.outer, size_items);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;
  do { if ((0)) do { if (__builtin_expect(!!(!(*size_items >= -(ptrdiff_t)begin.outer.mc_db->md_entries && *size_items <= (ptrdiff_t)begin.outer.mc_db->md_entries)), 0)) mdbx_assert_fail(
# 21853 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 21853 "/libmdbx/src/core.c"
 , "*size_items >= -(ptrdiff_t)begin.outer.mc_db->md_entries && *size_items <= (ptrdiff_t)begin.outer.mc_db->md_entries", __func__, 21853); } while (0); } while (0)
                                                                 ;
# 21879 "/libmdbx/src/core.c"
  return MDBX_SUCCESS;
}
# 21908 "/libmdbx/src/core.c"
int mdbx_replace_ex(MDBX_txn *txn, MDBX_dbi dbi, const MDBX_val *key,
                    MDBX_val *new_data, MDBX_val *old_data,
                    MDBX_put_flags_t flags, MDBX_preserve_func preserver,
                    void *preserver_context) {
  int rc = check_txn_rw(txn, (0x01 | 0x02 | 0x10));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(!key || !old_data || old_data == new_data), 0))
    return MDBX_EINVAL;

  if (__builtin_expect(!!(old_data->iov_base == 
# 21919 "/libmdbx/src/core.c" 3 4
     ((void *)0) 
# 21919 "/libmdbx/src/core.c"
     && old_data->iov_len), 0))
    return MDBX_EINVAL;

  if (__builtin_expect(!!(new_data == 
# 21922 "/libmdbx/src/core.c" 3 4
     ((void *)0) 
# 21922 "/libmdbx/src/core.c"
     && (flags & (MDBX_CURRENT | MDBX_RESERVE)) != MDBX_CURRENT), 0)
                                                                       )
    return MDBX_EINVAL;

  if (__builtin_expect(!!(!check_dbi(txn, dbi, 0x20)), 0))
    return MDBX_BAD_DBI;

  if (__builtin_expect(!!(flags & ~(MDBX_NOOVERWRITE | MDBX_NODUPDATA | MDBX_ALLDUPS | MDBX_RESERVE | MDBX_APPEND | MDBX_APPENDDUP | MDBX_CURRENT)), 0)

                                                                             )
    return MDBX_EINVAL;

  MDBX_cursor_couple cx;
  rc = mdbx_cursor_init(&cx.outer, txn, dbi);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;
  cx.outer.mc_next = txn->mt_cursors[dbi];
  txn->mt_cursors[dbi] = &cx.outer;

  MDBX_val present_key = *key;
  if ((((flags) & (MDBX_CURRENT | MDBX_NOOVERWRITE)) == (MDBX_CURRENT | MDBX_NOOVERWRITE))) {

    if (__builtin_expect(!!(!(txn->mt_dbs[dbi].md_flags & MDBX_DUPSORT)), 0)) {
      rc = MDBX_EINVAL;
      goto bailout;
    }


    flags -= MDBX_NOOVERWRITE;

    rc = mdbx_cursor_get(&cx.outer, &present_key, old_data, MDBX_GET_BOTH);
    if (rc != MDBX_SUCCESS)
      goto bailout;
  } else {

    if (__builtin_expect(!!(new_data && old_data->iov_base == new_data->iov_base), 0))
      return MDBX_EINVAL;
    MDBX_val present_data;
    rc = mdbx_cursor_get(&cx.outer, &present_key, &present_data, MDBX_SET_KEY);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0)) {
      old_data->iov_base = 
# 21962 "/libmdbx/src/core.c" 3 4
                          ((void *)0)
# 21962 "/libmdbx/src/core.c"
                              ;
      old_data->iov_len = 0;
      if (rc != MDBX_NOTFOUND || (flags & MDBX_CURRENT))
        goto bailout;
    } else if (flags & MDBX_NOOVERWRITE) {
      rc = MDBX_KEYEXIST;
      *old_data = present_data;
      goto bailout;
    } else {
      MDBX_page *page = cx.outer.mc_pg[cx.outer.mc_top];
      if (txn->mt_dbs[dbi].md_flags & MDBX_DUPSORT) {
        if (flags & MDBX_CURRENT) {

          MDBX_node *node = page_node(page, cx.outer.mc_ki[cx.outer.mc_top]);
          if ((((node_flags(node)) & (0x04)) == (0x04))) {
            do { if ((0)) do { if (__builtin_expect(!!(!(((&cx.outer)->mc_xcursor && ((&cx.outer)->mc_xcursor->mx_cursor.mc_flags & 0x01)) && cx.outer.mc_xcursor->mx_db.md_entries > 1)), 0)) mdbx_assert_fail((txn)->mt_env, "((&cx.outer)->mc_xcursor && ((&cx.outer)->mc_xcursor->mx_cursor.mc_flags & 0x01)) && cx.outer.mc_xcursor->mx_db.md_entries > 1", __func__, 21977); } while (0); } while (0)
                                                                            ;
            if (cx.outer.mc_xcursor->mx_db.md_entries > 1) {
              rc = MDBX_EMULTIVAL;
              goto bailout;
            }
          }




        }
      }

      if (((page)->mp_txnid == (txn)->mt_front)) {
        if (new_data && cmp_lenfast(&present_data, new_data) == 0) {

          *old_data = *new_data;
          goto bailout;
        }
        rc = preserver ? preserver(preserver_context, old_data,
                                   present_data.iov_base, present_data.iov_len)
                       : MDBX_SUCCESS;
        if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
          goto bailout;
      } else {
        *old_data = present_data;
      }
      flags |= MDBX_CURRENT;
    }
  }

  if (__builtin_expect(!!(new_data), 1))
    rc = mdbx_cursor_put(&cx.outer, key, new_data, flags);
  else
    rc = mdbx_cursor_del(&cx.outer, flags & MDBX_ALLDUPS);

bailout:
  txn->mt_cursors[dbi] = cx.outer.mc_next;
  return rc;
}

static int default_value_preserver(void *context, MDBX_val *target,
                                   const void *src, size_t bytes) {
  (void)context;
  if (__builtin_expect(!!(target->iov_len < bytes), 0)) {
    target->iov_base = 
# 22023 "/libmdbx/src/core.c" 3 4
                      ((void *)0)
# 22023 "/libmdbx/src/core.c"
                             ;
    target->iov_len = bytes;
    return MDBX_RESULT_TRUE;
  }
  memcpy(target->iov_base, src, target->iov_len = bytes);
  return MDBX_SUCCESS;
}

int mdbx_replace(MDBX_txn *txn, MDBX_dbi dbi, const MDBX_val *key,
                 MDBX_val *new_data, MDBX_val *old_data,
                 MDBX_put_flags_t flags) {
  return mdbx_replace_ex(txn, dbi, key, new_data, old_data, flags,
                         default_value_preserver, 
# 22035 "/libmdbx/src/core.c" 3 4
                                                 ((void *)0)
# 22035 "/libmdbx/src/core.c"
                                                        );
}
# 22060 "/libmdbx/src/core.c"
int mdbx_is_dirty(const MDBX_txn *txn, const void *ptr) {
  int rc = check_txn(txn, (0x01 | 0x02 | 0x10));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  const MDBX_env *env = txn->mt_env;
  const ptrdiff_t offset = (uint8_t *)ptr - env->me_dxb_mmap.dxb;
  if (offset >= 0) {
    const pgno_t pgno = bytes2pgno(env, offset);
    if (__builtin_expect(!!(pgno < txn->mt_geo.next), 1)) {
      const MDBX_page *page = pgno2page(env, pgno);
      if (__builtin_expect(!!(page->mp_pgno != pgno || (page->mp_flags & (~(0x01 | 0x02 | 0x20 | 0x04 | 0x2000))) != 0), 0)
                                                      ) {


        return MDBX_EINVAL;
      }
      return ((txn->mt_flags & MDBX_TXN_RDONLY) || !((page)->mp_txnid == (txn)->mt_front))
                 ? MDBX_RESULT_FALSE
                 : MDBX_RESULT_TRUE;
    }
    if ((size_t)offset < env->me_dxb_mmap.limit) {




      return (txn->mt_flags & MDBX_TXN_RDONLY) ? MDBX_EINVAL : MDBX_RESULT_TRUE;
    }
  }







  return (txn->mt_flags & (MDBX_WRITEMAP | MDBX_TXN_RDONLY)) ? MDBX_EINVAL
                                                             : MDBX_RESULT_TRUE;
}

int mdbx_dbi_sequence(MDBX_txn *txn, MDBX_dbi dbi, uint64_t *result,
                      uint64_t increment) {
  int rc = check_txn(txn, (0x01 | 0x02 | 0x10));
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    return rc;

  if (__builtin_expect(!!(!check_dbi(txn, dbi, 0x20)), 0))
    return MDBX_BAD_DBI;

  if (__builtin_expect(!!(txn->mt_dbistate[dbi] & MDBX_DBI_STALE), 0)) {
    rc = mdbx_fetch_sdb(txn, dbi);
    if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
      return rc;
  }

  MDBX_db *dbs = &txn->mt_dbs[dbi];
  if (__builtin_expect(!!(result), 1))
    *result = dbs->md_seq;

  if (__builtin_expect(!!(increment > 0), 1)) {
    if (__builtin_expect(!!(txn->mt_flags & MDBX_TXN_RDONLY), 0))
      return MDBX_EACCESS;

    uint64_t new = dbs->md_seq + increment;
    if (__builtin_expect(!!(new < increment), 0))
      return MDBX_RESULT_TRUE;

    do { if ((0)) do { if (__builtin_expect(!!(!(new > dbs->md_seq)), 0)) mdbx_assert_fail((txn)->mt_env, "new > dbs->md_seq", __func__, 22127); } while (0); } while (0);
    dbs->md_seq = new;
    txn->mt_flags |= 0x04;
    txn->mt_dbistate[dbi] |= MDBX_DBI_DIRTY;
  }

  return MDBX_SUCCESS;
}




__attribute__((__cold__)) __attribute__((__optimize__("Os"))) __attribute__((__const__, __nothrow__)) intptr_t mdbx_limits_pgsize_min(void) {
  return __inline_mdbx_limits_pgsize_min();
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) __attribute__((__const__, __nothrow__)) intptr_t mdbx_limits_pgsize_max(void) {
  return __inline_mdbx_limits_pgsize_max();
}


__attribute__((__cold__)) __attribute__((__optimize__("Os"))) intptr_t mdbx_limits_dbsize_min(intptr_t pagesize) {
  if (pagesize < 1)
    pagesize = (intptr_t)mdbx_default_pagesize();
  else if (__builtin_expect(!!(pagesize < (intptr_t)MDBX_MIN_PAGESIZE || pagesize > (intptr_t)MDBX_MAX_PAGESIZE || !is_powerof2((size_t)pagesize)), 0)

                                                   )
    return -1;

  return 3 * pagesize;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) intptr_t mdbx_limits_dbsize_max(intptr_t pagesize) {
  if (pagesize < 1)
    pagesize = (intptr_t)mdbx_default_pagesize();
  else if (__builtin_expect(!!(pagesize < (intptr_t)MDBX_MIN_PAGESIZE || pagesize > (intptr_t)MDBX_MAX_PAGESIZE || !is_powerof2((size_t)pagesize)), 0)

                                                   )
    return -1;

  _Static_assert(((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE) < 
# 22167 "/libmdbx/src/core.c" 3 4
 (9223372036854775807L)
# 22167 "/libmdbx/src/core.c"
 , "MAX_MAPSIZE < INTPTR_MAX");
  const uint64_t limit = (1 + (uint64_t)0x7FFFffffU) * pagesize;
  return (limit < ((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE)) ? (intptr_t)limit : (intptr_t)((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE);
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) intptr_t mdbx_limits_txnsize_max(intptr_t pagesize) {
  if (pagesize < 1)
    pagesize = (intptr_t)mdbx_default_pagesize();
  else if (__builtin_expect(!!(pagesize < (intptr_t)MDBX_MIN_PAGESIZE || pagesize > (intptr_t)MDBX_MAX_PAGESIZE || !is_powerof2((size_t)pagesize)), 0)

                                                   )
    return -1;

  _Static_assert(((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE) < 
# 22180 "/libmdbx/src/core.c" 3 4
 (9223372036854775807L)
# 22180 "/libmdbx/src/core.c"
 , "MAX_MAPSIZE < INTPTR_MAX");
  const uint64_t pgl_limit =
      pagesize * (uint64_t)(((size_t)0x7FFFffffU) / 1.6180339887498948482);
  const uint64_t map_limit = (uint64_t)(((0x7FFFffffU + 1) * (uint64_t)MDBX_MAX_PAGESIZE) / 1.6180339887498948482);
  return (pgl_limit < map_limit) ? (intptr_t)pgl_limit : (intptr_t)map_limit;
}



static 
# 22189 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 22189 "/libmdbx/src/core.c"
                      double key2double(const int64_t key) {
  union {
    uint64_t u;
    double f;
  } casting;

  casting.u = (key < 0) ? key + 0x8000000000000000UL
                        : 0xffffFFFFffffFFFFUL - key;
  return casting.f;
}

static 
# 22200 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 22200 "/libmdbx/src/core.c"
                      uint64_t double2key(const double *const ptr) {
  _Static_assert(sizeof(double) == sizeof(int64_t), "sizeof(double) == sizeof(int64_t)");
  const int64_t i = *(const int64_t *)ptr;
  const uint64_t u = (i < 0) ? 0xffffFFFFffffFFFFUL - i
                             : i + 0x8000000000000000UL;
  if ((0)) {
    const double f = key2double(u);
    do { if ((0)) do { if (__builtin_expect(!!(!(memcmp(&f, ptr, 8) == 0)), 0)) mdbx_assert_fail(
# 22207 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 22207 "/libmdbx/src/core.c"
   , "memcmp(&f, ptr, 8) == 0", __func__, 22207); } while (0); } while (0);
  }
  return u;
}

static 
# 22212 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 22212 "/libmdbx/src/core.c"
                      float key2float(const int32_t key) {
  union {
    uint32_t u;
    float f;
  } casting;

  casting.u =
      (key < 0) ? key + 0x80000000U : 0xffffFFFFU - key;
  return casting.f;
}

static 
# 22223 "/libmdbx/src/core.c" 3 4
      __inline __attribute__ ((__always_inline__)) 
# 22223 "/libmdbx/src/core.c"
                      uint32_t float2key(const float *const ptr) {
  _Static_assert(sizeof(float) == sizeof(int32_t), "sizeof(float) == sizeof(int32_t)");
  const int32_t i = *(const int32_t *)ptr;
  const uint32_t u =
      (i < 0) ? 0xffffFFFFU - i : i + 0x80000000U;
  if ((0)) {
    const float f = key2float(u);
    do { if ((0)) do { if (__builtin_expect(!!(!(memcmp(&f, ptr, 4) == 0)), 0)) mdbx_assert_fail(
# 22230 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 22230 "/libmdbx/src/core.c"
   , "memcmp(&f, ptr, 4) == 0", __func__, 22230); } while (0); } while (0);
  }
  return u;
}

uint64_t mdbx_key_from_double(const double ieee754_64bit) {
  return double2key(&ieee754_64bit);
}

uint64_t mdbx_key_from_ptrdouble(const double *const ieee754_64bit) {
  return double2key(ieee754_64bit);
}

uint32_t mdbx_key_from_float(const float ieee754_32bit) {
  return float2key(&ieee754_32bit);
}

uint32_t mdbx_key_from_ptrfloat(const float *const ieee754_32bit) {
  return float2key(ieee754_32bit);
}


__attribute__((__const__, __nothrow__)) uint64_t mdbx_key_from_int64(const int64_t i64) {
  return __inline_mdbx_key_from_int64(i64);
}

__attribute__((__const__, __nothrow__)) uint32_t mdbx_key_from_int32(const int32_t i32) {
  return __inline_mdbx_key_from_int32(i32);
}
# 22268 "/libmdbx/src/core.c"
static __inline int clz64(uint64_t value) {

  if (sizeof(value) == sizeof(int))
    return __builtin_clz(value);
  if (sizeof(value) == sizeof(long))
    return __builtin_clzl(value);


  return __builtin_clzll(value);
# 22295 "/libmdbx/src/core.c"
  value |= value >> 1;
  value |= value >> 2;
  value |= value >> 4;
  value |= value >> 8;
  value |= value >> 16;
  value |= value >> 32;
  static const uint8_t debruijn_clz64[64] = {
      63, 16, 62, 7, 15, 36, 61, 3, 6, 14, 22, 26, 35, 47, 60, 2,
      9, 5, 28, 11, 13, 21, 42, 19, 25, 31, 34, 40, 46, 52, 59, 1,
      17, 8, 37, 4, 23, 27, 48, 10, 29, 12, 43, 20, 32, 41, 53, 18,
      38, 24, 49, 30, 44, 33, 54, 39, 50, 45, 55, 51, 56, 57, 58, 0};
  return debruijn_clz64[value * 0x03F79D71B4CB0A89UL >> 58];
}

static __inline uint64_t round_mantissa(const uint64_t u64, int shift) {
  do { if ((0)) do { if (__builtin_expect(!!(!(shift < 0 && u64 > 0)), 0)) mdbx_assert_fail(
# 22310 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 22310 "/libmdbx/src/core.c"
 , "shift < 0 && u64 > 0", __func__, 22310); } while (0); } while (0);
  shift = -shift;
  const unsigned half = 1 << (shift - 1);
  const unsigned lsb = 1 & (unsigned)(u64 >> shift);
  const unsigned tie2even = 1 ^ lsb;
  return (u64 + half - tie2even) >> shift;
}

uint64_t mdbx_key_from_jsonInteger(const int64_t json_integer) {
  const uint64_t bias = 0x8000000000000000UL;
  if (json_integer > 0) {
    const uint64_t u64 = json_integer;
    int shift = clz64(u64) - (64 - 52 - 1);
    uint64_t mantissa = u64 << shift;
    if (__builtin_expect(!!(shift < 0), 0)) {
      mantissa = round_mantissa(u64, shift);
      if (mantissa > 0x001FFFFFFFFFFFFFUL)
        mantissa = round_mantissa(u64, --shift);
    }

    do { if ((0)) do { if (__builtin_expect(!!(!(mantissa >= 0x0010000000000000UL && mantissa <= 0x001FFFFFFFFFFFFFUL)), 0)) mdbx_assert_fail(
# 22330 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 22330 "/libmdbx/src/core.c"
   , "mantissa >= 0x0010000000000000UL && mantissa <= 0x001FFFFFFFFFFFFFUL", __func__, 22330); } while (0); } while (0)
                                                    ;
    const uint64_t exponent =
        0x3FF + 52 - shift;
    do { if ((0)) do { if (__builtin_expect(!!(!(exponent > 0 && exponent <= 0x7FF)), 0)) mdbx_assert_fail(
# 22334 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 22334 "/libmdbx/src/core.c"
   , "exponent > 0 && exponent <= 0x7FF", __func__, 22334); } while (0); } while (0);
    const uint64_t key = bias + (exponent << 52) +
                         (mantissa - 0x0010000000000000UL);




    do { if ((0)) do { if (__builtin_expect(!!(!(key == mdbx_key_from_double((double)json_integer))), 0)) mdbx_assert_fail(
# 22341 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 22341 "/libmdbx/src/core.c"
   , "key == mdbx_key_from_double((double)json_integer)", __func__, 22341); } while (0); } while (0);

    return key;
  }

  if (json_integer < 0) {
    const uint64_t u64 = -json_integer;
    int shift = clz64(u64) - (64 - 52 - 1);
    uint64_t mantissa = u64 << shift;
    if (__builtin_expect(!!(shift < 0), 0)) {
      mantissa = round_mantissa(u64, shift);
      if (mantissa > 0x001FFFFFFFFFFFFFUL)
        mantissa = round_mantissa(u64, --shift);
    }

    do { if ((0)) do { if (__builtin_expect(!!(!(mantissa >= 0x0010000000000000UL && mantissa <= 0x001FFFFFFFFFFFFFUL)), 0)) mdbx_assert_fail(
# 22356 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 22356 "/libmdbx/src/core.c"
   , "mantissa >= 0x0010000000000000UL && mantissa <= 0x001FFFFFFFFFFFFFUL", __func__, 22356); } while (0); } while (0)
                                                    ;
    const uint64_t exponent =
        0x3FF + 52 - shift;
    do { if ((0)) do { if (__builtin_expect(!!(!(exponent > 0 && exponent <= 0x7FF)), 0)) mdbx_assert_fail(
# 22360 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 22360 "/libmdbx/src/core.c"
   , "exponent > 0 && exponent <= 0x7FF", __func__, 22360); } while (0); } while (0);
    const uint64_t key = bias - 1 - (exponent << 52) -
                         (mantissa - 0x0010000000000000UL);




    do { if ((0)) do { if (__builtin_expect(!!(!(key == mdbx_key_from_double((double)json_integer))), 0)) mdbx_assert_fail(
# 22367 "/libmdbx/src/core.c" 3 4
   ((void *)0)
# 22367 "/libmdbx/src/core.c"
   , "key == mdbx_key_from_double((double)json_integer)", __func__, 22367); } while (0); } while (0);

    return key;
  }

  return bias;
}

int64_t mdbx_jsonInteger_from_key(const MDBX_val v) {
  do { if ((0)) do { if (__builtin_expect(!!(!(v.iov_len == 8)), 0)) mdbx_assert_fail(
# 22376 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 22376 "/libmdbx/src/core.c"
 , "v.iov_len == 8", __func__, 22376); } while (0); } while (0);
  const uint64_t key = unaligned_peek_u64(2, v.iov_base);
  const uint64_t bias = 0x8000000000000000UL;
  const uint64_t covalent = (key > bias) ? key - bias : bias - key - 1;
  const int shift = 0x3FF + 63 -
                    (0x7FF &
                     (int)(covalent >> 52));
  if (__builtin_expect(!!(shift < 1), 0))
    return (key < bias) ? 
# 22384 "/libmdbx/src/core.c" 3 4
                         (-9223372036854775807L -1) 
# 22384 "/libmdbx/src/core.c"
                                   : 
# 22384 "/libmdbx/src/core.c" 3 4
                                     (9223372036854775807L)
# 22384 "/libmdbx/src/core.c"
                                              ;
  if (__builtin_expect(!!(shift > 63), 0))
    return 0;

  const uint64_t unscaled = ((covalent & 0x000FFFFFFFFFFFFFUL)
                             << (63 - 52)) +
                            bias;
  const int64_t absolute = unscaled >> shift;
  const int64_t value = (key < bias) ? -absolute : absolute;
  do { if ((0)) do { if (__builtin_expect(!!(!(key == mdbx_key_from_jsonInteger(value) || (mdbx_key_from_jsonInteger(value - 1) < key && key < mdbx_key_from_jsonInteger(value + 1)))), 0)) mdbx_assert_fail(
# 22393 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 22393 "/libmdbx/src/core.c"
 , "key == mdbx_key_from_jsonInteger(value) || (mdbx_key_from_jsonInteger(value - 1) < key && key < mdbx_key_from_jsonInteger(value + 1))", __func__, 22393); } while (0); } while (0)

                                                      ;
  return value;
}

double mdbx_double_from_key(const MDBX_val v) {
  do { if ((0)) do { if (__builtin_expect(!!(!(v.iov_len == 8)), 0)) mdbx_assert_fail(
# 22400 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 22400 "/libmdbx/src/core.c"
 , "v.iov_len == 8", __func__, 22400); } while (0); } while (0);
  return key2double(unaligned_peek_u64(2, v.iov_base));
}

float mdbx_float_from_key(const MDBX_val v) {
  do { if ((0)) do { if (__builtin_expect(!!(!(v.iov_len == 4)), 0)) mdbx_assert_fail(
# 22405 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 22405 "/libmdbx/src/core.c"
 , "v.iov_len == 4", __func__, 22405); } while (0); } while (0);
  return key2float(unaligned_peek_u32(2, v.iov_base));
}

int32_t mdbx_int32_from_key(const MDBX_val v) {
  do { if ((0)) do { if (__builtin_expect(!!(!(v.iov_len == 4)), 0)) mdbx_assert_fail(
# 22410 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 22410 "/libmdbx/src/core.c"
 , "v.iov_len == 4", __func__, 22410); } while (0); } while (0);
  return (int32_t)(unaligned_peek_u32(2, v.iov_base) - 0x80000000U);
}

int64_t mdbx_int64_from_key(const MDBX_val v) {
  do { if ((0)) do { if (__builtin_expect(!!(!(v.iov_len == 8)), 0)) mdbx_assert_fail(
# 22415 "/libmdbx/src/core.c" 3 4
 ((void *)0)
# 22415 "/libmdbx/src/core.c"
 , "v.iov_len == 8", __func__, 22415); } while (0); } while (0);
  return (int64_t)(unaligned_peek_u64(2, v.iov_base) -
                   0x8000000000000000UL);
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) MDBX_cmp_func *mdbx_get_keycmp(unsigned flags) {
  return get_default_keycmp(flags);
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) MDBX_cmp_func *mdbx_get_datacmp(unsigned flags) {
  return get_default_datacmp(flags);
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_set_option(MDBX_env *env, const MDBX_option_t option,
                               uint64_t value) {
  int err = check_env(env, (0));
  if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
    return err;

  const _Bool lock_needed = ((env->me_flags & 0x20000000U) && env->me_txn0 &&
                            env->me_txn0->mt_owner != mdbx_thread_self());
  _Bool should_unlock = (0);
  switch (option) {
  case MDBX_opt_sync_bytes:
    if (value == 
# 22439 "/libmdbx/src/core.c" 3 4
                (18446744073709551615UL)
# 22439 "/libmdbx/src/core.c"
                          )
      value = 
# 22440 "/libmdbx/src/core.c" 3 4
             (18446744073709551615UL) 
# 22440 "/libmdbx/src/core.c"
                      - 65536;
    if (__builtin_expect(!!(env->me_flags & MDBX_RDONLY), 0))
      return MDBX_EACCESS;
    if (__builtin_expect(!!(!(env->me_flags & 0x20000000U)), 0))
      return MDBX_EPERM;
    if (__builtin_expect(!!(value > 
# 22445 "/libmdbx/src/core.c" 3 4
       (18446744073709551615UL) 
# 22445 "/libmdbx/src/core.c"
       - 65536), 0))
      return MDBX_TOO_LARGE;
    if (atomic_store32(&env->me_lck->mti_autosync_threshold,
                       bytes2pgno(env, (size_t)value + env->me_psize - 1),
                       mo_Relaxed) != 0 &&
        (env->me_flags & 0x20000000U)) {
      err = mdbx_env_sync_poll(env);
      if (__builtin_expect(!!(((err) != MDBX_RESULT_TRUE && (err) != MDBX_RESULT_FALSE)), 0))
        return err;
      err = MDBX_SUCCESS;
    }
    break;

  case MDBX_opt_sync_period:
    if (value == 
# 22459 "/libmdbx/src/core.c" 3 4
                (18446744073709551615UL)
# 22459 "/libmdbx/src/core.c"
                          )
      value = 
# 22460 "/libmdbx/src/core.c" 3 4
             (4294967295U)
# 22460 "/libmdbx/src/core.c"
                       ;
    if (__builtin_expect(!!(env->me_flags & MDBX_RDONLY), 0))
      return MDBX_EACCESS;
    if (__builtin_expect(!!(!(env->me_flags & 0x20000000U)), 0))
      return MDBX_EPERM;
    if (__builtin_expect(!!(value > 
# 22465 "/libmdbx/src/core.c" 3 4
       (4294967295U)
# 22465 "/libmdbx/src/core.c"
       ), 0))
      return MDBX_TOO_LARGE;
    if (atomic_store64(&env->me_lck->mti_autosync_period,
                       mdbx_osal_16dot16_to_monotime((uint32_t)value),
                       mo_Relaxed) != 0 &&
        (env->me_flags & 0x20000000U)) {
      err = mdbx_env_sync_poll(env);
      if (__builtin_expect(!!(((err) != MDBX_RESULT_TRUE && (err) != MDBX_RESULT_FALSE)), 0))
        return err;
      err = MDBX_SUCCESS;
    }
    break;

  case MDBX_opt_max_db:
    if (value == 
# 22479 "/libmdbx/src/core.c" 3 4
                (18446744073709551615UL)
# 22479 "/libmdbx/src/core.c"
                          )
      value = MDBX_MAX_DBI;
    if (__builtin_expect(!!(value > MDBX_MAX_DBI), 0))
      return MDBX_EINVAL;
    if (__builtin_expect(!!(env->me_dxb_mmap.dxb), 0))
      return MDBX_EPERM;
    env->me_maxdbs = (unsigned)value + 2;
    break;

  case MDBX_opt_max_readers:
    if (value == 
# 22489 "/libmdbx/src/core.c" 3 4
                (18446744073709551615UL)
# 22489 "/libmdbx/src/core.c"
                          )
      value = 32767;
    if (__builtin_expect(!!(value < 1 || value > 32767), 0))
      return MDBX_EINVAL;
    if (__builtin_expect(!!(env->me_dxb_mmap.dxb), 0))
      return MDBX_EPERM;
    env->me_maxreaders = (unsigned)value;
    break;

  case MDBX_opt_dp_reserve_limit:
    if (value == 
# 22499 "/libmdbx/src/core.c" 3 4
                (18446744073709551615UL)
# 22499 "/libmdbx/src/core.c"
                          )
      value = 0x7fffffff;
    if (__builtin_expect(!!(value > 0x7fffffff), 0))
      return MDBX_EINVAL;
    if (env->me_options.dp_reserve_limit != (unsigned)value) {
      if (lock_needed) {
        err = mdbx_txn_lock(env, (0));
        if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
          return err;
        should_unlock = (1);
      }
      env->me_options.dp_reserve_limit = (unsigned)value;
      while (env->me_dp_reserve_len > env->me_options.dp_reserve_limit) {
        do { if ((0)) do { if (__builtin_expect(!!(!(env->me_dp_reserve != 
# 22512 "/libmdbx/src/core.c" 3 4
       ((void *)0)
# 22512 "/libmdbx/src/core.c"
       )), 0)) mdbx_assert_fail(env, "env->me_dp_reserve != ((void *)0)", __func__, 22512); } while (0); } while (0);
        MDBX_page *dp = env->me_dp_reserve;
        do { do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 22514, "UNPOISON_MEMORY_REGION(%p, %zu) at %u" "\n", (void *)(dp), (size_t)(env->me_psize), 22514); } while (0); ((void)(dp), (void)(env->me_psize)); } while (0);
        ;
        env->me_dp_reserve = dp->mp_next;
        ;
        free(dp);
        env->me_dp_reserve_len -= 1;
      }
    }
    break;

  case MDBX_opt_rp_augment_limit:
    if (value == 
# 22525 "/libmdbx/src/core.c" 3 4
                (18446744073709551615UL)
# 22525 "/libmdbx/src/core.c"
                          )
      value = ((size_t)0x7FFFffffU);
    if (__builtin_expect(!!(value > ((size_t)0x7FFFffffU)), 0))
      return MDBX_EINVAL;
    env->me_options.rp_augment_limit = (unsigned)value;
    break;

  case MDBX_opt_txn_dp_limit:
  case MDBX_opt_txn_dp_initial:
    if (value == 
# 22534 "/libmdbx/src/core.c" 3 4
                (18446744073709551615UL)
# 22534 "/libmdbx/src/core.c"
                          )
      value = ((size_t)0x7FFFffffU);
    if (__builtin_expect(!!(value > ((size_t)0x7FFFffffU) || value < 32 * 4), 0))
      return MDBX_EINVAL;
    if (__builtin_expect(!!(env->me_flags & MDBX_RDONLY), 0))
      return MDBX_EACCESS;
    if (lock_needed) {
      err = mdbx_txn_lock(env, (0));
      if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
        return err;
      should_unlock = (1);
    }
    if (env->me_txn)
      err = MDBX_EPERM ;
    else {
      const pgno_t value32 = (pgno_t)value;
      if (option == MDBX_opt_txn_dp_initial &&
          env->me_options.dp_initial != value32) {
        env->me_options.dp_initial = value32;
        if (env->me_options.dp_limit < value32) {
          env->me_options.dp_limit = value32;
          env->me_options.flags.non_auto.dp_limit = 1;
        }
      }
      if (option == MDBX_opt_txn_dp_limit &&
          env->me_options.dp_limit != value32) {
        env->me_options.dp_limit = value32;
        env->me_options.flags.non_auto.dp_limit = 1;
        if (env->me_options.dp_initial > value32)
          env->me_options.dp_initial = value32;
      }
    }
    break;

  case MDBX_opt_spill_max_denominator:
    if (value == 
# 22569 "/libmdbx/src/core.c" 3 4
                (18446744073709551615UL)
# 22569 "/libmdbx/src/core.c"
                          )
      value = 255;
    if (__builtin_expect(!!(value > 255), 0))
      return MDBX_EINVAL;
    env->me_options.spill_max_denominator = (uint8_t)value;
    break;
  case MDBX_opt_spill_min_denominator:
    if (__builtin_expect(!!(value > 255), 0))
      return MDBX_EINVAL;
    env->me_options.spill_min_denominator = (uint8_t)value;
    break;
  case MDBX_opt_spill_parent4child_denominator:
    if (__builtin_expect(!!(value > 255), 0))
      return MDBX_EINVAL;
    env->me_options.spill_parent4child_denominator = (uint8_t)value;
    break;

  case MDBX_opt_loose_limit:
    if (value == 
# 22587 "/libmdbx/src/core.c" 3 4
                (18446744073709551615UL)
# 22587 "/libmdbx/src/core.c"
                          )
      value = 255;
    if (__builtin_expect(!!(value > 255), 0))
      return MDBX_EINVAL;
    env->me_options.dp_loose_limit = (uint8_t)value;
    break;

  case MDBX_opt_merge_threshold_16dot16_percent:
    if (value == 
# 22595 "/libmdbx/src/core.c" 3 4
                (18446744073709551615UL)
# 22595 "/libmdbx/src/core.c"
                          )
      value = 32768;
    if (__builtin_expect(!!(value < 8192 || value > 32768), 0))
      return MDBX_EINVAL;
    env->me_options.merge_threshold_16dot16_percent = (unsigned)value;
    recalculate_merge_threshold(env);
    break;

  default:
    return MDBX_EINVAL;
  }

  if (should_unlock)
    mdbx_txn_unlock(env);
  return err;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_env_get_option(const MDBX_env *env, const MDBX_option_t option,
                               uint64_t *pvalue) {
  int err = check_env(env, (0));
  if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
    return err;
  if (__builtin_expect(!!(!pvalue), 0))
    return MDBX_EINVAL;

  switch (option) {
  case MDBX_opt_sync_bytes:
    if (__builtin_expect(!!(!(env->me_flags & 0x20000000U)), 0))
      return MDBX_EPERM;
    *pvalue = pgno2bytes(
        env, atomic_load32(&env->me_lck->mti_autosync_threshold, mo_Relaxed));
    break;

  case MDBX_opt_sync_period:
    if (__builtin_expect(!!(!(env->me_flags & 0x20000000U)), 0))
      return MDBX_EPERM;
    *pvalue = mdbx_osal_monotime_to_16dot16(
        atomic_load64(&env->me_lck->mti_autosync_period, mo_Relaxed));
    break;

  case MDBX_opt_max_db:
    *pvalue = env->me_maxdbs - 2;
    break;

  case MDBX_opt_max_readers:
    *pvalue = env->me_maxreaders;
    break;

  case MDBX_opt_dp_reserve_limit:
    *pvalue = env->me_options.dp_reserve_limit;
    break;

  case MDBX_opt_rp_augment_limit:
    *pvalue = env->me_options.rp_augment_limit;
    break;

  case MDBX_opt_txn_dp_limit:
    *pvalue = env->me_options.dp_limit;
    break;
  case MDBX_opt_txn_dp_initial:
    *pvalue = env->me_options.dp_initial;
    break;

  case MDBX_opt_spill_max_denominator:
    *pvalue = env->me_options.spill_max_denominator;
    break;
  case MDBX_opt_spill_min_denominator:
    *pvalue = env->me_options.spill_min_denominator;
    break;
  case MDBX_opt_spill_parent4child_denominator:
    *pvalue = env->me_options.spill_parent4child_denominator;
    break;

  case MDBX_opt_loose_limit:
    *pvalue = env->me_options.dp_loose_limit;
    break;

  case MDBX_opt_merge_threshold_16dot16_percent:
    *pvalue = env->me_options.merge_threshold_16dot16_percent;
    break;

  default:
    return MDBX_EINVAL;
  }

  return MDBX_SUCCESS;
}
# 22813 "/libmdbx/src/core.c"
__attribute__((__visibility__("default")))

    
# 22815 "/libmdbx/src/core.c" 3 4
   __attribute__ ((__used__))







    
# 22823 "/libmdbx/src/core.c"
   __attribute__((__externally_visible__))

    const struct MDBX_build_info mdbx_build = {

    "2022-12-20T07:42:42Z"




    ,

    "aarch64-linux-gnu-Linux"
# 22931 "/libmdbx/src/core.c"
    "-" "Release"

    ,
    "MDBX_DEBUG=" "0"
    " MDBX_WORDBITS=" "64"
    " BYTE_ORDER="

    "LITTLE_ENDIAN"





    " MDBX_ENV_CHECKPID=" "AUTO=" "0"
    " MDBX_TXN_CHECKOWNER=" "1"
    " MDBX_64BIT_ATOMIC=" "AUTO=" "1"
    " MDBX_64BIT_CAS=" "AUTO=" "1"
    " MDBX_TRUST_RTC=" "AUTO=" "0"
    " MDBX_ENABLE_REFUND=" "1"
    " MDBX_ENABLE_MADVISE=" "1"
# 22964 "/libmdbx/src/core.c"
    " _GNU_SOURCE=YES"
# 22979 "/libmdbx/src/core.c"
    " MDBX_LOCKING=" "AUTO=" "2008"
    " MDBX_USE_OFDLOCKS=" "AUTO=" "1"

    " MDBX_CACHELINE_SIZE=" "64"
    " MDBX_CPU_WRITEBACK_INCOHERENT=" "1"
    " MDBX_MMAP_INCOHERENT_CPU_CACHE=" "0"
    " MDBX_MMAP_INCOHERENT_FILE_WRITE=" "0"
    " MDBX_UNALIGNED_OK=" "4"
    " MDBX_PNL_ASCENDING=" "0"
    ,

    "cc (Ubuntu 11.3.0-1ubuntu1~22.04) 11.3.0"
# 23020 "/libmdbx/src/core.c"
    ,




    " -fexceptions -fno-semantic-interposition -fno-common -ggdb -Wno-unknown-pragmas -ffunction-sections -fdata-sections -Wall -Wextra -flto -fno-fat-lto-objects -fuse-linker-plugin -flto-odr-type-merging -O3 -DNDEBUG LIBMDBX_EXPORTS MDBX_BUILD_SHARED_LIBRARY=1 -ffast-math -fvisibility=hidden"
# 23035 "/libmdbx/src/core.c"
};
# 18 "/libmdbx/src/alloy.c" 2
# 1 "/libmdbx/src/osal.c" 1
# 159 "/libmdbx/src/osal.c"
 void __assert_fail(const char *assertion, const char *file,
                              unsigned line, const char *function)

    
# 162 "/libmdbx/src/osal.c" 3 4
   __attribute__ ((__nothrow__ , __leaf__))



    
# 166 "/libmdbx/src/osal.c"
   __attribute__((__noreturn__));
# 220 "/libmdbx/src/osal.c"
__attribute__((__cold__)) __attribute__((__optimize__("Os"))) void mdbx_assert_fail(const MDBX_env *env, const char *msg,
                             const char *func, int line) {






  (void)env;


  if (mdbx_debug_logger)
    mdbx_debug_log(MDBX_LOG_FATAL, func, line, "assert: %s\n", msg);
  else {
# 246 "/libmdbx/src/osal.c"
    __assert_fail(msg, "mdbx", line, func);

  }




  abort();

}



__attribute__((__cold__)) __attribute__((__optimize__("Os"))) void mdbx_panic(const char *fmt, ...) {
  va_list ap;
  
# 261 "/libmdbx/src/osal.c" 3 4
 __builtin_va_start(
# 261 "/libmdbx/src/osal.c"
 ap
# 261 "/libmdbx/src/osal.c" 3 4
 ,
# 261 "/libmdbx/src/osal.c"
 fmt
# 261 "/libmdbx/src/osal.c" 3 4
 )
# 261 "/libmdbx/src/osal.c"
                  ;

  char *message = 
# 263 "/libmdbx/src/osal.c" 3 4
                 ((void *)0)
# 263 "/libmdbx/src/osal.c"
                        ;
  const int num = mdbx_vasprintf(&message, fmt, ap);
  
# 265 "/libmdbx/src/osal.c" 3 4
 __builtin_va_end(
# 265 "/libmdbx/src/osal.c"
 ap
# 265 "/libmdbx/src/osal.c" 3 4
 )
# 265 "/libmdbx/src/osal.c"
           ;
  const char *const const_message =
      (num < 1 || !message) ? "<troubles with panic-message preparation>"
                            : message;
# 280 "/libmdbx/src/osal.c"
  __assert_fail(const_message, "mdbx", 0, "panic");

  abort();

}




static int mdbx_vasprintf(char **strp, const char *fmt,
                                      va_list ap) {
  va_list ones;
  
# 292 "/libmdbx/src/osal.c" 3 4
 __builtin_va_copy(
# 292 "/libmdbx/src/osal.c"
 ones
# 292 "/libmdbx/src/osal.c" 3 4
 ,
# 292 "/libmdbx/src/osal.c"
 ap
# 292 "/libmdbx/src/osal.c" 3 4
 )
# 292 "/libmdbx/src/osal.c"
                  ;
  int needed = vsnprintf(
# 293 "/libmdbx/src/osal.c" 3 4
                        ((void *)0)
# 293 "/libmdbx/src/osal.c"
                               , 0, fmt, ap);

  if (__builtin_expect(!!(needed < 0 || needed >= 0x7fffffff), 0)) {
    *strp = 
# 296 "/libmdbx/src/osal.c" 3 4
           ((void *)0)
# 296 "/libmdbx/src/osal.c"
                  ;
    
# 297 "/libmdbx/src/osal.c" 3 4
   __builtin_va_end(
# 297 "/libmdbx/src/osal.c"
   ones
# 297 "/libmdbx/src/osal.c" 3 4
   )
# 297 "/libmdbx/src/osal.c"
               ;
    return needed;
  }

  *strp = malloc(needed + 1);
  if (__builtin_expect(!!(*strp == 
# 302 "/libmdbx/src/osal.c" 3 4
     ((void *)0)
# 302 "/libmdbx/src/osal.c"
     ), 0)) {
    
# 303 "/libmdbx/src/osal.c" 3 4
   __builtin_va_end(
# 303 "/libmdbx/src/osal.c"
   ones
# 303 "/libmdbx/src/osal.c" 3 4
   )
# 303 "/libmdbx/src/osal.c"
               ;



    
# 307 "/libmdbx/src/osal.c" 3 4
   (*__errno_location ()) 
# 307 "/libmdbx/src/osal.c"
         = MDBX_ENOMEM;

    return -1;
  }

  int actual = vsnprintf(*strp, needed + 1, fmt, ones);
  
# 313 "/libmdbx/src/osal.c" 3 4
 __builtin_va_end(
# 313 "/libmdbx/src/osal.c"
 ones
# 313 "/libmdbx/src/osal.c" 3 4
 )
# 313 "/libmdbx/src/osal.c"
             ;

  do { if ((0)) do { if (__builtin_expect(!!(!(actual == needed)), 0)) mdbx_assert_fail(
# 315 "/libmdbx/src/osal.c" 3 4
 ((void *)0)
# 315 "/libmdbx/src/osal.c"
 , "actual == needed", __func__, 315); } while (0); } while (0);
  if (__builtin_expect(!!(actual < 0), 0)) {
    free(*strp);
    *strp = 
# 318 "/libmdbx/src/osal.c" 3 4
           ((void *)0)
# 318 "/libmdbx/src/osal.c"
                  ;
  }
  return actual;
}



static int mdbx_asprintf(char **strp, const char *fmt, ...) {
  va_list ap;
  
# 327 "/libmdbx/src/osal.c" 3 4
 __builtin_va_start(
# 327 "/libmdbx/src/osal.c"
 ap
# 327 "/libmdbx/src/osal.c" 3 4
 ,
# 327 "/libmdbx/src/osal.c"
 fmt
# 327 "/libmdbx/src/osal.c" 3 4
 )
# 327 "/libmdbx/src/osal.c"
                  ;
  int rc = mdbx_vasprintf(strp, fmt, ap);
  
# 329 "/libmdbx/src/osal.c" 3 4
 __builtin_va_end(
# 329 "/libmdbx/src/osal.c"
 ap
# 329 "/libmdbx/src/osal.c" 3 4
 )
# 329 "/libmdbx/src/osal.c"
           ;
  return rc;
}



static int mdbx_memalign_alloc(size_t alignment, size_t bytes,
                                           void **result) {
  do { if ((0)) do { if (__builtin_expect(!!(!(is_powerof2(alignment) && alignment >= sizeof(void *))), 0)) mdbx_assert_fail(
# 337 "/libmdbx/src/osal.c" 3 4
 ((void *)0)
# 337 "/libmdbx/src/osal.c"
 , "is_powerof2(alignment) && alignment >= sizeof(void *)", __func__, 337); } while (0); } while (0);





  *result = aligned_alloc(alignment, ceil_powerof2(bytes, alignment));
  return *result ? MDBX_SUCCESS : 
# 344 "/libmdbx/src/osal.c" 3 4
                                 (*__errno_location ())
# 344 "/libmdbx/src/osal.c"
                                      ;
# 355 "/libmdbx/src/osal.c"
}



static void mdbx_memalign_free(void *ptr) {



  free(ptr);

}
# 382 "/libmdbx/src/osal.c"
static int mdbx_condpair_init(mdbx_condpair_t *condpair) {
  int rc;
  memset(condpair, 0, sizeof(mdbx_condpair_t));
# 402 "/libmdbx/src/osal.c"
  rc = pthread_mutex_init(&condpair->mutex, 
# 402 "/libmdbx/src/osal.c" 3 4
                                           ((void *)0)
# 402 "/libmdbx/src/osal.c"
                                               );
  if (__builtin_expect(!!(rc != 0), 0))
    goto bailout_mutex;
  rc = pthread_cond_init(&condpair->cond[0], 
# 405 "/libmdbx/src/osal.c" 3 4
                                            ((void *)0)
# 405 "/libmdbx/src/osal.c"
                                                );
  if (__builtin_expect(!!(rc != 0), 0))
    goto bailout_cond;
  rc = pthread_cond_init(&condpair->cond[1], 
# 408 "/libmdbx/src/osal.c" 3 4
                                            ((void *)0)
# 408 "/libmdbx/src/osal.c"
                                                );
  if (__builtin_expect(!!(rc == 0), 1))
    return MDBX_SUCCESS;

  (void)pthread_cond_destroy(&condpair->cond[0]);
bailout_cond:
  (void)pthread_mutex_destroy(&condpair->mutex);

bailout_mutex:
  memset(condpair, 0, sizeof(mdbx_condpair_t));
  return rc;
}

static int mdbx_condpair_destroy(mdbx_condpair_t *condpair) {





  int err, rc = pthread_mutex_destroy(&condpair->mutex);
  rc = (err = pthread_cond_destroy(&condpair->cond[0])) ? err : rc;
  rc = (err = pthread_cond_destroy(&condpair->cond[1])) ? err : rc;

  memset(condpair, 0, sizeof(mdbx_condpair_t));
  return rc;
}

static int mdbx_condpair_lock(mdbx_condpair_t *condpair) {




  return pthread_mutex_lock(&condpair->mutex);

}

static int mdbx_condpair_unlock(mdbx_condpair_t *condpair) {



  return pthread_mutex_unlock(&condpair->mutex);

}

static int mdbx_condpair_signal(mdbx_condpair_t *condpair,
                                            _Bool part) {



  return pthread_cond_signal(&condpair->cond[part]);

}

static int mdbx_condpair_wait(mdbx_condpair_t *condpair,
                                          _Bool part) {
# 473 "/libmdbx/src/osal.c"
  return pthread_cond_wait(&condpair->cond[part], &condpair->mutex);

}



static int mdbx_fastmutex_init(mdbx_fastmutex_t *fastmutex) {




  return pthread_mutex_init(fastmutex, 
# 484 "/libmdbx/src/osal.c" 3 4
                                      ((void *)0)
# 484 "/libmdbx/src/osal.c"
                                          );

}

static int mdbx_fastmutex_destroy(mdbx_fastmutex_t *fastmutex) {




  return pthread_mutex_destroy(fastmutex);

}

static int mdbx_fastmutex_acquire(mdbx_fastmutex_t *fastmutex) {
# 510 "/libmdbx/src/osal.c"
  return pthread_mutex_lock(fastmutex);

}

static int mdbx_fastmutex_release(mdbx_fastmutex_t *fastmutex) {




  return pthread_mutex_unlock(fastmutex);

}



static int mdbx_removefile(const char *pathname) {
# 535 "/libmdbx/src/osal.c"
  return unlink(pathname) ? 
# 535 "/libmdbx/src/osal.c" 3 4
                           (*__errno_location ()) 
# 535 "/libmdbx/src/osal.c"
                                 : MDBX_SUCCESS;

}


static _Bool is_valid_fd(int fd) { return !(isatty(fd) < 0 && 
# 540 "/libmdbx/src/osal.c" 3 4
                                                            (*__errno_location ()) 
# 540 "/libmdbx/src/osal.c"
                                                                  == 
# 540 "/libmdbx/src/osal.c" 3 4
                                                                     9
# 540 "/libmdbx/src/osal.c"
                                                                          ); }


static int mdbx_removedirectory(const char *pathname) {
# 553 "/libmdbx/src/osal.c"
  return rmdir(pathname) ? 
# 553 "/libmdbx/src/osal.c" 3 4
                          (*__errno_location ()) 
# 553 "/libmdbx/src/osal.c"
                                : MDBX_SUCCESS;

}

static int mdbx_openfile(const enum mdbx_openfile_purpose purpose,
                                     const MDBX_env *env, const char *pathname,
                                     mdbx_filehandle_t *fd,
                                     mdbx_mode_t unix_mode_bits) {
  *fd = (-1);
# 635 "/libmdbx/src/osal.c"
  int flags = unix_mode_bits ? 
# 635 "/libmdbx/src/osal.c" 3 4
                              0100 
# 635 "/libmdbx/src/osal.c"
                                      : 0;
  switch (purpose) {
  default:
    return 
# 638 "/libmdbx/src/osal.c" 3 4
          22
# 638 "/libmdbx/src/osal.c"
                ;
  case MDBX_OPEN_LCK:
    flags |= 
# 640 "/libmdbx/src/osal.c" 3 4
            02
# 640 "/libmdbx/src/osal.c"
                  ;
    break;
  case MDBX_OPEN_DXB_READ:
    flags = 
# 643 "/libmdbx/src/osal.c" 3 4
           00
# 643 "/libmdbx/src/osal.c"
                   ;
    break;
  case MDBX_OPEN_DXB_LAZY:
    flags |= 
# 646 "/libmdbx/src/osal.c" 3 4
            02
# 646 "/libmdbx/src/osal.c"
                  ;
    break;
  case MDBX_OPEN_COPY:
    flags = 
# 649 "/libmdbx/src/osal.c" 3 4
           0100 
# 649 "/libmdbx/src/osal.c"
                   | 
# 649 "/libmdbx/src/osal.c" 3 4
                     01 
# 649 "/libmdbx/src/osal.c"
                              | 
# 649 "/libmdbx/src/osal.c" 3 4
                                0200
# 649 "/libmdbx/src/osal.c"
                                      ;
    break;
  case MDBX_OPEN_DXB_DSYNC:
    flags |= 
# 652 "/libmdbx/src/osal.c" 3 4
            01
# 652 "/libmdbx/src/osal.c"
                    ;

    flags |= 
# 654 "/libmdbx/src/osal.c" 3 4
            010000
# 654 "/libmdbx/src/osal.c"
                   ;





    break;
  case MDBX_OPEN_DELETE:
    flags = 
# 662 "/libmdbx/src/osal.c" 3 4
           02
# 662 "/libmdbx/src/osal.c"
                 ;
    break;
  }

  const _Bool direct_nocache_for_copy =
      env->me_psize >= env->me_os_psize && purpose == MDBX_OPEN_COPY;
  if (direct_nocache_for_copy) {

    flags |= 
# 670 "/libmdbx/src/osal.c" 3 4
            0200000
# 670 "/libmdbx/src/osal.c"
                    ;




  }


  flags |= 
# 678 "/libmdbx/src/osal.c" 3 4
          02000000
# 678 "/libmdbx/src/osal.c"
                   ;




  int stub_fd0 = -1, stub_fd1 = -1, stub_fd2 = -1;
  static const char dev_null[] = "/dev/null";
  if (!is_valid_fd(
# 685 "/libmdbx/src/osal.c" 3 4
                  0
# 685 "/libmdbx/src/osal.c"
                              )) {
    do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 686, "STD%s_FILENO/%d is invalid, open %s for temporary stub" "\n", "IN", 
# 686 "/libmdbx/src/osal.c" 3 4
   0
# 686 "/libmdbx/src/osal.c"
   , dev_null); } while (0)
                                        ;
    stub_fd0 = open(dev_null, 
# 688 "/libmdbx/src/osal.c" 3 4
                             00 
# 688 "/libmdbx/src/osal.c"
                                      | 
# 688 "/libmdbx/src/osal.c" 3 4
                                        0400
# 688 "/libmdbx/src/osal.c"
                                                );
  }
  if (!is_valid_fd(
# 690 "/libmdbx/src/osal.c" 3 4
                  1
# 690 "/libmdbx/src/osal.c"
                               )) {
    do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 691, "STD%s_FILENO/%d is invalid, open %s for temporary stub" "\n", "OUT", 
# 691 "/libmdbx/src/osal.c" 3 4
   1
# 691 "/libmdbx/src/osal.c"
   , dev_null); } while (0)
                                                ;
    stub_fd1 = open(dev_null, 
# 693 "/libmdbx/src/osal.c" 3 4
                             01 
# 693 "/libmdbx/src/osal.c"
                                      | 
# 693 "/libmdbx/src/osal.c" 3 4
                                        0400
# 693 "/libmdbx/src/osal.c"
                                                );
  }
  if (!is_valid_fd(
# 695 "/libmdbx/src/osal.c" 3 4
                  2
# 695 "/libmdbx/src/osal.c"
                               )) {
    do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 696, "STD%s_FILENO/%d is invalid, open %s for temporary stub" "\n", "ERR", 
# 696 "/libmdbx/src/osal.c" 3 4
   2
# 696 "/libmdbx/src/osal.c"
   , dev_null); } while (0)
                                                ;
    stub_fd2 = open(dev_null, 
# 698 "/libmdbx/src/osal.c" 3 4
                             01 
# 698 "/libmdbx/src/osal.c"
                                      | 
# 698 "/libmdbx/src/osal.c" 3 4
                                        0400
# 698 "/libmdbx/src/osal.c"
                                                );
  }




  *fd = open(pathname, flags, unix_mode_bits);

  if (*fd < 0 && (flags & 
# 706 "/libmdbx/src/osal.c" 3 4
                         0200000
# 706 "/libmdbx/src/osal.c"
                                 ) &&
      (
# 707 "/libmdbx/src/osal.c" 3 4
      (*__errno_location ()) 
# 707 "/libmdbx/src/osal.c"
            == 
# 707 "/libmdbx/src/osal.c" 3 4
               22 
# 707 "/libmdbx/src/osal.c"
                      || 
# 707 "/libmdbx/src/osal.c" 3 4
                         (*__errno_location ()) 
# 707 "/libmdbx/src/osal.c"
                               == 
# 707 "/libmdbx/src/osal.c" 3 4
                                  97
# 707 "/libmdbx/src/osal.c"
                                              )) {
    flags &= ~(
# 708 "/libmdbx/src/osal.c" 3 4
              0200000 
# 708 "/libmdbx/src/osal.c"
                       | 
# 708 "/libmdbx/src/osal.c" 3 4
                         0200
# 708 "/libmdbx/src/osal.c"
                               );
    *fd = open(pathname, flags, unix_mode_bits);
  }




  if (*fd == 
# 715 "/libmdbx/src/osal.c" 3 4
            0
# 715 "/libmdbx/src/osal.c"
                        ) {
    do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 716, "Got STD%s_FILENO/%d, avoid using it by dup(fd)" "\n", "IN", 
# 716 "/libmdbx/src/osal.c" 3 4
   0
# 716 "/libmdbx/src/osal.c"
   ); } while (0)
                              ;
    do { if ((0)) do { if (__builtin_expect(!!(!(stub_fd0 == -1)), 0)) mdbx_assert_fail(
# 718 "/libmdbx/src/osal.c" 3 4
   ((void *)0)
# 718 "/libmdbx/src/osal.c"
   , "stub_fd0 == -1", __func__, 718); } while (0); } while (0);
    *fd = dup(stub_fd0 = *fd);
  }
  if (*fd == 
# 721 "/libmdbx/src/osal.c" 3 4
            1
# 721 "/libmdbx/src/osal.c"
                         ) {
    do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 722, "Got STD%s_FILENO/%d, avoid using it by dup(fd)" "\n", "OUT", 
# 722 "/libmdbx/src/osal.c" 3 4
   1
# 722 "/libmdbx/src/osal.c"
   ); } while (0)
                               ;
    do { if ((0)) do { if (__builtin_expect(!!(!(stub_fd1 == -1)), 0)) mdbx_assert_fail(
# 724 "/libmdbx/src/osal.c" 3 4
   ((void *)0)
# 724 "/libmdbx/src/osal.c"
   , "stub_fd1 == -1", __func__, 724); } while (0); } while (0);
    *fd = dup(stub_fd1 = *fd);
  }
  if (*fd == 
# 727 "/libmdbx/src/osal.c" 3 4
            2
# 727 "/libmdbx/src/osal.c"
                         ) {
    do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 728, "Got STD%s_FILENO/%d, avoid using it by dup(fd)" "\n", "ERR", 
# 728 "/libmdbx/src/osal.c" 3 4
   2
# 728 "/libmdbx/src/osal.c"
   ); } while (0)
                               ;
    do { if ((0)) do { if (__builtin_expect(!!(!(stub_fd2 == -1)), 0)) mdbx_assert_fail(
# 730 "/libmdbx/src/osal.c" 3 4
   ((void *)0)
# 730 "/libmdbx/src/osal.c"
   , "stub_fd2 == -1", __func__, 730); } while (0); } while (0);
    *fd = dup(stub_fd2 = *fd);
  }
  if (stub_fd0 != -1)
    close(stub_fd0);
  if (stub_fd1 != -1)
    close(stub_fd1);
  if (stub_fd2 != -1)
    close(stub_fd2);
  if (*fd >= 
# 739 "/libmdbx/src/osal.c" 3 4
            0 
# 739 "/libmdbx/src/osal.c"
                         && *fd <= 
# 739 "/libmdbx/src/osal.c" 3 4
                                   2
# 739 "/libmdbx/src/osal.c"
                                                ) {
    do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 740, "Rejecting the use of a FD in the range " "STDIN_FILENO/%d..STDERR_FILENO/%d to prevent database corruption" "\n", 
# 740 "/libmdbx/src/osal.c" 3 4
   0
# 740 "/libmdbx/src/osal.c"
   , 
# 740 "/libmdbx/src/osal.c" 3 4
   2
# 740 "/libmdbx/src/osal.c"
   ); } while (0)


                                    ;
    close(*fd);
    return 
# 745 "/libmdbx/src/osal.c" 3 4
          9
# 745 "/libmdbx/src/osal.c"
               ;
  }




  if (*fd < 0)
    return 
# 752 "/libmdbx/src/osal.c" 3 4
          (*__errno_location ())
# 752 "/libmdbx/src/osal.c"
               ;







  if (direct_nocache_for_copy) {



  }


  return MDBX_SUCCESS;
}

static int mdbx_closefile(mdbx_filehandle_t fd) {



  do { if ((0)) do { if (__builtin_expect(!!(!(fd > 
# 774 "/libmdbx/src/osal.c" 3 4
 2
# 774 "/libmdbx/src/osal.c"
 )), 0)) mdbx_assert_fail(
# 774 "/libmdbx/src/osal.c" 3 4
 ((void *)0)
# 774 "/libmdbx/src/osal.c"
 , "fd > 2", __func__, 774); } while (0); } while (0);
  return (close(fd) == 0) ? MDBX_SUCCESS : 
# 775 "/libmdbx/src/osal.c" 3 4
                                          (*__errno_location ())
# 775 "/libmdbx/src/osal.c"
                                               ;

}

static int mdbx_pread(mdbx_filehandle_t fd, void *buf, size_t bytes,
                                  uint64_t offset) {
  if (bytes > 0x3fff0000U)
    return MDBX_EINVAL;
# 795 "/libmdbx/src/osal.c"
  _Static_assert(sizeof(off_t) >= sizeof(size_t), "libmdbx requires 64-bit file I/O on 64-bit systems")
                                                                         ;
  intptr_t read = pread(fd, buf, bytes, offset);
  if (read < 0) {
    int rc = 
# 799 "/libmdbx/src/osal.c" 3 4
            (*__errno_location ())
# 799 "/libmdbx/src/osal.c"
                 ;
    return (rc == MDBX_SUCCESS) ? MDBX_EIO : rc;
  }

  return (bytes == (size_t)read) ? MDBX_SUCCESS : MDBX_ENODATA;
}

static int mdbx_pwrite(mdbx_filehandle_t fd, const void *buf,
                                   size_t bytes, uint64_t offset) {
  while ((1)) {
# 823 "/libmdbx/src/osal.c"
    _Static_assert(sizeof(off_t) >= sizeof(size_t), "libmdbx requires 64-bit file I/O on 64-bit systems")
                                                                           ;
    const intptr_t written =
        pwrite(fd, buf, __builtin_expect(!!(bytes <= 0x3fff0000U), 1) ? bytes : 0x3fff0000U, offset);
    if (__builtin_expect(!!(bytes == (size_t)written), 1))
      return MDBX_SUCCESS;
    if (written < 0) {
      const int rc = 
# 830 "/libmdbx/src/osal.c" 3 4
                    (*__errno_location ())
# 830 "/libmdbx/src/osal.c"
                         ;
      if (rc != 
# 831 "/libmdbx/src/osal.c" 3 4
               4
# 831 "/libmdbx/src/osal.c"
                    )
        return rc;
      continue;
    }

    bytes -= written;
    offset += written;
    buf = (char *)buf + written;
  }
}

static int mdbx_write(mdbx_filehandle_t fd, const void *buf,
                                  size_t bytes) {
  while ((1)) {
# 854 "/libmdbx/src/osal.c"
    _Static_assert(sizeof(off_t) >= sizeof(size_t), "libmdbx requires 64-bit file I/O on 64-bit systems")
                                                                           ;
    const intptr_t written =
        write(fd, buf, __builtin_expect(!!(bytes <= 0x3fff0000U), 1) ? bytes : 0x3fff0000U);
    if (__builtin_expect(!!(bytes == (size_t)written), 1))
      return MDBX_SUCCESS;
    if (written < 0) {
      const int rc = 
# 861 "/libmdbx/src/osal.c" 3 4
                    (*__errno_location ())
# 861 "/libmdbx/src/osal.c"
                         ;
      if (rc != 
# 862 "/libmdbx/src/osal.c" 3 4
               4
# 862 "/libmdbx/src/osal.c"
                    )
        return rc;
      continue;
    }

    bytes -= written;
    buf = (char *)buf + written;
  }
}

int mdbx_pwritev(mdbx_filehandle_t fd, struct iovec *iov, int iovcnt,
                 uint64_t offset, size_t expected_written) {
# 887 "/libmdbx/src/osal.c"
  int rc;
  intptr_t written;
  do {
    _Static_assert(sizeof(off_t) >= sizeof(size_t), "libmdbx requires 64-bit file I/O on 64-bit systems")
                                                                           ;
    written = pwritev(fd, iov, iovcnt, offset);
    if (__builtin_expect(!!(expected_written == (size_t)written), 1))
      return MDBX_SUCCESS;
    rc = 
# 895 "/libmdbx/src/osal.c" 3 4
        (*__errno_location ())
# 895 "/libmdbx/src/osal.c"
             ;
  } while (rc == 
# 896 "/libmdbx/src/osal.c" 3 4
                4
# 896 "/libmdbx/src/osal.c"
                     );
  return (written < 0) ? rc : MDBX_EIO ;

}

static int mdbx_fsync(mdbx_filehandle_t fd,
                                  enum mdbx_syncmode_bits mode_bits) {
# 920 "/libmdbx/src/osal.c"
  while (1) {
    switch (mode_bits & (MDBX_SYNC_DATA | MDBX_SYNC_SIZE)) {
    case MDBX_SYNC_NONE:
      return MDBX_SUCCESS ;

    case MDBX_SYNC_DATA:
      if (fdatasync(fd) == 0)
        return MDBX_SUCCESS;
      break ;

    case MDBX_SYNC_SIZE:
      if (mdbx_linux_kernel_version >= 0x03060000)
        return MDBX_SUCCESS;
      __attribute__((__fallthrough__)) ;


    default:
      if (fsync(fd) == 0)
        return MDBX_SUCCESS;
    }

    int rc = 
# 941 "/libmdbx/src/osal.c" 3 4
            (*__errno_location ())
# 941 "/libmdbx/src/osal.c"
                 ;
    if (rc != 
# 942 "/libmdbx/src/osal.c" 3 4
             4
# 942 "/libmdbx/src/osal.c"
                  )
      return rc;
  }

}

int mdbx_filesize(mdbx_filehandle_t fd, uint64_t *length) {






  struct stat st;

  _Static_assert(sizeof(off_t) <= sizeof(uint64_t), "libmdbx requires 64-bit file I/O on 64-bit systems")
                                                                         ;
  if (fstat(fd, &st))
    return 
# 960 "/libmdbx/src/osal.c" 3 4
          (*__errno_location ())
# 960 "/libmdbx/src/osal.c"
               ;

  *length = st.st_size;

  return MDBX_SUCCESS;
}

static int mdbx_is_pipe(mdbx_filehandle_t fd) {
# 979 "/libmdbx/src/osal.c"
  struct stat info;
  if (fstat(fd, &info))
    return 
# 981 "/libmdbx/src/osal.c" 3 4
          (*__errno_location ())
# 981 "/libmdbx/src/osal.c"
               ;
  switch (info.st_mode & 
# 982 "/libmdbx/src/osal.c" 3 4
                        0170000
# 982 "/libmdbx/src/osal.c"
                              ) {
  case 
# 983 "/libmdbx/src/osal.c" 3 4
      0060000
# 983 "/libmdbx/src/osal.c"
             :
  case 
# 984 "/libmdbx/src/osal.c" 3 4
      0100000
# 984 "/libmdbx/src/osal.c"
             :
    return MDBX_RESULT_FALSE;
  case 
# 986 "/libmdbx/src/osal.c" 3 4
      0020000
# 986 "/libmdbx/src/osal.c"
             :
  case 
# 987 "/libmdbx/src/osal.c" 3 4
      0010000
# 987 "/libmdbx/src/osal.c"
             :
  case 
# 988 "/libmdbx/src/osal.c" 3 4
      0140000
# 988 "/libmdbx/src/osal.c"
              :
    return MDBX_RESULT_TRUE;
  case 
# 990 "/libmdbx/src/osal.c" 3 4
      0040000
# 990 "/libmdbx/src/osal.c"
             :
  case 
# 991 "/libmdbx/src/osal.c" 3 4
      0120000
# 991 "/libmdbx/src/osal.c"
             :
  default:
    return MDBX_INCOMPATIBLE;
  }

}

static int mdbx_ftruncate(mdbx_filehandle_t fd, uint64_t length) {
# 1016 "/libmdbx/src/osal.c"
  _Static_assert(sizeof(off_t) >= sizeof(size_t), "libmdbx requires 64-bit file I/O on 64-bit systems")
                                                                         ;
  return ftruncate(fd, length) == 0 ? MDBX_SUCCESS : 
# 1018 "/libmdbx/src/osal.c" 3 4
                                                    (*__errno_location ())
# 1018 "/libmdbx/src/osal.c"
                                                         ;

}

static int mdbx_fseek(mdbx_filehandle_t fd, uint64_t pos) {






  _Static_assert(sizeof(off_t) >= sizeof(size_t), "libmdbx requires 64-bit file I/O on 64-bit systems")
                                                                         ;
  return (lseek(fd, pos, 
# 1031 "/libmdbx/src/osal.c" 3 4
                        0
# 1031 "/libmdbx/src/osal.c"
                                ) < 0) ? 
# 1031 "/libmdbx/src/osal.c" 3 4
                                         (*__errno_location ()) 
# 1031 "/libmdbx/src/osal.c"
                                               : MDBX_SUCCESS;

}



static int
mdbx_thread_create(mdbx_thread_t *thread,
                   void *( *start_routine)(void *),
                   void *arg) {




  return pthread_create(thread, 
# 1045 "/libmdbx/src/osal.c" 3 4
                               ((void *)0)
# 1045 "/libmdbx/src/osal.c"
                                   , start_routine, arg);

}

static int mdbx_thread_join(mdbx_thread_t thread) {




  void *unused_retval = &unused_retval;
  return pthread_join(thread, &unused_retval);

}



static int mdbx_msync(mdbx_mmap_t *map, size_t offset,
                                  size_t length,
                                  enum mdbx_syncmode_bits mode_bits) {
  uint8_t *ptr = (uint8_t *)map->address + offset;





  if (mode_bits == MDBX_SYNC_NONE && mdbx_linux_kernel_version > 0x02061300)


    return MDBX_SUCCESS;

  if (msync(ptr, length, (mode_bits & MDBX_SYNC_DATA) ? 
# 1075 "/libmdbx/src/osal.c" 3 4
                                                       4 
# 1075 "/libmdbx/src/osal.c"
                                                               : 
# 1075 "/libmdbx/src/osal.c" 3 4
                                                                 1
# 1075 "/libmdbx/src/osal.c"
                                                                         ))
    return 
# 1076 "/libmdbx/src/osal.c" 3 4
          (*__errno_location ())
# 1076 "/libmdbx/src/osal.c"
               ;
  mode_bits &= ~MDBX_SYNC_DATA;

  return mdbx_fsync(map->fd, mode_bits);
}

static int mdbx_check_fs_rdonly(mdbx_filehandle_t handle,
                                            const char *pathname, int err) {
# 1096 "/libmdbx/src/osal.c"
  struct statvfs info;
  if (err != MDBX_ENOFILE) {
    if (statvfs(pathname, &info))
      return 
# 1099 "/libmdbx/src/osal.c" 3 4
            (*__errno_location ())
# 1099 "/libmdbx/src/osal.c"
                 ;
    if ((info.f_flag & 
# 1100 "/libmdbx/src/osal.c" 3 4
                      ST_RDONLY
# 1100 "/libmdbx/src/osal.c"
                               ) == 0)
      return err;
  }
  if (fstatvfs(handle, &info))
    return 
# 1104 "/libmdbx/src/osal.c" 3 4
          (*__errno_location ())
# 1104 "/libmdbx/src/osal.c"
               ;
  if ((info.f_flag & 
# 1105 "/libmdbx/src/osal.c" 3 4
                    ST_RDONLY
# 1105 "/libmdbx/src/osal.c"
                             ) == 0)
    return (err == MDBX_ENOFILE) ? MDBX_EACCESS : err;

  return MDBX_SUCCESS;
}

static int mdbx_check_fs_local(mdbx_filehandle_t handle, int flags) {
# 1227 "/libmdbx/src/osal.c"
  struct statvfs statvfs_info;
  if (fstatvfs(handle, &statvfs_info))
    return 
# 1229 "/libmdbx/src/osal.c" 3 4
          (*__errno_location ())
# 1229 "/libmdbx/src/osal.c"
               ;
# 1260 "/libmdbx/src/osal.c"
  struct statfs statfs_info;
  if (fstatfs(handle, &statfs_info))
    return 
# 1262 "/libmdbx/src/osal.c" 3 4
          (*__errno_location ())
# 1262 "/libmdbx/src/osal.c"
               ;



  const unsigned type = statfs_info.f_type;
# 1282 "/libmdbx/src/osal.c"
  const char *name = "";
  unsigned name_len = 0;

  struct stat st;
  if (fstat(handle, &st))
    return 
# 1287 "/libmdbx/src/osal.c" 3 4
          (*__errno_location ())
# 1287 "/libmdbx/src/osal.c"
               ;

  char pathbuf[
# 1289 "/libmdbx/src/osal.c" 3 4
              4096
# 1289 "/libmdbx/src/osal.c"
                      ];
  FILE *mounted = 
# 1290 "/libmdbx/src/osal.c" 3 4
                 ((void *)0)
# 1290 "/libmdbx/src/osal.c"
                        ;

  mounted = setmntent("/proc/mounts", "r");

  if (!mounted)
    mounted = setmntent("/etc/mtab", "r");
  if (mounted) {
    const struct mntent *ent;


    struct mntent entbuf;
    const _Bool should_copy = (0);
    while (
# 1302 "/libmdbx/src/osal.c" 3 4
          ((void *)0) 
# 1302 "/libmdbx/src/osal.c"
                  !=
           (ent = getmntent_r(mounted, &entbuf, pathbuf, sizeof(pathbuf))))




    {
      struct stat mnt;
      if (!stat(ent->mnt_dir, &mnt) && mnt.st_dev == st.st_dev) {
        if (should_copy) {
          name =
              strncpy(pathbuf, ent->mnt_fsname, name_len = sizeof(pathbuf) - 1);
          pathbuf[name_len] = 0;
        } else {
          name = ent->mnt_fsname;
          name_len = strlen(name);
        }
        break;
      }
    }
    endmntent(mounted);
  }



  if (name_len) {
    if (((name_len > 2 && strncasecmp("nfs", name, 3) == 0) ||
         strncasecmp("cifs", name, name_len) == 0 ||
         strncasecmp("ncpfs", name, name_len) == 0 ||
         strncasecmp("smbfs", name, name_len) == 0 ||
         strcasecmp("9P" , name) == 0 ||
         ((name_len > 3 && strncasecmp("fuse", name, 4) == 0) &&
          strncasecmp("fuseblk", name, name_len) != 0)) &&
        !(flags & MDBX_EXCLUSIVE))
      return MDBX_EREMOTE;
    if (strcasecmp("ftp", name) == 0 || strcasecmp("http", name) == 0 ||
        strcasecmp("sshfs", name) == 0)
      return MDBX_EREMOTE;
  }
# 1358 "/libmdbx/src/osal.c"
  switch (type) {
  case 0xFF534D42 :
  case 0x6969 :
  case 0x564c :
  case 0x517B :






    if ((flags & MDBX_EXCLUSIVE) == 0)
      return MDBX_EREMOTE;
  case 0:
  default:
    break;
  }


  return MDBX_SUCCESS;
}

static int check_mmap_limit(const size_t limit) {
  const _Bool should_check =



      (0);


  if (should_check) {
    intptr_t pagesize, total_ram_pages, avail_ram_pages;
    int err =
        mdbx_get_sysraminfo(&pagesize, &total_ram_pages, &avail_ram_pages);
    if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
      return err;

    const int log2page = log2n_powerof2(pagesize);
    if ((limit >> (log2page + 7)) > (size_t)total_ram_pages ||
        (limit >> (log2page + 6)) > (size_t)avail_ram_pages) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 1398, "%s (%zu pages) is too large for available (%zu pages) or total " "(%zu pages) system RAM" "\n", "database upper size limit", limit >> log2page, avail_ram_pages, total_ram_pages); } while (0)



                          ;
      return MDBX_TOO_LARGE;
    }
  }

  return MDBX_SUCCESS;
}

static int mdbx_mmap(const int flags, mdbx_mmap_t *map,
                                 const size_t size, const size_t limit,
                                 const unsigned options) {
  do { if ((0)) do { if (__builtin_expect(!!(!(size <= limit)), 0)) mdbx_assert_fail(
# 1413 "/libmdbx/src/osal.c" 3 4
 ((void *)0)
# 1413 "/libmdbx/src/osal.c"
 , "size <= limit", __func__, 1413); } while (0); } while (0);
  map->limit = 0;
  map->current = 0;
  map->address = 
# 1416 "/libmdbx/src/osal.c" 3 4
                ((void *)0)
# 1416 "/libmdbx/src/osal.c"
                       ;
  map->filesize = 0;




  int err = mdbx_check_fs_local(map->fd, flags);
  if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
    return err;

  err = check_mmap_limit(limit);
  if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
    return err;

  if ((flags & MDBX_RDONLY) == 0 && (options & 1) != 0) {
    err = mdbx_ftruncate(map->fd, size);
    if (err != MDBX_SUCCESS)
      return err;
    map->filesize = size;

    map->current = size;

  } else {
    err = mdbx_filesize(map->fd, &map->filesize);
    if (err != MDBX_SUCCESS)
      return err;

    map->current = (map->filesize > limit) ? limit : (size_t)map->filesize;

  }
# 1513 "/libmdbx/src/osal.c"
  map->address = mmap(
      
# 1514 "/libmdbx/src/osal.c" 3 4
     ((void *)0)
# 1514 "/libmdbx/src/osal.c"
         , limit, (flags & MDBX_WRITEMAP) ? 
# 1514 "/libmdbx/src/osal.c" 3 4
                                            0x1 
# 1514 "/libmdbx/src/osal.c"
                                                      | 
# 1514 "/libmdbx/src/osal.c" 3 4
                                                        0x2 
# 1514 "/libmdbx/src/osal.c"
                                                                   : 
# 1514 "/libmdbx/src/osal.c" 3 4
                                                                     0x1
# 1514 "/libmdbx/src/osal.c"
                                                                              ,
      
# 1515 "/libmdbx/src/osal.c" 3 4
     0x01 
# 1515 "/libmdbx/src/osal.c"
                | 
# 1515 "/libmdbx/src/osal.c" 3 4
                  0 
# 1515 "/libmdbx/src/osal.c"
                           | 
# 1515 "/libmdbx/src/osal.c" 3 4
                             0x04000 
# 1515 "/libmdbx/src/osal.c"
                                           |
          ((((flags) & (MDBX_UTTERLY_NOSYNC)) == (MDBX_UTTERLY_NOSYNC)) ? 0 : 0) |
          ((options & 2) ? 0 | 0
                                             : 0),
      map->fd, 0);

  if (__builtin_expect(!!(map->address == 
# 1521 "/libmdbx/src/osal.c" 3 4
     ((void *) -1)
# 1521 "/libmdbx/src/osal.c"
     ), 0)) {
    map->limit = 0;
    map->current = 0;
    map->address = 
# 1524 "/libmdbx/src/osal.c" 3 4
                  ((void *)0)
# 1524 "/libmdbx/src/osal.c"
                         ;
    return 
# 1525 "/libmdbx/src/osal.c" 3 4
          (*__errno_location ())
# 1525 "/libmdbx/src/osal.c"
               ;
  }
  map->limit = limit;



  if (__builtin_expect(!!(madvise(map->address, map->limit, 
# 1531 "/libmdbx/src/osal.c" 3 4
     10
# 1531 "/libmdbx/src/osal.c"
     ) != 0), 0))
    return 
# 1532 "/libmdbx/src/osal.c" 3 4
          (*__errno_location ())
# 1532 "/libmdbx/src/osal.c"
               ;


  (void)madvise(map->address, map->limit, 
# 1535 "/libmdbx/src/osal.c" 3 4
                                         15
# 1535 "/libmdbx/src/osal.c"
                                                        );





  ;
  do { do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 1542, "UNPOISON_MEMORY_REGION(%p, %zu) at %u" "\n", (void *)(map->address), (size_t)(map->current), 1542); } while (0); ((void)(map->address), (void)(map->current)); } while (0);
  return MDBX_SUCCESS;
}

static int mdbx_munmap(mdbx_mmap_t *map) {
  ;



  do { do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 1551, "UNPOISON_MEMORY_REGION(%p, %zu) at %u" "\n", (void *)(map->address), (size_t)((map->filesize && map->filesize < map->limit) ? map->filesize : map->limit), 1551); } while (0); ((void)(map->address), (void)((map->filesize && map->filesize < map->limit) ? map->filesize : map->limit)); } while (0)


                                                    ;







  if (__builtin_expect(!!(munmap(map->address, map->limit)), 0))
    return 
# 1563 "/libmdbx/src/osal.c" 3 4
          (*__errno_location ())
# 1563 "/libmdbx/src/osal.c"
               ;


  map->limit = 0;
  map->current = 0;
  map->address = 
# 1568 "/libmdbx/src/osal.c" 3 4
                ((void *)0)
# 1568 "/libmdbx/src/osal.c"
                       ;
  return MDBX_SUCCESS;
}

static int mdbx_mresize(const int flags, mdbx_mmap_t *map,
                                    size_t size, size_t limit) {
  do { if ((0)) do { if (__builtin_expect(!!(!(size <= limit)), 0)) mdbx_assert_fail(
# 1574 "/libmdbx/src/osal.c" 3 4
 ((void *)0)
# 1574 "/libmdbx/src/osal.c"
 , "size <= limit", __func__, 1574); } while (0); } while (0);
# 1748 "/libmdbx/src/osal.c"
  map->filesize = 0;
  int rc = mdbx_filesize(map->fd, &map->filesize);
  if (rc != MDBX_SUCCESS)
    return rc;

  if (flags & MDBX_RDONLY) {
    map->current = (map->filesize > limit) ? limit : (size_t)map->filesize;
    if (map->current != size)
      rc = (size > map->current) ? MDBX_UNABLE_EXTEND_MAPSIZE : MDBX_EPERM;
  } else {
    if (map->filesize != size) {
      rc = mdbx_ftruncate(map->fd, size);
      if (rc != MDBX_SUCCESS)
        return rc;
      map->filesize = size;
    }

    if (map->current > size) {






      do { do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 1772, "UNPOISON_MEMORY_REGION(%p, %zu) at %u" "\n", (void *)((char *)map->address + size), (size_t)(((map->current < map->limit) ? map->current : map->limit) - size), 1772); } while (0); ((void)((char *)map->address + size), (void)(((map->current < map->limit) ? map->current : map->limit) - size)); } while (0)

                                                                           ;
    }
    map->current = size;
  }

  if (limit == map->limit)
    return rc;

  if (limit < map->limit) {


    if (__builtin_expect(!!(munmap(map->dxb + limit, map->limit - limit)), 0))
      return 
# 1786 "/libmdbx/src/osal.c" 3 4
            (*__errno_location ())
# 1786 "/libmdbx/src/osal.c"
                 ;
    map->limit = limit;
    return rc;
  }

  int err = check_mmap_limit(limit);
  if (__builtin_expect(!!(err != MDBX_SUCCESS), 0))
    return err;

  do { if ((0)) do { if (__builtin_expect(!!(!(limit > map->limit)), 0)) mdbx_assert_fail(
# 1795 "/libmdbx/src/osal.c" 3 4
 ((void *)0)
# 1795 "/libmdbx/src/osal.c"
 , "limit > map->limit", __func__, 1795); } while (0); } while (0);
  uint8_t *ptr = 
# 1796 "/libmdbx/src/osal.c" 3 4
                ((void *) -1)
# 1796 "/libmdbx/src/osal.c"
                          ;


  ptr = mremap(map->address, map->limit, limit,
               (flags & 0x00000100) ? 
# 1800 "/libmdbx/src/osal.c" 3 4
                                                1 
# 1800 "/libmdbx/src/osal.c"
                                                               : 0);
  if (ptr == 
# 1801 "/libmdbx/src/osal.c" 3 4
            ((void *) -1)
# 1801 "/libmdbx/src/osal.c"
                      ) {
    err = 
# 1802 "/libmdbx/src/osal.c" 3 4
         (*__errno_location ())
# 1802 "/libmdbx/src/osal.c"
              ;
    switch (err) {
    default:
      return err;
    case 
# 1806 "/libmdbx/src/osal.c" 3 4
        11
# 1806 "/libmdbx/src/osal.c"
              :
    case 
# 1807 "/libmdbx/src/osal.c" 3 4
        12
# 1807 "/libmdbx/src/osal.c"
              :
      return MDBX_UNABLE_EXTEND_MAPSIZE;
    case 
# 1809 "/libmdbx/src/osal.c" 3 4
        14 
# 1809 "/libmdbx/src/osal.c"
                                                                         :
      break;
    }
  }


  const unsigned mmap_flags =
      0 | 
# 1816 "/libmdbx/src/osal.c" 3 4
                   0x01 
# 1816 "/libmdbx/src/osal.c"
                              | 
# 1816 "/libmdbx/src/osal.c" 3 4
                                0 
# 1816 "/libmdbx/src/osal.c"
                                         | 
# 1816 "/libmdbx/src/osal.c" 3 4
                                           0x04000 
# 1816 "/libmdbx/src/osal.c"
                                                         |
      ((((flags) & (MDBX_UTTERLY_NOSYNC)) == (MDBX_UTTERLY_NOSYNC)) ? 0 : 0);
  const unsigned mmap_prot =
      (flags & MDBX_WRITEMAP) ? 
# 1819 "/libmdbx/src/osal.c" 3 4
                               0x1 
# 1819 "/libmdbx/src/osal.c"
                                         | 
# 1819 "/libmdbx/src/osal.c" 3 4
                                           0x2 
# 1819 "/libmdbx/src/osal.c"
                                                      : 
# 1819 "/libmdbx/src/osal.c" 3 4
                                                        0x1
# 1819 "/libmdbx/src/osal.c"
                                                                 ;

  if (ptr == 
# 1821 "/libmdbx/src/osal.c" 3 4
            ((void *) -1)
# 1821 "/libmdbx/src/osal.c"
                      ) {

    ptr = mmap(map->dxb + map->limit, limit - map->limit, mmap_prot,
               mmap_flags | 
# 1824 "/libmdbx/src/osal.c" 3 4
                           0x100000
# 1824 "/libmdbx/src/osal.c"
                                              , map->fd, map->limit);
    if (ptr == map->dxb + map->limit)
      ptr = map->dxb;
    else if (ptr != 
# 1827 "/libmdbx/src/osal.c" 3 4
                   ((void *) -1)
# 1827 "/libmdbx/src/osal.c"
                             ) {

      if (__builtin_expect(!!(munmap(ptr, limit - map->limit)), 0))
        return 
# 1830 "/libmdbx/src/osal.c" 3 4
              (*__errno_location ())
# 1830 "/libmdbx/src/osal.c"
                   ;
      ptr = 
# 1831 "/libmdbx/src/osal.c" 3 4
           ((void *) -1)
# 1831 "/libmdbx/src/osal.c"
                     ;
    } else {
      err = 
# 1833 "/libmdbx/src/osal.c" 3 4
           (*__errno_location ())
# 1833 "/libmdbx/src/osal.c"
                ;
      switch (err) {
      default:
        return err;
      case 
# 1837 "/libmdbx/src/osal.c" 3 4
          11
# 1837 "/libmdbx/src/osal.c"
                :
      case 
# 1838 "/libmdbx/src/osal.c" 3 4
          12
# 1838 "/libmdbx/src/osal.c"
                :
        return MDBX_UNABLE_EXTEND_MAPSIZE;
      case 
# 1840 "/libmdbx/src/osal.c" 3 4
          17
# 1840 "/libmdbx/src/osal.c"
                :
      case 
# 1841 "/libmdbx/src/osal.c" 3 4
          22
# 1841 "/libmdbx/src/osal.c"
                :
        break;
      }
    }
  }

  if (ptr == 
# 1847 "/libmdbx/src/osal.c" 3 4
            ((void *) -1)
# 1847 "/libmdbx/src/osal.c"
                      ) {

    if ((flags & 0x00000200) == 0) {


      return MDBX_UNABLE_EXTEND_MAPSIZE;
    }

    if (__builtin_expect(!!(munmap(map->address, map->limit)), 0))
      return 
# 1856 "/libmdbx/src/osal.c" 3 4
            (*__errno_location ())
# 1856 "/libmdbx/src/osal.c"
                 ;


    ptr = mmap(map->address, limit, mmap_prot,
               (flags & 0x00000100)
                   ? mmap_flags
                   : mmap_flags | (
# 1862 "/libmdbx/src/osal.c" 3 4
                                  0x100000 
# 1862 "/libmdbx/src/osal.c"
                                                      ? 
# 1862 "/libmdbx/src/osal.c" 3 4
                                                        0x100000
                                                       
# 1863 "/libmdbx/src/osal.c"
                                                      : 
# 1863 "/libmdbx/src/osal.c" 3 4
                                                        0x10
# 1863 "/libmdbx/src/osal.c"
                                                                 ),
               map->fd, 0);
    if (
# 1865 "/libmdbx/src/osal.c" 3 4
       0x100000 
# 1865 "/libmdbx/src/osal.c"
                           != 0 && 
# 1865 "/libmdbx/src/osal.c" 3 4
                                   0x100000 
# 1865 "/libmdbx/src/osal.c"
                                                       != 
# 1865 "/libmdbx/src/osal.c" 3 4
                                                          0x10 
# 1865 "/libmdbx/src/osal.c"
                                                                    &&
        __builtin_expect(!!(ptr == 
# 1866 "/libmdbx/src/osal.c" 3 4
       ((void *) -1)
# 1866 "/libmdbx/src/osal.c"
       ), 0) && !(flags & 0x00000100) &&
        
# 1867 "/libmdbx/src/osal.c" 3 4
       (*__errno_location ()) 
# 1867 "/libmdbx/src/osal.c"
             == 
# 1867 "/libmdbx/src/osal.c" 3 4
                                                               22
# 1867 "/libmdbx/src/osal.c"
                                                                     )

      ptr = mmap(map->address, limit, mmap_prot, mmap_flags | 
# 1869 "/libmdbx/src/osal.c" 3 4
                                                             0x10
# 1869 "/libmdbx/src/osal.c"
                                                                      ,
                 map->fd, 0);

    if (__builtin_expect(!!(ptr == 
# 1872 "/libmdbx/src/osal.c" 3 4
       ((void *) -1)
# 1872 "/libmdbx/src/osal.c"
       ), 0)) {


      ptr = mmap(map->address, map->limit, mmap_prot,
                 (flags & 0x00000100)
                     ? mmap_flags
                     : mmap_flags | (
# 1878 "/libmdbx/src/osal.c" 3 4
                                    0x100000 
# 1878 "/libmdbx/src/osal.c"
                                                        ? 
# 1878 "/libmdbx/src/osal.c" 3 4
                                                          0x100000
                                                         
# 1879 "/libmdbx/src/osal.c"
                                                        : 
# 1879 "/libmdbx/src/osal.c" 3 4
                                                          0x10
# 1879 "/libmdbx/src/osal.c"
                                                                   ),
                 map->fd, 0);
      if (
# 1881 "/libmdbx/src/osal.c" 3 4
         0x100000 
# 1881 "/libmdbx/src/osal.c"
                             != 0 && 
# 1881 "/libmdbx/src/osal.c" 3 4
                                     0x100000 
# 1881 "/libmdbx/src/osal.c"
                                                         != 
# 1881 "/libmdbx/src/osal.c" 3 4
                                                            0x10 
# 1881 "/libmdbx/src/osal.c"
                                                                      &&
          __builtin_expect(!!(ptr == 
# 1882 "/libmdbx/src/osal.c" 3 4
         ((void *) -1)
# 1882 "/libmdbx/src/osal.c"
         ), 0) && !(flags & 0x00000100) &&
          
# 1883 "/libmdbx/src/osal.c" 3 4
         (*__errno_location ()) 
# 1883 "/libmdbx/src/osal.c"
               == 
# 1883 "/libmdbx/src/osal.c" 3 4
                                                                 22
# 1883 "/libmdbx/src/osal.c"
                                                                       )

        ptr = mmap(map->address, map->limit, mmap_prot, mmap_flags | 
# 1885 "/libmdbx/src/osal.c" 3 4
                                                                    0x10
# 1885 "/libmdbx/src/osal.c"
                                                                             ,
                   map->fd, 0);
      if (__builtin_expect(!!(ptr == 
# 1887 "/libmdbx/src/osal.c" 3 4
         ((void *) -1)
# 1887 "/libmdbx/src/osal.c"
         ), 0)) {
        ;




        do { do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 1893, "UNPOISON_MEMORY_REGION(%p, %zu) at %u" "\n", (void *)(map->address), (size_t)((map->current < map->limit) ? map->current : map->limit), 1893); } while (0); ((void)(map->address), (void)((map->current < map->limit) ? map->current : map->limit)); } while (0)

                                                                    ;
        map->limit = 0;
        map->current = 0;
        map->address = 
# 1898 "/libmdbx/src/osal.c" 3 4
                      ((void *)0)
# 1898 "/libmdbx/src/osal.c"
                             ;
        return 
# 1899 "/libmdbx/src/osal.c" 3 4
              (*__errno_location ())
# 1899 "/libmdbx/src/osal.c"
                   ;
      }
      rc = MDBX_UNABLE_EXTEND_MAPSIZE;
      limit = map->limit;
    }
  }

  do { if ((0)) do { if (__builtin_expect(!!(!(ptr && ptr != 
# 1906 "/libmdbx/src/osal.c" 3 4
 ((void *) -1)
# 1906 "/libmdbx/src/osal.c"
 )), 0)) mdbx_assert_fail(
# 1906 "/libmdbx/src/osal.c" 3 4
 ((void *)0)
# 1906 "/libmdbx/src/osal.c"
 , "ptr && ptr != ((void *) -1)", __func__, 1906); } while (0); } while (0);
  if (map->address != ptr) {
    ;



    do { do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 1912, "UNPOISON_MEMORY_REGION(%p, %zu) at %u" "\n", (void *)(map->address), (size_t)((map->current < map->limit) ? map->current : map->limit), 1912); } while (0); ((void)(map->address), (void)((map->current < map->limit) ? map->current : map->limit)); } while (0)
                                                                              ;

    ;
    do { do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 1916, "UNPOISON_MEMORY_REGION(%p, %zu) at %u" "\n", (void *)(ptr), (size_t)(map->current), 1916); } while (0); ((void)(ptr), (void)(map->current)); } while (0);
    map->address = ptr;
  }
  map->limit = limit;



  if (__builtin_expect(!!(madvise(map->address, map->limit, 
# 1923 "/libmdbx/src/osal.c" 3 4
     10
# 1923 "/libmdbx/src/osal.c"
     ) != 0), 0))
    return 
# 1924 "/libmdbx/src/osal.c" 3 4
          (*__errno_location ())
# 1924 "/libmdbx/src/osal.c"
               ;


  (void)madvise(map->address, map->limit, 
# 1927 "/libmdbx/src/osal.c" 3 4
                                         15
# 1927 "/libmdbx/src/osal.c"
                                                        );





  return rc;
}



__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static void mdbx_osal_jitter(_Bool tiny) {
  for (;;) {




    const unsigned salt = rand();


    const unsigned coin = salt % (tiny ? 29u : 43u);
    if (coin < 43 / 3)
      break;





    sched_yield();
    if (coin > 43 * 2 / 3)
      usleep(coin);

  }
}





__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static clockid_t choice_monoclock(void) {
  struct timespec probe;

  if (clock_gettime(
# 1969 "/libmdbx/src/osal.c" 3 4
                   7
# 1969 "/libmdbx/src/osal.c"
                                 , &probe) == 0)
    return 
# 1970 "/libmdbx/src/osal.c" 3 4
          7
# 1970 "/libmdbx/src/osal.c"
                        ;







  return 
# 1978 "/libmdbx/src/osal.c" 3 4
        1
# 1978 "/libmdbx/src/osal.c"
                       ;
}
# 1990 "/libmdbx/src/osal.c"
static uint64_t
mdbx_osal_16dot16_to_monotime(uint32_t seconds_16dot16) {
# 2004 "/libmdbx/src/osal.c"
  const uint64_t ratio = 1000000000UL;

  const uint64_t ret = (ratio * seconds_16dot16 + 32768) >> 16;
  return __builtin_expect(!!(ret || seconds_16dot16 == 0), 1) ? ret : 1;
}

static uint32_t mdbx_osal_monotime_to_16dot16(uint64_t monotime) {
  static uint64_t limit;
  if (__builtin_expect(!!(monotime > limit), 0)) {
    if (limit != 0)
      return 
# 2014 "/libmdbx/src/osal.c" 3 4
            (4294967295U)
# 2014 "/libmdbx/src/osal.c"
                      ;
    limit = mdbx_osal_16dot16_to_monotime(
# 2015 "/libmdbx/src/osal.c" 3 4
                                         (4294967295U) 
# 2015 "/libmdbx/src/osal.c"
                                                    - 1);
    if (monotime > limit)
      return 
# 2017 "/libmdbx/src/osal.c" 3 4
            (4294967295U)
# 2017 "/libmdbx/src/osal.c"
                      ;
  }
  const uint32_t ret =





      (uint32_t)(monotime * 128 / 1953125);

  return __builtin_expect(!!(ret || monotime == 0), 1) ? ret : 1;
}

static uint64_t mdbx_osal_monotime(void) {
# 2041 "/libmdbx/src/osal.c"
  static clockid_t posix_clockid = -1;
  if (__builtin_expect(!!(posix_clockid < 0), 0))
    posix_clockid = choice_monoclock();






  struct timespec ts;
  if (__builtin_expect(!!(clock_gettime(posix_clockid, &ts) != 0), 0)) {
    ts.tv_nsec = 0;
    ts.tv_sec = 0;
  }
  return ts.tv_sec * 1000000000UL + ts.tv_nsec;

}



static void bootid_shake(bin128_t *p) {

  const uint32_t e = p->a - (p->b << 23 | p->b >> 9);
  p->a = p->b ^ (p->c << 16 | p->c >> 16);
  p->b = p->c + (p->d << 11 | p->d >> 21);
  p->c = p->d + e;
  p->d = e + p->a;
}

static void bootid_collect(bin128_t *p, const void *s, size_t n) {
  p->y += 64526882297375213UL;
  bootid_shake(p);
  for (size_t i = 0; i < n; ++i) {
    bootid_shake(p);
    p->y ^= 48797879452804441UL * ((const uint8_t *)s)[i];
    bootid_shake(p);
    p->y += 14621231;
  }
  bootid_shake(p);


  const unsigned z = p->x % 61;
  p->y = p->y << z | p->y >> (64 - z);
  bootid_shake(p);
  bootid_shake(p);
  const unsigned q = p->x % 59;
  p->y = p->y << q | p->y >> (64 - q);
  bootid_shake(p);
  bootid_shake(p);
  bootid_shake(p);
}
# 2158 "/libmdbx/src/osal.c"
__attribute__((__cold__)) __attribute__((__optimize__("Os"))) __attribute__((__unused__)) static _Bool
bootid_parse_uuid(bin128_t *s, const void *p, const size_t n) {
  if (n > 31) {
    unsigned bits = 0;
    for (unsigned i = 0; i < n; ++i) {
      uint8_t c = ((const uint8_t *)p)[i];
      if (c >= '0' && c <= '9')
        c -= '0';
      else if (c >= 'a' && c <= 'f')
        c -= 'a' - 10;
      else if (c >= 'A' && c <= 'F')
        c -= 'A' - 10;
      else
        continue;
      do { if ((0)) do { if (__builtin_expect(!!(!(c <= 15)), 0)) mdbx_assert_fail(
# 2172 "/libmdbx/src/osal.c" 3 4
     ((void *)0)
# 2172 "/libmdbx/src/osal.c"
     , "c <= 15", __func__, 2172); } while (0); } while (0);
      c ^= s->y >> 60;
      s->y = s->y << 4 | s->x >> 60;
      s->x = s->x << 4 | c;
      bits += 4;
    }
    if (bits > 42 * 3)

      return (1);
  }

  if (n > 15) {
    if (n == sizeof(bin128_t)) {
      bin128_t aligned;
      memcpy(&aligned, p, sizeof(bin128_t));
      s->x += aligned.x;
      s->y += aligned.y;
    } else
      bootid_collect(s, p, n);
    return (1);
  }

  if (n)
    bootid_collect(s, p, n);
  return (0);
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static bin128_t mdbx_osal_bootid(void) {
  bin128_t bin = {{0, 0}};
  _Bool got_machineid = (0), got_boottime = (0), got_bootseq = (0);


  {
    const int fd =
        open("/proc/sys/kernel/random/boot_id", 
# 2206 "/libmdbx/src/osal.c" 3 4
                                               00 
# 2206 "/libmdbx/src/osal.c"
                                                        | 
# 2206 "/libmdbx/src/osal.c" 3 4
                                                          0100000
# 2206 "/libmdbx/src/osal.c"
                                                                    );
    if (fd != -1) {
      struct statfs fs;
      char buf[42];
      const ssize_t len =
          (fstatfs(fd, &fs) == 0 && fs.f_type == 0x9FA0)
              ? read(fd, buf, sizeof(buf))
              : -1;
      const int err = close(fd);
      do { if ((0)) do { if (__builtin_expect(!!(!(err == 0)), 0)) mdbx_assert_fail(
# 2215 "/libmdbx/src/osal.c" 3 4
     ((void *)0)
# 2215 "/libmdbx/src/osal.c"
     , "err == 0", __func__, 2215); } while (0); } while (0);
      (void)err;
      if (len > 0 && bootid_parse_uuid(&bin, buf, len))
        return bin;
    }
  }
# 2400 "/libmdbx/src/osal.c"
  if (!got_machineid) {
    const int hostid = gethostid();
    if (hostid > 0) {
      bootid_collect(&bin, &hostid, sizeof(hostid));
      got_machineid = (1);
    }
  }


  if (!got_machineid) {
  lack:
    bin.x = bin.y = 0;
    return bin;
  }
# 2461 "/libmdbx/src/osal.c"
  if (!got_boottime) {
    setutxent();
    const struct utmpx id = {.ut_type = 
# 2463 "/libmdbx/src/osal.c" 3 4
                                       2
# 2463 "/libmdbx/src/osal.c"
                                                };
    const struct utmpx *entry = getutxid(&id);
    if (entry) {
      bootid_collect(&bin, entry, sizeof(*entry));
      got_boottime = (1);
      while (__builtin_expect(!!((entry = getutxid(&id)) != 
# 2468 "/libmdbx/src/osal.c" 3 4
            ((void *)0)
# 2468 "/libmdbx/src/osal.c"
            ), 0)) {


        bootid_collect(&bin, entry, sizeof(*entry));
        got_bootseq = (1);
      }
    }
    endutxent();
  }


  if (!got_bootseq) {
    if (!got_boottime || !0)
      goto lack;






    struct timespec mono, real;
    if (clock_gettime(
# 2489 "/libmdbx/src/osal.c" 3 4
                     1
# 2489 "/libmdbx/src/osal.c"
                                    , &mono) ||
        clock_gettime(
# 2490 "/libmdbx/src/osal.c" 3 4
                     0
# 2490 "/libmdbx/src/osal.c"
                                   , &real) ||

        1555555555l > real.tv_sec ||

        real.tv_sec < mono.tv_sec || 1234567890l > real.tv_sec - mono.tv_sec ||
        (real.tv_sec - mono.tv_sec) % 900u == 0)

      goto lack;
  }

  return bin;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) int mdbx_get_sysraminfo(intptr_t *page_size, intptr_t *total_pages,
                               intptr_t *avail_pages) {
  if (!page_size && !total_pages && !avail_pages)
    return MDBX_EINVAL;
  if (total_pages)
    *total_pages = -1;
  if (avail_pages)
    *avail_pages = -1;

  const intptr_t pagesize = mdbx_syspagesize();
  if (page_size)
    *page_size = pagesize;
  if (__builtin_expect(!!(pagesize < MDBX_MIN_PAGESIZE || !is_powerof2(pagesize)), 0))
    return MDBX_INCOMPATIBLE;

  __attribute__((__unused__)) const int log2page = log2n_powerof2(pagesize);
  do { if ((0)) do { if (__builtin_expect(!!(!(pagesize == (1L << log2page))), 0)) mdbx_assert_fail(
# 2519 "/libmdbx/src/osal.c" 3 4
 ((void *)0)
# 2519 "/libmdbx/src/osal.c"
 , "pagesize == (1L << log2page)", __func__, 2519); } while (0); } while (0);
  (void)log2page;
# 2530 "/libmdbx/src/osal.c"
  if (total_pages) {



    const intptr_t total_ram_pages = sysconf(
# 2534 "/libmdbx/src/osal.c" 3 4
                                            _SC_PHYS_PAGES
# 2534 "/libmdbx/src/osal.c"
                                                          );
    if (total_ram_pages == -1)
      return 
# 2536 "/libmdbx/src/osal.c" 3 4
            (*__errno_location ())
# 2536 "/libmdbx/src/osal.c"
                 ;
# 2570 "/libmdbx/src/osal.c"
    *total_pages = total_ram_pages;
    if (total_ram_pages < 1)
      return MDBX_ENOSYS;
  }

  if (avail_pages) {



    const intptr_t avail_ram_pages = sysconf(
# 2579 "/libmdbx/src/osal.c" 3 4
                                            _SC_AVPHYS_PAGES
# 2579 "/libmdbx/src/osal.c"
                                                            );
    if (avail_ram_pages == -1)
      return 
# 2581 "/libmdbx/src/osal.c" 3 4
            (*__errno_location ())
# 2581 "/libmdbx/src/osal.c"
                 ;
# 2616 "/libmdbx/src/osal.c"
    *avail_pages = avail_ram_pages;
    if (avail_ram_pages < 1)
      return MDBX_ENOSYS;
  }

  return MDBX_SUCCESS;
}
# 19 "/libmdbx/src/alloy.c" 2
# 1 "/libmdbx/build/version.c" 1
# 11 "/libmdbx/build/version.c"
static const char sourcery[] = "d8797a55c55b5b0b920ac6e230d5563977eb23c86542d570a245d0841b6beb2c_v0_11_6_39_gbb8f4318_dirty";

__attribute__((__visibility__("default")))

    
# 15 "/libmdbx/build/version.c" 3 4
   __attribute__ ((__used__))







    
# 23 "/libmdbx/build/version.c"
   __attribute__((__externally_visible__))

    const struct MDBX_version_info mdbx_version = {
        0,
        11,
        6,
        39,
        {"2022-04-13T11:05:50+03:00", "04fd8130aaecb30dfcfba8e33352613eb38d9605", "bb8f43181783686879219846d64379a04c1430e3",
         "v0.11.6-39-gbb8f4318-dirty"},
        sourcery};

__attribute__((__visibility__("default")))

    
# 36 "/libmdbx/build/version.c" 3 4
   __attribute__ ((__used__))







    
# 44 "/libmdbx/build/version.c"
   __attribute__((__externally_visible__))

    const char *const mdbx_sourcery_d8797a55c55b5b0b920ac6e230d5563977eb23c86542d570a245d0841b6beb2c_v0_11_6_39_gbb8f4318_dirty = sourcery;
# 20 "/libmdbx/src/alloy.c" 2




# 1 "/libmdbx/src/lck-posix.c" 1
# 28 "/libmdbx/src/lck-posix.c"
# 1 "/usr/include/aarch64-linux-gnu/sys/utsname.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/sys/utsname.h" 3 4


# 1 "/usr/include/aarch64-linux-gnu/bits/utsname.h" 1 3 4
# 30 "/usr/include/aarch64-linux-gnu/sys/utsname.h" 2 3 4
# 48 "/usr/include/aarch64-linux-gnu/sys/utsname.h" 3 4

# 48 "/usr/include/aarch64-linux-gnu/sys/utsname.h" 3 4
struct utsname
  {

    char sysname[65];


    char nodename[65];


    char release[65];

    char version[65];


    char machine[65];




    char domainname[65];




  };
# 81 "/usr/include/aarch64-linux-gnu/sys/utsname.h" 3 4
extern int uname (struct utsname *__name) __attribute__ ((__nothrow__ , __leaf__));



# 29 "/libmdbx/src/lck-posix.c" 2







# 35 "/libmdbx/src/lck-posix.c"
__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static uint8_t probe_for_WSL(const char *tag) {
  const char *const WSL = strstr(tag, "WSL");
  if (WSL && WSL[3] >= '2' && WSL[3] <= '9')
    return WSL[3] - '0';
  const char *const wsl = strstr(tag, "wsl");
  if (wsl && wsl[3] >= '2' && wsl[3] <= '9')
    return wsl[3] - '0';
  if (WSL || wsl || strcasestr(tag, "Microsoft"))


    return (mdbx_linux_kernel_version < 0x04130000) ? 1 : 2;
  return 0;
}



__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static __attribute__((__constructor__)) void
mdbx_global_constructor(void) {

  struct utsname buffer;
  if (uname(&buffer) == 0) {
    int i = 0;
    char *p = buffer.release;
    while (*p && i < 4) {
      if (*p >= '0' && *p <= '9') {
        long number = strtol(p, &p, 10);
        if (number > 0) {
          if (number > 255)
            number = 255;
          mdbx_linux_kernel_version += number << (24 - i * 8);
        }
        ++i;
      } else {
        ++p;
      }
    }







    mdbx_RunningOnWSL1 = probe_for_WSL(buffer.version) == 1 ||
                         probe_for_WSL(buffer.sysname) == 1 ||
                         probe_for_WSL(buffer.release) == 1;
  }


  mdbx_rthc_global_init();
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static __attribute__((__destructor__)) void
mdbx_global_destructor(void) {
  mdbx_rthc_global_dtor();
}
# 150 "/libmdbx/src/lck-posix.c"
static int op_setlk, op_setlkw, op_getlk;
__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static void choice_fcntl() {
  do { if ((0)) do { if (__builtin_expect(!!(!(!op_setlk && !op_setlkw && !op_getlk)), 0)) mdbx_assert_fail(
# 152 "/libmdbx/src/lck-posix.c" 3 4
 ((void *)0)
# 152 "/libmdbx/src/lck-posix.c"
 , "!op_setlk && !op_setlkw && !op_getlk", __func__, 152); } while (0); } while (0);
  if ((mdbx_runtime_flags & MDBX_DBG_LEGACY_MULTIOPEN) == 0

      && mdbx_linux_kernel_version >
             0x030f0000



  ) {
    op_setlk = 
# 161 "/libmdbx/src/lck-posix.c" 3 4
              37
# 161 "/libmdbx/src/lck-posix.c"
                         ;
    op_setlkw = 
# 162 "/libmdbx/src/lck-posix.c" 3 4
               38
# 162 "/libmdbx/src/lck-posix.c"
                           ;
    op_getlk = 
# 163 "/libmdbx/src/lck-posix.c" 3 4
              36
# 163 "/libmdbx/src/lck-posix.c"
                         ;
    return;
  }
  op_setlk = 
# 166 "/libmdbx/src/lck-posix.c" 3 4
            6
# 166 "/libmdbx/src/lck-posix.c"
                   ;
  op_setlkw = 
# 167 "/libmdbx/src/lck-posix.c" 3 4
             7
# 167 "/libmdbx/src/lck-posix.c"
                     ;
  op_getlk = 
# 168 "/libmdbx/src/lck-posix.c" 3 4
            5
# 168 "/libmdbx/src/lck-posix.c"
                   ;
}
# 181 "/libmdbx/src/lck-posix.c"
static int lck_op(mdbx_filehandle_t fd, int cmd, int lck, off_t offset,
                  off_t len) {
  mdbx_jitter4testing((1));
  for (;;) {
    struct flock lock_op;
    memset(&lock_op, 0, sizeof(lock_op));
    lock_op.l_type = lck;
    lock_op.l_whence = 
# 188 "/libmdbx/src/lck-posix.c" 3 4
                      0
# 188 "/libmdbx/src/lck-posix.c"
                              ;
    lock_op.l_start = offset;
    lock_op.l_len = len;
    int rc = fcntl(fd, cmd, &lock_op);
    mdbx_jitter4testing((1));
    if (rc != -1) {
      if (cmd == op_getlk) {



        return (lock_op.l_type == 
# 198 "/libmdbx/src/lck-posix.c" 3 4
                                 2
# 198 "/libmdbx/src/lck-posix.c"
                                        ) ? MDBX_RESULT_FALSE
                                           : MDBX_RESULT_TRUE;
      }
      return MDBX_SUCCESS;
    }
    rc = 
# 203 "/libmdbx/src/lck-posix.c" 3 4
        (*__errno_location ())
# 203 "/libmdbx/src/lck-posix.c"
             ;

    if (rc == 
# 205 "/libmdbx/src/lck-posix.c" 3 4
             22 
# 205 "/libmdbx/src/lck-posix.c"
                    &&
        (cmd == 
# 206 "/libmdbx/src/lck-posix.c" 3 4
               37 
# 206 "/libmdbx/src/lck-posix.c"
                           || cmd == 
# 206 "/libmdbx/src/lck-posix.c" 3 4
                                     38 
# 206 "/libmdbx/src/lck-posix.c"
                                                  || cmd == 
# 206 "/libmdbx/src/lck-posix.c" 3 4
                                                            36
# 206 "/libmdbx/src/lck-posix.c"
                                                                       )) {

      if (cmd == 
# 208 "/libmdbx/src/lck-posix.c" 3 4
                37
# 208 "/libmdbx/src/lck-posix.c"
                           )
        cmd = 
# 209 "/libmdbx/src/lck-posix.c" 3 4
             6
# 209 "/libmdbx/src/lck-posix.c"
                    ;
      else if (cmd == 
# 210 "/libmdbx/src/lck-posix.c" 3 4
                     38
# 210 "/libmdbx/src/lck-posix.c"
                                 )
        cmd = 
# 211 "/libmdbx/src/lck-posix.c" 3 4
             7
# 211 "/libmdbx/src/lck-posix.c"
                     ;
      else
        cmd = 
# 213 "/libmdbx/src/lck-posix.c" 3 4
             5
# 213 "/libmdbx/src/lck-posix.c"
                    ;
      op_setlk = 
# 214 "/libmdbx/src/lck-posix.c" 3 4
                6
# 214 "/libmdbx/src/lck-posix.c"
                       ;
      op_setlkw = 
# 215 "/libmdbx/src/lck-posix.c" 3 4
                 7
# 215 "/libmdbx/src/lck-posix.c"
                         ;
      op_getlk = 
# 216 "/libmdbx/src/lck-posix.c" 3 4
                5
# 216 "/libmdbx/src/lck-posix.c"
                       ;
      continue;
    }

    if (rc != 
# 220 "/libmdbx/src/lck-posix.c" 3 4
             4 
# 220 "/libmdbx/src/lck-posix.c"
                   || cmd == op_setlkw) {
      do { if ((0)) do { if (__builtin_expect(!!(!(((rc) != MDBX_RESULT_TRUE && (rc) != MDBX_RESULT_FALSE))), 0)) mdbx_assert_fail(
# 221 "/libmdbx/src/lck-posix.c" 3 4
     ((void *)0)
# 221 "/libmdbx/src/lck-posix.c"
     , "((rc) != MDBX_RESULT_TRUE && (rc) != MDBX_RESULT_FALSE)", __func__, 221); } while (0); } while (0);
      return rc;
    }
  }
}

static int mdbx_lockfile(mdbx_filehandle_t fd, _Bool wait) {

  if (__builtin_expect(!!(op_setlk == 0), 0))
    choice_fcntl();

  return lck_op(fd, wait ? op_setlkw : op_setlk, 
# 232 "/libmdbx/src/lck-posix.c" 3 4
                                                1
# 232 "/libmdbx/src/lck-posix.c"
                                                       , 0, ((sizeof(off_t) > 4 ? 
# 232 "/libmdbx/src/lck-posix.c" 3 4
                                                            (9223372036854775807L) 
# 232 "/libmdbx/src/lck-posix.c"
                                                            : 
# 232 "/libmdbx/src/lck-posix.c" 3 4
                                                            (2147483647)
# 232 "/libmdbx/src/lck-posix.c"
                                                            ) & ~(size_t)0xffff));
}

static int mdbx_rpid_set(MDBX_env *env) {
  do { if ((0)) do { if (__builtin_expect(!!(!(env->me_lck_mmap.fd != (-1))), 0)) mdbx_assert_fail(
# 236 "/libmdbx/src/lck-posix.c" 3 4
 ((void *)0)
# 236 "/libmdbx/src/lck-posix.c"
 , "env->me_lck_mmap.fd != (-1)", __func__, 236); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(env->me_pid > 0)), 0)) mdbx_assert_fail(
# 237 "/libmdbx/src/lck-posix.c" 3 4
 ((void *)0)
# 237 "/libmdbx/src/lck-posix.c"
 , "env->me_pid > 0", __func__, 237); } while (0); } while (0);
  if (__builtin_expect(!!(mdbx_getpid() != env->me_pid), 0))
    return MDBX_PANIC;
  return lck_op(env->me_lck_mmap.fd, op_setlk, 
# 240 "/libmdbx/src/lck-posix.c" 3 4
                                      1
# 240 "/libmdbx/src/lck-posix.c"
                                             , env->me_pid, 1);
}

static int mdbx_rpid_clear(MDBX_env *env) {
  do { if ((0)) do { if (__builtin_expect(!!(!(env->me_lck_mmap.fd != (-1))), 0)) mdbx_assert_fail(
# 244 "/libmdbx/src/lck-posix.c" 3 4
 ((void *)0)
# 244 "/libmdbx/src/lck-posix.c"
 , "env->me_lck_mmap.fd != (-1)", __func__, 244); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(env->me_pid > 0)), 0)) mdbx_assert_fail(
# 245 "/libmdbx/src/lck-posix.c" 3 4
 ((void *)0)
# 245 "/libmdbx/src/lck-posix.c"
 , "env->me_pid > 0", __func__, 245); } while (0); } while (0);
  return lck_op(env->me_lck_mmap.fd, op_setlk, 
# 246 "/libmdbx/src/lck-posix.c" 3 4
                                      2
# 246 "/libmdbx/src/lck-posix.c"
                                             , env->me_pid, 1);
}

static int mdbx_rpid_check(MDBX_env *env, uint32_t pid) {
  do { if ((0)) do { if (__builtin_expect(!!(!(env->me_lck_mmap.fd != (-1))), 0)) mdbx_assert_fail(
# 250 "/libmdbx/src/lck-posix.c" 3 4
 ((void *)0)
# 250 "/libmdbx/src/lck-posix.c"
 , "env->me_lck_mmap.fd != (-1)", __func__, 250); } while (0); } while (0);
  do { if ((0)) do { if (__builtin_expect(!!(!(pid > 0)), 0)) mdbx_assert_fail(
# 251 "/libmdbx/src/lck-posix.c" 3 4
 ((void *)0)
# 251 "/libmdbx/src/lck-posix.c"
 , "pid > 0", __func__, 251); } while (0); } while (0);
  return lck_op(env->me_lck_mmap.fd, op_getlk, 
# 252 "/libmdbx/src/lck-posix.c" 3 4
                                      1
# 252 "/libmdbx/src/lck-posix.c"
                                             , pid, 1);
}




static int mdbx_ipclock_stub(mdbx_ipclock_t *ipc) {




  return pthread_mutex_init(ipc, 
# 263 "/libmdbx/src/lck-posix.c" 3 4
                                ((void *)0)
# 263 "/libmdbx/src/lck-posix.c"
                                       );



}

static int mdbx_ipclock_destroy(mdbx_ipclock_t *ipc) {




  return pthread_mutex_destroy(ipc);



}


static int check_fstat(MDBX_env *env) {
  struct stat st;

  int rc = MDBX_SUCCESS;
  if (fstat(env->me_dxb_mmap.fd, &st)) {
    rc = 
# 286 "/libmdbx/src/lck-posix.c" 3 4
        (*__errno_location ())
# 286 "/libmdbx/src/lck-posix.c"
             ;
    do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 287, "fstat(%s), err %d" "\n", "DXB", rc); } while (0);
    return rc;
  }

  if (!
# 291 "/libmdbx/src/lck-posix.c" 3 4
      ((((
# 291 "/libmdbx/src/lck-posix.c"
      st.st_mode
# 291 "/libmdbx/src/lck-posix.c" 3 4
      )) & 0170000) == (0100000)) 
# 291 "/libmdbx/src/lck-posix.c"
                          || st.st_nlink < 1) {

    rc = 
# 293 "/libmdbx/src/lck-posix.c" 3 4
        77
# 293 "/libmdbx/src/lck-posix.c"
              ;



    do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 297, "%s %s, err %d" "\n", "DXB", (st.st_nlink < 1) ? "file was removed" : "not a regular file", rc); } while (0)

                  ;
    return rc;
  }

  if (st.st_size < (off_t)(MDBX_MIN_PAGESIZE * 3)) {
    do { if ((MDBX_LOG_VERBOSE < MDBX_LOG_VERBOSE && MDBX_LOG_VERBOSE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_VERBOSE, __func__, 304, "dxb-file is too short (%u), exclusive-lock needed" "\n", (unsigned)st.st_size); } while (0)
                                      ;
    rc = MDBX_RESULT_TRUE;
  }



  if (fstat(env->me_lck_mmap.fd, &st)) {
    rc = 
# 312 "/libmdbx/src/lck-posix.c" 3 4
        (*__errno_location ())
# 312 "/libmdbx/src/lck-posix.c"
             ;
    do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 313, "fstat(%s), err %d" "\n", "LCK", rc); } while (0);
    return rc;
  }

  if (!
# 317 "/libmdbx/src/lck-posix.c" 3 4
      ((((
# 317 "/libmdbx/src/lck-posix.c"
      st.st_mode
# 317 "/libmdbx/src/lck-posix.c" 3 4
      )) & 0170000) == (0100000)) 
# 317 "/libmdbx/src/lck-posix.c"
                          || st.st_nlink < 1) {

    rc = 
# 319 "/libmdbx/src/lck-posix.c" 3 4
        77
# 319 "/libmdbx/src/lck-posix.c"
              ;



    do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 323, "%s %s, err %d" "\n", "LCK", (st.st_nlink < 1) ? "file was removed" : "not a regular file", rc); } while (0)

                  ;
    return rc;
  }



  if (st.st_size < (off_t)(sizeof(MDBX_lockinfo) + sizeof(MDBX_reader))) {
    do { if ((MDBX_LOG_VERBOSE < MDBX_LOG_VERBOSE && MDBX_LOG_VERBOSE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_VERBOSE, __func__, 332, "lck-file is too short (%u), exclusive-lock needed" "\n", (unsigned)st.st_size); } while (0)
                                      ;
    rc = MDBX_RESULT_TRUE;
  }

  return rc;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static int mdbx_lck_seize(MDBX_env *env) {
  do { if ((0)) do { if (__builtin_expect(!!(!(env->me_dxb_mmap.fd != (-1))), 0)) mdbx_assert_fail(
# 341 "/libmdbx/src/lck-posix.c" 3 4
 ((void *)0)
# 341 "/libmdbx/src/lck-posix.c"
 , "env->me_dxb_mmap.fd != (-1)", __func__, 341); } while (0); } while (0);
  if (__builtin_expect(!!(mdbx_getpid() != env->me_pid), 0))
    return MDBX_PANIC;

  if (__builtin_expect(!!(op_setlk == 0), 0))
    choice_fcntl();


  int rc = MDBX_SUCCESS;

  if (__builtin_expect(!!(mdbx_RunningOnWSL1), 0)) {
    rc = 
# 352 "/libmdbx/src/lck-posix.c" 3 4
        37 
# 352 "/libmdbx/src/lck-posix.c"
                                              ;
    do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 353, "%s, err %u" "\n", "WSL1 (Windows Subsystem for Linux) is mad and trouble-full, " "injecting failure to avoid data loss", rc); } while (0)


                  ;
    return rc;
  }


  if (env->me_lck_mmap.fd == (-1)) {

    rc =
        lck_op(env->me_dxb_mmap.fd, op_setlk,
               (env->me_flags & MDBX_RDONLY) ? 
# 365 "/libmdbx/src/lck-posix.c" 3 4
                                              0 
# 365 "/libmdbx/src/lck-posix.c"
                                                      : 
# 365 "/libmdbx/src/lck-posix.c" 3 4
                                                        1
# 365 "/libmdbx/src/lck-posix.c"
                                                               , 0, ((sizeof(off_t) > 4 ? 
# 365 "/libmdbx/src/lck-posix.c" 3 4
                                                                    (9223372036854775807L) 
# 365 "/libmdbx/src/lck-posix.c"
                                                                    : 
# 365 "/libmdbx/src/lck-posix.c" 3 4
                                                                    (2147483647)
# 365 "/libmdbx/src/lck-posix.c"
                                                                    ) & ~(size_t)0xffff));
    if (rc != MDBX_SUCCESS) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 367, "%s, err %u" "\n", "without-lck", rc); } while (0);
      do { if ((0)) do { if (__builtin_expect(!!(!(((rc) != MDBX_RESULT_TRUE && (rc) != MDBX_RESULT_FALSE))), 0)) mdbx_assert_fail(env, "((rc) != MDBX_RESULT_TRUE && (rc) != MDBX_RESULT_FALSE)", __func__, 368); } while (0); } while (0);
      return rc;
    }
    return MDBX_RESULT_TRUE ;
  }

  sched_yield();


retry:
  if (rc == MDBX_RESULT_TRUE) {
    rc = lck_op(env->me_lck_mmap.fd, op_setlk, 
# 379 "/libmdbx/src/lck-posix.c" 3 4
                                      2
# 379 "/libmdbx/src/lck-posix.c"
                                             , 0, 1);
    if (rc != MDBX_SUCCESS) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 381, "%s, err %u" "\n", "unlock-before-retry", rc); } while (0);
      do { if ((0)) do { if (__builtin_expect(!!(!(((rc) != MDBX_RESULT_TRUE && (rc) != MDBX_RESULT_FALSE))), 0)) mdbx_assert_fail(env, "((rc) != MDBX_RESULT_TRUE && (rc) != MDBX_RESULT_FALSE)", __func__, 382); } while (0); } while (0);
      return rc;
    }
  }


  rc = lck_op(env->me_lck_mmap.fd, op_setlk, 
# 388 "/libmdbx/src/lck-posix.c" 3 4
                                    1
# 388 "/libmdbx/src/lck-posix.c"
                                           , 0, 1);
  if (rc == MDBX_SUCCESS) {
    rc = check_fstat(env);
    if (((rc) != MDBX_RESULT_TRUE && (rc) != MDBX_RESULT_FALSE))
      return rc;

  continue_dxb_exclusive:
    rc =
        lck_op(env->me_dxb_mmap.fd, op_setlk,
               (env->me_flags & MDBX_RDONLY) ? 
# 397 "/libmdbx/src/lck-posix.c" 3 4
                                              0 
# 397 "/libmdbx/src/lck-posix.c"
                                                      : 
# 397 "/libmdbx/src/lck-posix.c" 3 4
                                                        1
# 397 "/libmdbx/src/lck-posix.c"
                                                               , 0, ((sizeof(off_t) > 4 ? 
# 397 "/libmdbx/src/lck-posix.c" 3 4
                                                                    (9223372036854775807L) 
# 397 "/libmdbx/src/lck-posix.c"
                                                                    : 
# 397 "/libmdbx/src/lck-posix.c" 3 4
                                                                    (2147483647)
# 397 "/libmdbx/src/lck-posix.c"
                                                                    ) & ~(size_t)0xffff));
    if (rc == MDBX_SUCCESS)
      return MDBX_RESULT_TRUE ;

    int err = check_fstat(env);
    if (((err) != MDBX_RESULT_TRUE && (err) != MDBX_RESULT_FALSE))
      return err;


    if (!(rc == 
# 406 "/libmdbx/src/lck-posix.c" 3 4
               11 
# 406 "/libmdbx/src/lck-posix.c"
                      || rc == 
# 406 "/libmdbx/src/lck-posix.c" 3 4
                               13 
# 406 "/libmdbx/src/lck-posix.c"
                                      || rc == 
# 406 "/libmdbx/src/lck-posix.c" 3 4
                                               16 
# 406 "/libmdbx/src/lck-posix.c"
                                                     || rc == 
# 406 "/libmdbx/src/lck-posix.c" 3 4
                                                              11 
# 406 "/libmdbx/src/lck-posix.c"
                                                                          ||
          rc == 
# 407 "/libmdbx/src/lck-posix.c" 3 4
               35
# 407 "/libmdbx/src/lck-posix.c"
                      )) {
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 408, "%s, err %u" "\n", "dxb-exclusive", rc); } while (0);
      do { if ((0)) do { if (__builtin_expect(!!(!(((rc) != MDBX_RESULT_TRUE && (rc) != MDBX_RESULT_FALSE))), 0)) mdbx_assert_fail(env, "((rc) != MDBX_RESULT_TRUE && (rc) != MDBX_RESULT_FALSE)", __func__, 409); } while (0); } while (0);
      return rc;
    }


  } else if (!(rc == 
# 414 "/libmdbx/src/lck-posix.c" 3 4
                    11 
# 414 "/libmdbx/src/lck-posix.c"
                           || rc == 
# 414 "/libmdbx/src/lck-posix.c" 3 4
                                    13 
# 414 "/libmdbx/src/lck-posix.c"
                                           || rc == 
# 414 "/libmdbx/src/lck-posix.c" 3 4
                                                    16 
# 414 "/libmdbx/src/lck-posix.c"
                                                          ||
               rc == 
# 415 "/libmdbx/src/lck-posix.c" 3 4
                    11 
# 415 "/libmdbx/src/lck-posix.c"
                                || rc == 
# 415 "/libmdbx/src/lck-posix.c" 3 4
                                         35
# 415 "/libmdbx/src/lck-posix.c"
                                                )) {
    do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 416, "%s, err %u" "\n", "try-exclusive", rc); } while (0);
    do { if ((0)) do { if (__builtin_expect(!!(!(((rc) != MDBX_RESULT_TRUE && (rc) != MDBX_RESULT_FALSE))), 0)) mdbx_assert_fail(env, "((rc) != MDBX_RESULT_TRUE && (rc) != MDBX_RESULT_FALSE)", __func__, 417); } while (0); } while (0);
    return rc;
  }
# 431 "/libmdbx/src/lck-posix.c"
  rc = lck_op(env->me_lck_mmap.fd, op_setlkw, 
# 431 "/libmdbx/src/lck-posix.c" 3 4
                                     0
# 431 "/libmdbx/src/lck-posix.c"
                                            , 0, 1);
  if (rc != MDBX_SUCCESS) {
    do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 433, "%s, err %u" "\n", "try-shared", rc); } while (0);
    do { if ((0)) do { if (__builtin_expect(!!(!(((rc) != MDBX_RESULT_TRUE && (rc) != MDBX_RESULT_FALSE))), 0)) mdbx_assert_fail(env, "((rc) != MDBX_RESULT_TRUE && (rc) != MDBX_RESULT_FALSE)", __func__, 434); } while (0); } while (0);
    return rc;
  }

  rc = check_fstat(env);
  if (rc == MDBX_RESULT_TRUE)
    goto retry;
  if (rc != MDBX_SUCCESS) {
    do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 442, "%s, err %u" "\n", "lck_fstat", rc); } while (0);
    return rc;
  }


  rc = lck_op(env->me_lck_mmap.fd, op_setlk, 
# 447 "/libmdbx/src/lck-posix.c" 3 4
                                    1
# 447 "/libmdbx/src/lck-posix.c"
                                           , 0, 1);
  if (rc == MDBX_SUCCESS)
    goto continue_dxb_exclusive;

  if (!(rc == 
# 451 "/libmdbx/src/lck-posix.c" 3 4
             11 
# 451 "/libmdbx/src/lck-posix.c"
                    || rc == 
# 451 "/libmdbx/src/lck-posix.c" 3 4
                             13 
# 451 "/libmdbx/src/lck-posix.c"
                                    || rc == 
# 451 "/libmdbx/src/lck-posix.c" 3 4
                                             16 
# 451 "/libmdbx/src/lck-posix.c"
                                                   || rc == 
# 451 "/libmdbx/src/lck-posix.c" 3 4
                                                            11 
# 451 "/libmdbx/src/lck-posix.c"
                                                                        ||
        rc == 
# 452 "/libmdbx/src/lck-posix.c" 3 4
             35
# 452 "/libmdbx/src/lck-posix.c"
                    )) {
    do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 453, "%s, err %u" "\n", "try-exclusive", rc); } while (0);
    do { if ((0)) do { if (__builtin_expect(!!(!(((rc) != MDBX_RESULT_TRUE && (rc) != MDBX_RESULT_FALSE))), 0)) mdbx_assert_fail(env, "((rc) != MDBX_RESULT_TRUE && (rc) != MDBX_RESULT_FALSE)", __func__, 454); } while (0); } while (0);
    return rc;
  }


  rc =
      lck_op(env->me_dxb_mmap.fd, op_setlk,
             (env->me_flags & MDBX_RDONLY) ? 
# 461 "/libmdbx/src/lck-posix.c" 3 4
                                            0 
# 461 "/libmdbx/src/lck-posix.c"
                                                    : 
# 461 "/libmdbx/src/lck-posix.c" 3 4
                                                      1
# 461 "/libmdbx/src/lck-posix.c"
                                                             , env->me_pid, 1);
  if (rc != MDBX_SUCCESS) {
    do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 463, "%s, err %u" "\n", "lock-against-without-lck", rc); } while (0);
    do { if ((0)) do { if (__builtin_expect(!!(!(((rc) != MDBX_RESULT_TRUE && (rc) != MDBX_RESULT_FALSE))), 0)) mdbx_assert_fail(env, "((rc) != MDBX_RESULT_TRUE && (rc) != MDBX_RESULT_FALSE)", __func__, 464); } while (0); } while (0);
    return rc;
  }


  return MDBX_RESULT_FALSE;
}

static int mdbx_lck_downgrade(MDBX_env *env) {
  do { if ((0)) do { if (__builtin_expect(!!(!(env->me_lck_mmap.fd != (-1))), 0)) mdbx_assert_fail(
# 473 "/libmdbx/src/lck-posix.c" 3 4
 ((void *)0)
# 473 "/libmdbx/src/lck-posix.c"
 , "env->me_lck_mmap.fd != (-1)", __func__, 473); } while (0); } while (0);
  if (__builtin_expect(!!(mdbx_getpid() != env->me_pid), 0))
    return MDBX_PANIC;

  int rc = MDBX_SUCCESS;
  if ((env->me_flags & MDBX_EXCLUSIVE) == 0) {
    rc = lck_op(env->me_dxb_mmap.fd, op_setlk, 
# 479 "/libmdbx/src/lck-posix.c" 3 4
                                          2
# 479 "/libmdbx/src/lck-posix.c"
                                                 , 0, env->me_pid);
    if (rc == MDBX_SUCCESS)
      rc = lck_op(env->me_dxb_mmap.fd, op_setlk, 
# 481 "/libmdbx/src/lck-posix.c" 3 4
                                            2
# 481 "/libmdbx/src/lck-posix.c"
                                                   , env->me_pid + 1,
                  ((sizeof(off_t) > 4 ? 
# 482 "/libmdbx/src/lck-posix.c" 3 4
                 (9223372036854775807L) 
# 482 "/libmdbx/src/lck-posix.c"
                 : 
# 482 "/libmdbx/src/lck-posix.c" 3 4
                 (2147483647)
# 482 "/libmdbx/src/lck-posix.c"
                 ) & ~(size_t)0xffff) - env->me_pid - 1);
  }
  if (rc == MDBX_SUCCESS)
    rc = lck_op(env->me_lck_mmap.fd, op_setlk, 
# 485 "/libmdbx/src/lck-posix.c" 3 4
                                      0
# 485 "/libmdbx/src/lck-posix.c"
                                             , 0, 1);
  if (__builtin_expect(!!(rc != 0), 0)) {
    do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 487, "%s, err %u" "\n", "lck", rc); } while (0);
    do { if ((0)) do { if (__builtin_expect(!!(!(((rc) != MDBX_RESULT_TRUE && (rc) != MDBX_RESULT_FALSE))), 0)) mdbx_assert_fail(
# 488 "/libmdbx/src/lck-posix.c" 3 4
   ((void *)0)
# 488 "/libmdbx/src/lck-posix.c"
   , "((rc) != MDBX_RESULT_TRUE && (rc) != MDBX_RESULT_FALSE)", __func__, 488); } while (0); } while (0);
  }
  return rc;
}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static int mdbx_lck_destroy(MDBX_env *env,
                                               MDBX_env *inprocess_neighbor) {
  if (__builtin_expect(!!(mdbx_getpid() != env->me_pid), 0))
    return MDBX_PANIC;

  int rc = MDBX_SUCCESS;
  struct stat lck_info;
  MDBX_lockinfo *lck = env->me_lck_mmap.lck;
  if (env->me_lck_mmap.fd != (-1) && !inprocess_neighbor && lck &&

      lck_op(env->me_lck_mmap.fd, op_setlk, 
# 503 "/libmdbx/src/lck-posix.c" 3 4
                                   1
# 503 "/libmdbx/src/lck-posix.c"
                                          , 0, ((sizeof(off_t) > 4 ? 
# 503 "/libmdbx/src/lck-posix.c" 3 4
                                               (9223372036854775807L) 
# 503 "/libmdbx/src/lck-posix.c"
                                               : 
# 503 "/libmdbx/src/lck-posix.c" 3 4
                                               (2147483647)
# 503 "/libmdbx/src/lck-posix.c"
                                               ) & ~(size_t)0xffff)) == 0 &&

      fstat(env->me_lck_mmap.fd, &lck_info) == 0 && lck_info.st_nlink > 0 &&
      lck_op(env->me_dxb_mmap.fd, op_setlk,
             (env->me_flags & MDBX_RDONLY) ? 
# 507 "/libmdbx/src/lck-posix.c" 3 4
                                            0 
# 507 "/libmdbx/src/lck-posix.c"
                                                    : 
# 507 "/libmdbx/src/lck-posix.c" 3 4
                                                      1
# 507 "/libmdbx/src/lck-posix.c"
                                                             , 0,
             ((sizeof(off_t) > 4 ? 
# 508 "/libmdbx/src/lck-posix.c" 3 4
            (9223372036854775807L) 
# 508 "/libmdbx/src/lck-posix.c"
            : 
# 508 "/libmdbx/src/lck-posix.c" 3 4
            (2147483647)
# 508 "/libmdbx/src/lck-posix.c"
            ) & ~(size_t)0xffff)) == 0) {

    do { if ((MDBX_LOG_VERBOSE < MDBX_LOG_VERBOSE && MDBX_LOG_VERBOSE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_VERBOSE, __func__, 510, "%p got exclusive, drown locks" "\n", (void *)env); } while (0);




    rc = mdbx_ipclock_destroy(&lck->mti_rlock);
    if (rc == 0)
      rc = mdbx_ipclock_destroy(&lck->mti_wlock);


    do { if ((0)) do { if (__builtin_expect(!!(!(rc == 0)), 0)) mdbx_assert_fail(env, "rc == 0", __func__, 520); } while (0); } while (0);
    if (rc == 0) {
      const _Bool synced = lck->mti_unsynced_pages.weak == 0;
      mdbx_munmap(&env->me_lck_mmap);
      if (synced)
        rc = ftruncate(env->me_lck_mmap.fd, 0) ? 
# 525 "/libmdbx/src/lck-posix.c" 3 4
                                        (*__errno_location ()) 
# 525 "/libmdbx/src/lck-posix.c"
                                              : 0;
    }

    mdbx_jitter4testing((0));
  }
# 539 "/libmdbx/src/lck-posix.c"
  if (env->me_dsync_fd != (-1)) {
    if (__builtin_expect(!!(close(env->me_dsync_fd) != 0), 0) && rc == MDBX_SUCCESS)
      rc = 
# 541 "/libmdbx/src/lck-posix.c" 3 4
          (*__errno_location ())
# 541 "/libmdbx/src/lck-posix.c"
               ;
    env->me_dsync_fd = (-1);
  }
  if (env->me_dxb_mmap.fd != (-1)) {
    if (__builtin_expect(!!(close(env->me_dxb_mmap.fd) != 0), 0) && rc == MDBX_SUCCESS)
      rc = 
# 546 "/libmdbx/src/lck-posix.c" 3 4
          (*__errno_location ())
# 546 "/libmdbx/src/lck-posix.c"
               ;
    env->me_dxb_mmap.fd = (-1);
    if (op_setlk == 
# 548 "/libmdbx/src/lck-posix.c" 3 4
                   6 
# 548 "/libmdbx/src/lck-posix.c"
                           && inprocess_neighbor && rc == MDBX_SUCCESS) {

      rc = lck_op(
          inprocess_neighbor->me_dxb_mmap.fd, 
# 551 "/libmdbx/src/lck-posix.c" 3 4
                                         7
# 551 "/libmdbx/src/lck-posix.c"
                                                 ,
          (inprocess_neighbor->me_flags & MDBX_RDONLY) ? 
# 552 "/libmdbx/src/lck-posix.c" 3 4
                                                        0 
# 552 "/libmdbx/src/lck-posix.c"
                                                                : 
# 552 "/libmdbx/src/lck-posix.c" 3 4
                                                                  1
# 552 "/libmdbx/src/lck-posix.c"
                                                                         ,
          (inprocess_neighbor->me_flags & MDBX_EXCLUSIVE)
              ? 0
              : inprocess_neighbor->me_pid,
          (inprocess_neighbor->me_flags & MDBX_EXCLUSIVE) ? ((sizeof(off_t) > 4 ? 
# 556 "/libmdbx/src/lck-posix.c" 3 4
                                                           (9223372036854775807L) 
# 556 "/libmdbx/src/lck-posix.c"
                                                           : 
# 556 "/libmdbx/src/lck-posix.c" 3 4
                                                           (2147483647)
# 556 "/libmdbx/src/lck-posix.c"
                                                           ) & ~(size_t)0xffff) : 1);
    }
  }


  if (env->me_lck_mmap.fd != (-1)) {
    if (__builtin_expect(!!(close(env->me_lck_mmap.fd) != 0), 0) && rc == MDBX_SUCCESS)
      rc = 
# 563 "/libmdbx/src/lck-posix.c" 3 4
          (*__errno_location ())
# 563 "/libmdbx/src/lck-posix.c"
               ;
    env->me_lck_mmap.fd = (-1);
    if (op_setlk == 
# 565 "/libmdbx/src/lck-posix.c" 3 4
                   6 
# 565 "/libmdbx/src/lck-posix.c"
                           && inprocess_neighbor && rc == MDBX_SUCCESS) {

      rc = lck_op(inprocess_neighbor->me_lck_mmap.fd, 
# 567 "/libmdbx/src/lck-posix.c" 3 4
                                             7
# 567 "/libmdbx/src/lck-posix.c"
                                                     , 
# 567 "/libmdbx/src/lck-posix.c" 3 4
                                                       0
# 567 "/libmdbx/src/lck-posix.c"
                                                              , 0, 1);
      if (rc == MDBX_SUCCESS && inprocess_neighbor->me_live_reader)
        rc = mdbx_rpid_set(inprocess_neighbor);
    }
  }

  if (inprocess_neighbor && rc != MDBX_SUCCESS)
    inprocess_neighbor->me_flags |= 0x80000000U;
  return rc;
}



__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static int mdbx_lck_init(MDBX_env *env,
                                            MDBX_env *inprocess_neighbor,
                                            int global_uniqueness_flag) {
# 652 "/libmdbx/src/lck-posix.c"
  if (inprocess_neighbor)
    return MDBX_SUCCESS

        ;
# 673 "/libmdbx/src/lck-posix.c"
  if (global_uniqueness_flag != MDBX_RESULT_TRUE)
    return MDBX_SUCCESS;


  pthread_mutexattr_t ma;
  int rc = pthread_mutexattr_init(&ma);
  if (rc)
    return rc;

  rc = pthread_mutexattr_setpshared(&ma, 
# 682 "/libmdbx/src/lck-posix.c" 3 4
                                        PTHREAD_PROCESS_SHARED
# 682 "/libmdbx/src/lck-posix.c"
                                                              );
  if (rc)
    goto bailout;
# 695 "/libmdbx/src/lck-posix.c"
  rc = pthread_mutexattr_setrobust(&ma, PTHREAD_MUTEX_ROBUST);

  if (rc)
    goto bailout;




  rc = pthread_mutexattr_setprotocol(&ma, PTHREAD_PRIO_INHERIT);
  if (rc == 
# 704 "/libmdbx/src/lck-posix.c" 3 4
           95
# 704 "/libmdbx/src/lck-posix.c"
                  )
    rc = pthread_mutexattr_setprotocol(&ma, PTHREAD_PRIO_NONE);
  if (rc && rc != 
# 706 "/libmdbx/src/lck-posix.c" 3 4
                 95
# 706 "/libmdbx/src/lck-posix.c"
                        )
    goto bailout;


  rc = pthread_mutexattr_settype(&ma, PTHREAD_MUTEX_ERRORCHECK);
  if (rc && rc != 
# 711 "/libmdbx/src/lck-posix.c" 3 4
                 95
# 711 "/libmdbx/src/lck-posix.c"
                        )
    goto bailout;

  rc = pthread_mutex_init(&env->me_lck_mmap.lck->mti_rlock, &ma);
  if (rc)
    goto bailout;
  rc = pthread_mutex_init(&env->me_lck_mmap.lck->mti_wlock, &ma);

bailout:
  pthread_mutexattr_destroy(&ma);
  return rc;



}

__attribute__((__cold__)) __attribute__((__optimize__("Os"))) static int mdbx_ipclock_failed(MDBX_env *env, mdbx_ipclock_t *ipc,
                                      const int err) {
  int rc = err;

  if (err == 
# 731 "/libmdbx/src/lck-posix.c" 3 4
            130
# 731 "/libmdbx/src/lck-posix.c"
                      ) {


    const _Bool rlocked = ipc == &env->me_lck->mti_rlock;
    rc = MDBX_SUCCESS;
    if (!rlocked) {
      if (__builtin_expect(!!(env->me_txn), 0)) {

        env->me_flags |= 0x80000000U;
        env->me_txn = 
# 740 "/libmdbx/src/lck-posix.c" 3 4
                     ((void *)0)
# 740 "/libmdbx/src/lck-posix.c"
                         ;
        rc = MDBX_PANIC;
      }
    }
    do { if ((MDBX_LOG_WARN < MDBX_LOG_VERBOSE && MDBX_LOG_WARN <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_WARN, __func__, 744, "%clock owner died, %s" "\n", (rlocked ? 'r' : 'w'), (rc ? "this process' env is hosed" : "recovering")); } while (0)
                                                                    ;

    int check_rc = mdbx_cleanup_dead_readers(env, rlocked, 
# 747 "/libmdbx/src/lck-posix.c" 3 4
                                                          ((void *)0)
# 747 "/libmdbx/src/lck-posix.c"
                                                              );
    check_rc = (check_rc == MDBX_SUCCESS) ? MDBX_RESULT_TRUE : check_rc;
# 760 "/libmdbx/src/lck-posix.c"
    int mreco_rc = pthread_mutex_consistent(ipc);

    check_rc = (mreco_rc == 0) ? check_rc : mreco_rc;

    if (__builtin_expect(!!(mreco_rc), 0))
      do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 765, "lock recovery failed, %s" "\n", mdbx_strerror(mreco_rc)); } while (0);

    rc = (rc == MDBX_SUCCESS) ? check_rc : rc;
    if (((rc) != MDBX_RESULT_TRUE && (rc) != MDBX_RESULT_FALSE))
      pthread_mutex_unlock(ipc);

    return rc;
  }
# 788 "/libmdbx/src/lck-posix.c"
  do { if ((MDBX_LOG_ERROR < MDBX_LOG_VERBOSE && MDBX_LOG_ERROR <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_ERROR, __func__, 788, "mutex (un)lock failed, %s" "\n", mdbx_strerror(err)); } while (0);
  if (rc != 
# 789 "/libmdbx/src/lck-posix.c" 3 4
           35
# 789 "/libmdbx/src/lck-posix.c"
                  )
    env->me_flags |= 0x80000000U;
  return rc;
}

static int mdbx_ipclock_lock(MDBX_env *env, mdbx_ipclock_t *ipc,
                             const _Bool dont_wait) {


  int rc = dont_wait ? pthread_mutex_trylock(ipc) : pthread_mutex_lock(ipc);
  rc = (rc == 
# 799 "/libmdbx/src/lck-posix.c" 3 4
             16 
# 799 "/libmdbx/src/lck-posix.c"
                   && dont_wait) ? MDBX_BUSY : rc;
# 827 "/libmdbx/src/lck-posix.c"
  if (__builtin_expect(!!(rc != MDBX_SUCCESS && rc != MDBX_BUSY), 0))
    rc = mdbx_ipclock_failed(env, ipc, rc);
  return rc;
}

static int mdbx_ipclock_unlock(MDBX_env *env, mdbx_ipclock_t *ipc) {


  int rc = pthread_mutex_unlock(ipc);
  (void)env;
# 851 "/libmdbx/src/lck-posix.c"
  return rc;
}

static int mdbx_rdt_lock(MDBX_env *env) {
  do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 855, "%s" "\n", ">>"); } while (0);
  mdbx_jitter4testing((1));
  int rc = mdbx_ipclock_lock(env, &env->me_lck->mti_rlock, (0));
  do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 858, "<< rc %d" "\n", rc); } while (0);
  return rc;
}

static void mdbx_rdt_unlock(MDBX_env *env) {
  do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 863, "%s" "\n", ">>"); } while (0);
  int rc = mdbx_ipclock_unlock(env, &env->me_lck->mti_rlock);
  do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 865, "<< rc %d" "\n", rc); } while (0);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    mdbx_panic("%s() failed: err %d\n", __func__, rc);
  mdbx_jitter4testing((1));
}

int mdbx_txn_lock(MDBX_env *env, _Bool dont_wait) {
  do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 872, "%swait %s" "\n", dont_wait ? "dont-" : "", ">>"); } while (0);
  mdbx_jitter4testing((1));
  int rc = mdbx_ipclock_lock(env, &env->me_lck->mti_wlock, dont_wait);
  do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 875, "<< rc %d" "\n", rc); } while (0);
  return ((rc) != MDBX_RESULT_TRUE && (rc) != MDBX_RESULT_FALSE) ? rc : MDBX_SUCCESS;
}

void mdbx_txn_unlock(MDBX_env *env) {
  do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 880, "%s" "\n", ">>"); } while (0);
  int rc = mdbx_ipclock_unlock(env, &env->me_lck->mti_wlock);
  do { if ((MDBX_LOG_TRACE < MDBX_LOG_VERBOSE && MDBX_LOG_TRACE <= mdbx_loglevel)) mdbx_debug_log(MDBX_LOG_TRACE, __func__, 882, "<< rc %d" "\n", rc); } while (0);
  if (__builtin_expect(!!(rc != MDBX_SUCCESS), 0))
    mdbx_panic("%s() failed: err %d\n", __func__, rc);
  mdbx_jitter4testing((1));
}
# 25 "/libmdbx/src/alloy.c" 2
